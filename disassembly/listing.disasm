Disassembly Listing for ImageProc2
Generated From:

---  C:/Users/Cameron/Documents/Git/imageproc-lib/xl.c  -------------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Analog Devices ADXL345 3-axis MEMS accelerometer IC Interface
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-06-05    Initial release
38:                 *
39:                 * Notes:
40:                 *  - Uses an I2C port for communicating with the accelerometer chip
41:                 *  - MCU resources requied for this module:
42:                 *      I2C bus (I2C1 for ImageProc2) - SCL1 & SDA1
43:                 *      External INT (INT3 for ImageProc2)
44:                 */
45:                
46:                
47:                #include "ports.h"      // for external interrupt
48:                #include "i2c_driver.h"
49:                #include "i2c.h"        // kept only for peripheral setup
50:                #include "xl.h"
51:                #include "utils.h"
52:                
53:                #define XL_ADDR_RD             0xA7
54:                #define XL_ADDR_WR             0xA6
55:                #define XL_DEFAULT_SCALE       0.03832  // = 9.81/256
56:                #define XL_I2C_CHAN            1
57:                
58:                
59:                /*-----------------------------------------------------------------------------
60:                 *          Static Variables
61:                -----------------------------------------------------------------------------*/
62:                // data storage for receiving data
63:                static union {
64:                    unsigned char chr_data[6];
65:                    int int_data[3];
66:                } XlData;
67:                
68:                
69:                static union {
70:                    unsigned char chr_data[24];
71:                    float f_data[6];
72:                } CalibParam;
73:                
74:                
75:                /*-----------------------------------------------------------------------------
76:                 *          Declaration of static functions
77:                -----------------------------------------------------------------------------*/
78:                static void xlWrite(unsigned char regaddr, unsigned char data);
79:                static inline void xlSetupPeripheral(void);
80:                
81:                
82:                /*-----------------------------------------------------------------------------
83:                 *          Public functions
84:                -----------------------------------------------------------------------------*/
85:                
86:                void xlSetup(void) {
00B202  FA0000     LNK #0x0
87:                
88:                    xlSetupPeripheral();
00B204  07018E     RCALL xlSetupPeripheral
89:                
90:                    ConfigINT3(RISING_EDGE_INT & EXT_INT_DISABLE & EXT_INT_PRI_3);
00B206  2FFE30     MOV #0xFFE3, W0
00B208  022376     CALL _ConfigINT3
00B20A  000000     NOP
91:                
92:                    delay_ms(25);   // power up delay, may not need...
00B20C  200190     MOV #0x19, W0
00B20E  02E270     CALL msELAPSED
00B210  000000     NOP
93:                
94:                    // Do not use offset registers, but use calib_param_
95:                    xlWrite(0x1e, 0x00); // x-axis offset is zero
00B212  EB4080     CLR.B W1
00B214  B3C1E0     MOV #0x1E, W0
00B216  07016E     RCALL xlWrite
96:                    xlWrite(0x1f, 0x00); // y-axis offset is zero
00B218  EB4080     CLR.B W1
00B21A  B3C1F0     MOV #0x1F, W0
00B21C  07016B     RCALL xlWrite
97:                    xlWrite(0x20, 0x00); // z-axis offset is zero
00B21E  EB4080     CLR.B W1
00B220  B3C200     MOV #0x20, W0
00B222  070168     RCALL xlWrite
98:                
99:                    xlWrite(0x21, 0x00); // disable the single/double tap functions
00B224  EB4080     CLR.B W1
00B226  B3C210     MOV #0x21, W0
00B228  070165     RCALL xlWrite
100:                   xlWrite(0x22, 0x00); // disable the double tap function
00B22A  EB4080     CLR.B W1
00B22C  B3C220     MOV #0x22, W0
00B22E  070162     RCALL xlWrite
101:                   xlWrite(0x23, 0x00); // disable the double tap function
00B230  EB4080     CLR.B W1
00B232  B3C230     MOV #0x23, W0
00B234  07015F     RCALL xlWrite
102:                   xlWrite(0x27, 0x00); // disable the activity/inactivity
00B236  EB4080     CLR.B W1
00B238  B3C270     MOV #0x27, W0
00B23A  07015C     RCALL xlWrite
103:                   xlWrite(0x2a, 0x00); // disable single/double tap fuctions
00B23C  EB4080     CLR.B W1
00B23E  B3C2A0     MOV #0x2A, W0
00B240  070159     RCALL xlWrite
104:               
105:                   xlWrite(0x2c, 0x0d); // normal power mode & 800Hz output rate
00B242  B3C0D1     MOV #0xD, W1
00B244  B3C2C0     MOV #0x2C, W0
00B246  070156     RCALL xlWrite
106:                   xlWrite(0x2d, 0x08); // normal mode
00B248  B3C081     MOV #0x8, W1
00B24A  B3C2D0     MOV #0x2D, W0
00B24C  070153     RCALL xlWrite
107:               
108:                   //interrupt enable/disable
109:                   xlWrite(0x2e, 0x80); // DATA_READY is enabled. others are disabled
00B24E  B3C801     MOV #0x80, W1
00B250  B3C2E0     MOV #0x2E, W0
00B252  070150     RCALL xlWrite
110:                   xlWrite(0x2f, 0x00); // all interrputs are sent to INT1 Pin
00B254  EB4080     CLR.B W1
00B256  B3C2F0     MOV #0x2F, W0
00B258  07014D     RCALL xlWrite
111:               
112:                   // data format
113:                   // enable the self-test force
114:                   // active high for interrupts
115:                   // full resolution mode
116:                   // right justified mode
117:                   // +-8g range
118:                   xlWrite(0x31, 0b00001010);
00B25A  B3C0A1     MOV #0xA, W1
00B25C  B3C310     MOV #0x31, W0
00B25E  07014A     RCALL xlWrite
119:               
120:                   xlWrite(0x38, 0x00); // FIFO control is bypassed
00B260  EB4080     CLR.B W1
00B262  B3C380     MOV #0x38, W0
00B264  070147     RCALL xlWrite
121:               
122:                   // set default scale factors
123:                   CalibParam.f_data[0] = XL_DEFAULT_SCALE;
00B266  2F56F0     MOV #0xF56F, W0
00B268  23D1C1     MOV #0x3D1C, W1
00B26A  890A30     MOV W0, CalibParam
00B26C  890A41     MOV W1, 0x2148
124:                   CalibParam.f_data[1] = XL_DEFAULT_SCALE;
00B26E  2F56F0     MOV #0xF56F, W0
00B270  23D1C1     MOV #0x3D1C, W1
00B272  890A50     MOV W0, 0x214A
00B274  890A61     MOV W1, 0x214C
125:                   CalibParam.f_data[2] = XL_DEFAULT_SCALE;
00B276  2F56F0     MOV #0xF56F, W0
00B278  23D1C1     MOV #0x3D1C, W1
00B27A  890A70     MOV W0, 0x214E
00B27C  890A81     MOV W1, 0x2150
126:               
127:               }
00B27E  FA8000     ULNK
00B280  060000     RETURN
128:               
129:               
130:               void xlSetIntEn(unsigned char flag) {
00B282  FA0002     LNK #0x2
00B284  784F00     MOV.B W0, [W14]
131:                   _INT3IE = flag;
00B286  78409E     MOV.B [W14], W1
00B288  60C061     AND.B W1, #0x1, W0
00B28A  FB8000     ZE W0, W0
00B28C  600061     AND W0, #0x1, W0
00B28E  DD0045     SL W0, #5, W0
00B290  8004D2     MOV IEC3, W2
00B292  2FFDF1     MOV #0xFFDF, W1
00B294  610081     AND W2, W1, W1
00B296  708000     IOR W1, W0, W0
00B298  8804D0     MOV W0, IEC3
132:               }
00B29A  FA8000     ULNK
00B29C  060000     RETURN
133:               
134:               
135:               void xlSetRange(unsigned char range) {
00B29E  FA0002     LNK #0x2
00B2A0  784F00     MOV.B W0, [W14]
136:                   if (range == 2) {
00B2A2  78409E     MOV.B [W14], W1
00B2A4  B3C020     MOV #0x2, W0
00B2A6  50CF80     SUB.B W1, W0, [W15]
00B2A8  3A0004     BRA NZ, 0xB2B2
137:                       xlWrite(0x31, 0b00001000);
00B2AA  B3C081     MOV #0x8, W1
00B2AC  B3C310     MOV #0x31, W0
00B2AE  070122     RCALL xlWrite
00B2B0  370017     BRA 0xB2E0
138:                   } else if (range == 4) {
00B2B2  78409E     MOV.B [W14], W1
00B2B4  B3C040     MOV #0x4, W0
00B2B6  50CF80     SUB.B W1, W0, [W15]
00B2B8  3A0004     BRA NZ, 0xB2C2
139:                       xlWrite(0x31, 0b00001001);
00B2BA  B3C091     MOV #0x9, W1
00B2BC  B3C310     MOV #0x31, W0
00B2BE  07011A     RCALL xlWrite
00B2C0  37000F     BRA 0xB2E0
140:                   } else if (range == 8) {
00B2C2  78409E     MOV.B [W14], W1
00B2C4  B3C080     MOV #0x8, W0
00B2C6  50CF80     SUB.B W1, W0, [W15]
00B2C8  3A0004     BRA NZ, 0xB2D2
141:                       xlWrite(0x31, 0b00001010);
00B2CA  B3C0A1     MOV #0xA, W1
00B2CC  B3C310     MOV #0x31, W0
00B2CE  070112     RCALL xlWrite
00B2D0  370007     BRA 0xB2E0
142:                   } else if (range == 16) {
00B2D2  78409E     MOV.B [W14], W1
00B2D4  B3C100     MOV #0x10, W0
00B2D6  50CF80     SUB.B W1, W0, [W15]
00B2D8  3A0003     BRA NZ, 0xB2E0
143:                       xlWrite(0x31, 0b00001011);
00B2DA  B3C0B1     MOV #0xB, W1
00B2DC  B3C310     MOV #0x31, W0
00B2DE  07010A     RCALL xlWrite
144:                   }
145:                   // else do not change anything
146:               }
00B2E0  FA8000     ULNK
00B2E2  060000     RETURN
147:               
148:               
149:               void xlSetOutputRate(unsigned char power_mode, unsigned char rate) {
00B2E4  FA0002     LNK #0x2
00B2E6  784F00     MOV.B W0, [W14]
00B2E8  984711     MOV.B W1, [W14+1]
150:                   if (power_mode == 0) {
00B2EA  78409E     MOV.B [W14], W1
00B2EC  EB4000     CLR.B W0
00B2EE  50CF80     SUB.B W1, W0, [W15]
00B2F0  3A0006     BRA NZ, 0xB2FE
151:                       xlWrite(0x2c, (0x0f & rate));
00B2F2  90401E     MOV.B [W14+1], W0
00B2F4  60406F     AND.B W0, #0xF, W0
00B2F6  784080     MOV.B W0, W1
00B2F8  B3C2C0     MOV #0x2C, W0
00B2FA  0700FC     RCALL xlWrite
00B2FC  370006     BRA 0xB30A
152:                   } else {
153:                       xlWrite(0x2c, ((0x0f & rate) | 0x10));
00B2FE  90401E     MOV.B [W14+1], W0
00B300  60406F     AND.B W0, #0xF, W0
00B302  A04400     BSET.B W0, #4
00B304  784080     MOV.B W0, W1
00B306  B3C2C0     MOV #0x2C, W0
00B308  0700F5     RCALL xlWrite
154:                   }
155:               }
00B30A  FA8000     ULNK
00B30C  060000     RETURN
156:               
157:               
158:               void xlSleep(void) {
00B30E  FA0000     LNK #0x0
159:                   xlWrite(0x2d, 0x00);    // stanby mode, clear Measure bit
00B310  EB4080     CLR.B W1
00B312  B3C2D0     MOV #0x2D, W0
00B314  0700EF     RCALL xlWrite
160:               }
00B316  FA8000     ULNK
00B318  060000     RETURN
161:               
162:               
163:               void xlWake(void) {
00B31A  FA0000     LNK #0x0
164:                   xlWrite(0x2d, 0x08);    // normal measurement mode, set Measure bit
00B31C  B3C081     MOV #0x8, W1
00B31E  B3C2D0     MOV #0x2D, W0
00B320  0700E9     RCALL xlWrite
165:               }
00B322  FA8000     ULNK
00B324  060000     RETURN
166:               
167:               void xlSetCalibParam(unsigned char* param) {
00B326  FA0004     LNK #0x4
00B328  980710     MOV W0, [W14+2]
168:                   unsigned char i;
169:               
170:                   for(i = 0; i < 24; ++i) {
00B32A  EB4000     CLR.B W0
00B32C  784F00     MOV.B W0, [W14]
00B32E  37000B     BRA 0xB346
00B344  E84F1E     INC.B [W14], [W14]
00B346  78409E     MOV.B [W14], W1
00B348  B3C170     MOV #0x17, W0
00B34A  50CF80     SUB.B W1, W0, [W15]
00B34C  36FFF1     BRA LEU, 0xB330
171:                       CalibParam.chr_data[i] = param[i];
00B330  78401E     MOV.B [W14], W0
00B332  FB8100     ZE W0, W2
00B334  78409E     MOV.B [W14], W1
00B336  FB8001     ZE W1, W0
00B338  90009E     MOV [W14+2], W1
00B33A  408000     ADD W1, W0, W0
00B33C  784010     MOV.B [W0], W0
00B33E  221461     MOV #0x2146, W1
00B340  410081     ADD W2, W1, W1
00B342  784880     MOV.B W0, [W1]
172:                   }
173:               }
00B34E  FA8000     ULNK
00B350  060000     RETURN
174:               
175:               unsigned char* xlGetCalibParam(void) {
00B352  FA0000     LNK #0x0
176:                   return CalibParam.chr_data;
00B354  221460     MOV #0x2146, W0
177:               }
00B356  FA8000     ULNK
00B358  060000     RETURN
178:               
179:               
180:               void xlLoadCalibParam(void) {
00B35A  FA0000     LNK #0x0
181:                   // TODO: Implement !!!!!
182:                  // work harder !!
183:               }
00B35C  FA8000     ULNK
00B35E  060000     RETURN
184:               
185:               
186:               void xlSaveCalibParam(void){
00B360  FA0000     LNK #0x0
187:                   // TODO: Implement !!!!!
188:                  // work harder !!
189:               }
00B362  FA8000     ULNK
00B364  060000     RETURN
190:               
191:               unsigned char xlGetID(void) {
00B366  FA0002     LNK #0x2
192:                   unsigned char c;
193:               
194:                   i2cStartTx(XL_I2C_CHAN);
00B368  B3C010     MOV #0x1, W0
00B36A  02D6F8     CALL i2cStartTx
00B36C  000000     NOP
195:                   i2cSendByte(XL_I2C_CHAN, XL_ADDR_WR);
00B36E  B3CA61     MOV #0xA6, W1
00B370  B3C010     MOV #0x1, W0
00B372  02D7A8     CALL i2cSendByte
00B374  000000     NOP
196:                   i2cSendByte(XL_I2C_CHAN, 0x00);
00B376  EB4080     CLR.B W1
00B378  B3C010     MOV #0x1, W0
00B37A  02D7A8     CALL i2cSendByte
00B37C  000000     NOP
197:                   i2cEndTx(XL_I2C_CHAN);
00B37E  B3C010     MOV #0x1, W0
00B380  02D72A     CALL i2cEndTx
00B382  000000     NOP
198:                   i2cStartTx(XL_I2C_CHAN);
00B384  B3C010     MOV #0x1, W0
00B386  02D6F8     CALL i2cStartTx
00B388  000000     NOP
199:                   i2cSendByte(XL_I2C_CHAN, XL_ADDR_RD);
00B38A  B3CA71     MOV #0xA7, W1
00B38C  B3C010     MOV #0x1, W0
00B38E  02D7A8     CALL i2cSendByte
00B390  000000     NOP
200:                   c = i2cReceiveByte(XL_I2C_CHAN);
00B392  B3C010     MOV #0x1, W0
00B394  02D78E     CALL i2cReceiveByte
00B396  000000     NOP
00B398  784F00     MOV.B W0, [W14]
201:                   i2cEndTx(XL_I2C_CHAN);
00B39A  B3C010     MOV #0x1, W0
00B39C  02D72A     CALL i2cEndTx
00B39E  000000     NOP
202:               
203:                   return c;
00B3A0  78401E     MOV.B [W14], W0
204:               }
00B3A2  FA8000     ULNK
00B3A4  060000     RETURN
205:               
206:               void xlGetFloatXYZ(float* data){
00B3A6  FA0002     LNK #0x2
00B3A8  781F88     MOV W8, [W15++]
00B3AA  780F00     MOV W0, [W14]
207:                   data[0] = XlData.int_data[0]*CalibParam.f_data[0] + CalibParam.f_data[3];
00B3AC  810A00     MOV XlData, W0
00B3AE  DE80CF     ASR W0, #15, W1
00B3B0  022624     CALL ___floatsisf
00B3B2  000000     NOP
00B3B4  BE0200     MOV.D W0, W4
00B3B6  810A30     MOV CalibParam, W0
00B3B8  810A41     MOV 0x2148, W1
00B3BA  BE0100     MOV.D W0, W2
00B3BC  BE0004     MOV.D W4, W0
00B3BE  022C36     CALL ___mulsf3
00B3C0  000000     NOP
00B3C2  BE0200     MOV.D W0, W4
00B3C4  810A90     MOV 0x2152, W0
00B3C6  810AA1     MOV 0x2154, W1
00B3C8  BE0100     MOV.D W0, W2
00B3CA  BE0004     MOV.D W4, W0
00B3CC  022A6C     CALL ___addsf3
00B3CE  000000     NOP
00B3D0  78011E     MOV [W14], W2
00B3D2  BE8900     MOV.D W0, [W2]
208:                   data[1] = XlData.int_data[1]*CalibParam.f_data[1] + CalibParam.f_data[4];
00B3D4  78001E     MOV [W14], W0
00B3D6  400464     ADD W0, #0x4, W8
00B3D8  810A10     MOV 0x2142, W0
00B3DA  DE80CF     ASR W0, #15, W1
00B3DC  022624     CALL ___floatsisf
00B3DE  000000     NOP
00B3E0  BE0200     MOV.D W0, W4
00B3E2  810A50     MOV 0x214A, W0
00B3E4  810A61     MOV 0x214C, W1
00B3E6  BE0100     MOV.D W0, W2
00B3E8  BE0004     MOV.D W4, W0
00B3EA  022C36     CALL ___mulsf3
00B3EC  000000     NOP
00B3EE  BE0200     MOV.D W0, W4
00B3F0  810AB0     MOV 0x2156, W0
00B3F2  810AC1     MOV 0x2158, W1
00B3F4  BE0100     MOV.D W0, W2
00B3F6  BE0004     MOV.D W4, W0
00B3F8  022A6C     CALL ___addsf3
00B3FA  000000     NOP
00B3FC  BE8C00     MOV.D W0, [W8]
209:                   data[2] = XlData.int_data[2]*CalibParam.f_data[2] + CalibParam.f_data[5];
00B3FE  78001E     MOV [W14], W0
00B400  400468     ADD W0, #0x8, W8
00B402  810A20     MOV 0x2144, W0
00B404  DE80CF     ASR W0, #15, W1
00B406  022624     CALL ___floatsisf
00B408  000000     NOP
00B40A  BE0200     MOV.D W0, W4
00B40C  810A70     MOV 0x214E, W0
00B40E  810A81     MOV 0x2150, W1
00B410  BE0100     MOV.D W0, W2
00B412  BE0004     MOV.D W4, W0
00B414  022C36     CALL ___mulsf3
00B416  000000     NOP
00B418  BE0200     MOV.D W0, W4
00B41A  810AD0     MOV 0x215A, W0
00B41C  810AE1     MOV 0x215C, W1
00B41E  BE0100     MOV.D W0, W2
00B420  BE0004     MOV.D W4, W0
00B422  022A6C     CALL ___addsf3
00B424  000000     NOP
00B426  BE8C00     MOV.D W0, [W8]
210:               }
00B428  78044F     MOV [--W15], W8
00B42A  FA8000     ULNK
00B42C  060000     RETURN
211:               
212:               int* xlGetIntXYZ(void){
00B42E  FA0000     LNK #0x0
213:                   return XlData.int_data;
00B430  221400     MOV #0x2140, W0
214:               }
00B432  FA8000     ULNK
00B434  060000     RETURN
215:               
216:               unsigned char* xlToString(void) {
00B436  FA0000     LNK #0x0
217:                   return XlData.chr_data;
00B438  221400     MOV #0x2140, W0
218:               }
00B43A  FA8000     ULNK
00B43C  060000     RETURN
219:               
220:               void xlDumpData(unsigned char* buffer) {
00B43E  FA0004     LNK #0x4
00B440  980710     MOV W0, [W14+2]
221:                   int i;
222:                   for (i = 0; i < 6; i++) {
00B442  EB0000     CLR W0
00B444  780F00     MOV W0, [W14]
00B446  370008     BRA 0xB458
00B456  E80F1E     INC [W14], [W14]
00B458  78009E     MOV [W14], W1
00B45A  200050     MOV #0x5, W0
00B45C  508F80     SUB W1, W0, [W15]
00B45E  34FFF4     BRA LE, 0xB448
223:                       buffer[i] = XlData.chr_data[i];
00B448  78001E     MOV [W14], W0
00B44A  90009E     MOV [W14+2], W1
00B44C  408080     ADD W1, W0, W1
00B44E  221400     MOV #0x2140, W0
00B450  40001E     ADD W0, [W14], W0
00B452  784010     MOV.B [W0], W0
00B454  784880     MOV.B W0, [W1]
224:                   }
225:               }
00B460  FA8000     ULNK
00B462  060000     RETURN
226:               
227:               unsigned char* xlReadXYZ(void)  {
00B464  FA0000     LNK #0x0
228:                   i2cStartTx(XL_I2C_CHAN);
00B466  B3C010     MOV #0x1, W0
00B468  02D6F8     CALL i2cStartTx
00B46A  000000     NOP
229:                   i2cSendByte(XL_I2C_CHAN, XL_ADDR_WR);
00B46C  B3CA61     MOV #0xA6, W1
00B46E  B3C010     MOV #0x1, W0
00B470  02D7A8     CALL i2cSendByte
00B472  000000     NOP
230:                   i2cSendByte(XL_I2C_CHAN, 0x32);
00B474  B3C321     MOV #0x32, W1
00B476  B3C010     MOV #0x1, W0
00B478  02D7A8     CALL i2cSendByte
00B47A  000000     NOP
231:                   i2cEndTx(XL_I2C_CHAN);
00B47C  B3C010     MOV #0x1, W0
00B47E  02D72A     CALL i2cEndTx
00B480  000000     NOP
232:                   i2cStartTx(XL_I2C_CHAN);
00B482  B3C010     MOV #0x1, W0
00B484  02D6F8     CALL i2cStartTx
00B486  000000     NOP
233:                   i2cSendByte(XL_I2C_CHAN, XL_ADDR_RD);
00B488  B3CA71     MOV #0xA7, W1
00B48A  B3C010     MOV #0x1, W0
00B48C  02D7A8     CALL i2cSendByte
00B48E  000000     NOP
234:                   i2cReadString(XL_I2C_CHAN, 6, XlData.chr_data, 1000);
00B490  203E83     MOV #0x3E8, W3
00B492  221402     MOV #0x2140, W2
00B494  200061     MOV #0x6, W1
00B496  B3C010     MOV #0x1, W0
00B498  02D800     CALL i2cReadString
00B49A  000000     NOP
235:                   i2cEndTx(XL_I2C_CHAN);
00B49C  B3C010     MOV #0x1, W0
00B49E  02D72A     CALL i2cEndTx
00B4A0  000000     NOP
236:               
237:                   return XlData.chr_data;
00B4A2  221400     MOV #0x2140, W0
238:               }
00B4A4  FA8000     ULNK
00B4A6  060000     RETURN
239:               
240:               void xlGetXYZ(unsigned char *data)  {
00B4A8  FA0002     LNK #0x2
00B4AA  780F00     MOV W0, [W14]
241:                   i2cStartTx(XL_I2C_CHAN);
00B4AC  B3C010     MOV #0x1, W0
00B4AE  02D6F8     CALL i2cStartTx
00B4B0  000000     NOP
242:                   i2cSendByte(XL_I2C_CHAN,XL_ADDR_WR);
00B4B2  B3CA61     MOV #0xA6, W1
00B4B4  B3C010     MOV #0x1, W0
00B4B6  02D7A8     CALL i2cSendByte
00B4B8  000000     NOP
243:                   i2cSendByte(XL_I2C_CHAN,0x32);
00B4BA  B3C321     MOV #0x32, W1
00B4BC  B3C010     MOV #0x1, W0
00B4BE  02D7A8     CALL i2cSendByte
00B4C0  000000     NOP
244:                   i2cEndTx(XL_I2C_CHAN);
00B4C2  B3C010     MOV #0x1, W0
00B4C4  02D72A     CALL i2cEndTx
00B4C6  000000     NOP
245:                   i2cStartTx(XL_I2C_CHAN);
00B4C8  B3C010     MOV #0x1, W0
00B4CA  02D6F8     CALL i2cStartTx
00B4CC  000000     NOP
246:                   i2cSendByte(XL_I2C_CHAN, XL_ADDR_RD);
00B4CE  B3CA71     MOV #0xA7, W1
00B4D0  B3C010     MOV #0x1, W0
00B4D2  02D7A8     CALL i2cSendByte
00B4D4  000000     NOP
247:                   i2cReadString(XL_I2C_CHAN, 6, data, 1000);
00B4D6  203E83     MOV #0x3E8, W3
00B4D8  78011E     MOV [W14], W2
00B4DA  200061     MOV #0x6, W1
00B4DC  B3C010     MOV #0x1, W0
00B4DE  02D800     CALL i2cReadString
00B4E0  000000     NOP
248:                   i2cEndTx(XL_I2C_CHAN);
00B4E2  B3C010     MOV #0x1, W0
00B4E4  02D72A     CALL i2cEndTx
00B4E6  000000     NOP
249:               }
00B4E8  FA8000     ULNK
00B4EA  060000     RETURN
250:               
251:               
252:               /*-----------------------------------------------------------------------------
253:                * ----------------------------------------------------------------------------
254:                * The functions below are intended for internal use, i.e., private methods.
255:                * Users are recommended to use functions defined above.
256:                * ----------------------------------------------------------------------------
257:               -----------------------------------------------------------------------------*/
258:               
259:               /**************************************************
260:                * Interrupt hander for Accelerometer
261:                * ************************************************/
262:               void __attribute__((interrupt, no_auto_psv)) _INT3Interrupt(void) {
00B4EC  FA0000     LNK #0x0
263:               
264:                   _INT3IF = 0;    // Clear the interrupt flag
00B4EE  A9A08A     BCLR IFS3, #5
265:               }
00B4F0  FA8000     ULNK
00B4F2  064000     RETFIE
266:               
267:               /*****************************************************************************
268:               * Function Name : xlWrite
269:               * Description   : Write a data to a register
270:               * Parameters    : regaddr - address of register
271:               *                 data - value to be written to the register
272:               * Return Value  : None
273:               *****************************************************************************/
274:               static void xlWrite(unsigned char regaddr, unsigned char data ){
00B4F4  FA0002     LNK #0x2
00B4F6  784F00     MOV.B W0, [W14]
00B4F8  984711     MOV.B W1, [W14+1]
275:                   i2cStartTx(XL_I2C_CHAN);
00B4FA  B3C010     MOV #0x1, W0
00B4FC  02D6F8     CALL i2cStartTx
00B4FE  000000     NOP
276:                   i2cSendByte(XL_I2C_CHAN, XL_ADDR_WR);
00B500  B3CA61     MOV #0xA6, W1
00B502  B3C010     MOV #0x1, W0
00B504  02D7A8     CALL i2cSendByte
00B506  000000     NOP
277:                   i2cSendByte(XL_I2C_CHAN, regaddr);
00B508  78409E     MOV.B [W14], W1
00B50A  B3C010     MOV #0x1, W0
00B50C  02D7A8     CALL i2cSendByte
00B50E  000000     NOP
278:                   i2cSendByte(XL_I2C_CHAN, data);
00B510  90409E     MOV.B [W14+1], W1
00B512  B3C010     MOV #0x1, W0
00B514  02D7A8     CALL i2cSendByte
00B516  000000     NOP
279:                   i2cEndTx(XL_I2C_CHAN);
00B518  B3C010     MOV #0x1, W0
00B51A  02D72A     CALL i2cEndTx
00B51C  000000     NOP
280:               }
00B51E  FA8000     ULNK
00B520  060000     RETURN
281:               
282:               /******************************************************************************
283:               * Function Name : xlSetupPeripheral
284:               * Description   : This routine sets up I2C bus for this module
285:               * Parameters    : None
286:               * Return Value  : None
287:               *******************************************************************************/
288:               static inline void xlSetupPeripheral(void) {
00B522  FA0004     LNK #0x4
289:                   unsigned int I2C1CONvalue, I2C1BRGvalue;
290:                   I2C1CONvalue = I2C1_ON & I2C1_IDLE_CON & I2C1_CLK_HLD &
00B524  2C2200     MOV #0xC220, W0
00B526  780F00     MOV W0, [W14]
291:                                  I2C1_IPMI_DIS & I2C1_7BIT_ADD & I2C1_SLW_DIS &
292:                                  I2C1_SM_DIS & I2C1_GCALL_DIS & I2C1_STR_DIS &
293:                                  I2C1_NACK & I2C1_ACK_DIS & I2C1_RCV_DIS &
294:                                  I2C1_STOP_DIS & I2C1_RESTART_DIS & I2C1_START_DIS;
295:               
296:                   // BRG = Fcy(1/Fscl - 1/10000000)-1, Fscl = 400KHz
297:                   //Maximum ADC data rate of 800 Hz
298:                   I2C1BRGvalue = 95;
00B528  2005F0     MOV #0x5F, W0
00B52A  980710     MOV W0, [W14+2]
299:                   OpenI2C1(I2C1CONvalue, I2C1BRGvalue);
00B52C  90009E     MOV [W14+2], W1
00B52E  78001E     MOV [W14], W0
00B530  0222D2     CALL _OpenI2C1
00B532  000000     NOP
300:                   IdleI2C1();
00B534  022176     CALL _IdleI2C1
00B536  000000     NOP
301:               }
00B538  FA8000     ULNK
00B53A  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/wii.c  ------------------------------------------------
1:                 /*
2:                  * Copyright (c) 2009-2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Communication with Wiimote IR Detector (I2C)
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2009-08-10    Initial release
38:                 *                      
39:                 * Notes:
40:                 *  - Uses an I2C port for communicating with an Wii IR camera (I2C1 for
41:                 *    ImageProc1 and I2C2 for ImageProc2)
42:                 */
43:                
44:                #include "utils.h"
45:                #include "i2c.h"
46:                #include "wii.h"
47:                
48:                #define WII_ADDR_RD             0xB1    
49:                #define WII_ADDR_WR             0xB0    // 0x58 << 1
50:                #define WII_DATA_WAIT           1000
51:                #define WII_SETUP_DELAY	        10	// 10 is safe...
52:                #define WII_READ_DELAY          1
53:                #define WII_POSTREAD_DELAY      4
54:                
55:                #define WII_DATA_WIDTH          16
56:                
57:                
58:                #define wiiReadString(a,b,c) MastergetsI2C2(a,b,c)
59:                
60:                /******************************************************************************
61:                * Sensitivity Settings
62:                * [0x02, 0x00, 0x00, 0x71, 0x01, 0x00, PO, 0x00, P1, P2, P3]
63:                * P0 = MAX blob size (0x62 - 0xC8)
64:                * P1 = Sensor GAIN, smaller = higher gain
65:                * P2 = Sensor gain LIMIT, must be less than GAIN 
66:                * P3 = MIN blob size, (3 - 5)
67:                ******************************************************************************/
68:                
69:                const unsigned char WiiSensitivity[5][11] = {
70:                    {0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0x72, 0x00, 0x20, 0x1F, 0x03},
71:                    {0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0xC8, 0x00, 0x36, 0x35, 0x03},
72:                    {0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0xAA, 0x00, 0x64, 0x63, 0x03},
73:                    {0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0x96, 0x00, 0xB4, 0xB3, 0x04},
74:                    {0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0x96, 0x00, 0xFE, 0xFE, 0x05}};
75:                    
76:                
77:                /*-----------------------------------------------------------------------------
78:                 *          Static Variables
79:                -----------------------------------------------------------------------------*/
80:                
81:                static unsigned char wiiData[WII_DATA_WIDTH+1];
82:                // The first byte of wiiData must be thrown away.
83:                
84:                /*-----------------------------------------------------------------------------
85:                 *          Declaration of static functions
86:                -----------------------------------------------------------------------------*/
87:                
88:                static void wiiWrite(unsigned char subaddr, unsigned char data);
89:                static void wiiSendByte(unsigned char byte );
90:                //static unsigned char wiiReceiveByte(void);
91:                //static void wiiSendNack(void);
92:                static void wiiStartTx(void);
93:                static void wiiEndTx(void);
94:                static void wiiSetupPeripheral(void);
95:                
96:                
97:                /*-----------------------------------------------------------------------------
98:                 *          Public functions
99:                -----------------------------------------------------------------------------*/
100:               
101:               void wiiSetupBasic(void) {
00A0EA  FA0000     LNK #0x0
102:               
103:                   wiiSetupPeripheral();
00A0EC  0701C0     RCALL wiiSetupPeripheral
104:               
105:                   wiiWrite(0x30, 0x01);
00A0EE  B3C011     MOV #0x1, W1
00A0F0  B3C300     MOV #0x30, W0
00A0F2  070185     RCALL wiiWrite
106:                   delay_ms(WII_SETUP_DELAY);
00A0F4  2000A0     MOV #0xA, W0
00A0F6  02E270     CALL msELAPSED
00A0F8  000000     NOP
107:                   wiiWrite(0x30, 0x08);
00A0FA  B3C081     MOV #0x8, W1
00A0FC  B3C300     MOV #0x30, W0
00A0FE  07017F     RCALL wiiWrite
108:                   delay_ms(WII_SETUP_DELAY);
00A100  2000A0     MOV #0xA, W0
00A102  02E270     CALL msELAPSED
00A104  000000     NOP
109:                   wiiWrite(0x06, 0x90);
00A106  B3C901     MOV #0x90, W1
00A108  B3C060     MOV #0x6, W0
00A10A  070179     RCALL wiiWrite
110:                   delay_ms(WII_SETUP_DELAY);
00A10C  2000A0     MOV #0xA, W0
00A10E  02E270     CALL msELAPSED
00A110  000000     NOP
111:                   wiiWrite(0x08, 0xC0);
00A112  B3CC01     MOV #0xC0, W1
00A114  B3C080     MOV #0x8, W0
00A116  070173     RCALL wiiWrite
112:                   delay_ms(WII_SETUP_DELAY);
00A118  2000A0     MOV #0xA, W0
00A11A  02E270     CALL msELAPSED
00A11C  000000     NOP
113:                   wiiWrite(0x1A, 0x40);
00A11E  B3C401     MOV #0x40, W1
00A120  B3C1A0     MOV #0x1A, W0
00A122  07016D     RCALL wiiWrite
114:                   delay_ms(WII_SETUP_DELAY);
00A124  2000A0     MOV #0xA, W0
00A126  02E270     CALL msELAPSED
00A128  000000     NOP
115:                   wiiWrite(0x33, 0x33);
00A12A  B3C331     MOV #0x33, W1
00A12C  B3C330     MOV #0x33, W0
00A12E  070167     RCALL wiiWrite
116:                   delay_ms(WII_SETUP_DELAY);
00A130  2000A0     MOV #0xA, W0
00A132  02E270     CALL msELAPSED
00A134  000000     NOP
117:               
118:               }
00A136  FA8000     ULNK
00A138  060000     RETURN
119:               
120:               void wiiSetupAdvance(unsigned char sensitivity, unsigned char mode) {
00A13A  FA0002     LNK #0x2
00A13C  784F00     MOV.B W0, [W14]
00A13E  984711     MOV.B W1, [W14+1]
121:               //sensitivity: 1 = highest sensitivity, 5 = lowest
122:               
123:                   if (sensitivity > 5 || sensitivity < 1) {
00A140  78409E     MOV.B [W14], W1
00A142  B3C050     MOV #0x5, W0
00A144  50CF80     SUB.B W1, W0, [W15]
00A146  3E0004     BRA GTU, 0xA150
00A148  78409E     MOV.B [W14], W1
00A14A  EB4000     CLR.B W0
00A14C  50CF80     SUB.B W1, W0, [W15]
00A14E  3A0002     BRA NZ, 0xA154
124:                       wiiSetupBasic();
00A150  07FFCC     RCALL wiiSetupBasic
125:                       return;
00A152  370085     BRA 0xA25E
126:                   }
127:               
128:                   wiiSetupPeripheral();
00A154  07018C     RCALL wiiSetupPeripheral
129:                   wiiWrite(0x30, 0x01);
00A156  B3C011     MOV #0x1, W1
00A158  B3C300     MOV #0x30, W0
00A15A  070151     RCALL wiiWrite
130:                   delay_ms(WII_SETUP_DELAY);
00A15C  2000A0     MOV #0xA, W0
00A15E  02E270     CALL msELAPSED
00A160  000000     NOP
131:                   
132:                   wiiStartTx();
00A162  07016F     RCALL wiiStartTx
133:                   wiiSendByte(WII_ADDR_WR);
00A164  B3CB00     MOV #0xB0, W0
00A166  070158     RCALL wiiSendByte
134:                   wiiSendByte(0x00);
00A168  EB4000     CLR.B W0
00A16A  070156     RCALL wiiSendByte
135:                   wiiSendByte(WiiSensitivity[sensitivity][0]);
00A16C  78409E     MOV.B [W14], W1
00A16E  FB8001     ZE W1, W0
00A170  B9006B     MUL.SU W0, #11, W0
00A172  780000     MOV W0, W0
00A174  2BE601     MOV #0xBE60, W1
00A176  784061     MOV.B [W1+W0], W0
00A178  07014F     RCALL wiiSendByte
136:                   wiiSendByte(WiiSensitivity[sensitivity][1]);
00A17A  78409E     MOV.B [W14], W1
00A17C  FB8001     ZE W1, W0
00A17E  B9006B     MUL.SU W0, #11, W0
00A180  780000     MOV W0, W0
00A182  E80000     INC W0, W0
00A184  2BE601     MOV #0xBE60, W1
00A186  784061     MOV.B [W1+W0], W0
00A188  070147     RCALL wiiSendByte
137:                   wiiSendByte(WiiSensitivity[sensitivity][2]);
00A18A  78409E     MOV.B [W14], W1
00A18C  FB8001     ZE W1, W0
00A18E  B9006B     MUL.SU W0, #11, W0
00A190  780000     MOV W0, W0
00A192  E88000     INC2 W0, W0
00A194  2BE601     MOV #0xBE60, W1
00A196  784061     MOV.B [W1+W0], W0
00A198  07013F     RCALL wiiSendByte
138:                   wiiSendByte(WiiSensitivity[sensitivity][3]);
00A19A  78409E     MOV.B [W14], W1
00A19C  FB8001     ZE W1, W0
00A19E  B9006B     MUL.SU W0, #11, W0
00A1A0  780000     MOV W0, W0
00A1A2  400063     ADD W0, #0x3, W0
00A1A4  2BE601     MOV #0xBE60, W1
00A1A6  784061     MOV.B [W1+W0], W0
00A1A8  070137     RCALL wiiSendByte
139:                   wiiSendByte(WiiSensitivity[sensitivity][4]);
00A1AA  78409E     MOV.B [W14], W1
00A1AC  FB8001     ZE W1, W0
00A1AE  B9006B     MUL.SU W0, #11, W0
00A1B0  780000     MOV W0, W0
00A1B2  400064     ADD W0, #0x4, W0
00A1B4  2BE601     MOV #0xBE60, W1
00A1B6  784061     MOV.B [W1+W0], W0
00A1B8  07012F     RCALL wiiSendByte
140:                   wiiSendByte(WiiSensitivity[sensitivity][5]);
00A1BA  78409E     MOV.B [W14], W1
00A1BC  FB8001     ZE W1, W0
00A1BE  B9006B     MUL.SU W0, #11, W0
00A1C0  780000     MOV W0, W0
00A1C2  400065     ADD W0, #0x5, W0
00A1C4  2BE601     MOV #0xBE60, W1
00A1C6  784061     MOV.B [W1+W0], W0
00A1C8  070127     RCALL wiiSendByte
141:                   wiiSendByte(WiiSensitivity[sensitivity][6]);
00A1CA  78409E     MOV.B [W14], W1
00A1CC  FB8001     ZE W1, W0
00A1CE  B9006B     MUL.SU W0, #11, W0
00A1D0  780000     MOV W0, W0
00A1D2  400066     ADD W0, #0x6, W0
00A1D4  2BE601     MOV #0xBE60, W1
00A1D6  784061     MOV.B [W1+W0], W0
00A1D8  07011F     RCALL wiiSendByte
142:                   wiiEndTx();
00A1DA  07013E     RCALL wiiEndTx
143:                   delay_ms(WII_SETUP_DELAY);
00A1DC  2000A0     MOV #0xA, W0
00A1DE  02E270     CALL msELAPSED
00A1E0  000000     NOP
144:               
145:                   wiiStartTx();
00A1E2  07012F     RCALL wiiStartTx
146:                   wiiSendByte(WII_ADDR_WR);
00A1E4  B3CB00     MOV #0xB0, W0
00A1E6  070118     RCALL wiiSendByte
147:                   wiiSendByte(0x07);
00A1E8  B3C070     MOV #0x7, W0
00A1EA  070116     RCALL wiiSendByte
148:                   wiiSendByte(WiiSensitivity[sensitivity][7]);
00A1EC  78409E     MOV.B [W14], W1
00A1EE  FB8001     ZE W1, W0
00A1F0  B9006B     MUL.SU W0, #11, W0
00A1F2  780000     MOV W0, W0
00A1F4  400067     ADD W0, #0x7, W0
00A1F6  2BE601     MOV #0xBE60, W1
00A1F8  784061     MOV.B [W1+W0], W0
00A1FA  07010E     RCALL wiiSendByte
149:                   wiiSendByte(WiiSensitivity[sensitivity][8]);
00A1FC  78409E     MOV.B [W14], W1
00A1FE  FB8001     ZE W1, W0
00A200  B9006B     MUL.SU W0, #11, W0
00A202  780000     MOV W0, W0
00A204  400068     ADD W0, #0x8, W0
00A206  2BE601     MOV #0xBE60, W1
00A208  784061     MOV.B [W1+W0], W0
00A20A  070106     RCALL wiiSendByte
150:                   wiiEndTx();
00A20C  070125     RCALL wiiEndTx
151:                   delay_ms(WII_SETUP_DELAY);
00A20E  2000A0     MOV #0xA, W0
00A210  02E270     CALL msELAPSED
00A212  000000     NOP
152:               
153:                   wiiStartTx();
00A214  070116     RCALL wiiStartTx
154:                   wiiSendByte(WII_ADDR_WR);
00A216  B3CB00     MOV #0xB0, W0
00A218  0700FF     RCALL wiiSendByte
155:                   wiiSendByte(0x1A);
00A21A  B3C1A0     MOV #0x1A, W0
00A21C  0700FD     RCALL wiiSendByte
156:                   wiiSendByte(WiiSensitivity[sensitivity][9]);
00A21E  78409E     MOV.B [W14], W1
00A220  FB8001     ZE W1, W0
00A222  B9006B     MUL.SU W0, #11, W0
00A224  780000     MOV W0, W0
00A226  400069     ADD W0, #0x9, W0
00A228  2BE601     MOV #0xBE60, W1
00A22A  784061     MOV.B [W1+W0], W0
00A22C  0700F5     RCALL wiiSendByte
157:                   wiiSendByte(WiiSensitivity[sensitivity][10]);
00A22E  78409E     MOV.B [W14], W1
00A230  FB8001     ZE W1, W0
00A232  B9006B     MUL.SU W0, #11, W0
00A234  780000     MOV W0, W0
00A236  40006A     ADD W0, #0xA, W0
00A238  2BE601     MOV #0xBE60, W1
00A23A  784061     MOV.B [W1+W0], W0
00A23C  0700ED     RCALL wiiSendByte
158:                   wiiEndTx();
00A23E  07010C     RCALL wiiEndTx
159:                   delay_ms(WII_SETUP_DELAY);
00A240  2000A0     MOV #0xA, W0
00A242  02E270     CALL msELAPSED
00A244  000000     NOP
160:               
161:                   wiiWrite(0x33, mode);
00A246  90409E     MOV.B [W14+1], W1
00A248  B3C330     MOV #0x33, W0
00A24A  0700D9     RCALL wiiWrite
162:                   delay_ms(WII_SETUP_DELAY);
00A24C  2000A0     MOV #0xA, W0
00A24E  02E270     CALL msELAPSED
00A250  000000     NOP
163:               
164:                   wiiWrite(0x30, 0x08);
00A252  B3C081     MOV #0x8, W1
00A254  B3C300     MOV #0x30, W0
00A256  0700D3     RCALL wiiWrite
165:                   delay_ms(WII_SETUP_DELAY);
00A258  2000A0     MOV #0xA, W0
00A25A  02E270     CALL msELAPSED
00A25C  000000     NOP
166:               
167:               }
00A25E  FA8000     ULNK
00A260  060000     RETURN
168:               
169:               
170:               void wiiGetData(WiiBlob* blobs) {
00A262  FA0002     LNK #0x2
00A264  780F00     MOV W0, [W14]
171:               
172:                   wiiReadData();
00A266  07008D     RCALL wiiReadData
173:                   wiiConvertData(blobs);
00A268  78001E     MOV [W14], W0
00A26A  070002     RCALL wiiConvertData
174:               }
00A26C  FA8000     ULNK
00A26E  060000     RETURN
175:               
176:               
177:               void wiiConvertData(WiiBlob *blobs) {
00A270  FA0006     LNK #0x6
00A272  980720     MOV W0, [W14+4]
178:               
179:                   unsigned char* wiidata = wiiData + 1;
00A274  221A90     MOV #0x21A9, W0
00A276  980710     MOV W0, [W14+2]
180:                   unsigned int i;
181:               
182:                   for (i = 0; i < 4; i++) {
00A278  EB0000     CLR W0
00A27A  780F00     MOV W0, [W14]
00A27C  370065     BRA 0xA348
00A346  E80F1E     INC [W14], [W14]
00A348  78009E     MOV [W14], W1
00A34A  200030     MOV #0x3, W0
00A34C  508F80     SUB W1, W0, [W15]
00A34E  36FF97     BRA LEU, 0xA27E
183:                       blobs[i].x = (((unsigned int)wiidata[i*3+2] & 0x0030) << 4) + wiidata[i*3];
00A27E  78001E     MOV [W14], W0
00A280  DD0043     SL W0, #3, W0
00A282  9000AE     MOV [W14+4], W1
00A284  408100     ADD W1, W0, W2
00A286  78001E     MOV [W14], W0
00A288  B90063     MUL.SU W0, #3, W0
00A28A  780000     MOV W0, W0
00A28C  E88000     INC2 W0, W0
00A28E  90009E     MOV [W14+2], W1
00A290  408000     ADD W1, W0, W0
00A292  784010     MOV.B [W0], W0
00A294  FB8080     ZE W0, W1
00A296  200300     MOV #0x30, W0
00A298  608000     AND W1, W0, W0
00A29A  DD01C4     SL W0, #4, W3
00A29C  78001E     MOV [W14], W0
00A29E  B90063     MUL.SU W0, #3, W0
00A2A0  780000     MOV W0, W0
00A2A2  90009E     MOV [W14+2], W1
00A2A4  408000     ADD W1, W0, W0
00A2A6  784010     MOV.B [W0], W0
00A2A8  FB8000     ZE W0, W0
00A2AA  418000     ADD W3, W0, W0
00A2AC  780900     MOV W0, [W2]
184:                       blobs[i].y = (((unsigned int)wiidata[i*3+2] & 0x00C0) << 2) + wiidata[i*3+1];
00A2AE  78001E     MOV [W14], W0
00A2B0  DD0043     SL W0, #3, W0
00A2B2  9000AE     MOV [W14+4], W1
00A2B4  408100     ADD W1, W0, W2
00A2B6  78001E     MOV [W14], W0
00A2B8  B90063     MUL.SU W0, #3, W0
00A2BA  780000     MOV W0, W0
00A2BC  E88000     INC2 W0, W0
00A2BE  90009E     MOV [W14+2], W1
00A2C0  408000     ADD W1, W0, W0
00A2C2  784010     MOV.B [W0], W0
00A2C4  FB8080     ZE W0, W1
00A2C6  200C00     MOV #0xC0, W0
00A2C8  608000     AND W1, W0, W0
00A2CA  DD01C2     SL W0, #2, W3
00A2CC  78001E     MOV [W14], W0
00A2CE  B90063     MUL.SU W0, #3, W0
00A2D0  780000     MOV W0, W0
00A2D2  E80000     INC W0, W0
00A2D4  90009E     MOV [W14+2], W1
00A2D6  408000     ADD W1, W0, W0
00A2D8  784010     MOV.B [W0], W0
00A2DA  FB8000     ZE W0, W0
00A2DC  418000     ADD W3, W0, W0
00A2DE  980110     MOV W0, [W2+2]
185:                       blobs[i].size = wiidata[i*3+2] & 0x0F;
00A2E0  78001E     MOV [W14], W0
00A2E2  DD0043     SL W0, #3, W0
00A2E4  9000AE     MOV [W14+4], W1
00A2E6  408100     ADD W1, W0, W2
00A2E8  78001E     MOV [W14], W0
00A2EA  B90063     MUL.SU W0, #3, W0
00A2EC  780000     MOV W0, W0
00A2EE  E88000     INC2 W0, W0
00A2F0  90009E     MOV [W14+2], W1
00A2F2  408000     ADD W1, W0, W0
00A2F4  784010     MOV.B [W0], W0
00A2F6  60406F     AND.B W0, #0xF, W0
00A2F8  984140     MOV.B W0, [W2+4]
186:               
187:                       if (blobs[i].x < 5 || blobs[i].x > 1018 || blobs[i].y < 5 || blobs[i].y > 763) {
00A2FA  78001E     MOV [W14], W0
00A2FC  DD0043     SL W0, #3, W0
00A2FE  9000AE     MOV [W14+4], W1
00A300  408000     ADD W1, W0, W0
00A302  780090     MOV [W0], W1
00A304  200040     MOV #0x4, W0
00A306  508F80     SUB W1, W0, [W15]
00A308  340018     BRA LE, 0xA33A
00A30A  78001E     MOV [W14], W0
00A30C  DD0043     SL W0, #3, W0
00A30E  9000AE     MOV [W14+4], W1
00A310  408000     ADD W1, W0, W0
00A312  780090     MOV [W0], W1
00A314  203FA0     MOV #0x3FA, W0
00A316  508F80     SUB W1, W0, [W15]
00A318  3C0010     BRA GT, 0xA33A
00A31A  78001E     MOV [W14], W0
00A31C  DD0043     SL W0, #3, W0
00A31E  9000AE     MOV [W14+4], W1
00A320  408000     ADD W1, W0, W0
00A322  900090     MOV [W0+2], W1
00A324  200040     MOV #0x4, W0
00A326  508F80     SUB W1, W0, [W15]
00A328  340008     BRA LE, 0xA33A
00A32A  78001E     MOV [W14], W0
00A32C  DD0043     SL W0, #3, W0
00A32E  9000AE     MOV [W14+4], W1
00A330  408000     ADD W1, W0, W0
00A332  900090     MOV [W0+2], W1
00A334  202FB0     MOV #0x2FB, W0
00A336  508F80     SUB W1, W0, [W15]
00A338  340006     BRA LE, 0xA346
188:                           blobs[i].size = WII_INVALID_BLOB; // invalid blob
00A33A  78001E     MOV [W14], W0
00A33C  DD0043     SL W0, #3, W0
00A33E  9000AE     MOV [W14+4], W1
00A340  408080     ADD W1, W0, W1
00A342  EBC000     SETM.B W0
00A344  9840C0     MOV.B W0, [W1+4]
189:                       }
190:               
191:                   }
192:               }
00A350  FA8000     ULNK
00A352  060000     RETURN
193:               
194:               
195:               unsigned char* wiiToString(void) {
00A354  FA0000     LNK #0x0
196:                   return wiiData + 1; 
00A356  221A90     MOV #0x21A9, W0
197:               }
00A358  FA8000     ULNK
00A35A  060000     RETURN
198:               
199:               void wiiDumpData(unsigned char* buffer) {
00A35C  FA0004     LNK #0x4
00A35E  980710     MOV W0, [W14+2]
200:                   int i;
201:                   for (i = 0; i < 12; i++) {
00A360  EB0000     CLR W0
00A362  780F00     MOV W0, [W14]
00A364  370008     BRA 0xA376
00A374  E80F1E     INC [W14], [W14]
00A376  78009E     MOV [W14], W1
00A378  2000B0     MOV #0xB, W0
00A37A  508F80     SUB W1, W0, [W15]
00A37C  34FFF4     BRA LE, 0xA366
202:                       buffer[i] = wiiData[i+1];
00A366  78001E     MOV [W14], W0
00A368  90009E     MOV [W14+2], W1
00A36A  408080     ADD W1, W0, W1
00A36C  E8001E     INC [W14], W0
00A36E  221A82     MOV #0x21A8, W2
00A370  784062     MOV.B [W2+W0], W0
00A372  784880     MOV.B W0, [W1]
203:                   }
204:               }
00A37E  FA8000     ULNK
00A380  060000     RETURN
205:               
206:               
207:               unsigned char* wiiReadData(void) {
00A382  FA0000     LNK #0x0
208:                   wiiStartTx();
00A384  07005E     RCALL wiiStartTx
209:                   wiiSendByte(WII_ADDR_WR);
00A386  B3CB00     MOV #0xB0, W0
00A388  070047     RCALL wiiSendByte
210:                   wiiSendByte(0x36);
00A38A  B3C360     MOV #0x36, W0
00A38C  070045     RCALL wiiSendByte
211:                   wiiEndTx();
00A38E  070064     RCALL wiiEndTx
212:                   //delay_us(WII_READ_DELAY);       //this may not need.
213:                   wiiStartTx();
00A390  070058     RCALL wiiStartTx
214:                   wiiSendByte(WII_ADDR_RD);
00A392  B3CB10     MOV #0xB1, W0
00A394  070041     RCALL wiiSendByte
215:                   wiiReadString(13, wiiData, WII_DATA_WAIT);
00A396  203E82     MOV #0x3E8, W2
00A398  221A81     MOV #0x21A8, W1
00A39A  2000D0     MOV #0xD, W0
00A39C  022286     CALL _MastergetsI2C2
00A39E  000000     NOP
216:                   wiiEndTx();   
00A3A0  07005B     RCALL wiiEndTx
217:                   return wiiData + 1; 
00A3A2  221A90     MOV #0x21A9, W0
218:               }
00A3A4  FA8000     ULNK
00A3A6  060000     RETURN
219:               
220:               // Just return the first nonzero blob.
221:               // if there is no nonzero blob, return the previous one.
222:               // Need to refine this function later.
223:               // It would not work for more than two blobs at the same frame.
224:               char wiiFindTarget(WiiBlob* blobs) {
00A3A8  FA0004     LNK #0x4
00A3AA  980710     MOV W0, [W14+2]
225:               
226:                   int i;
227:                   static unsigned char valid_wii_index = 0;
228:               
229:                   wiiConvertData(blobs);
00A3AC  90001E     MOV [W14+2], W0
00A3AE  07FF60     RCALL wiiConvertData
230:               
231:                   if (blobs[valid_wii_index].size != WII_INVALID_BLOB) {
00A3B0  221B90     MOV #0x21B9, W0
00A3B2  784010     MOV.B [W0], W0
00A3B4  FB8000     ZE W0, W0
00A3B6  DD0043     SL W0, #3, W0
00A3B8  90009E     MOV [W14+2], W1
00A3BA  408000     ADD W1, W0, W0
00A3BC  9040C0     MOV.B [W0+4], W1
00A3BE  EBC000     SETM.B W0
00A3C0  50CF80     SUB.B W1, W0, [W15]
00A3C2  320003     BRA Z, 0xA3CA
232:                       return valid_wii_index;
00A3C4  221B90     MOV #0x21B9, W0
00A3C6  784010     MOV.B [W0], W0
00A3C8  370018     BRA 0xA3FA
233:                   } else {
234:                       for (i = 0; i < 4; i++) {
00A3CA  EB0000     CLR W0
00A3CC  780F00     MOV W0, [W14]
00A3CE  370010     BRA 0xA3F0
00A3EE  E80F1E     INC [W14], [W14]
00A3F0  78009E     MOV [W14], W1
00A3F2  200030     MOV #0x3, W0
00A3F4  508F80     SUB W1, W0, [W15]
00A3F6  34FFEC     BRA LE, 0xA3D0
235:                           if (blobs[i].size != WII_INVALID_BLOB) {
00A3D0  78001E     MOV [W14], W0
00A3D2  DD0043     SL W0, #3, W0
00A3D4  90009E     MOV [W14+2], W1
00A3D6  408000     ADD W1, W0, W0
00A3D8  9040C0     MOV.B [W0+4], W1
00A3DA  EBC000     SETM.B W0
00A3DC  50CF80     SUB.B W1, W0, [W15]
00A3DE  320007     BRA Z, 0xA3EE
236:                               valid_wii_index = i;
00A3E0  78001E     MOV [W14], W0
00A3E2  784000     MOV.B W0, W0
00A3E4  221B91     MOV #0x21B9, W1
00A3E6  784880     MOV.B W0, [W1]
237:                               return i;
00A3E8  78001E     MOV [W14], W0
00A3EA  784000     MOV.B W0, W0
00A3EC  370006     BRA 0xA3FA
238:                           }
239:                       }
240:                   }
241:               
242:                   return -1;   // cound not find target.
00A3F8  EBC000     SETM.B W0
243:               
244:               
245:                   /* For flashing targets
246:                   int i;
247:                   static unsigned char patterns[4] = {0,0,0,0};
248:                   unsigned char nibbles[2];
249:                   unsigned char target_index = 4;
250:               
251:                   wiiConvertData(blobs);
252:               
253:                   for (i = 0; i < 4; ++i) {
254:                       if (blobs[i].size == WII_INVALID_BLOB) {
255:                           patterns[i] = patterns[i] << 1;     // pad 0 at the end
256:                       } else { 
257:                           patterns[i] = (patterns[i] << 1) + 1;     // pad 1 at the end
258:                       }
259:               
260:                       // nibbles should be the same for pattern detectioin except PATERN_1111
261:                       nibbles[0] = patterns[i] & 0x0f;
262:                       nibbles[1] = (patterns[i] >> 4) & 0x0f;
263:               
264:                       if (nibbles[0] == 0x0f) {   // target found
265:                           blobs[i].pattern = WII_PATTERN_1111;
266:                           target_index = i;
267:                       } else if (nibbles[0] != nibbles[1] || nibbles[0] == 0x00) {       // no pattern found yet
268:                           blobs[i].pattern = WII_PATTERN_0000;
269:                       } else if (nibbles[0] == 0x05 || nibbles[0] == 0x0a ) {
270:                           blobs[i].pattern = WII_PATTERN_0101;
271:                       } else if (nibbles[0] == 0x01 || nibbles[0] == 0x02 || nibbles[0] == 0x04 || nibbles[0] == 0x08) {
272:                           blobs[i].pattern = WII_PATTERN_0001;
273:                       } else if (nibbles[0] == 0x03 || nibbles[0] == 0x06 || nibbles[0] == 0x09 || nibbles[0] == 0x0c ) {
274:                           blobs[i].pattern = WII_PATTERN_0011;
275:                       } else {    // 0x07, 0x0b, 0x0d, 0x0e
276:                           blobs[i].pattern = WII_PATTERN_0111;
277:                       }
278:               
279:                   }
280:               
281:                   return target_index;
282:               
283:                   */
284:               
285:               }
00A3FA  FA8000     ULNK
00A3FC  060000     RETURN
286:               
287:               
288:               
289:               
290:               
291:               
292:               /*-----------------------------------------------------------------------------
293:                * ----------------------------------------------------------------------------
294:                * The functions below are intended for internal use, i.e., private methods.
295:                * Users are recommended to use functions defined above.
296:                * ----------------------------------------------------------------------------
297:               -----------------------------------------------------------------------------*/
298:               
299:               
300:               /*****************************************************************************
301:               * Function Name : wiiWrite
302:               * Description   : Write a data to a register
303:               * Parameters    : regaddr - address of register
304:               *                 data - value to be written to the register
305:               * Return Value  : None
306:               *****************************************************************************/
307:               static void wiiWrite( unsigned char subaddr, unsigned char data ){
00A3FE  FA0002     LNK #0x2
00A400  784F00     MOV.B W0, [W14]
00A402  984711     MOV.B W1, [W14+1]
308:                   wiiStartTx();
00A404  07001E     RCALL wiiStartTx
309:                   wiiSendByte(WII_ADDR_WR);
00A406  B3CB00     MOV #0xB0, W0
00A408  070007     RCALL wiiSendByte
310:                   wiiSendByte(subaddr);
00A40A  78401E     MOV.B [W14], W0
00A40C  070005     RCALL wiiSendByte
311:                   wiiSendByte(data);
00A40E  90401E     MOV.B [W14+1], W0
00A410  070003     RCALL wiiSendByte
312:                   wiiEndTx();
00A412  070022     RCALL wiiEndTx
313:               }
00A414  FA8000     ULNK
00A416  060000     RETURN
314:               
315:               /*****************************************************************************
316:               * Function Name : wiiSendByte
317:               * Description   : Send a byte to wii camera
318:               * Parameters    : byte - a byte to send
319:               * Return Value  : None
320:               *****************************************************************************/
321:               static void wiiSendByte( unsigned char byte ){
00A418  FA0002     LNK #0x2
00A41A  784F00     MOV.B W0, [W14]
322:                   MasterWriteI2C2(byte);
00A41C  78401E     MOV.B [W14], W0
00A41E  02221E     CALL _MasterWriteI2C2
00A420  000000     NOP
323:                   while(I2C2STATbits.TRSTAT);
00A422  000000     NOP
00A424  8010C1     MOV I2C2STAT, W1
00A426  240000     MOV #0x4000, W0
00A428  608080     AND W1, W0, W1
00A42A  EB0000     CLR W0
00A42C  508F80     SUB W1, W0, [W15]
00A42E  3AFFFA     BRA NZ, 0xA424
324:                   while(I2C2STATbits.ACKSTAT);
00A430  000000     NOP
00A432  8010C1     MOV I2C2STAT, W1
00A434  280000     MOV #0x8000, W0
00A436  608080     AND W1, W0, W1
00A438  EB0000     CLR W0
00A43A  508F80     SUB W1, W0, [W15]
00A43C  3AFFFA     BRA NZ, 0xA432
325:               }
00A43E  FA8000     ULNK
00A440  060000     RETURN
326:               
327:               /*****************************************************************************
328:               * Function Name : wiiReceiveByte
329:               * Description   : Receive a byte from wii camera
330:               * Parameters    : None
331:               * Return Value  : None
332:               *****************************************************************************/
333:               /*
334:               static unsigned char wiiReceiveByte(void){
335:                   return MasterReadI2C2();
336:               }
337:               */
338:               
339:               /*****************************************************************************
340:               * Function Name : wiiSendNack
341:               * Description   : Send NACK to wii camera
342:               * Parameters    : None
343:               * Return Value  : None
344:               *****************************************************************************/
345:               /*
346:               static void wiiSendNack (void){
347:                   NotAckI2C2();
348:                   while(I2C2CONbits.ACKEN);
349:               }
350:               */
351:               
352:               /*****************************************************************************
353:               * Function Name : wiiStartTx
354:               * Description   : Start I2C transmission
355:               * Parameters    : None
356:               * Return Value  : None
357:               *****************************************************************************/
358:               static void wiiStartTx(void){
00A442  FA0000     LNK #0x0
359:                   StartI2C2();
00A444  0222E2     CALL _StartI2C2
00A446  000000     NOP
360:                   while(I2C2CONbits.SEN);
00A448  000000     NOP
00A44A  8010B0     MOV I2C2CON, W0
00A44C  6000E1     AND W0, #0x1, W1
00A44E  EB0000     CLR W0
00A450  508F80     SUB W1, W0, [W15]
00A452  3AFFFB     BRA NZ, 0xA44A
361:               }
00A454  FA8000     ULNK
00A456  060000     RETURN
362:               
363:               /*****************************************************************************
364:               * Function Name : wiiEndTx
365:               * Description   : End I2C transmission
366:               * Parameters    : None
367:               * Return Value  : None
368:               *****************************************************************************/
369:               static void wiiEndTx (void){
00A458  FA0000     LNK #0x0
370:                   StopI2C2();
00A45A  0222EA     CALL _StopI2C2
00A45C  000000     NOP
371:                   while(I2C2CONbits.PEN);
00A45E  000000     NOP
00A460  8010B0     MOV I2C2CON, W0
00A462  6000E4     AND W0, #0x4, W1
00A464  EB0000     CLR W0
00A466  508F80     SUB W1, W0, [W15]
00A468  3AFFFB     BRA NZ, 0xA460
372:               }
00A46A  FA8000     ULNK
00A46C  060000     RETURN
373:               
374:               /*****************************************************************************
375:               * Function Name : wiiSetupPeripheral
376:               * Description   : Setup I2C for wiimote
377:               * Parameters    : None
378:               * Return Value  : None
379:               *****************************************************************************/
380:               static void wiiSetupPeripheral(void) {
00A46E  FA0004     LNK #0x4
381:                   unsigned int I2C2CONvalue, I2C2BRGvalue;
382:                   I2C2CONvalue = I2C2_ON & I2C2_IDLE_CON & I2C2_CLK_HLD &
00A470  2C2200     MOV #0xC220, W0
00A472  780F00     MOV W0, [W14]
383:                                  I2C2_IPMI_DIS & I2C2_7BIT_ADD & I2C2_SLW_DIS &
384:                                  I2C2_SM_DIS & I2C2_GCALL_DIS & I2C2_STR_DIS &
385:                                  I2C2_NACK & I2C2_ACK_DIS & I2C2_RCV_DIS &
386:                                  I2C2_STOP_DIS & I2C2_RESTART_DIS & I2C2_START_DIS;
387:               
388:                   // BRG = Fcy(1/Fscl - 1/10000000)-1, Fscl = 400KHz 	
389:                   I2C2BRGvalue = 95; 
00A474  2005F0     MOV #0x5F, W0
00A476  980710     MOV W0, [W14+2]
390:                   OpenI2C2(I2C2CONvalue, I2C2BRGvalue);
00A478  90009E     MOV [W14+2], W1
00A47A  78001E     MOV [W14], W0
00A47C  0222D8     CALL _OpenI2C2
00A47E  000000     NOP
391:                   IdleI2C2();
00A480  0221A8     CALL _IdleI2C2
00A482  000000     NOP
392:               }
00A484  FA8000     ULNK
00A486  060000     RETURN
393:               
394:               
395:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/stopwatch.c  ------------------------------------------
1:                 /*
2:                  * Copyright (c) 2008-2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Real time clock
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-06-16     Initial release
38:                 *                      
39:                 * Notes:
40:                 *  - MCU resources requied for this module:
41:                 *      Timer8 & Timer9 are used for a 32-bit timer.
42:                 *  - This module may need to be renamed to rtclock (real time clock).
43:                 *
44:                 */
45:                
46:                #include "timer.h"
47:                #include "stopwatch.h"
48:                
49:                #define TMR_MSW         TMR9HLD
50:                #define TMR_LSW         TMR8
51:                #define TIME_FACTOR     5   // resolution is 0.2us for prescale of 8
52:                
53:                typedef union {
54:                    unsigned long time;
55:                    struct {
56:                        unsigned int lsw;
57:                        unsigned int msw;
58:                    } half;
59:                } Clock;
60:                
61:                
62:                /*-----------------------------------------------------------------------------
63:                 *          Static Variables
64:                -----------------------------------------------------------------------------*/
65:                
66:                // to save the time when swatchTic() is called.
67:                static Clock tictoc_;
68:                
69:                /*-----------------------------------------------------------------------------
70:                 *          Declaration of static functions
71:                -----------------------------------------------------------------------------*/
72:                
73:                static void swatchSetupPeripheral(void);
74:                
75:                /*-----------------------------------------------------------------------------
76:                 *          Public functions
77:                -----------------------------------------------------------------------------*/
78:                
79:                void swatchSetup(void) {
00DC60  FA0000     LNK #0x0
80:                    swatchSetupPeripheral();
00DC62  07005D     RCALL swatchSetupPeripheral
81:                    swatchReset();
00DC64  070002     RCALL swatchReset
82:                }
00DC66  FA8000     ULNK
00DC68  060000     RETURN
83:                
84:                void swatchReset(void) {
00DC6A  FA0000     LNK #0x0
85:                    // do not change the order of the following two lines.
86:                    TMR_MSW = 0;
00DC6C  EB0000     CLR W0
00DC6E  880990     MOV W0, TMR9HLD
87:                    TMR_LSW = 0;
00DC70  EB0000     CLR W0
00DC72  880980     MOV W0, TMR8
88:                }
00DC74  FA8000     ULNK
00DC76  060000     RETURN
89:                
90:                unsigned long swatchTic(void) {
00DC78  FA0000     LNK #0x0
91:                    // do not change the order of the following two lines.
92:                    tictoc_.half.lsw = TMR_LSW;
00DC7A  800980     MOV TMR8, W0
00DC7C  891130     MOV W0, _tictoc_
93:                    tictoc_.half.msw = TMR_MSW;
00DC7E  800990     MOV TMR9HLD, W0
00DC80  891140     MOV W0, 0x2228
94:                    return (tictoc_.time)/TIME_FACTOR;
00DC82  811130     MOV _tictoc_, W0
00DC84  811141     MOV 0x2228, W1
00DC86  200052     MOV #0x5, W2
00DC88  200003     MOV #0x0, W3
00DC8A  022D42     CALL ___udivsi3x
00DC8C  000000     NOP
95:                }
00DC8E  FA8000     ULNK
00DC90  060000     RETURN
96:                
97:                unsigned long swatchToc(void) {
00DC92  FA0004     LNK #0x4
98:                    Clock toc;
99:                    // do not change the order of the following two lines.
100:                   toc.half.lsw = TMR_LSW;
00DC94  800980     MOV TMR8, W0
00DC96  780F00     MOV W0, [W14]
101:                   toc.half.msw = TMR_MSW;
00DC98  800990     MOV TMR9HLD, W0
00DC9A  980710     MOV W0, [W14+2]
102:                   return (toc.time - tictoc_.time)/TIME_FACTOR;
00DC9C  BE011E     MOV.D [W14], W2
00DC9E  811130     MOV _tictoc_, W0
00DCA0  811141     MOV 0x2228, W1
00DCA2  510000     SUB W2, W0, W0
00DCA4  598081     SUBB W3, W1, W1
00DCA6  200052     MOV #0x5, W2
00DCA8  200003     MOV #0x0, W3
00DCAA  022D42     CALL ___udivsi3x
00DCAC  000000     NOP
103:               }
00DCAE  FA8000     ULNK
00DCB0  060000     RETURN
104:               
105:               
106:               void swatchDelayUs(unsigned long delay) {
00DCB2  FA000C     LNK #0xC
00DCB4  980740     MOV W0, [W14+8]
00DCB6  980751     MOV W1, [W14+10]
107:                   Clock swatch;
108:                   unsigned long exit_time;
109:               
110:                   swatch.half.lsw = TMR_LSW;
00DCB8  800980     MOV TMR8, W0
00DCBA  980720     MOV W0, [W14+4]
111:                   swatch.half.msw = TMR_MSW;
00DCBC  800990     MOV TMR9HLD, W0
00DCBE  980730     MOV W0, [W14+6]
112:                   exit_time = swatch.time + delay*TIME_FACTOR;
00DCC0  90022E     MOV [W14+4], W4
00DCC2  9002BE     MOV [W14+6], W5
00DCC4  90005E     MOV [W14+10], W0
00DCC6  B90065     MUL.SU W0, #5, W0
00DCC8  780100     MOV W0, W2
00DCCA  90004E     MOV [W14+8], W0
00DCCC  B90060     MUL.SU W0, #0, W0
00DCCE  780000     MOV W0, W0
00DCD0  410100     ADD W2, W0, W2
00DCD2  9000CE     MOV [W14+8], W1
00DCD4  200050     MOV #0x5, W0
00DCD6  B80800     MUL.UU W1, W0, W0
00DCD8  410101     ADD W2, W1, W2
00DCDA  780082     MOV W2, W1
00DCDC  421F00     ADD W4, W0, [W14++]
00DCDE  4A9701     ADDC W5, W1, [W14--]
113:                   
114:                   while(swatch.time < exit_time) {
00DCE0  370004     BRA 0xDCEA
00DCEA  90012E     MOV [W14+4], W2
00DCEC  9001BE     MOV [W14+6], W3
00DCEE  BE001E     MOV.D [W14], W0
00DCF0  510F80     SUB W2, W0, [W15]
00DCF2  598F81     SUBB W3, W1, [W15]
00DCF4  39FFF6     BRA NC, 0xDCE2
115:                       swatch.half.lsw = TMR_LSW;
00DCE2  800980     MOV TMR8, W0
00DCE4  980720     MOV W0, [W14+4]
116:                       swatch.half.msw = TMR_MSW;
00DCE6  800990     MOV TMR9HLD, W0
00DCE8  980730     MOV W0, [W14+6]
117:                   }
118:               }
00DCF6  FA8000     ULNK
00DCF8  060000     RETURN
119:               
120:               
121:               void swatchDelayMs(unsigned long delay) {
00DCFA  FA0004     LNK #0x4
00DCFC  BE8F00     MOV.D W0, [W14]
122:                   swatchDelayUs(delay*1000);
00DCFE  90009E     MOV [W14+2], W1
00DD00  203E80     MOV #0x3E8, W0
00DD02  B98800     MUL.SS W1, W0, W0
00DD04  780100     MOV W0, W2
00DD06  78001E     MOV [W14], W0
00DD08  B90060     MUL.SU W0, #0, W0
00DD0A  780000     MOV W0, W0
00DD0C  410100     ADD W2, W0, W2
00DD0E  78009E     MOV [W14], W1
00DD10  203E80     MOV #0x3E8, W0
00DD12  B80800     MUL.UU W1, W0, W0
00DD14  410101     ADD W2, W1, W2
00DD16  780082     MOV W2, W1
00DD18  07FFCC     RCALL swatchDelayUs
123:               }
00DD1A  FA8000     ULNK
00DD1C  060000     RETURN
124:               
125:               
126:               
127:               /*-----------------------------------------------------------------------------
128:                * ----------------------------------------------------------------------------
129:                * The functions below are intended for internal use, i.e., static functions.
130:                * Users are recommended to use functions defined above.
131:                * ----------------------------------------------------------------------------
132:               -----------------------------------------------------------------------------*/
133:               
134:               
135:               /*****************************************************************************
136:               * Timer8 & Timer9 are used for swatch module.
137:               * No Interrupt is associated with Timer8.
138:               * T8PER does not mean anything.
139:               * Timer increase by one every 0.2us  
140:               * Timer8 & Timer9 should be set up as 32-bit timer with prescale of 8
141:               * Then, the 32-bit timer will increase its value by one every 0.2us.
142:               * Interrupt for Timers is not used.
143:               *****************************************************************************/
144:               static void swatchSetupPeripheral(void) {
00DD1E  FA0004     LNK #0x4
145:                   unsigned int T8CONvalue, T8PERvalue;
146:                   T8CONvalue = T8_OFF & T8_IDLE_CON & T8_GATE_OFF &
00DD20  25F9D0     MOV #0x5F9D, W0
00DD22  780F00     MOV W0, [W14]
147:                                T8_PS_1_8 & T8_32BIT_MODE_ON & T8_SOURCE_INT;
148:                   // prescale 1:8
149:                   // Period is set so that period = 1us (1MHz), MIPS = 40MHz
150:                   // value = Fcy/(prescale*Ftimer)
151:                   T8PERvalue = 40;    // this value doesn't really mean anything here.
00DD24  200280     MOV #0x28, W0
00DD26  980710     MOV W0, [W14+2]
152:                   OpenTimer8(T8CONvalue, T8PERvalue);	
00DD28  90009E     MOV [W14+2], W1
00DD2A  78001E     MOV [W14], W0
00DD2C  022566     CALL _OpenTimer8
00DD2E  000000     NOP
153:                   T8CONbits.TON = 1;
00DD30  A8E13B     BSET 0x13B, #7
154:               }
00DD32  FA8000     ULNK
00DD34  060000     RETURN
155:               
156:               
157:               
158:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/spi_controller.c  -------------------------------------
1:                 /**
2:                  * Copyright (c) 2011, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Master Mode SPI Controller for the dsPIC33F
31:                 *
32:                 *    by Humphrey Hu
33:                 *
34:                 * Revisions:
35:                 *  Humphrey Hu        2011-11-10      Initial implemetation
36:                 *  Humphrey Hu     2012-02-09      Code refactor and comments
37:                 * Notes:
38:                 * Work harder!
39:                 * Add #defines to remove buffers when not in use
40:                 * If DMA operations never return, calls to blocking methods will deadlock
41:                 * This is a problem if a higher-level timeout fires before the spic timeout
42:                 */
43:                
44:                #include "spi_controller.h"
45:                #include "spi.h"
46:                #include "timer.h"
47:                #include "dma.h"
48:                
49:                #include <string.h>
50:                
51:                // This section is board-specific
52:                // TODO: Generalize or move to BSP header
53:                #if defined(__IMAGEPROC2)
54:                
55:                    #define SPI1_CS             (_LATB2)    // Radio Chip Select
56:                    #define SPI2_CS             (_LATG9)    // Flash Chip Select
57:                
58:                #endif
59:                // DMA channels allocated as per Wiki assignments
60:                #define SPIC1_DMAR_CONbits      (DMA2CONbits)
61:                #define SPIC1_DMAR_CNT          (DMA2CNT)
62:                #define SPIC1_DMAR_REQbits      (DMA2REQbits)
63:                #define SPIC1_DMAW_CONbits      (DMA3CONbits)
64:                #define SPIC1_DMAW_CNT          (DMA3CNT)
65:                #define SPIC1_DMAW_REQbits      (DMA3REQbits)
66:                
67:                #define SPIC2_DMAR_CONbits      (DMA4CONbits)
68:                #define SPIC2_DMAR_CNT          (DMA4CNT)
69:                #define SPIC2_DMAR_REQbits      (DMA4REQbits)
70:                #define SPIC2_DMAW_CONbits      (DMA5CONbits)
71:                #define SPIC2_DMAW_CNT          (DMA5CNT)
72:                #define SPIC2_DMAW_REQbits      (DMA5REQbits)
73:                
74:                #define SPI1_REQ_VAL            (0x00A) // SPI1 Transfer Done Interrupt
75:                #define SPI2_REQ_VAL            (0x021) // SPI2 Transfer Done Interrupt
76:                    
77:                #define SPIC1_RX_BUFF_LEN       (128) // Radio buffer is 128 bytes
78:                #define SPIC1_TX_BUFF_LEN       (128)
79:                
80:                #define SPIC2_RX_BUFF_LEN       (264) // Flash page is 264/528 bytes
81:                #define SPIC2_TX_BUFF_LEN       (264) // Currently not in use
82:                
83:                #define US_TO_TICKS(X)          ((X*10)/16) // Microseconds to cycles with 64:1 prescale 
84:                
85:                // TODO: Move this into some generics.h !!
86:                #define FCY                     (40000000)
87:                
88:                #define SPI_CS_ACTIVE           (0)
89:                #define SPI_CS_IDLE             (1)
90:                
91:                /** Port status codes */
92:                typedef enum {
93:                    STAT_SPI_CLOSED, /** Port not initialized */
94:                    STAT_SPI_OPEN,  /** Port not busy */
95:                    STAT_SPI_BUSY,  /** Port busy */
96:                } SpicStatus;
97:                
98:                // =========== Function Prototypes ============================================
99:                static void setupDMASet1(void);
100:               static void setupDMASet2(void);
101:               
102:               // =========== Static Variables ===============================================
103:               
104:               /** Interrupt handlers */
105:               static SpicIrqHandler int_handler[SPIC_NUM_PORTS];
106:               
107:               /** Current port statuses */
108:               static SpicStatus port_status[SPIC_NUM_PORTS];
109:               
110:               // Port 1 buffers
111:               static unsigned char spic1_rx_buff[SPIC1_RX_BUFF_LEN] __attribute__((space(dma)));
112:               static unsigned char spic1_tx_buff[SPIC1_TX_BUFF_LEN] __attribute__((space(dma)));
113:               
114:               // Port 2 buffers
115:               static unsigned char spic2_rx_buff[SPIC2_RX_BUFF_LEN] __attribute__((space(dma)));
116:               static unsigned char spic2_tx_buff[SPIC2_TX_BUFF_LEN] __attribute__((space(dma)));
117:               
118:               // =========== Public Methods =================================================
119:               
120:               void spicSetupChannel1(void) {
00AB74  FA0000     LNK #0x0
121:                   
122:                   setupDMASet1();     // Set up DMA channels       
00AB76  070130     RCALL setupDMASet1
123:                   port_status[0] = STAT_SPI_CLOSED;   // Initialize status    
00AB78  EB0000     CLR W0
00AB7A  891020     MOV W0, port_status
124:                   
125:               }
00AB7C  FA8000     ULNK
00AB7E  060000     RETURN
126:               
127:               void spicSetupChannel2(void) {
00AB80  FA0000     LNK #0x0
128:               
129:                   setupDMASet2();
00AB82  070163     RCALL setupDMASet2
130:                   port_status[1] = STAT_SPI_CLOSED;
00AB84  EB0000     CLR W0
00AB86  891030     MOV W0, 0x2206
131:               
132:               }
00AB88  FA8000     ULNK
00AB8A  060000     RETURN
133:               
134:               void spic1SetCallback(SpicIrqHandler handler) {
00AB8C  FA0002     LNK #0x2
00AB8E  780F00     MOV W0, [W14]
135:                   
136:                   int_handler[0] = handler;
00AB90  78001E     MOV [W14], W0
00AB92  891000     MOV W0, int_handler
137:                   
138:               }
00AB94  FA8000     ULNK
00AB96  060000     RETURN
139:               
140:               
141:               void spic2SetCallback(SpicIrqHandler handler) {
00AB98  FA0002     LNK #0x2
00AB9A  780F00     MOV W0, [W14]
142:                   
143:                   int_handler[1] = handler;
00AB9C  78001E     MOV [W14], W0
00AB9E  891010     MOV W0, 0x2202
144:                   
145:               }
00ABA0  FA8000     ULNK
00ABA2  060000     RETURN
146:               
147:               void spic1BeginTransaction(void) {
00ABA4  FA0000     LNK #0x0
148:                   // TODO: Timeout?
149:                   while(port_status[0] == STAT_SPI_BUSY); // Wait for port to become available
00ABA6  000000     NOP
00ABA8  811021     MOV port_status, W1
00ABAA  200020     MOV #0x2, W0
00ABAC  508F80     SUB W1, W0, [W15]
00ABAE  32FFFC     BRA Z, 0xABA8
150:                   port_status[0] = STAT_SPI_BUSY;
00ABB0  200020     MOV #0x2, W0
00ABB2  891020     MOV W0, port_status
151:                   SPI1_CS = SPI_CS_ACTIVE;    // Activate chip select
00ABB4  A942CA     BCLR LATB, #2
152:                   
153:               }
00ABB6  FA8000     ULNK
00ABB8  060000     RETURN
154:               
155:               void spic2BeginTransaction(void) {
00ABBA  FA0000     LNK #0x0
156:               
157:                   while(port_status[1] == STAT_SPI_BUSY); // Wait for port to become available
00ABBC  000000     NOP
00ABBE  811031     MOV 0x2206, W1
00ABC0  200020     MOV #0x2, W0
00ABC2  508F80     SUB W1, W0, [W15]
00ABC4  32FFFC     BRA Z, 0xABBE
158:                   port_status[1] = STAT_SPI_BUSY;
00ABC6  200020     MOV #0x2, W0
00ABC8  891030     MOV W0, 0x2206
159:                   SPI2_CS = SPI_CS_ACTIVE;     // Activate chip select
00ABCA  A922E9     BCLR 0x2E9, #1
160:                   
161:               }
00ABCC  FA8000     ULNK
00ABCE  060000     RETURN
162:               
163:               void spic1EndTransaction(void) {
00ABD0  FA0000     LNK #0x0
164:               
165:                   port_status[0] = STAT_SPI_OPEN; // Free port
00ABD2  200010     MOV #0x1, W0
00ABD4  891020     MOV W0, port_status
166:                   SPI1_CS = SPI_CS_IDLE;  // Idle chip select after freeing since may cause irq
00ABD6  A842CA     BSET LATB, #2
167:                   
168:               }
00ABD8  FA8000     ULNK
00ABDA  060000     RETURN
169:               
170:               void spic2EndTransaction(void) {
00ABDC  FA0000     LNK #0x0
171:               
172:                   port_status[1] = STAT_SPI_OPEN; // Free port
00ABDE  200010     MOV #0x1, W0
00ABE0  891030     MOV W0, 0x2206
173:                   SPI2_CS = SPI_CS_IDLE;  // Idle chip select
00ABE2  A822E9     BSET 0x2E9, #1
174:                   
175:               }
00ABE4  FA8000     ULNK
00ABE6  060000     RETURN
176:               
177:               void spic1Reset(void) {
00ABE8  FA0000     LNK #0x0
178:               
179:                   SPI1_CS = SPI_CS_IDLE;          // Disable chip select
00ABEA  A842CA     BSET LATB, #2
180:                   SPIC1_DMAR_CONbits.CHEN = 0;    // Disable DMA module
00ABEC  A9E399     BCLR 0x399, #7
181:                   SPIC1_DMAW_CONbits.CHEN = 0;
00ABEE  A9E3A5     BCLR 0x3A5, #7
182:                   SPI1STATbits.SPIROV = 0;        // Clear overwrite bit
00ABF0  A9C240     BCLR SPI1STAT, #6
183:                   port_status[0] = STAT_SPI_OPEN;    // Release lock on channel
00ABF2  200010     MOV #0x1, W0
00ABF4  891020     MOV W0, port_status
184:                   //stopTimer();                    // Stop watchdog timer
185:                   
186:               }
00ABF6  FA8000     ULNK
00ABF8  060000     RETURN
187:               
188:               void spic2Reset(void) {
00ABFA  FA0000     LNK #0x0
189:               
190:                   SPI2_CS = SPI_CS_IDLE;          // Disable chip select
00ABFC  A822E9     BSET 0x2E9, #1
191:                   SPIC2_DMAR_CONbits.CHEN = 0;    // Disable DMA module
00ABFE  A9E3B1     BCLR 0x3B1, #7
192:                   //stopTimer();                    // Stop watchdog timer
193:                   port_status[1] = STAT_SPI_OPEN;    // Release lock on channel
00AC00  200010     MOV #0x1, W0
00AC02  891030     MOV W0, 0x2206
194:               
195:               }
00AC04  FA8000     ULNK
00AC06  060000     RETURN
196:               
197:               unsigned char spic1Transmit(unsigned char data) {
00AC08  FA0004     LNK #0x4
00AC0A  984720     MOV.B W0, [W14+2]
198:                   
199:                   unsigned char c;
200:                   SPI1STATbits.SPIROV = 0;        // Clear overflow bit
00AC0C  A9C240     BCLR SPI1STAT, #6
201:                   SPI1BUF = data;                   // Initiate SPI bus cycle by byte write 
00AC0E  90402E     MOV.B [W14+2], W0
00AC10  FB8000     ZE W0, W0
00AC12  881240     MOV W0, SPI1BUF
202:                   while(SPI1STATbits.SPITBF);        // Wait for transmit to complete
00AC14  000000     NOP
00AC16  801200     MOV SPI1STAT, W0
00AC18  6000E2     AND W0, #0x2, W1
00AC1A  EB0000     CLR W0
00AC1C  508F80     SUB W1, W0, [W15]
00AC1E  3AFFFB     BRA NZ, 0xAC16
203:                   while(!SPI1STATbits.SPIRBF);    // Wait for receive to complete
00AC20  000000     NOP
00AC22  801200     MOV SPI1STAT, W0
00AC24  6000E1     AND W0, #0x1, W1
00AC26  EB0000     CLR W0
00AC28  508F80     SUB W1, W0, [W15]
00AC2A  32FFFB     BRA Z, 0xAC22
204:                   c = SPI1BUF;                    // Read out received data to avoid overflow 
00AC2C  801240     MOV SPI1BUF, W0
00AC2E  784F00     MOV.B W0, [W14]
205:                   return c;                        
00AC30  78401E     MOV.B [W14], W0
206:                   
207:               }
00AC32  FA8000     ULNK
00AC34  060000     RETURN
208:               
209:               unsigned char spic2Transmit(unsigned char data) {
00AC36  FA0004     LNK #0x4
00AC38  984720     MOV.B W0, [W14+2]
210:                   
211:                   unsigned char c;
212:                   SPI2STATbits.SPIROV = 0;        // Clear overflow bit
00AC3A  A9C260     BCLR SPI2STAT, #6
213:                   SPI2BUF = data;                   // Initiate SPI bus cycle by byte write 
00AC3C  90402E     MOV.B [W14+2], W0
00AC3E  FB8000     ZE W0, W0
00AC40  881340     MOV W0, SPI2BUF
214:                   while(SPI2STATbits.SPITBF);        // Wait for transmit to complete
00AC42  000000     NOP
00AC44  801300     MOV SPI2STAT, W0
00AC46  6000E2     AND W0, #0x2, W1
00AC48  EB0000     CLR W0
00AC4A  508F80     SUB W1, W0, [W15]
00AC4C  3AFFFB     BRA NZ, 0xAC44
215:                   while(!SPI2STATbits.SPIRBF);    // Wait for receive to complete
00AC4E  000000     NOP
00AC50  801300     MOV SPI2STAT, W0
00AC52  6000E1     AND W0, #0x1, W1
00AC54  EB0000     CLR W0
00AC56  508F80     SUB W1, W0, [W15]
00AC58  32FFFB     BRA Z, 0xAC50
216:                   c = SPI2BUF;                    // Read out received data to avoid overflow 
00AC5A  801340     MOV SPI2BUF, W0
00AC5C  784F00     MOV.B W0, [W14]
217:                   return c;                        
00AC5E  78401E     MOV.B [W14], W0
218:                   
219:               }
00AC60  FA8000     ULNK
00AC62  060000     RETURN
220:               
221:               // Note that this is the same as transmit with data = 0x00
222:               unsigned char spic1Receive(void) {
00AC64  FA0002     LNK #0x2
223:                   
224:                   unsigned char c;
225:                   SPI1STATbits.SPIROV = 0;        // Clear overflow bit
00AC66  A9C240     BCLR SPI1STAT, #6
226:                   SPI1BUF = 0x00;                 // Initiate SPI bus cycle by byte write 
00AC68  EB0000     CLR W0
00AC6A  881240     MOV W0, SPI1BUF
227:                   while(SPI1STATbits.SPITBF);     // Wait for transmit to complete
00AC6C  000000     NOP
00AC6E  801200     MOV SPI1STAT, W0
00AC70  6000E2     AND W0, #0x2, W1
00AC72  EB0000     CLR W0
00AC74  508F80     SUB W1, W0, [W15]
00AC76  3AFFFB     BRA NZ, 0xAC6E
228:                   while(!SPI1STATbits.SPIRBF);    // Wait for receive to complete
00AC78  000000     NOP
00AC7A  801200     MOV SPI1STAT, W0
00AC7C  6000E1     AND W0, #0x1, W1
00AC7E  EB0000     CLR W0
00AC80  508F80     SUB W1, W0, [W15]
00AC82  32FFFB     BRA Z, 0xAC7A
229:                   c = SPI1BUF;                    // Read out received data to avoid overflow 
00AC84  801240     MOV SPI1BUF, W0
00AC86  784F00     MOV.B W0, [W14]
230:                   return c;                        
00AC88  78401E     MOV.B [W14], W0
231:                   
232:               }
00AC8A  FA8000     ULNK
00AC8C  060000     RETURN
233:               
234:               
235:               // Note that this is the same as transmit with data = 0x00
236:               unsigned char spic2Receive(void) {
00AC8E  FA0002     LNK #0x2
237:                   
238:                   unsigned char c;
239:                   SPI2STATbits.SPIROV = 0;        // Clear overflow bit
00AC90  A9C260     BCLR SPI2STAT, #6
240:                   SPI2BUF = 0x00;                   // Initiate SPI bus cycle by byte write 
00AC92  EB0000     CLR W0
00AC94  881340     MOV W0, SPI2BUF
241:                   while(SPI2STATbits.SPITBF);        // Wait for transmit to complete
00AC96  000000     NOP
00AC98  801300     MOV SPI2STAT, W0
00AC9A  6000E2     AND W0, #0x2, W1
00AC9C  EB0000     CLR W0
00AC9E  508F80     SUB W1, W0, [W15]
00ACA0  3AFFFB     BRA NZ, 0xAC98
242:                   while(!SPI2STATbits.SPIRBF);    // Wait for receive to complete
00ACA2  000000     NOP
00ACA4  801300     MOV SPI2STAT, W0
00ACA6  6000E1     AND W0, #0x1, W1
00ACA8  EB0000     CLR W0
00ACAA  508F80     SUB W1, W0, [W15]
00ACAC  32FFFB     BRA Z, 0xACA4
243:                   c = SPI2BUF;                    // Read out received data to avoid overflow 
00ACAE  801340     MOV SPI2BUF, W0
00ACB0  784F00     MOV.B W0, [W14]
244:                   return c;                        
00ACB2  78401E     MOV.B [W14], W0
245:                   
246:               }
00ACB4  FA8000     ULNK
00ACB6  060000     RETURN
247:               
248:               
249:               unsigned int spic1MassTransmit(unsigned int len, unsigned char *buff, unsigned int timeout) {
00ACB8  FA0006     LNK #0x6
00ACBA  780F00     MOV W0, [W14]
00ACBC  980711     MOV W1, [W14+2]
00ACBE  980722     MOV W2, [W14+4]
250:                   
251:                   // Make sure requested length is in range
252:                   if(len > SPIC1_TX_BUFF_LEN) {
00ACC0  200800     MOV #0x80, W0
00ACC2  78009E     MOV [W14], W1
00ACC4  508F80     SUB W1, W0, [W15]
00ACC6  360002     BRA LEU, 0xACCC
253:                       len = SPIC1_TX_BUFF_LEN;
00ACC8  200800     MOV #0x80, W0
00ACCA  780F00     MOV W0, [W14]
254:                   }
255:                   
256:                   // If data is to be written
257:                   if(buff != NULL) {
00ACCC  90009E     MOV [W14+2], W1
00ACCE  EB0000     CLR W0
00ACD0  508F80     SUB W1, W0, [W15]
00ACD2  320008     BRA Z, 0xACE4
258:                       memcpy(spic1_tx_buff, buff, len);   // Copy data to DMA memory
00ACD4  78011E     MOV [W14], W2
00ACD6  90009E     MOV [W14+2], W1
00ACD8  244F00     MOV #0x44F0, W0
00ACDA  023582     CALL _memcpy
00ACDC  000000     NOP
259:                       SPIC1_DMAR_CONbits.NULLW = 0;   // Ensure null writes are disabled
00ACDE  A96399     BCLR 0x399, #3
260:                       SPIC1_DMAW_CONbits.NULLW = 0;
00ACE0  A963A5     BCLR 0x3A5, #3
00ACE2  370002     BRA 0xACE8
261:                   } else {    
262:                       SPIC1_DMAR_CONbits.NULLW = 1;   // Else use null write mode
00ACE4  A86399     BSET 0x399, #3
263:                       SPIC1_DMAW_CONbits.NULLW = 1;
00ACE6  A863A5     BSET 0x3A5, #3
264:                   }
265:                   
266:                   SPIC1_DMAR_CNT = len;   // Set number of bytes to send
00ACE8  78001E     MOV [W14], W0
00ACEA  881D10     MOV W0, DMA2CNT
267:                   SPIC1_DMAW_CNT = len;
00ACEC  78001E     MOV [W14], W0
00ACEE  881D70     MOV W0, DMA3CNT
268:                   //startTimer(timeout);    // Start timeout timer
269:                   SPIC1_DMAR_CONbits.CHEN = 1;    // Begin transmission
00ACF0  A8E399     BSET 0x399, #7
270:                   SPIC1_DMAW_CONbits.CHEN = 1;
00ACF2  A8E3A5     BSET 0x3A5, #7
271:                   SPIC1_DMAW_REQbits.FORCE = 1;
00ACF4  A8E3A7     BSET 0x3A7, #7
272:                   return len;
00ACF6  78001E     MOV [W14], W0
273:                   
274:               }
00ACF8  FA8000     ULNK
00ACFA  060000     RETURN
275:               
276:               unsigned int spic2MassTransmit(unsigned int len, unsigned char *buff, unsigned int timeout) {
00ACFC  FA0006     LNK #0x6
00ACFE  780F00     MOV W0, [W14]
00AD00  980711     MOV W1, [W14+2]
00AD02  980722     MOV W2, [W14+4]
277:                   
278:                   // Make sure requested length is in range
279:                   if(len > SPIC2_TX_BUFF_LEN) {
00AD04  201080     MOV #0x108, W0
00AD06  78009E     MOV [W14], W1
00AD08  508F80     SUB W1, W0, [W15]
00AD0A  360002     BRA LEU, 0xAD10
280:                       len = SPIC2_TX_BUFF_LEN;
00AD0C  201080     MOV #0x108, W0
00AD0E  780F00     MOV W0, [W14]
281:                   }
282:                   
283:                   // If data is to be written
284:                   if(buff != NULL) {
00AD10  90009E     MOV [W14+2], W1
00AD12  EB0000     CLR W0
00AD14  508F80     SUB W1, W0, [W15]
00AD16  320008     BRA Z, 0xAD28
285:                       memcpy(spic2_tx_buff, buff, len);   // Copy data to DMA memory
00AD18  78011E     MOV [W14], W2
00AD1A  90009E     MOV [W14+2], W1
00AD1C  245F00     MOV #0x45F0, W0
00AD1E  023582     CALL _memcpy
00AD20  000000     NOP
286:                       SPIC2_DMAR_CONbits.NULLW = 0;   // Ensure null writes are disabled
00AD22  A963B1     BCLR 0x3B1, #3
287:                       SPIC2_DMAW_CONbits.NULLW = 0;
00AD24  A963BD     BCLR 0x3BD, #3
00AD26  370002     BRA 0xAD2C
288:                   } else {    
289:                       SPIC2_DMAR_CONbits.NULLW = 1;   // Else use null write mode
00AD28  A863B1     BSET 0x3B1, #3
290:                       SPIC2_DMAW_CONbits.NULLW = 1;
00AD2A  A863BD     BSET 0x3BD, #3
291:                   }
292:                   
293:                   SPIC2_DMAR_CNT = len;   // Set number of bytes to send
00AD2C  78001E     MOV [W14], W0
00AD2E  881DD0     MOV W0, DMA4CNT
294:                   SPIC2_DMAW_CNT = len;
00AD30  78001E     MOV [W14], W0
00AD32  881E30     MOV W0, DMA5CNT
295:                   //startTimer(timeout);        // Start timeout timer
296:                   SPIC2_DMAR_CONbits.CHEN = 1;    // Begin transmission
00AD34  A8E3B1     BSET 0x3B1, #7
297:                   SPIC2_DMAW_CONbits.CHEN = 1;
00AD36  A8E3BD     BSET 0x3BD, #7
298:                   SPIC2_DMAW_REQbits.FORCE = 1;
00AD38  A8E3BF     BSET 0x3BF, #7
299:                   return len;
00AD3A  78001E     MOV [W14], W0
300:                   
301:               }
00AD3C  FA8000     ULNK
00AD3E  060000     RETURN
302:               
303:               unsigned int spic1ReadBuffer(unsigned int len, unsigned char *buff) {
00AD40  FA0004     LNK #0x4
00AD42  780F00     MOV W0, [W14]
00AD44  980711     MOV W1, [W14+2]
304:                   
305:                   // Make sure requested length is in range
306:                   if(len > SPIC1_RX_BUFF_LEN) {
00AD46  200800     MOV #0x80, W0
00AD48  78009E     MOV [W14], W1
00AD4A  508F80     SUB W1, W0, [W15]
00AD4C  360002     BRA LEU, 0xAD52
307:                       len = SPIC1_RX_BUFF_LEN;
00AD4E  200800     MOV #0x80, W0
00AD50  780F00     MOV W0, [W14]
308:                   }
309:                   
310:                   memcpy(buff, spic1_rx_buff, len);   // Read DMA buffer contents into buffer
00AD52  78011E     MOV [W14], W2
00AD54  245701     MOV #0x4570, W1
00AD56  90001E     MOV [W14+2], W0
00AD58  023582     CALL _memcpy
00AD5A  000000     NOP
311:                   return len;
00AD5C  78001E     MOV [W14], W0
312:                   
313:               }
00AD5E  FA8000     ULNK
00AD60  060000     RETURN
314:               
315:               unsigned int spic2ReadBuffer(unsigned int len, unsigned char *buff) {
00AD62  FA0004     LNK #0x4
00AD64  780F00     MOV W0, [W14]
00AD66  980711     MOV W1, [W14+2]
316:                   
317:                   // Make sure requested length is in range
318:                   if(len > SPIC2_RX_BUFF_LEN) {
00AD68  201080     MOV #0x108, W0
00AD6A  78009E     MOV [W14], W1
00AD6C  508F80     SUB W1, W0, [W15]
00AD6E  360002     BRA LEU, 0xAD74
319:                       len = SPIC2_RX_BUFF_LEN;
00AD70  201080     MOV #0x108, W0
00AD72  780F00     MOV W0, [W14]
320:                   }
321:                   
322:                   memcpy(buff, spic2_rx_buff, len);   // Read DMA buffer contents into buffer
00AD74  78011E     MOV [W14], W2
00AD76  246F81     MOV #0x46F8, W1
00AD78  90001E     MOV [W14+2], W0
00AD7A  023582     CALL _memcpy
00AD7C  000000     NOP
323:                   return len;
00AD7E  78001E     MOV [W14], W0
324:               }
00AD80  FA8000     ULNK
00AD82  060000     RETURN
325:               
326:               // =========== Private Functions ==============================================
327:               // TODO: Check for DMA error codes and return appropriate interrupt cause
328:               // ISR for DMA2 interrupt, currently DMAR for channel 1
329:               void __attribute__((interrupt, no_auto_psv)) _DMA2Interrupt(void) {
00AD84  F80036     PUSH RCOUNT
00AD86  BE9F80     MOV.D W0, [W15++]
00AD88  BE9F82     MOV.D W2, [W15++]
00AD8A  BE9F84     MOV.D W4, [W15++]
00AD8C  BE9F86     MOV.D W6, [W15++]
00AD8E  FA0000     LNK #0x0
330:                           
331:                   int_handler[0](SPIC_TRANS_SUCCESS);        // Call registered callback function
00AD90  811001     MOV int_handler, W1
00AD92  EB0000     CLR W0
00AD94  010001     CALL W1
332:                   _DMA2IF = 0;  
00AD96  A90087     BCLR 0x87, #0
333:                   
334:               }
00AD98  FA8000     ULNK
00AD9A  BE034F     MOV.D [--W15], W6
00AD9C  BE024F     MOV.D [--W15], W4
00AD9E  BE014F     MOV.D [--W15], W2
00ADA0  BE004F     MOV.D [--W15], W0
00ADA2  F90036     POP RCOUNT
00ADA4  064000     RETFIE
335:               
336:               // ISR for DMA3 interrupt, currently DMAW for channel 1
337:               void __attribute__((interrupt, no_auto_psv)) _DMA3Interrupt(void) {
00ADA6  FA0000     LNK #0x0
338:               
339:                   _DMA3IF = 0;
00ADA8  A98088     BCLR IFS2, #4
340:               
341:               }
00ADAA  FA8000     ULNK
00ADAC  064000     RETFIE
342:               
343:               // ISR for DMA4 interrupt, currently DMAR for channel 2
344:               void __attribute__((interrupt, no_auto_psv)) _DMA4Interrupt(void) {
00ADAE  F80036     PUSH RCOUNT
00ADB0  BE9F80     MOV.D W0, [W15++]
00ADB2  BE9F82     MOV.D W2, [W15++]
00ADB4  BE9F84     MOV.D W4, [W15++]
00ADB6  BE9F86     MOV.D W6, [W15++]
00ADB8  FA0000     LNK #0x0
345:                       
346:                   int_handler[1](SPIC_TRANS_SUCCESS);        // Call registered callback function    
00ADBA  811011     MOV 0x2202, W1
00ADBC  EB0000     CLR W0
00ADBE  010001     CALL W1
347:                   _DMA4IF = 0;
00ADC0  A9C089     BCLR 0x89, #6
348:                   
349:               }    
00ADC2  FA8000     ULNK
00ADC4  BE034F     MOV.D [--W15], W6
00ADC6  BE024F     MOV.D [--W15], W4
00ADC8  BE014F     MOV.D [--W15], W2
00ADCA  BE004F     MOV.D [--W15], W0
00ADCC  F90036     POP RCOUNT
00ADCE  064000     RETFIE
350:               
351:               // ISR for DMA5 interrupt, currently DMAW for channel 2
352:               // Currently not used, though it may be useful for debugging
353:               void __attribute__((interrupt, no_auto_psv)) _DMA5Interrupt(void) {
00ADD0  FA0000     LNK #0x0
354:                   
355:                   _DMA5IF = 0;
00ADD2  A9A08B     BCLR 0x8B, #5
356:                   
357:               }    
00ADD4  FA8000     ULNK
00ADD6  064000     RETFIE
358:               
359:               static void setupDMASet1(void) {
00ADD8  FA0004     LNK #0x4
360:               
361:                   DMA2CON =   DMA2_REGISTER_POST_INCREMENT &     // Increment address after each byte
00ADDA  247010     MOV #0x4701, W0
00ADDC  881CC0     MOV W0, DMA2CON
362:                               DMA2_ONE_SHOT &                 // Stop module after transfer complete
363:                               PERIPHERAL_TO_DMA2 &             // Receive data from peripheral to memory
364:                               DMA2_SIZE_BYTE &                 // Byte-size transactions
365:                               DMA2_INTERRUPT_BLOCK &             // Interrupt after entire transaction
366:                               DMA2_NORMAL &                     //
367:                               DMA2_MODULE_OFF;                // Start module disabled
368:                   
369:                   DMA2REQ = SPI1_REQ_VAL;
00ADDE  2000A0     MOV #0xA, W0
00ADE0  881CD0     MOV W0, DMA2REQ
370:                   DMA2STA = __builtin_dmaoffset(spic1_rx_buff);
00ADE2  205700     MOV #0x570, W0
00ADE4  881CE0     MOV W0, DMA2STA
371:                   DMA2STB = __builtin_dmaoffset(spic1_rx_buff);
00ADE6  205700     MOV #0x570, W0
00ADE8  881CF0     MOV W0, DMA2STB
372:                   DMA2PAD = (volatile unsigned int) &SPI1BUF;
00ADEA  202480     MOV #0x248, W0
00ADEC  881D00     MOV W0, DMA2PAD
373:                   DMA2CNT = 0; // Default
00ADEE  EB0000     CLR W0
00ADF0  881D10     MOV W0, DMA2CNT
374:                   
375:                   // Need this to avoid compiler bitlength issues
376:                   unsigned long priority = DMA2_INT_PRI_5;
00ADF2  2FFFD0     MOV #0xFFFD, W0
00ADF4  200001     MOV #0x0, W1
00ADF6  BE8F00     MOV.D W0, [W14]
377:                   SetPriorityIntDMA2(priority);
00ADF8  78001E     MOV [W14], W0
00ADFA  784000     MOV.B W0, W0
00ADFC  604067     AND.B W0, #0x7, W0
00ADFE  FB8000     ZE W0, W0
00AE00  600067     AND W0, #0x7, W0
00AE02  800582     MOV IPC6, W2
00AE04  2FFF81     MOV #0xFFF8, W1
00AE06  610081     AND W2, W1, W1
00AE08  708000     IOR W1, W0, W0
00AE0A  880580     MOV W0, IPC6
378:                   
379:                   EnableIntDMA2;
00AE0C  A80097     BSET 0x97, #0
380:                   _DMA2IF  = 0;        // Clear DMA interrupt flag
00AE0E  A90087     BCLR 0x87, #0
381:                   
382:                   DMA3CON =     DMA3_REGISTER_POST_INCREMENT &     // Increment address after each byte
00AE10  267010     MOV #0x6701, W0
00AE12  881D20     MOV W0, DMA3CON
383:                               DMA3_ONE_SHOT &                 // Stop module after transfer complete
384:                               DMA3_TO_PERIPHERAL &            // Send data to peripheral from memory
385:                               DMA3_SIZE_BYTE &                 // Byte-size transaction
386:                               DMA3_INTERRUPT_BLOCK &             // Interrupt after entire transaction
387:                               DMA3_NORMAL &                     //
388:                               DMA3_MODULE_OFF;                // Start module disabled
389:                   
390:                   DMA3REQ = SPI1_REQ_VAL;
00AE14  2000A0     MOV #0xA, W0
00AE16  881D30     MOV W0, DMA3REQ
391:                   DMA3STA = __builtin_dmaoffset(spic1_tx_buff);
00AE18  204F00     MOV #0x4F0, W0
00AE1A  881D40     MOV W0, DMA3STA
392:                   DMA3STB = __builtin_dmaoffset(spic1_tx_buff);
00AE1C  204F00     MOV #0x4F0, W0
00AE1E  881D50     MOV W0, DMA3STB
393:                   DMA3PAD = (volatile unsigned int) &SPI1BUF;
00AE20  202480     MOV #0x248, W0
00AE22  881D60     MOV W0, DMA3PAD
394:                   DMA3CNT = 0; // Default
00AE24  EB0000     CLR W0
00AE26  881D70     MOV W0, DMA3CNT
395:                   
396:                   priority = DMA3_INT_PRI_5;
00AE28  2FFFD0     MOV #0xFFFD, W0
00AE2A  200001     MOV #0x0, W1
00AE2C  BE8F00     MOV.D W0, [W14]
397:                   SetPriorityIntDMA3(priority);
00AE2E  78001E     MOV [W14], W0
00AE30  784000     MOV.B W0, W0
00AE32  604067     AND.B W0, #0x7, W0
00AE34  FB8000     ZE W0, W0
00AE36  600067     AND W0, #0x7, W0
00AE38  8005B2     MOV IPC9, W2
00AE3A  2FFF81     MOV #0xFFF8, W1
00AE3C  610081     AND W2, W1, W1
00AE3E  708000     IOR W1, W0, W0
00AE40  8805B0     MOV W0, IPC9
398:                   DisableIntDMA3;             // Only need one of the DMA interrupts
00AE42  A98098     BCLR IEC2, #4
399:                   _DMA3IF  = 0;        // Clear DMA interrupt
00AE44  A98088     BCLR IFS2, #4
400:                   
401:               }
00AE46  FA8000     ULNK
00AE48  060000     RETURN
402:               
403:               static void setupDMASet2(void) {
00AE4A  FA0004     LNK #0x4
404:               
405:                   DMA4CON =     DMA4_REGISTER_POST_INCREMENT &     // Increment address after each byte
00AE4C  247010     MOV #0x4701, W0
00AE4E  881D80     MOV W0, DMA4CON
406:                               DMA4_ONE_SHOT &                 // Stop module after transfer complete
407:                               PERIPHERAL_TO_DMA4 &             // Receive data from peripheral to memory
408:                               DMA4_SIZE_BYTE &                 // Byte-size transactions
409:                               DMA4_INTERRUPT_BLOCK &             // Interrupt after entire transaction
410:                               DMA4_NORMAL &                     //
411:                               DMA4_MODULE_OFF;                // Start module disabled
412:                   
413:                   DMA4REQ = SPI2_REQ_VAL;
00AE50  200210     MOV #0x21, W0
00AE52  881D90     MOV W0, DMA4REQ
414:                   DMA4STA = __builtin_dmaoffset(spic2_rx_buff);
00AE54  206F80     MOV #0x6F8, W0
00AE56  881DA0     MOV W0, DMA4STA
415:                   DMA4STB = __builtin_dmaoffset(spic2_rx_buff);
00AE58  206F80     MOV #0x6F8, W0
00AE5A  881DB0     MOV W0, DMA4STB
416:                   DMA4PAD = (volatile unsigned int) &SPI2BUF;
00AE5C  202680     MOV #0x268, W0
00AE5E  881DC0     MOV W0, DMA4PAD
417:                   DMA4CNT = 0; // Default
00AE60  EB0000     CLR W0
00AE62  881DD0     MOV W0, DMA4CNT
418:                   
419:                   // Need this to avoid compiler bitlength issues
420:                   unsigned long priority = DMA4_INT_PRI_5;
00AE64  2FFFD0     MOV #0xFFFD, W0
00AE66  200001     MOV #0x0, W1
00AE68  BE8F00     MOV.D W0, [W14]
421:                   SetPriorityIntDMA4(priority);
00AE6A  78001E     MOV [W14], W0
00AE6C  784000     MOV.B W0, W0
00AE6E  604067     AND.B W0, #0x7, W0
00AE70  FB8000     ZE W0, W0
00AE72  600067     AND W0, #0x7, W0
00AE74  DD0048     SL W0, #8, W0
00AE76  8005D2     MOV IPC11, W2
00AE78  2F8FF1     MOV #0xF8FF, W1
00AE7A  610081     AND W2, W1, W1
00AE7C  708000     IOR W1, W0, W0
00AE7E  8805D0     MOV W0, IPC11
422:                   
423:                   EnableIntDMA4;
00AE80  A8C099     BSET 0x99, #6
424:                   _DMA4IF  = 0;        // Clear DMA interrupt flag
00AE82  A9C089     BCLR 0x89, #6
425:                   
426:                   DMA5CON =   DMA5_REGISTER_POST_INCREMENT &     // Increment address after each byte
00AE84  267010     MOV #0x6701, W0
00AE86  881DE0     MOV W0, DMA5CON
427:                               DMA5_ONE_SHOT &                 // Stop module after transfer complete
428:                               DMA5_TO_PERIPHERAL &            // Send data to peripheral from memory
429:                               DMA5_SIZE_BYTE &                 // Byte-size transaction
430:                               DMA5_INTERRUPT_BLOCK &             // Interrupt after entire transaction
431:                               DMA5_NORMAL &                     //
432:                               DMA5_MODULE_OFF;                // Start module disabled
433:                   
434:                   DMA5REQ = SPI2_REQ_VAL;
00AE88  200210     MOV #0x21, W0
00AE8A  881DF0     MOV W0, DMA5REQ
435:                   DMA5STA = __builtin_dmaoffset(spic2_tx_buff);
00AE8C  205F00     MOV #0x5F0, W0
00AE8E  881E00     MOV W0, DMA5STA
436:                   DMA5STB = __builtin_dmaoffset(spic2_tx_buff);
00AE90  205F00     MOV #0x5F0, W0
00AE92  881E10     MOV W0, DMA5STB
437:                   DMA5PAD = (volatile unsigned int) &SPI2BUF;
00AE94  202680     MOV #0x268, W0
00AE96  881E20     MOV W0, DMA5PAD
438:                   DMA5CNT = 0; // Default
00AE98  EB0000     CLR W0
00AE9A  881E30     MOV W0, DMA5CNT
439:                   
440:                   priority = DMA5_INT_PRI_5;
00AE9C  2FFFD0     MOV #0xFFFD, W0
00AE9E  200001     MOV #0x0, W1
00AEA0  BE8F00     MOV.D W0, [W14]
441:                   SetPriorityIntDMA5(priority);
00AEA2  78001E     MOV [W14], W0
00AEA4  784000     MOV.B W0, W0
00AEA6  604067     AND.B W0, #0x7, W0
00AEA8  FB8000     ZE W0, W0
00AEAA  600067     AND W0, #0x7, W0
00AEAC  DD0044     SL W0, #4, W0
00AEAE  800612     MOV IPC15, W2
00AEB0  2FF8F1     MOV #0xFF8F, W1
00AEB2  610081     AND W2, W1, W1
00AEB4  708000     IOR W1, W0, W0
00AEB6  880610     MOV W0, IPC15
442:                   DisableIntDMA5; // Only need one of the DMA interrupts
00AEB8  A9A09B     BCLR 0x9B, #5
443:                   _DMA5IF  = 0;        // Clear DMA interrupt
00AEBA  A9A08B     BCLR 0x8B, #5
444:                   
445:               }
00AEBC  FA8000     ULNK
00AEBE  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/radio.c  ----------------------------------------------
1:                 /**
2:                  * Copyright (c) 2011-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * High Level Wireless Communications Driver
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v. 0.4
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu      2011-06-06      Initial implementation
38:                 *  Humphrey Hu      2012-02-03      Structural changes to reduce irq handler runtime
39:                 */
40:                
41:                #include "utils.h"
42:                #include "radio.h"
43:                #include "payload.h"
44:                #include "carray.h"
45:                #include "mac_packet.h"
46:                #include "sys_clock.h"
47:                #include "timer.h"
48:                #include "led.h"
49:                #include "ppool.h"
50:                
51:                #include "at86rf231.h"  // Current transceiver IC
52:                #include "at86rf231_driver.h"
53:                
54:                #include <stdio.h>
55:                #include <stdlib.h>
56:                
57:                #define RADIO_DEFAULT_SRC_ADDR                  (0x1101)
58:                #define RADIO_DEFAULT_SRC_PAN                   (0x1005)
59:                #define RADIO_DEFAULT_CHANNEL                   (0x12)
60:                #define RADIO_DEFAULT_RETRIES                   (3)
61:                
62:                #define RADIO_DEFAULT_PACKET_RETRIES            (2)
63:                #define TX_TIMEOUT_MS                           (75)
64:                #define WATCHDOG_TIMEOUT_MS                     (2000)
65:                
66:                #define RADIO_CALIB_PERIOD                      (300000) // 5 minutes
67:                
68:                
69:                // =========== Static variables ===============================================
70:                
71:                // State information
72:                static unsigned char is_ready = 0;
73:                static RadioState radio_state;
74:                static unsigned char packet_sqn, retries;
75:                
76:                static unsigned long last_calib_timestamp, progress_timestamp;
77:                static unsigned int watchdog_timeout, watchdog_state;
78:                
79:                // In/out packet FIFO queues
80:                static CircArray tx_queue, rx_queue;
81:                
82:                // Local config information
83:                static unsigned int local_addr, local_pan, max_packet_retries;
84:                static unsigned char local_channel;
85:                
86:                
87:                // =========== Function stubs =================================================
88:                
89:                // IRQ handlers
90:                void trxCallback(unsigned int irq_cause);
91:                static inline void watchdogProgress(void);
92:                
93:                static void radioReset(void);
94:                
95:                // Internal processing
96:                static void radioProcessTx(void);
97:                static void radioProcessRx(void);
98:                
99:                // Internal state management methods
100:               static unsigned int radioBeginTransition(void);
101:               static unsigned int radioSetStateTx(void);
102:               static unsigned int radioSetStateRx(void);
103:               static unsigned int radioSetStateIdle(void);
104:               //static unsigned int radioSetStateOff(void);
105:               
106:               
107:               // =========== Public functions ===============================================
108:               
109:               // Initialize radio software and hardware
110:               void radioInit(unsigned int tx_queue_length, unsigned int rx_queue_length) {
00801A  FA0004     LNK #0x4
00801C  780F00     MOV W0, [W14]
00801E  980711     MOV W1, [W14+2]
111:               
112:                   // Initialize FIFO buffers
113:                   tx_queue = carrayCreate(tx_queue_length);    // Initialize TX queue
008020  78001E     MOV [W14], W0
008022  028F1C     CALL carrayCreate
008024  000000     NOP
008026  8909A0     MOV W0, tx_queue
114:                   rx_queue = carrayCreate(rx_queue_length);    // Initialize RX queue
008028  90001E     MOV [W14+2], W0
00802A  028F1C     CALL carrayCreate
00802C  000000     NOP
00802E  8909B0     MOV W0, rx_queue
115:               
116:                   // Reset radio_state
117:                   packet_sqn = 0;                            // Initialize packet number
008030  221261     MOV #0x2126, W1
008032  EB4000     CLR.B W0
008034  784880     MOV.B W0, [W1]
118:                   retries = 0;                            // Initialize retry counter
008036  221271     MOV #0x2127, W1
008038  EB4000     CLR.B W0
00803A  784880     MOV.B W0, [W1]
119:                   max_packet_retries = RADIO_DEFAULT_PACKET_RETRIES;
00803C  200020     MOV #0x2, W0
00803E  8909E0     MOV W0, max_packet_retries
120:                   last_calib_timestamp = 0;
008040  B80060     MUL.UU W0, #0, W0
008042  890940     MOV W0, last_calib_timestamp
008044  890951     MOV W1, 0x212A
121:                   watchdogProgress();
008046  070278     RCALL watchdogProgress
122:                   watchdog_timeout = WATCHDOG_TIMEOUT_MS;
008048  207D00     MOV #0x7D0, W0
00804A  890980     MOV W0, watchdog_timeout
123:                   watchdog_state = 0;
00804C  EB0000     CLR W0
00804E  890990     MOV W0, watchdog_state
124:               
125:                   trxSetup(); // Configure transceiver IC
008050  0272B8     CALL trxSetup
008052  000000     NOP
126:               
127:                   trxSetIrqCallback(&trxCallback); // Set IC driver callback
008054  283000     MOV #0x8300, W0
008056  0273F0     CALL trxSetIrqCallback
008058  000000     NOP
128:               
129:               
130:                   // set default address
131:                   trxSetAddress(RADIO_DEFAULT_SRC_ADDR);
00805A  211010     MOV #0x1101, W0
00805C  02738C     CALL trxSetAddress
00805E  000000     NOP
132:                   local_addr = RADIO_DEFAULT_SRC_ADDR;
008060  211010     MOV #0x1101, W0
008062  8909C0     MOV W0, local_addr
133:               
134:                   // set default PAN ID
135:                   trxSetPan(RADIO_DEFAULT_SRC_PAN);
008064  210050     MOV #0x1005, W0
008066  0273AA     CALL trxSetPan
008068  000000     NOP
136:                   local_pan = RADIO_DEFAULT_SRC_PAN;
00806A  210050     MOV #0x1005, W0
00806C  8909D0     MOV W0, local_pan
137:               
138:                   // set default radio channel
139:                   trxSetChannel(RADIO_DEFAULT_CHANNEL);
00806E  B3C120     MOV #0x12, W0
008070  0273C8     CALL trxSetChannel
008072  000000     NOP
140:                   local_channel = RADIO_DEFAULT_CHANNEL;
008074  2213E1     MOV #0x213E, W1
008076  B3C120     MOV #0x12, W0
008078  784880     MOV.B W0, [W1]
141:               
142:                   // Set number of frame transmit retries
143:                   trxSetRetries(RADIO_DEFAULT_RETRIES);
00807A  200030     MOV #0x3, W0
00807C  0273DA     CALL trxSetRetries
00807E  000000     NOP
144:               
145:                   is_ready = 1;
008080  221221     MOV #0x2122, W1
008082  B3C010     MOV #0x1, W0
008084  784880     MOV.B W0, [W1]
146:               
147:                   trxSetStateRx();
008086  0275BE     CALL trxSetStateRx
008088  000000     NOP
148:               
149:               }
00808A  FA8000     ULNK
00808C  060000     RETURN
150:               
151:               void radioSetSrcAddr(unsigned int src_addr) {
00808E  FA0002     LNK #0x2
008090  780F00     MOV W0, [W14]
152:               
153:                   local_addr = src_addr;
008092  78001E     MOV [W14], W0
008094  8909C0     MOV W0, local_addr
154:                   trxSetAddress(src_addr);
008096  78001E     MOV [W14], W0
008098  02738C     CALL trxSetAddress
00809A  000000     NOP
155:               
156:               }
00809C  FA8000     ULNK
00809E  060000     RETURN
157:               
158:               unsigned int radioGetSrcAddr(void) {
0080A0  FA0000     LNK #0x0
159:               
160:                   return local_addr;
0080A2  8109C0     MOV local_addr, W0
161:               
162:               }
0080A4  FA8000     ULNK
0080A6  060000     RETURN
163:               
164:               void radioSetSrcPanID(unsigned int src_pan_id) {
0080A8  FA0002     LNK #0x2
0080AA  780F00     MOV W0, [W14]
165:               
166:                   local_pan = src_pan_id;
0080AC  78001E     MOV [W14], W0
0080AE  8909D0     MOV W0, local_pan
167:                   trxSetPan(src_pan_id);
0080B0  78001E     MOV [W14], W0
0080B2  0273AA     CALL trxSetPan
0080B4  000000     NOP
168:               
169:               }
0080B6  FA8000     ULNK
0080B8  060000     RETURN
170:               
171:               unsigned int radioGetSrcPanID(void) {
0080BA  FA0000     LNK #0x0
172:               
173:                   return local_pan;
0080BC  8109D0     MOV local_pan, W0
174:               
175:               }
0080BE  FA8000     ULNK
0080C0  060000     RETURN
176:               
177:               void radioSetChannel(unsigned char channel) {
0080C2  FA0002     LNK #0x2
0080C4  784F00     MOV.B W0, [W14]
178:               
179:                   local_channel = channel;
0080C6  2213E0     MOV #0x213E, W0
0080C8  78481E     MOV.B [W14], [W0]
180:                   trxSetChannel(channel);
0080CA  78401E     MOV.B [W14], W0
0080CC  0273C8     CALL trxSetChannel
0080CE  000000     NOP
181:               
182:               }
0080D0  FA8000     ULNK
0080D2  060000     RETURN
183:               
184:               unsigned char radioGetChannel(void) {
0080D4  FA0000     LNK #0x0
185:               
186:                   return local_channel;
0080D6  2213E0     MOV #0x213E, W0
0080D8  784010     MOV.B [W0], W0
187:               
188:               }
0080DA  FA8000     ULNK
0080DC  060000     RETURN
189:               
190:               void radioSetRetries(unsigned char retries) {
0080DE  FA0002     LNK #0x2
0080E0  784F00     MOV.B W0, [W14]
191:               
192:                   max_packet_retries = retries;
0080E2  78409E     MOV.B [W14], W1
0080E4  FB8001     ZE W1, W0
0080E6  8909E0     MOV W0, max_packet_retries
193:               
194:               }
0080E8  FA8000     ULNK
0080EA  060000     RETURN
195:               
196:               unsigned char radioGetRetries(void) {
0080EC  FA0000     LNK #0x0
197:               
198:                   return max_packet_retries;
0080EE  8109E0     MOV max_packet_retries, W0
0080F0  784000     MOV.B W0, W0
199:               
200:               }
0080F2  FA8000     ULNK
0080F4  060000     RETURN
201:               
202:               RadioState radioGetState(void) {
0080F6  FA0000     LNK #0x0
203:               
204:                   return radio_state;
0080F8  810920     MOV radio_state, W0
205:               
206:               }
0080FA  FA8000     ULNK
0080FC  060000     RETURN
207:               
208:               void radioSetWatchdogState(unsigned char state) {
0080FE  FA0002     LNK #0x2
008100  784F00     MOV.B W0, [W14]
209:               
210:                   watchdog_state = state;
008102  78409E     MOV.B [W14], W1
008104  FB8001     ZE W1, W0
008106  890990     MOV W0, watchdog_state
211:                   watchdogProgress();
008108  070217     RCALL watchdogProgress
212:               
213:               }
00810A  FA8000     ULNK
00810C  060000     RETURN
214:               
215:               void radioSetWatchdogTime(unsigned int time) {
00810E  FA0002     LNK #0x2
008110  780F00     MOV W0, [W14]
216:               
217:                   watchdog_timeout = time;
008112  78001E     MOV [W14], W0
008114  890980     MOV W0, watchdog_timeout
218:                   watchdogProgress();
008116  070210     RCALL watchdogProgress
219:               
220:               }
008118  FA8000     ULNK
00811A  060000     RETURN
221:               
222:               MacPacket radioDequeueRxPacket(void) {
00811C  FA0000     LNK #0x0
223:               
224:                   return (MacPacket)carrayPopTail(rx_queue);
00811E  8109B0     MOV rx_queue, W0
008120  029102     CALL carrayPopTail
008122  000000     NOP
225:               
226:               }
008124  FA8000     ULNK
008126  060000     RETURN
227:               
228:               unsigned int radioEnqueueTxPacket(MacPacket packet) {
008128  FA0002     LNK #0x2
00812A  780F00     MOV W0, [W14]
229:               
230:                   return carrayAddTail(tx_queue, packet);
00812C  8109A0     MOV tx_queue, W0
00812E  78009E     MOV [W14], W1
008130  028F9A     CALL carrayAddTail
008132  000000     NOP
231:               
232:               }
008134  FA8000     ULNK
008136  060000     RETURN
233:               
234:               unsigned int radioTxQueueEmpty(void) {
008138  FA0000     LNK #0x0
235:               
236:                   return carrayIsEmpty(tx_queue);
00813A  8109A0     MOV tx_queue, W0
00813C  02937A     CALL carrayIsEmpty
00813E  000000     NOP
237:               
238:               }
008140  FA8000     ULNK
008142  060000     RETURN
239:               
240:               unsigned int radioTxQueueFull(void) {
008144  FA0000     LNK #0x0
241:               
242:                   return carrayIsFull(tx_queue);
008146  8109A0     MOV tx_queue, W0
008148  029390     CALL carrayIsFull
00814A  000000     NOP
243:               
244:               }
00814C  FA8000     ULNK
00814E  060000     RETURN
245:               
246:               unsigned int radioGetTxQueueSize(void) {
008150  FA0000     LNK #0x0
247:               
248:                   return carrayGetSize(tx_queue);
008152  8109A0     MOV tx_queue, W0
008154  0293A8     CALL carrayGetSize
008156  000000     NOP
249:               
250:               }
008158  FA8000     ULNK
00815A  060000     RETURN
251:               
252:               unsigned int radioRxQueueEmpty(void){
00815C  FA0000     LNK #0x0
253:               
254:                   return carrayIsEmpty(rx_queue);
00815E  8109B0     MOV rx_queue, W0
008160  02937A     CALL carrayIsEmpty
008162  000000     NOP
255:               
256:               }
008164  FA8000     ULNK
008166  060000     RETURN
257:               
258:               unsigned int radioRxQueueFull(void) {
008168  FA0000     LNK #0x0
259:               
260:                   return carrayIsFull(rx_queue);
00816A  8109B0     MOV rx_queue, W0
00816C  029390     CALL carrayIsFull
00816E  000000     NOP
261:               
262:               }
008170  FA8000     ULNK
008172  060000     RETURN
263:               
264:               unsigned int radioGetRxQueueSize(void) {
008174  FA0000     LNK #0x0
265:               
266:                   return carrayGetSize(rx_queue);
008176  8109B0     MOV rx_queue, W0
008178  0293A8     CALL carrayGetSize
00817A  000000     NOP
267:               
268:               }
00817C  FA8000     ULNK
00817E  060000     RETURN
269:               
270:               void radioFlushQueues(void) {
008180  FA0000     LNK #0x0
271:               
272:                   while (!carrayIsEmpty(tx_queue)) {
008182  370004     BRA 0x818C
00818C  8109A0     MOV tx_queue, W0
00818E  02937A     CALL carrayIsEmpty
008190  000000     NOP
008192  EB0080     CLR W1
008194  500F81     SUB W0, W1, [W15]
008196  32FFF6     BRA Z, 0x8184
273:                       radioReturnPacket((MacPacket)carrayPopTail(tx_queue));
008184  8109A0     MOV tx_queue, W0
008186  029102     CALL carrayPopTail
008188  000000     NOP
00818A  07005A     RCALL radioReturnPacket
274:                   }
275:               
276:                   while (!carrayIsEmpty(rx_queue)) {
008198  370004     BRA 0x81A2
0081A2  8109B0     MOV rx_queue, W0
0081A4  02937A     CALL carrayIsEmpty
0081A6  000000     NOP
0081A8  EB0080     CLR W1
0081AA  500F81     SUB W0, W1, [W15]
0081AC  32FFF6     BRA Z, 0x819A
277:                       radioReturnPacket((MacPacket)carrayPopTail(rx_queue));
00819A  8109B0     MOV rx_queue, W0
00819C  029102     CALL carrayPopTail
00819E  000000     NOP
0081A0  07004F     RCALL radioReturnPacket
278:                   }
279:               
280:               }
0081AE  FA8000     ULNK
0081B0  060000     RETURN
281:               
282:               MacPacket radioRequestPacket(unsigned int data_size) {
0081B2  FA0004     LNK #0x4
0081B4  980710     MOV W0, [W14+2]
283:               
284:                   MacPacket packet;
285:               
286:                   packet = ppoolRequestFullPacket(data_size);
0081B6  90001E     MOV [W14+2], W0
0081B8  02B9B2     CALL ppoolRequestFullPacket
0081BA  000000     NOP
0081BC  780F00     MOV W0, [W14]
287:                   if(packet == NULL) { return NULL; }
0081BE  78009E     MOV [W14], W1
0081C0  EB0000     CLR W0
0081C2  508F80     SUB W1, W0, [W15]
0081C4  3A0002     BRA NZ, 0x81CA
0081C6  EB0000     CLR W0
0081C8  37000D     BRA 0x81E4
288:               
289:                   macSetSrc(packet, local_pan, local_addr);
0081CA  8109C1     MOV local_addr, W1
0081CC  8109D0     MOV local_pan, W0
0081CE  780101     MOV W1, W2
0081D0  780080     MOV W0, W1
0081D2  78001E     MOV [W14], W0
0081D4  02865C     CALL macSetSrc
0081D6  000000     NOP
290:                   macSetDestPan(packet, local_pan);
0081D8  8109D0     MOV local_pan, W0
0081DA  780080     MOV W0, W1
0081DC  78001E     MOV [W14], W0
0081DE  02864C     CALL macSetDestPan
0081E0  000000     NOP
291:               
292:                   return packet;
0081E2  78001E     MOV [W14], W0
293:               
294:               }
0081E4  FA8000     ULNK
0081E6  060000     RETURN
295:               
296:               MacPacket radioCreatePacket(unsigned int data_size) {
0081E8  FA0006     LNK #0x6
0081EA  980720     MOV W0, [W14+4]
297:               
298:                   MacPacket packet = macCreateDataPacket();
0081EC  0285B4     CALL macCreateDataPacket
0081EE  000000     NOP
0081F0  780F00     MOV W0, [W14]
299:                   if(packet == NULL) { return NULL; }
0081F2  78009E     MOV [W14], W1
0081F4  EB0000     CLR W0
0081F6  508F80     SUB W1, W0, [W15]
0081F8  3A0002     BRA NZ, 0x81FE
0081FA  EB0000     CLR W0
0081FC  37001F     BRA 0x823C
300:               
301:                   Payload pld = payCreateEmpty(data_size);
0081FE  90002E     MOV [W14+4], W0
008200  784000     MOV.B W0, W0
008202  02C960     CALL payCreateEmpty
008204  000000     NOP
008206  980710     MOV W0, [W14+2]
302:                   if(pld == NULL) {
008208  90009E     MOV [W14+2], W1
00820A  EB0000     CLR W0
00820C  508F80     SUB W1, W0, [W15]
00820E  3A0005     BRA NZ, 0x821A
303:                       macDeletePacket(packet);
008210  78001E     MOV [W14], W0
008212  02861E     CALL macDeletePacket
008214  000000     NOP
304:                       return NULL;
008216  EB0000     CLR W0
008218  370011     BRA 0x823C
305:                   }
306:               
307:                   macSetPayload(packet, pld);
00821A  90009E     MOV [W14+2], W1
00821C  78001E     MOV [W14], W0
00821E  0286CC     CALL macSetPayload
008220  000000     NOP
308:                   macSetSrc(packet, local_pan, local_addr);
008222  8109C1     MOV local_addr, W1
008224  8109D0     MOV local_pan, W0
008226  780101     MOV W1, W2
008228  780080     MOV W0, W1
00822A  78001E     MOV [W14], W0
00822C  02865C     CALL macSetSrc
00822E  000000     NOP
309:                   macSetDestPan(packet, local_pan);
008230  8109D0     MOV local_pan, W0
008232  780080     MOV W0, W1
008234  78001E     MOV [W14], W0
008236  02864C     CALL macSetDestPan
008238  000000     NOP
310:               
311:                   return packet;
00823A  78001E     MOV [W14], W0
312:               
313:               }
00823C  FA8000     ULNK
00823E  060000     RETURN
314:               
315:               unsigned int radioReturnPacket(MacPacket packet) {
008240  FA0002     LNK #0x2
008242  780F00     MOV W0, [W14]
316:               
317:                   return ppoolReturnFullPacket(packet);
008244  78001E     MOV [W14], W0
008246  02BA4A     CALL ppoolReturnFullPacket
008248  000000     NOP
318:               
319:               }
00824A  FA8000     ULNK
00824C  060000     RETURN
320:               
321:               void radioDeletePacket(MacPacket packet) {
00824E  FA0002     LNK #0x2
008250  780F00     MOV W0, [W14]
322:               
323:                   if(packet != NULL) {
008252  78009E     MOV [W14], W1
008254  EB0000     CLR W0
008256  508F80     SUB W1, W0, [W15]
008258  32000C     BRA Z, 0x8272
324:                       if(packet->payload != NULL) {
00825A  78001E     MOV [W14], W0
00825C  9000E0     MOV [W0+12], W1
00825E  EB0000     CLR W0
008260  508F80     SUB W1, W0, [W15]
008262  320004     BRA Z, 0x826C
325:                           payDelete(packet->payload);
008264  78001E     MOV [W14], W0
008266  900060     MOV [W0+12], W0
008268  02CB22     CALL payDelete
00826A  000000     NOP
326:                       }
327:                       macDeletePacket(packet);
00826C  78001E     MOV [W14], W0
00826E  02861E     CALL macDeletePacket
008270  000000     NOP
328:                   }
329:               
330:               }
008272  FA8000     ULNK
008274  060000     RETURN
331:               
332:               // The Big Function
333:               void radioProcess(void) {
008276  FA0000     LNK #0x0
334:               
335:                   if(watchdog_state) {
008278  810991     MOV watchdog_state, W1
00827A  EB0000     CLR W0
00827C  508F80     SUB W1, W0, [W15]
00827E  32000E     BRA Z, 0x829C
336:                       if(sclockGetLocalMillis() - progress_timestamp > WATCHDOG_TIMEOUT_MS) {
008280  02DE60     CALL sclockGetLocalMillis
008282  000000     NOP
008284  BE0100     MOV.D W0, W2
008286  810960     MOV progress_timestamp, W0
008288  810971     MOV 0x212E, W1
00828A  510100     SUB W2, W0, W2
00828C  598181     SUBB W3, W1, W3
00828E  207D00     MOV #0x7D0, W0
008290  200001     MOV #0x0, W1
008292  510F80     SUB W2, W0, [W15]
008294  598F81     SUBB W3, W1, [W15]
008296  360002     BRA LEU, 0x829C
337:                           radioReset();
008298  070019     RCALL radioReset
338:                           return;
00829A  370016     BRA 0x82C8
339:                       }
340:                   }
341:               
342:                   // Process pending outgoing packets
343:                   if(!radioTxQueueEmpty()) {
00829C  07FF4D     RCALL radioTxQueueEmpty
00829E  EB0080     CLR W1
0082A0  500F81     SUB W0, W1, [W15]
0082A2  3A0009     BRA NZ, 0x82B6
344:               
345:                       // Return if can't get to Tx state at the moment
346:                       if(!radioSetStateTx()) { 
0082A4  070084     RCALL radioSetStateTx
0082A6  EB0080     CLR W1
0082A8  500F81     SUB W0, W1, [W15]
0082AA  32000B     BRA Z, 0x82C2
347:               			return; 
0082C2  000000     NOP
0082C4  370001     BRA 0x82C8
348:               		} else {
349:               			Nop();
0082AC  000000     NOP
350:               			Nop();
0082AE  000000     NOP
351:               		}
352:                       watchdogProgress();
0082B0  070143     RCALL watchdogProgress
353:                       radioProcessTx(); // Process outgoing buffer
0082B2  0700FC     RCALL radioProcessTx
354:                       return;
0082B4  370009     BRA 0x82C8
355:               
356:                   }
357:               
358:               #if defined(RADIO_AUTOCALIBRATE) // Auto calibration routine
359:                   // Check if calibration is necessary
360:                   unsigned long currentTime = sclockGetLocalMillis();
361:                   if(currentTime - last_calib_timestamp > RADIO_CALIB_PERIOD) {
362:                       if(!radioSetStateOff()) { return; }
363:                       trxCalibrate();
364:                       last_calib_timestamp = currentTime;
365:                   }
366:               #endif
367:               
368:                   // Default to Rx state
369:                   if(!radioSetStateRx()) { return; }
0082B6  070091     RCALL radioSetStateRx
0082B8  EB0080     CLR W1
0082BA  500F81     SUB W0, W1, [W15]
0082BC  320004     BRA Z, 0x82C6
0082C6  000000     NOP
370:               
371:                   // If the code runs to this point, all buffers are clear and radio is idle
372:                   watchdogProgress();
0082BE  07013C     RCALL watchdogProgress
0082C0  370003     BRA 0x82C8
373:               
374:               }
0082C8  FA8000     ULNK
0082CA  060000     RETURN
375:               
376:               
377:               // =========== Private functions ==============================================
378:               
379:               static void radioReset(void) {
0082CC  FA0000     LNK #0x0
380:               
381:                   progress_timestamp = sclockGetLocalMillis();
0082CE  02DE60     CALL sclockGetLocalMillis
0082D0  000000     NOP
0082D2  890960     MOV W0, progress_timestamp
0082D4  890971     MOV W1, 0x212E
382:                   trxReset();
0082D6  027332     CALL trxReset
0082D8  000000     NOP
383:                   radio_state = STATE_OFF;
0082DA  200010     MOV #0x1, W0
0082DC  890920     MOV W0, radio_state
384:                   radioSetStateIdle();
0082DE  070093     RCALL radioSetStateIdle
385:                   LED_ORANGE = 0;
0082E0  A9C2CB     BCLR 0x2CB, #6
386:                   LED_RED = ~LED_RED;
0082E2  801650     MOV LATB, W0
0082E4  DE004C     LSR W0, #12, W0
0082E6  604061     AND.B W0, #0x1, W0
0082E8  EAC000     COM.B W0, W0
0082EA  604061     AND.B W0, #0x1, W0
0082EC  FB8000     ZE W0, W0
0082EE  600061     AND W0, #0x1, W0
0082F0  DD004C     SL W0, #12, W0
0082F2  801652     MOV LATB, W2
0082F4  2EFFF1     MOV #0xEFFF, W1
0082F6  610081     AND W2, W1, W1
0082F8  708000     IOR W1, W0, W0
0082FA  881650     MOV W0, LATB
387:               
388:               }
0082FC  FA8000     ULNK
0082FE  060000     RETURN
389:               
390:               /**
391:                * Transceiver interrupt handler
392:                *
393:                * Note that this doesn't need critical sections since this will
394:                * only be called in interrupt context
395:                *
396:                * @param irq_cause Interrupt source code
397:                */
398:               void trxCallback(unsigned int irq_cause) {
008300  FA0002     LNK #0x2
008302  780F00     MOV W0, [W14]
399:               
400:                   if(radio_state == STATE_SLEEP) {
008304  810921     MOV radio_state, W1
008306  EB0000     CLR W0
008308  508F80     SUB W1, W0, [W15]
00830A  320049     BRA Z, 0x839E
401:                       // Shouldn't be here since sleep isn't implemented yet!
402:                   }
403:                   else if(radio_state == STATE_IDLE) {
00830C  810921     MOV radio_state, W1
00830E  200020     MOV #0x2, W0
008310  508F80     SUB W1, W0, [W15]
008312  320045     BRA Z, 0x839E
404:                       // Shouldn't be getting interrupts when idle
405:                   }
406:                   else if(radio_state == STATE_RX_IDLE) {
008314  810921     MOV radio_state, W1
008316  200040     MOV #0x4, W0
008318  508F80     SUB W1, W0, [W15]
00831A  3A0008     BRA NZ, 0x832C
407:               
408:                       // Beginning reception process
409:                       if(irq_cause == RADIO_RX_START) {
00831C  78009E     MOV [W14], W1
00831E  200020     MOV #0x2, W0
008320  508F80     SUB W1, W0, [W15]
008322  3A003D     BRA NZ, 0x839E
410:                           LED_ORANGE = 1;
008324  A8C2CB     BSET 0x2CB, #6
411:                           radio_state = STATE_RX_BUSY;
008326  200050     MOV #0x5, W0
008328  890920     MOV W0, radio_state
00832A  370039     BRA 0x839E
412:                       }
413:               
414:                   } else if(radio_state == STATE_RX_BUSY) {
00832C  810921     MOV radio_state, W1
00832E  200050     MOV #0x5, W0
008330  508F80     SUB W1, W0, [W15]
008332  3A0009     BRA NZ, 0x8346
415:               
416:                       // Reception complete
417:                       if(irq_cause == RADIO_RX_SUCCESS) {
008334  78009E     MOV [W14], W1
008336  200030     MOV #0x3, W0
008338  508F80     SUB W1, W0, [W15]
00833A  3A0031     BRA NZ, 0x839E
418:                           radioProcessRx();   // Process newly received data
00833C  0700D5     RCALL radioProcessRx
419:                           LED_ORANGE = 0;
00833E  A9C2CB     BCLR 0x2CB, #6
420:                           radio_state = STATE_RX_IDLE;    // Transition after data processed
008340  200040     MOV #0x4, W0
008342  890920     MOV W0, radio_state
008344  37002C     BRA 0x839E
421:                       }
422:               
423:                   } else if(radio_state == STATE_TX_IDLE) {
008346  810921     MOV radio_state, W1
008348  200060     MOV #0x6, W0
00834A  508F80     SUB W1, W0, [W15]
00834C  320028     BRA Z, 0x839E
424:                       // Shouldn't be getting interrupts when waiting to transmit
425:                   } else if(radio_state == STATE_TX_BUSY) {
00834E  810921     MOV radio_state, W1
008350  200070     MOV #0x7, W0
008352  508F80     SUB W1, W0, [W15]
008354  3A0024     BRA NZ, 0x839E
426:               
427:                       radio_state = STATE_TX_IDLE;
008356  200060     MOV #0x6, W0
008358  890920     MOV W0, radio_state
428:                       LED_ORANGE = 0;
00835A  A9C2CB     BCLR 0x2CB, #6
429:                       // Transmit successful
430:                       if(irq_cause == RADIO_TX_SUCCESS) {
00835C  78009E     MOV [W14], W1
00835E  EB0000     CLR W0
008360  508F80     SUB W1, W0, [W15]
008362  3A0006     BRA NZ, 0x8370
431:                           radioReturnPacket(carrayPopHead(tx_queue));
008364  8109A0     MOV tx_queue, W0
008366  0291BA     CALL carrayPopHead
008368  000000     NOP
00836A  07FF6A     RCALL radioReturnPacket
432:                           radioSetStateRx();
00836C  070036     RCALL radioSetStateRx
00836E  370017     BRA 0x839E
433:                       } else if(irq_cause == RADIO_TX_FAILURE) {
008370  78009E     MOV [W14], W1
008372  200010     MOV #0x1, W0
008374  508F80     SUB W1, W0, [W15]
008376  3A0013     BRA NZ, 0x839E
434:                           // If no more retries, reset retry counter
435:                           retries++;
008378  221270     MOV #0x2127, W0
00837A  784010     MOV.B [W0], W0
00837C  E84000     INC.B W0, W0
00837E  221271     MOV #0x2127, W1
008380  784880     MOV.B W0, [W1]
436:                           if(retries > max_packet_retries) {
008382  221270     MOV #0x2127, W0
008384  784010     MOV.B [W0], W0
008386  FB8080     ZE W0, W1
008388  8109E0     MOV max_packet_retries, W0
00838A  508F80     SUB W1, W0, [W15]
00838C  360008     BRA LEU, 0x839E
437:                               retries = 0;
00838E  221271     MOV #0x2127, W1
008390  EB4000     CLR.B W0
008392  784880     MOV.B W0, [W1]
438:                               radioReturnPacket((MacPacket)carrayPopHead(tx_queue));
008394  8109A0     MOV tx_queue, W0
008396  0291BA     CALL carrayPopHead
008398  000000     NOP
00839A  07FF52     RCALL radioReturnPacket
439:                               radioSetStateRx();
00839C  07001E     RCALL radioSetStateRx
440:                           }
441:                       }
442:                   }
443:               
444:                   // Hardware error
445:                   if(irq_cause == RADIO_HW_FAILURE) {
00839E  78009E     MOV [W14], W1
0083A0  200050     MOV #0x5, W0
0083A2  508F80     SUB W1, W0, [W15]
0083A4  3A0002     BRA NZ, 0x83AA
446:                       // Reset everything
447:                       trxReset();
0083A6  027332     CALL trxReset
0083A8  000000     NOP
448:                       //radioFlushQueues();
449:                   }
450:               }
0083AA  FA8000     ULNK
0083AC  060000     RETURN
451:               
452:               /**
453:                * Set the radio to a transmit state
454:                */
455:               static unsigned int radioSetStateTx(void) {
0083AE  FA0002     LNK #0x2
456:               
457:                   unsigned int lockAcquired;
458:               
459:                   // If already in Tx mode
460:                   if(radio_state == STATE_TX_IDLE) { return 1; }
0083B0  810921     MOV radio_state, W1
0083B2  200060     MOV #0x6, W0
0083B4  508F80     SUB W1, W0, [W15]
0083B6  3A0002     BRA NZ, 0x83BC
0083B8  200010     MOV #0x1, W0
0083BA  37000D     BRA 0x83D6
461:               
462:                   // Attempt to begin transition
463:                   lockAcquired = radioBeginTransition();
0083BC  07003A     RCALL radioBeginTransition
0083BE  780F00     MOV W0, [W14]
464:                   if(!lockAcquired) { return 0; }
0083C0  78009E     MOV [W14], W1
0083C2  EB0000     CLR W0
0083C4  508F80     SUB W1, W0, [W15]
0083C6  3A0002     BRA NZ, 0x83CC
0083C8  EB0000     CLR W0
0083CA  370005     BRA 0x83D6
465:               
466:                   trxSetStateTx();
0083CC  027534     CALL trxSetStateTx
0083CE  000000     NOP
467:                   radio_state = STATE_TX_IDLE;
0083D0  200060     MOV #0x6, W0
0083D2  890920     MOV W0, radio_state
468:                   return 1;
0083D4  200010     MOV #0x1, W0
469:               
470:               }
0083D6  FA8000     ULNK
0083D8  060000     RETURN
471:               
472:               /**
473:                * Set the radio to a receive state
474:                */
475:               static unsigned int radioSetStateRx(void) {
0083DA  FA0002     LNK #0x2
476:               
477:                   unsigned int lockAcquired;
478:               
479:                   // If already in Rx mode
480:                   if(radio_state == STATE_RX_IDLE) { return 1; }
0083DC  810921     MOV radio_state, W1
0083DE  200040     MOV #0x4, W0
0083E0  508F80     SUB W1, W0, [W15]
0083E2  3A0002     BRA NZ, 0x83E8
0083E4  200010     MOV #0x1, W0
0083E6  37000D     BRA 0x8402
481:               
482:                   // Attempt to begin transitionin
483:                   lockAcquired = radioBeginTransition();
0083E8  070024     RCALL radioBeginTransition
0083EA  780F00     MOV W0, [W14]
484:                   if(!lockAcquired) { return 0; }
0083EC  78009E     MOV [W14], W1
0083EE  EB0000     CLR W0
0083F0  508F80     SUB W1, W0, [W15]
0083F2  3A0002     BRA NZ, 0x83F8
0083F4  EB0000     CLR W0
0083F6  370005     BRA 0x8402
485:               
486:                   trxSetStateRx();
0083F8  0275BE     CALL trxSetStateRx
0083FA  000000     NOP
487:                   radio_state = STATE_RX_IDLE;
0083FC  200040     MOV #0x4, W0
0083FE  890920     MOV W0, radio_state
488:                   return 1;
008400  200010     MOV #0x1, W0
489:               
490:               }
008402  FA8000     ULNK
008404  060000     RETURN
491:               
492:               /**
493:                * Sets the radio to an idle state
494:                */
495:               static unsigned int radioSetStateIdle(void) {
008406  FA0002     LNK #0x2
496:               
497:                   unsigned int lockAcquired;
498:               
499:                   // If already in idle mode
500:                   if(radio_state == STATE_IDLE) { return 1; }
008408  810921     MOV radio_state, W1
00840A  200020     MOV #0x2, W0
00840C  508F80     SUB W1, W0, [W15]
00840E  3A0002     BRA NZ, 0x8414
008410  200010     MOV #0x1, W0
008412  37000D     BRA 0x842E
501:               
502:                   // Attempt to begin transitionin
503:                   lockAcquired = radioBeginTransition();
008414  07000E     RCALL radioBeginTransition
008416  780F00     MOV W0, [W14]
504:                   if(!lockAcquired) { return 0; }
008418  78009E     MOV [W14], W1
00841A  EB0000     CLR W0
00841C  508F80     SUB W1, W0, [W15]
00841E  3A0002     BRA NZ, 0x8424
008420  EB0000     CLR W0
008422  370005     BRA 0x842E
505:               
506:                   trxSetStateIdle();
008424  027648     CALL trxSetStateIdle
008426  000000     NOP
507:                   radio_state = STATE_IDLE;
008428  200020     MOV #0x2, W0
00842A  890920     MOV W0, radio_state
508:                   return 1;
00842C  200010     MOV #0x1, W0
509:               
510:               }
00842E  FA8000     ULNK
008430  060000     RETURN
511:               
512:               ///**
513:               // * Sets the radio to an off state
514:               // */
515:               //static unsigned int radioSetStateOff(void) {
516:               //
517:               //    unsigned int lockAcquired;
518:               //
519:               //    // If already in idle mode
520:               //    if(radio_state == STATE_OFF) { return 1; }
521:               //
522:               //    // Attempt to begin transitionin
523:               //    lockAcquired = radioBeginTransition();
524:               //    if(!lockAcquired) { return 0; }
525:               //
526:               //    trxSetStateOff();
527:               //    radio_state = STATE_OFF;
528:               //    return 1;
529:               //
530:               //}
531:               
532:               /**
533:                * Atomically checks and set the radio to transitioning state.
534:                *
535:                * Note that the radio in transitioning state will capture but disregard
536:                * interrupts from the transceiver.
537:                *
538:                * @return 1 if lock acquired, 0 otherwise
539:                */
540:               static unsigned int radioBeginTransition(void) {
008432  FA0008     LNK #0x8
541:               
542:                   unsigned int busy;
543:               
544:                   CRITICAL_SECTION_START
008434  800210     MOV SR, W0
008436  DE0045     LSR W0, #5, W0
008438  604067     AND.B W0, #0x7, W0
00843A  784F00     MOV.B W0, [W14]
00843C  800290     MOV DISICNT, W0
00843E  980710     MOV W0, [W14+2]
008440  FC3FFF     DISI #0x3FFF
008442  800211     MOV SR, W1
008444  200E00     MOV #0xE0, W0
008446  708000     IOR W1, W0, W0
008448  880210     MOV W0, SR
00844A  90001E     MOV [W14+2], W0
00844C  880290     MOV W0, DISICNT
00844E  880000     MOV W0, WREG0
545:               
546:                   busy =  (radio_state == STATE_RX_BUSY)
008450  810921     MOV radio_state, W1
008452  200050     MOV #0x5, W0
008454  508F80     SUB W1, W0, [W15]
008456  320008     BRA Z, 0x8468
008468  200010     MOV #0x1, W0
00846A  370001     BRA 0x846E
00846C  EB0000     CLR W0
00846E  980720     MOV W0, [W14+4]
547:                   || (radio_state == STATE_TX_BUSY)
008458  810921     MOV radio_state, W1
00845A  200070     MOV #0x7, W0
00845C  508F80     SUB W1, W0, [W15]
00845E  320004     BRA Z, 0x8468
548:                   || (radio_state == STATE_TRANSITIONING);
008460  810921     MOV radio_state, W1
008462  200030     MOV #0x3, W0
008464  508F80     SUB W1, W0, [W15]
008466  3A0002     BRA NZ, 0x846C
549:               
550:                   if(!busy) {
008470  9000AE     MOV [W14+4], W1
008472  EB0000     CLR W0
008474  508F80     SUB W1, W0, [W15]
008476  3A0002     BRA NZ, 0x847C
551:                       radio_state = STATE_TRANSITIONING;
008478  200030     MOV #0x3, W0
00847A  890920     MOV W0, radio_state
552:                   }
553:               
554:                   CRITICAL_SECTION_END
00847C  800290     MOV DISICNT, W0
00847E  980730     MOV W0, [W14+6]
008480  FC3FFF     DISI #0x3FFF
008482  78401E     MOV.B [W14], W0
008484  604067     AND.B W0, #0x7, W0
008486  FB8000     ZE W0, W0
008488  600067     AND W0, #0x7, W0
00848A  DD0045     SL W0, #5, W0
00848C  800212     MOV SR, W2
00848E  2FF1F1     MOV #0xFF1F, W1
008490  610081     AND W2, W1, W1
008492  708000     IOR W1, W0, W0
008494  880210     MOV W0, SR
008496  90003E     MOV [W14+6], W0
008498  880290     MOV W0, DISICNT
00849A  880000     MOV W0, WREG0
555:               
556:                   return !busy;
00849C  200010     MOV #0x1, W0
00849E  90012E     MOV [W14+4], W2
0084A0  EB0080     CLR W1
0084A2  510F81     SUB W2, W1, [W15]
0084A4  320001     BRA Z, 0x84A8
0084A6  EB0000     CLR W0
557:               
558:               }
0084A8  FA8000     ULNK
0084AA  060000     RETURN
559:               
560:               /**
561:                * Process a pending packet send request
562:                */
563:               static void radioProcessTx(void) {
0084AC  FA0002     LNK #0x2
564:               
565:                   MacPacket packet;
566:               
567:                   packet = (MacPacket) carrayPeekHead(tx_queue); // Find an outgoing packet
0084AE  8109A0     MOV tx_queue, W0
0084B0  0292F6     CALL carrayPeekHead
0084B2  000000     NOP
0084B4  780F00     MOV W0, [W14]
568:                   if(packet == NULL) { return; }
0084B6  78009E     MOV [W14], W1
0084B8  EB0000     CLR W0
0084BA  508F80     SUB W1, W0, [W15]
0084BC  320012     BRA Z, 0x84E2
0084E2  000000     NOP
569:               
570:                   // State should be STATE_TX_IDLE upon entering function
571:                   radio_state = STATE_TX_BUSY;    // Update state
0084BE  200070     MOV #0x7, W0
0084C0  890920     MOV W0, radio_state
572:                   LED_ORANGE = 1;                    // Indicate RX activity
0084C2  A8C2CB     BSET 0x2CB, #6
573:               
574:                   macSetSeqNum(packet, packet_sqn++); // Set packet sequence number
0084C4  221260     MOV #0x2126, W0
0084C6  784010     MOV.B [W0], W0
0084C8  784080     MOV.B W0, W1
0084CA  E84000     INC.B W0, W0
0084CC  221262     MOV #0x2126, W2
0084CE  784900     MOV.B W0, [W2]
0084D0  78001E     MOV [W14], W0
0084D2  02862C     CALL macSetSeqNum
0084D4  000000     NOP
575:               
576:                   trxWriteFrameBuffer(packet); // Write packet to transmitter and send
0084D6  78001E     MOV [W14], W0
0084D8  02742A     CALL trxWriteFrameBuffer
0084DA  000000     NOP
577:                   trxBeginTransmission();
0084DC  027522     CALL trxBeginTransmission
0084DE  000000     NOP
0084E0  370001     BRA 0x84E4
578:               
579:               }
0084E4  FA8000     ULNK
0084E6  060000     RETURN
580:               
581:               /**
582:                * Process a pending packet receive request
583:                */
584:               static void radioProcessRx(void) {
0084E8  FA0004     LNK #0x4
585:               
586:                   MacPacket packet;
587:                   unsigned char len;
588:               
589:                   if(radioRxQueueFull()) { return; } // Don't bother if rx queue full
0084EA  07FE3E     RCALL radioRxQueueFull
0084EC  EB0080     CLR W1
0084EE  500F81     SUB W0, W1, [W15]
0084F0  3A001E     BRA NZ, 0x852E
00852E  000000     NOP
008530  370001     BRA 0x8534
590:               
591:                   len = trxReadBufferDataLength(); // Read received frame data length
0084F2  027516     CALL trxReadBufferDataLength
0084F4  000000     NOP
0084F6  784F00     MOV.B W0, [W14]
592:                   packet = radioRequestPacket(len - PAYLOAD_HEADER_LENGTH); // Pull appropriate packet from pool
0084F8  78409E     MOV.B [W14], W1
0084FA  FB8001     ZE W1, W0
0084FC  E98000     DEC2 W0, W0
0084FE  07FE59     RCALL radioRequestPacket
008500  980710     MOV W0, [W14+2]
593:               
594:                   if(packet == NULL) { return; }
008502  90009E     MOV [W14+2], W1
008504  EB0000     CLR W0
008506  508F80     SUB W1, W0, [W15]
008508  320014     BRA Z, 0x8532
008532  000000     NOP
595:               
596:                   trxReadFrameBuffer(packet); // Retrieve frame from transceiver
00850A  90001E     MOV [W14+2], W0
00850C  027506     CALL trxReadFrameBuffer
00850E  000000     NOP
597:                   packet->timestamp = sclockGetLocalTicks(); // Mark local time of reception
008510  02DE50     CALL sclockGetLocalTicks
008512  000000     NOP
008514  90011E     MOV [W14+2], W2
008516  980900     MOV W0, [W2+16]
008518  980911     MOV W1, [W2+18]
598:               
599:                   if(!carrayAddTail(rx_queue, packet)) {
00851A  8109B0     MOV rx_queue, W0
00851C  90009E     MOV [W14+2], W1
00851E  028F9A     CALL carrayAddTail
008520  000000     NOP
008522  EB0080     CLR W1
008524  500F81     SUB W0, W1, [W15]
008526  3A0006     BRA NZ, 0x8534
600:                       radioReturnPacket(packet); // Check for failure
008528  90001E     MOV [W14+2], W0
00852A  07FE8A     RCALL radioReturnPacket
00852C  370003     BRA 0x8534
601:                   }
602:               
603:               }
008534  FA8000     ULNK
008536  060000     RETURN
604:               
605:               static inline void watchdogProgress(void) {
008538  FA0000     LNK #0x0
606:               
607:                   progress_timestamp = sclockGetLocalMillis();
00853A  02DE60     CALL sclockGetLocalMillis
00853C  000000     NOP
00853E  890960     MOV W0, progress_timestamp
008540  890971     MOV W1, 0x212E
608:               
609:               }
008542  FA8000     ULNK
008544  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/queue.c  ----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Linked List Queue (FIFO) for generic elements
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-08-03     Initial release
38:                 *                      
39:                 * Notes:
40:                 *
41:                 */
42:                
43:                #include "queue.h"
44:                #include "utils.h"
45:                #include "p33Fxxxx.h"
46:                #include <stdio.h>      // for NULL
47:                #include <stdlib.h>     // for malloc
48:                
49:                
50:                #ifndef CRITICAL_SECTION_START
51:                #define CRITICAL_SECTION_START	char saved_ipl; SET_AND_SAVE_CPU_IPL(saved_ipl, 7);
52:                #define CRITICAL_SECTION_END RESTORE_CPU_IPL(saved_ipl);	
53:                #endif
54:                
55:                /*-----------------------------------------------------------------------------
56:                 *          Public functions
57:                -----------------------------------------------------------------------------*/
58:                
59:                Queue queueInit(int max_size) {
00BB26  FA000A     LNK #0xA
00BB28  980740     MOV W0, [W14+8]
60:                    // begin critical section
61:                    CRITICAL_SECTION_START;
00BB2A  800210     MOV SR, W0
00BB2C  DE0045     LSR W0, #5, W0
00BB2E  604067     AND.B W0, #0x7, W0
00BB30  784F00     MOV.B W0, [W14]
00BB32  800290     MOV DISICNT, W0
00BB34  980710     MOV W0, [W14+2]
00BB36  FC3FFF     DISI #0x3FFF
00BB38  800211     MOV SR, W1
00BB3A  200E00     MOV #0xE0, W0
00BB3C  708000     IOR W1, W0, W0
00BB3E  880210     MOV W0, SR
00BB40  90001E     MOV [W14+2], W0
00BB42  880290     MOV W0, DISICNT
00BB44  880000     MOV W0, WREG0
62:                
63:                    Queue q = (Queue)malloc(sizeof(QueueStruct));
00BB46  2000A0     MOV #0xA, W0
00BB48  0233BA     CALL _malloc
00BB4A  000000     NOP
00BB4C  980720     MOV W0, [W14+4]
64:                
65:                    if (q == NULL) return NULL;
00BB4E  9000AE     MOV [W14+4], W1
00BB50  EB0000     CLR W0
00BB52  508F80     SUB W1, W0, [W15]
00BB54  3A0002     BRA NZ, 0xBB5A
00BB56  EB0000     CLR W0
00BB58  37001E     BRA 0xBB96
66:                
67:                    q->front = q->rear = NULL;
00BB5A  90002E     MOV [W14+4], W0
00BB5C  EB0080     CLR W1
00BB5E  980011     MOV W1, [W0+2]
00BB60  90002E     MOV [W14+4], W0
00BB62  900090     MOV [W0+2], W1
00BB64  90002E     MOV [W14+4], W0
00BB66  780801     MOV W1, [W0]
68:                    q->size = 0;
00BB68  90002E     MOV [W14+4], W0
00BB6A  EB0080     CLR W1
00BB6C  980031     MOV W1, [W0+6]
69:                    q->max_size = max_size;
00BB6E  90002E     MOV [W14+4], W0
00BB70  9000CE     MOV [W14+8], W1
00BB72  980041     MOV W1, [W0+8]
70:                
71:                    // end critical section    
72:                    CRITICAL_SECTION_END;
00BB74  800290     MOV DISICNT, W0
00BB76  980730     MOV W0, [W14+6]
00BB78  FC3FFF     DISI #0x3FFF
00BB7A  78401E     MOV.B [W14], W0
00BB7C  604067     AND.B W0, #0x7, W0
00BB7E  FB8000     ZE W0, W0
00BB80  600067     AND W0, #0x7, W0
00BB82  DD0045     SL W0, #5, W0
00BB84  800212     MOV SR, W2
00BB86  2FF1F1     MOV #0xFF1F, W1
00BB88  610081     AND W2, W1, W1
00BB8A  708000     IOR W1, W0, W0
00BB8C  880210     MOV W0, SR
00BB8E  90003E     MOV [W14+6], W0
00BB90  880290     MOV W0, DISICNT
00BB92  880000     MOV W0, WREG0
73:                    return q;
00BB94  90002E     MOV [W14+4], W0
74:                }
00BB96  FA8000     ULNK
00BB98  060000     RETURN
75:                
76:                
77:                Item queuePush(Queue q, Item item) {
00BB9A  FA000C     LNK #0xC
00BB9C  980740     MOV W0, [W14+8]
00BB9E  980751     MOV W1, [W14+10]
78:                
79:                    Item ret = NULL;
00BBA0  EB0000     CLR W0
00BBA2  780F00     MOV W0, [W14]
80:                
81:                    // begin critical section
82:                    CRITICAL_SECTION_START;
00BBA4  800210     MOV SR, W0
00BBA6  DE0045     LSR W0, #5, W0
00BBA8  604067     AND.B W0, #0x7, W0
00BBAA  984720     MOV.B W0, [W14+2]
00BBAC  800290     MOV DISICNT, W0
00BBAE  980720     MOV W0, [W14+4]
00BBB0  FC3FFF     DISI #0x3FFF
00BBB2  800211     MOV SR, W1
00BBB4  200E00     MOV #0xE0, W0
00BBB6  708000     IOR W1, W0, W0
00BBB8  880210     MOV W0, SR
00BBBA  90002E     MOV [W14+4], W0
00BBBC  880290     MOV W0, DISICNT
00BBBE  880000     MOV W0, WREG0
83:                
84:                    if (queueIsFull(q)) {
00BBC0  90004E     MOV [W14+8], W0
00BBC2  0700EF     RCALL queueIsFull
00BBC4  EB0080     CLR W1
00BBC6  500F81     SUB W0, W1, [W15]
00BBC8  320003     BRA Z, 0xBBD0
85:                        ret = queuePop(q);
00BBCA  90004E     MOV [W14+8], W0
00BBCC  070087     RCALL queuePop
00BBCE  780F00     MOV W0, [W14]
86:                    }
87:                
88:                    queueAppend(q, item);
00BBD0  9000DE     MOV [W14+10], W1
00BBD2  90004E     MOV [W14+8], W0
00BBD4  070013     RCALL queueAppend
89:                
90:                    // end critical section    
91:                    CRITICAL_SECTION_END;
00BBD6  800290     MOV DISICNT, W0
00BBD8  980730     MOV W0, [W14+6]
00BBDA  FC3FFF     DISI #0x3FFF
00BBDC  90402E     MOV.B [W14+2], W0
00BBDE  604067     AND.B W0, #0x7, W0
00BBE0  FB8000     ZE W0, W0
00BBE2  600067     AND W0, #0x7, W0
00BBE4  DD0045     SL W0, #5, W0
00BBE6  800212     MOV SR, W2
00BBE8  2FF1F1     MOV #0xFF1F, W1
00BBEA  610081     AND W2, W1, W1
00BBEC  708000     IOR W1, W0, W0
00BBEE  880210     MOV W0, SR
00BBF0  90003E     MOV [W14+6], W0
00BBF2  880290     MOV W0, DISICNT
00BBF4  880000     MOV W0, WREG0
92:                
93:                    return ret;
00BBF6  78001E     MOV [W14], W0
94:                
95:                }
00BBF8  FA8000     ULNK
00BBFA  060000     RETURN
96:                
97:                
98:                unsigned int queueAppend(Queue q, Item item) {
00BBFC  FA0010     LNK #0x10
00BBFE  980760     MOV W0, [W14+12]
00BC00  980771     MOV W1, [W14+14]
99:                
100:                   // begin critical section
101:                   CRITICAL_SECTION_START;
00BC02  800210     MOV SR, W0
00BC04  DE0045     LSR W0, #5, W0
00BC06  604067     AND.B W0, #0x7, W0
00BC08  784F00     MOV.B W0, [W14]
00BC0A  800290     MOV DISICNT, W0
00BC0C  980710     MOV W0, [W14+2]
00BC0E  FC3FFF     DISI #0x3FFF
00BC10  800211     MOV SR, W1
00BC12  200E00     MOV #0xE0, W0
00BC14  708000     IOR W1, W0, W0
00BC16  880210     MOV W0, SR
00BC18  90001E     MOV [W14+2], W0
00BC1A  880290     MOV W0, DISICNT
00BC1C  880000     MOV W0, WREG0
102:               
103:                   if (queueIsFull(q)) {
00BC1E  90006E     MOV [W14+12], W0
00BC20  0700C0     RCALL queueIsFull
00BC22  EB0080     CLR W1
00BC24  500F81     SUB W0, W1, [W15]
00BC26  320012     BRA Z, 0xBC4C
104:                       // end critical section    
105:                       CRITICAL_SECTION_END;
00BC28  800290     MOV DISICNT, W0
00BC2A  980720     MOV W0, [W14+4]
00BC2C  FC3FFF     DISI #0x3FFF
00BC2E  78401E     MOV.B [W14], W0
00BC30  604067     AND.B W0, #0x7, W0
00BC32  FB8000     ZE W0, W0
00BC34  600067     AND W0, #0x7, W0
00BC36  DD0045     SL W0, #5, W0
00BC38  800212     MOV SR, W2
00BC3A  2FF1F1     MOV #0xFF1F, W1
00BC3C  610081     AND W2, W1, W1
00BC3E  708000     IOR W1, W0, W0
00BC40  880210     MOV W0, SR
00BC42  90002E     MOV [W14+4], W0
00BC44  880290     MOV W0, DISICNT
00BC46  880000     MOV W0, WREG0
106:                       return 0;
00BC48  EB0000     CLR W0
00BC4A  370046     BRA 0xBCD8
107:                   }
108:               
109:                   Node* new_node = (Node*)malloc(sizeof(Node));
00BC4C  200040     MOV #0x4, W0
00BC4E  0233BA     CALL _malloc
00BC50  000000     NOP
00BC52  980730     MOV W0, [W14+6]
110:                   if (new_node == NULL) {
00BC54  9000BE     MOV [W14+6], W1
00BC56  EB0000     CLR W0
00BC58  508F80     SUB W1, W0, [W15]
00BC5A  3A0012     BRA NZ, 0xBC80
111:                       // end critical section    
112:                       CRITICAL_SECTION_END;
00BC5C  800290     MOV DISICNT, W0
00BC5E  980740     MOV W0, [W14+8]
00BC60  FC3FFF     DISI #0x3FFF
00BC62  78401E     MOV.B [W14], W0
00BC64  604067     AND.B W0, #0x7, W0
00BC66  FB8000     ZE W0, W0
00BC68  600067     AND W0, #0x7, W0
00BC6A  DD0045     SL W0, #5, W0
00BC6C  800212     MOV SR, W2
00BC6E  2FF1F1     MOV #0xFF1F, W1
00BC70  610081     AND W2, W1, W1
00BC72  708000     IOR W1, W0, W0
00BC74  880210     MOV W0, SR
00BC76  90004E     MOV [W14+8], W0
00BC78  880290     MOV W0, DISICNT
00BC7A  880000     MOV W0, WREG0
113:                       return 0;
00BC7C  EB0000     CLR W0
00BC7E  37002C     BRA 0xBCD8
114:                   }
115:               
116:               
117:                   new_node->item = item;
00BC80  90003E     MOV [W14+6], W0
00BC82  9000FE     MOV [W14+14], W1
00BC84  780801     MOV W1, [W0]
118:                   new_node->next = NULL;
00BC86  90003E     MOV [W14+6], W0
00BC88  EB0080     CLR W1
00BC8A  980011     MOV W1, [W0+2]
119:                   if (queueIsEmpty(q)) {
00BC8C  90006E     MOV [W14+12], W0
00BC8E  07009C     RCALL queueIsEmpty
00BC90  EB0080     CLR W1
00BC92  500F81     SUB W0, W1, [W15]
00BC94  320004     BRA Z, 0xBC9E
120:                       q->front = new_node;    // insert the item at the front
00BC96  90006E     MOV [W14+12], W0
00BC98  9000BE     MOV [W14+6], W1
00BC9A  780801     MOV W1, [W0]
00BC9C  370004     BRA 0xBCA6
121:                   } else {
122:                       q->rear->next = new_node; // append the item at the end
00BC9E  90006E     MOV [W14+12], W0
00BCA0  900010     MOV [W0+2], W0
00BCA2  9000BE     MOV [W14+6], W1
00BCA4  980011     MOV W1, [W0+2]
123:                   }
124:                   q->rear = new_node;     // relocated the rear node
00BCA6  90006E     MOV [W14+12], W0
00BCA8  9000BE     MOV [W14+6], W1
00BCAA  980011     MOV W1, [W0+2]
125:                   q->size++;
00BCAC  90006E     MOV [W14+12], W0
00BCAE  900030     MOV [W0+6], W0
00BCB0  E80080     INC W0, W1
00BCB2  90006E     MOV [W14+12], W0
00BCB4  980031     MOV W1, [W0+6]
126:               
127:                   // end critical section    
128:                   CRITICAL_SECTION_END;
00BCB6  800290     MOV DISICNT, W0
00BCB8  980750     MOV W0, [W14+10]
00BCBA  FC3FFF     DISI #0x3FFF
00BCBC  78401E     MOV.B [W14], W0
00BCBE  604067     AND.B W0, #0x7, W0
00BCC0  FB8000     ZE W0, W0
00BCC2  600067     AND W0, #0x7, W0
00BCC4  DD0045     SL W0, #5, W0
00BCC6  800212     MOV SR, W2
00BCC8  2FF1F1     MOV #0xFF1F, W1
00BCCA  610081     AND W2, W1, W1
00BCCC  708000     IOR W1, W0, W0
00BCCE  880210     MOV W0, SR
00BCD0  90005E     MOV [W14+10], W0
00BCD2  880290     MOV W0, DISICNT
00BCD4  880000     MOV W0, WREG0
129:               
130:                   return 1;
00BCD6  200010     MOV #0x1, W0
131:               
132:               }
00BCD8  FA8000     ULNK
00BCDA  060000     RETURN
133:               
134:               
135:               Item queuePop(Queue q) {
00BCDC  FA000E     LNK #0xE
00BCDE  980760     MOV W0, [W14+12]
136:               
137:                   // begin critical section
138:                   CRITICAL_SECTION_START;
00BCE0  800210     MOV SR, W0
00BCE2  DE0045     LSR W0, #5, W0
00BCE4  604067     AND.B W0, #0x7, W0
00BCE6  784F00     MOV.B W0, [W14]
00BCE8  800290     MOV DISICNT, W0
00BCEA  980710     MOV W0, [W14+2]
00BCEC  FC3FFF     DISI #0x3FFF
00BCEE  800211     MOV SR, W1
00BCF0  200E00     MOV #0xE0, W0
00BCF2  708000     IOR W1, W0, W0
00BCF4  880210     MOV W0, SR
00BCF6  90001E     MOV [W14+2], W0
00BCF8  880290     MOV W0, DISICNT
00BCFA  880000     MOV W0, WREG0
139:               
140:                   if(queueIsEmpty(q)) {
00BCFC  90006E     MOV [W14+12], W0
00BCFE  070064     RCALL queueIsEmpty
00BD00  EB0080     CLR W1
00BD02  500F81     SUB W0, W1, [W15]
00BD04  320012     BRA Z, 0xBD2A
141:                       // end critical section    
142:                       CRITICAL_SECTION_END;
00BD06  800290     MOV DISICNT, W0
00BD08  980720     MOV W0, [W14+4]
00BD0A  FC3FFF     DISI #0x3FFF
00BD0C  78401E     MOV.B [W14], W0
00BD0E  604067     AND.B W0, #0x7, W0
00BD10  FB8000     ZE W0, W0
00BD12  600067     AND W0, #0x7, W0
00BD14  DD0045     SL W0, #5, W0
00BD16  800212     MOV SR, W2
00BD18  2FF1F1     MOV #0xFF1F, W1
00BD1A  610081     AND W2, W1, W1
00BD1C  708000     IOR W1, W0, W0
00BD1E  880210     MOV W0, SR
00BD20  90002E     MOV [W14+4], W0
00BD22  880290     MOV W0, DISICNT
00BD24  880000     MOV W0, WREG0
143:               
144:                       return NULL;
00BD26  EB0000     CLR W0
00BD28  37002B     BRA 0xBD80
145:                   }
146:               
147:                   Node *front_node = q->front;
00BD2A  90006E     MOV [W14+12], W0
00BD2C  780090     MOV [W0], W1
00BD2E  980731     MOV W1, [W14+6]
148:                   Item item = front_node->item;
00BD30  90003E     MOV [W14+6], W0
00BD32  780090     MOV [W0], W1
00BD34  980741     MOV W1, [W14+8]
149:               
150:                   q->front = front_node->next;  // reloacte the front node;
00BD36  90003E     MOV [W14+6], W0
00BD38  900090     MOV [W0+2], W1
00BD3A  90006E     MOV [W14+12], W0
00BD3C  780801     MOV W1, [W0]
151:                   free(front_node);
00BD3E  90003E     MOV [W14+6], W0
00BD40  0234EC     CALL _free
00BD42  000000     NOP
152:               
153:                   q->size--;
00BD44  90006E     MOV [W14+12], W0
00BD46  900030     MOV [W0+6], W0
00BD48  E90080     DEC W0, W1
00BD4A  90006E     MOV [W14+12], W0
00BD4C  980031     MOV W1, [W0+6]
154:               
155:                   if(queueIsEmpty(q)) q->rear = NULL;
00BD4E  90006E     MOV [W14+12], W0
00BD50  07003B     RCALL queueIsEmpty
00BD52  EB0080     CLR W1
00BD54  500F81     SUB W0, W1, [W15]
00BD56  320003     BRA Z, 0xBD5E
00BD58  90006E     MOV [W14+12], W0
00BD5A  EB0080     CLR W1
00BD5C  980011     MOV W1, [W0+2]
156:               
157:                   // end critical section    
158:                   CRITICAL_SECTION_END;
00BD5E  800290     MOV DISICNT, W0
00BD60  980750     MOV W0, [W14+10]
00BD62  FC3FFF     DISI #0x3FFF
00BD64  78401E     MOV.B [W14], W0
00BD66  604067     AND.B W0, #0x7, W0
00BD68  FB8000     ZE W0, W0
00BD6A  600067     AND W0, #0x7, W0
00BD6C  DD0045     SL W0, #5, W0
00BD6E  800212     MOV SR, W2
00BD70  2FF1F1     MOV #0xFF1F, W1
00BD72  610081     AND W2, W1, W1
00BD74  708000     IOR W1, W0, W0
00BD76  880210     MOV W0, SR
00BD78  90005E     MOV [W14+10], W0
00BD7A  880290     MOV W0, DISICNT
00BD7C  880000     MOV W0, WREG0
159:               
160:                   return item;
00BD7E  90004E     MOV [W14+8], W0
161:               
162:               }
00BD80  FA8000     ULNK
00BD82  060000     RETURN
163:               
164:               Item queueGetFront(Queue q) {
00BD84  FA0004     LNK #0x4
00BD86  980710     MOV W0, [W14+2]
165:               
166:                   if(queueIsEmpty(q)) {
00BD88  90001E     MOV [W14+2], W0
00BD8A  07001E     RCALL queueIsEmpty
00BD8C  EB0080     CLR W1
00BD8E  500F81     SUB W0, W1, [W15]
00BD90  320002     BRA Z, 0xBD96
167:                       return NULL;
00BD92  EB0000     CLR W0
00BD94  370004     BRA 0xBD9E
168:                   }
169:               
170:                   Item item = q->front->item;
00BD96  90001E     MOV [W14+2], W0
00BD98  780010     MOV [W0], W0
00BD9A  780F10     MOV [W0], [W14]
171:                   //Item item = front_node->item;
172:               
173:                   return item;
00BD9C  78001E     MOV [W14], W0
174:               }
00BD9E  FA8000     ULNK
00BDA0  060000     RETURN
175:               
176:               
177:               int queueIsFull(Queue q) {
00BDA2  FA0002     LNK #0x2
00BDA4  780F00     MOV W0, [W14]
178:                   if(q->max_size == 0) return 1; // max_size == 0 means no max.
00BDA6  78001E     MOV [W14], W0
00BDA8  9000C0     MOV [W0+8], W1
00BDAA  EB0000     CLR W0
00BDAC  508F80     SUB W1, W0, [W15]
00BDAE  3A0002     BRA NZ, 0xBDB4
00BDB0  200010     MOV #0x1, W0
00BDB2  370008     BRA 0xBDC4
179:                   return q->size == q->max_size;
00BDB4  78001E     MOV [W14], W0
00BDB6  900130     MOV [W0+6], W2
00BDB8  78001E     MOV [W14], W0
00BDBA  9000C0     MOV [W0+8], W1
00BDBC  200010     MOV #0x1, W0
00BDBE  510F81     SUB W2, W1, [W15]
00BDC0  320001     BRA Z, 0xBDC4
00BDC2  EB0000     CLR W0
180:               }
00BDC4  FA8000     ULNK
00BDC6  060000     RETURN
181:               
182:               int queueIsEmpty(Queue q) {
00BDC8  FA0002     LNK #0x2
00BDCA  780F00     MOV W0, [W14]
183:                   return q->size == 0;
00BDCC  78001E     MOV [W14], W0
00BDCE  900130     MOV [W0+6], W2
00BDD0  200010     MOV #0x1, W0
00BDD2  EB0080     CLR W1
00BDD4  510F81     SUB W2, W1, [W15]
00BDD6  320001     BRA Z, 0xBDDA
00BDD8  EB0000     CLR W0
184:               }
00BDDA  FA8000     ULNK
00BDDC  060000     RETURN
185:               
186:               
187:               int queueGetSize(Queue q) {
00BDDE  FA0002     LNK #0x2
00BDE0  780F00     MOV W0, [W14]
188:                   return q->size;
00BDE2  78001E     MOV [W14], W0
00BDE4  900030     MOV [W0+6], W0
189:               }
00BDE6  FA8000     ULNK
00BDE8  060000     RETURN
190:               
191:               
192:               
193:               
194:               
195:               
196:               
197:               
198:               
199:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/quat.c  -----------------------------------------------
1:                 /*
2:                 * Copyright (c) 2011-2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Quaternion Library
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v 0.2
35:                *
36:                * Revisions:
37:                *  Humphrey Hu     2011-10-07      Initial release
38:                *  Humphrey Hu     2012-06-29      Updated implementations
39:                *
40:                */
41:                
42:                #include "quat.h"
43:                #include <stdlib.h>
44:                #include <math.h>
45:                #include <string.h>
46:                
47:                void quatCopy(Quaternion *dst, Quaternion *src) {
00A488  FA0004     LNK #0x4
00A48A  780F00     MOV W0, [W14]
00A48C  980711     MOV W1, [W14+2]
48:                
49:                    if(dst == NULL || src == NULL) { return; }
00A48E  78009E     MOV [W14], W1
00A490  EB0000     CLR W0
00A492  508F80     SUB W1, W0, [W15]
00A494  32000A     BRA Z, 0xA4AA
00A496  90009E     MOV [W14+2], W1
00A498  EB0000     CLR W0
00A49A  508F80     SUB W1, W0, [W15]
00A49C  320008     BRA Z, 0xA4AE
00A4AA  000000     NOP
00A4AC  370001     BRA 0xA4B0
00A4AE  000000     NOP
50:                    memcpy(dst, src, sizeof(Quaternion));
00A49E  200102     MOV #0x10, W2
00A4A0  90009E     MOV [W14+2], W1
00A4A2  78001E     MOV [W14], W0
00A4A4  023582     CALL _memcpy
00A4A6  000000     NOP
00A4A8  370003     BRA 0xA4B0
51:                
52:                }
00A4B0  FA8000     ULNK
00A4B2  060000     RETURN
53:                
54:                void quatRotate(Quaternion *q, Quaternion *v, Quaternion *result) {
00A4B4  FA0016     LNK #0x16
00A4B6  980F00     MOV W0, [W14+16]
00A4B8  980F11     MOV W1, [W14+18]
00A4BA  980F22     MOV W2, [W14+20]
55:                
56:                    if(q == NULL || v == NULL || result == NULL) { return; }
00A4BC  90088E     MOV [W14+16], W1
00A4BE  EB0000     CLR W0
00A4C0  508F80     SUB W1, W0, [W15]
00A4C2  320014     BRA Z, 0xA4EC
00A4C4  90089E     MOV [W14+18], W1
00A4C6  EB0000     CLR W0
00A4C8  508F80     SUB W1, W0, [W15]
00A4CA  320012     BRA Z, 0xA4F0
00A4CC  9008AE     MOV [W14+20], W1
00A4CE  EB0000     CLR W0
00A4D0  508F80     SUB W1, W0, [W15]
00A4D2  320010     BRA Z, 0xA4F4
00A4EC  000000     NOP
00A4EE  370003     BRA 0xA4F6
00A4F0  000000     NOP
00A4F2  370001     BRA 0xA4F6
00A4F4  000000     NOP
57:                
58:                    Quaternion temp;
59:                    quatConj(q, &temp);
00A4D4  78008E     MOV W14, W1
00A4D6  90080E     MOV [W14+16], W0
00A4D8  070010     RCALL quatConj
60:                    quatMult(q, v, result);
00A4DA  90092E     MOV [W14+20], W2
00A4DC  90089E     MOV [W14+18], W1
00A4DE  90080E     MOV [W14+16], W0
00A4E0  070036     RCALL quatMult
61:                    quatMult(result, &temp, result);
00A4E2  90092E     MOV [W14+20], W2
00A4E4  78008E     MOV W14, W1
00A4E6  90082E     MOV [W14+20], W0
00A4E8  070032     RCALL quatMult
00A4EA  370005     BRA 0xA4F6
62:                
63:                }
00A4F6  FA8000     ULNK
00A4F8  060000     RETURN
64:                
65:                void quatConj(Quaternion *a, Quaternion *result) {
00A4FA  FA0004     LNK #0x4
00A4FC  780F00     MOV W0, [W14]
00A4FE  980711     MOV W1, [W14+2]
66:                
67:                    if(a == NULL || result == NULL) { return; }
00A500  78009E     MOV [W14], W1
00A502  EB0000     CLR W0
00A504  508F80     SUB W1, W0, [W15]
00A506  32001E     BRA Z, 0xA544
00A508  90009E     MOV [W14+2], W1
00A50A  EB0000     CLR W0
00A50C  508F80     SUB W1, W0, [W15]
00A50E  32001C     BRA Z, 0xA548
00A544  000000     NOP
00A546  370001     BRA 0xA54A
00A548  000000     NOP
68:                
69:                    result->w = a->w;
00A510  78001E     MOV [W14], W0
00A512  BE0010     MOV.D [W0], W0
00A514  90011E     MOV [W14+2], W2
00A516  BE8900     MOV.D W0, [W2]
70:                    result->x = -a->x;
00A518  78001E     MOV [W14], W0
00A51A  9000B0     MOV [W0+6], W1
00A51C  900020     MOV [W0+4], W0
00A51E  A2F001     BTG W1, #15
00A520  90011E     MOV [W14+2], W2
00A522  980120     MOV W0, [W2+4]
00A524  980131     MOV W1, [W2+6]
71:                    result->y = -a->y;
00A526  78001E     MOV [W14], W0
00A528  9000D0     MOV [W0+10], W1
00A52A  900040     MOV [W0+8], W0
00A52C  A2F001     BTG W1, #15
00A52E  90011E     MOV [W14+2], W2
00A530  980140     MOV W0, [W2+8]
00A532  980151     MOV W1, [W2+10]
72:                    result->z = -a->z;
00A534  78001E     MOV [W14], W0
00A536  9000F0     MOV [W0+14], W1
00A538  900060     MOV [W0+12], W0
00A53A  A2F001     BTG W1, #15
00A53C  90011E     MOV [W14+2], W2
00A53E  980160     MOV W0, [W2+12]
00A540  980171     MOV W1, [W2+14]
00A542  370003     BRA 0xA54A
73:                
74:                }
00A54A  FA8000     ULNK
00A54C  060000     RETURN
75:                
76:                void quatMult(Quaternion *q1, Quaternion *q2, Quaternion *result) {
00A54E  FA0026     LNK #0x26
00A550  BE9F88     MOV.D W8, [W15++]
00A552  981700     MOV W0, [W14+32]
00A554  981711     MOV W1, [W14+34]
00A556  981722     MOV W2, [W14+36]
77:                
78:                    Quaternion a, b;
79:                
80:                    if(q1 == NULL || q2 == NULL || result == NULL) { return; }
00A558  90108E     MOV [W14+32], W1
00A55A  EB0000     CLR W0
00A55C  508F80     SUB W1, W0, [W15]
00A55E  3200DE     BRA Z, 0xA71C
00A560  90109E     MOV [W14+34], W1
00A562  EB0000     CLR W0
00A564  508F80     SUB W1, W0, [W15]
00A566  3200DC     BRA Z, 0xA720
00A568  9010AE     MOV [W14+36], W1
00A56A  EB0000     CLR W0
00A56C  508F80     SUB W1, W0, [W15]
00A56E  3200DA     BRA Z, 0xA724
00A71C  000000     NOP
00A71E  370003     BRA 0xA726
00A720  000000     NOP
00A722  370001     BRA 0xA726
00A724  000000     NOP
81:                
82:                    quatCopy(&a, q1); // Make copies so result can be operand
00A570  90108E     MOV [W14+32], W1
00A572  78000E     MOV W14, W0
00A574  07FF89     RCALL quatCopy
83:                    quatCopy(&b, q2);
00A576  470070     ADD W14, #0x10, W0
00A578  90109E     MOV [W14+34], W1
00A57A  07FF86     RCALL quatCopy
84:                
85:                    result->w = a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z;
00A57C  BE021E     MOV.D [W14], W4
00A57E  470070     ADD W14, #0x10, W0
00A580  BE0010     MOV.D [W0], W0
00A582  BE0100     MOV.D W0, W2
00A584  BE0004     MOV.D W4, W0
00A586  022C36     CALL ___mulsf3
00A588  000000     NOP
00A58A  BE0400     MOV.D W0, W8
00A58C  90022E     MOV [W14+4], W4
00A58E  9002BE     MOV [W14+6], W5
00A590  470070     ADD W14, #0x10, W0
00A592  9000B0     MOV [W0+6], W1
00A594  900020     MOV [W0+4], W0
00A596  BE0100     MOV.D W0, W2
00A598  BE0004     MOV.D W4, W0
00A59A  022C36     CALL ___mulsf3
00A59C  000000     NOP
00A59E  BE0100     MOV.D W0, W2
00A5A0  BE0008     MOV.D W8, W0
00A5A2  022A5A     CALL ___subsf3
00A5A4  000000     NOP
00A5A6  BE0400     MOV.D W0, W8
00A5A8  90024E     MOV [W14+8], W4
00A5AA  9002DE     MOV [W14+10], W5
00A5AC  470070     ADD W14, #0x10, W0
00A5AE  9000D0     MOV [W0+10], W1
00A5B0  900040     MOV [W0+8], W0
00A5B2  BE0100     MOV.D W0, W2
00A5B4  BE0004     MOV.D W4, W0
00A5B6  022C36     CALL ___mulsf3
00A5B8  000000     NOP
00A5BA  BE0100     MOV.D W0, W2
00A5BC  BE0008     MOV.D W8, W0
00A5BE  022A5A     CALL ___subsf3
00A5C0  000000     NOP
00A5C2  BE0400     MOV.D W0, W8
00A5C4  90026E     MOV [W14+12], W4
00A5C6  9002FE     MOV [W14+14], W5
00A5C8  470070     ADD W14, #0x10, W0
00A5CA  9000F0     MOV [W0+14], W1
00A5CC  900060     MOV [W0+12], W0
00A5CE  BE0100     MOV.D W0, W2
00A5D0  BE0004     MOV.D W4, W0
00A5D2  022C36     CALL ___mulsf3
00A5D4  000000     NOP
00A5D6  BE0100     MOV.D W0, W2
00A5D8  BE0008     MOV.D W8, W0
00A5DA  022A5A     CALL ___subsf3
00A5DC  000000     NOP
00A5DE  90112E     MOV [W14+36], W2
00A5E0  BE8900     MOV.D W0, [W2]
86:                    result->x = a.w*b.x + b.w*a.x + a.y*b.z - a.z*b.y;
00A5E2  BE021E     MOV.D [W14], W4
00A5E4  470070     ADD W14, #0x10, W0
00A5E6  9000B0     MOV [W0+6], W1
00A5E8  900020     MOV [W0+4], W0
00A5EA  BE0100     MOV.D W0, W2
00A5EC  BE0004     MOV.D W4, W0
00A5EE  022C36     CALL ___mulsf3
00A5F0  000000     NOP
00A5F2  BE0400     MOV.D W0, W8
00A5F4  470070     ADD W14, #0x10, W0
00A5F6  BE0210     MOV.D [W0], W4
00A5F8  90002E     MOV [W14+4], W0
00A5FA  9000BE     MOV [W14+6], W1
00A5FC  BE0100     MOV.D W0, W2
00A5FE  BE0004     MOV.D W4, W0
00A600  022C36     CALL ___mulsf3
00A602  000000     NOP
00A604  BE0100     MOV.D W0, W2
00A606  BE0008     MOV.D W8, W0
00A608  022A6C     CALL ___addsf3
00A60A  000000     NOP
00A60C  BE0400     MOV.D W0, W8
00A60E  90024E     MOV [W14+8], W4
00A610  9002DE     MOV [W14+10], W5
00A612  470070     ADD W14, #0x10, W0
00A614  9000F0     MOV [W0+14], W1
00A616  900060     MOV [W0+12], W0
00A618  BE0100     MOV.D W0, W2
00A61A  BE0004     MOV.D W4, W0
00A61C  022C36     CALL ___mulsf3
00A61E  000000     NOP
00A620  BE0100     MOV.D W0, W2
00A622  BE0008     MOV.D W8, W0
00A624  022A6C     CALL ___addsf3
00A626  000000     NOP
00A628  BE0400     MOV.D W0, W8
00A62A  90026E     MOV [W14+12], W4
00A62C  9002FE     MOV [W14+14], W5
00A62E  470070     ADD W14, #0x10, W0
00A630  9000D0     MOV [W0+10], W1
00A632  900040     MOV [W0+8], W0
00A634  BE0100     MOV.D W0, W2
00A636  BE0004     MOV.D W4, W0
00A638  022C36     CALL ___mulsf3
00A63A  000000     NOP
00A63C  BE0100     MOV.D W0, W2
00A63E  BE0008     MOV.D W8, W0
00A640  022A5A     CALL ___subsf3
00A642  000000     NOP
00A644  90112E     MOV [W14+36], W2
00A646  980120     MOV W0, [W2+4]
00A648  980131     MOV W1, [W2+6]
87:                    result->y = a.w*b.y + b.w*a.y - a.x*b.z + a.z*b.x;
00A64A  BE021E     MOV.D [W14], W4
00A64C  470070     ADD W14, #0x10, W0
00A64E  9000D0     MOV [W0+10], W1
00A650  900040     MOV [W0+8], W0
00A652  BE0100     MOV.D W0, W2
00A654  BE0004     MOV.D W4, W0
00A656  022C36     CALL ___mulsf3
00A658  000000     NOP
00A65A  BE0400     MOV.D W0, W8
00A65C  470070     ADD W14, #0x10, W0
00A65E  BE0210     MOV.D [W0], W4
00A660  90004E     MOV [W14+8], W0
00A662  9000DE     MOV [W14+10], W1
00A664  BE0100     MOV.D W0, W2
00A666  BE0004     MOV.D W4, W0
00A668  022C36     CALL ___mulsf3
00A66A  000000     NOP
00A66C  BE0100     MOV.D W0, W2
00A66E  BE0008     MOV.D W8, W0
00A670  022A6C     CALL ___addsf3
00A672  000000     NOP
00A674  BE0400     MOV.D W0, W8
00A676  90022E     MOV [W14+4], W4
00A678  9002BE     MOV [W14+6], W5
00A67A  470070     ADD W14, #0x10, W0
00A67C  9000F0     MOV [W0+14], W1
00A67E  900060     MOV [W0+12], W0
00A680  BE0100     MOV.D W0, W2
00A682  BE0004     MOV.D W4, W0
00A684  022C36     CALL ___mulsf3
00A686  000000     NOP
00A688  BE0100     MOV.D W0, W2
00A68A  BE0008     MOV.D W8, W0
00A68C  022A5A     CALL ___subsf3
00A68E  000000     NOP
00A690  BE0400     MOV.D W0, W8
00A692  90026E     MOV [W14+12], W4
00A694  9002FE     MOV [W14+14], W5
00A696  470070     ADD W14, #0x10, W0
00A698  9000B0     MOV [W0+6], W1
00A69A  900020     MOV [W0+4], W0
00A69C  BE0100     MOV.D W0, W2
00A69E  BE0004     MOV.D W4, W0
00A6A0  022C36     CALL ___mulsf3
00A6A2  000000     NOP
00A6A4  BE0100     MOV.D W0, W2
00A6A6  BE0008     MOV.D W8, W0
00A6A8  022A6C     CALL ___addsf3
00A6AA  000000     NOP
00A6AC  90112E     MOV [W14+36], W2
00A6AE  980140     MOV W0, [W2+8]
00A6B0  980151     MOV W1, [W2+10]
88:                    result->z = a.w*b.z + b.w*a.z + a.x*b.y - a.y*b.x;
00A6B2  BE021E     MOV.D [W14], W4
00A6B4  470070     ADD W14, #0x10, W0
00A6B6  9000F0     MOV [W0+14], W1
00A6B8  900060     MOV [W0+12], W0
00A6BA  BE0100     MOV.D W0, W2
00A6BC  BE0004     MOV.D W4, W0
00A6BE  022C36     CALL ___mulsf3
00A6C0  000000     NOP
00A6C2  BE0400     MOV.D W0, W8
00A6C4  470070     ADD W14, #0x10, W0
00A6C6  BE0210     MOV.D [W0], W4
00A6C8  90006E     MOV [W14+12], W0
00A6CA  9000FE     MOV [W14+14], W1
00A6CC  BE0100     MOV.D W0, W2
00A6CE  BE0004     MOV.D W4, W0
00A6D0  022C36     CALL ___mulsf3
00A6D2  000000     NOP
00A6D4  BE0100     MOV.D W0, W2
00A6D6  BE0008     MOV.D W8, W0
00A6D8  022A6C     CALL ___addsf3
00A6DA  000000     NOP
00A6DC  BE0400     MOV.D W0, W8
00A6DE  90022E     MOV [W14+4], W4
00A6E0  9002BE     MOV [W14+6], W5
00A6E2  470070     ADD W14, #0x10, W0
00A6E4  9000D0     MOV [W0+10], W1
00A6E6  900040     MOV [W0+8], W0
00A6E8  BE0100     MOV.D W0, W2
00A6EA  BE0004     MOV.D W4, W0
00A6EC  022C36     CALL ___mulsf3
00A6EE  000000     NOP
00A6F0  BE0100     MOV.D W0, W2
00A6F2  BE0008     MOV.D W8, W0
00A6F4  022A6C     CALL ___addsf3
00A6F6  000000     NOP
00A6F8  BE0400     MOV.D W0, W8
00A6FA  90024E     MOV [W14+8], W4
00A6FC  9002DE     MOV [W14+10], W5
00A6FE  470070     ADD W14, #0x10, W0
00A700  9000B0     MOV [W0+6], W1
00A702  900020     MOV [W0+4], W0
00A704  BE0100     MOV.D W0, W2
00A706  BE0004     MOV.D W4, W0
00A708  022C36     CALL ___mulsf3
00A70A  000000     NOP
00A70C  BE0100     MOV.D W0, W2
00A70E  BE0008     MOV.D W8, W0
00A710  022A5A     CALL ___subsf3
00A712  000000     NOP
00A714  90112E     MOV [W14+36], W2
00A716  980160     MOV W0, [W2+12]
00A718  980171     MOV W1, [W2+14]
00A71A  370005     BRA 0xA726
89:                
90:                }
00A726  BE044F     MOV.D [--W15], W8
00A728  FA8000     ULNK
00A72A  060000     RETURN
91:                
92:                void quatNormalize(Quaternion *a) {
00A72C  FA000A     LNK #0xA
00A72E  BE9F88     MOV.D W8, [W15++]
00A730  980740     MOV W0, [W14+8]
93:                
94:                    float square_sum, recip_norm;
95:                
96:                    if(a == NULL) { return; }
00A732  9000CE     MOV [W14+8], W1
00A734  EB0000     CLR W0
00A736  508F80     SUB W1, W0, [W15]
00A738  32006F     BRA Z, 0xA818
00A818  000000     NOP
00A81A  370001     BRA 0xA81E
97:                
98:                    square_sum = a->w*a->w + a->x*a->x + a->y*a->y + a->z*a->z;
00A73A  90004E     MOV [W14+8], W0
00A73C  BE0210     MOV.D [W0], W4
00A73E  90004E     MOV [W14+8], W0
00A740  BE0010     MOV.D [W0], W0
00A742  BE0100     MOV.D W0, W2
00A744  BE0004     MOV.D W4, W0
00A746  022C36     CALL ___mulsf3
00A748  000000     NOP
00A74A  BE0400     MOV.D W0, W8
00A74C  90004E     MOV [W14+8], W0
00A74E  900220     MOV [W0+4], W4
00A750  9002B0     MOV [W0+6], W5
00A752  90004E     MOV [W14+8], W0
00A754  9000B0     MOV [W0+6], W1
00A756  900020     MOV [W0+4], W0
00A758  BE0100     MOV.D W0, W2
00A75A  BE0004     MOV.D W4, W0
00A75C  022C36     CALL ___mulsf3
00A75E  000000     NOP
00A760  BE0100     MOV.D W0, W2
00A762  BE0008     MOV.D W8, W0
00A764  022A6C     CALL ___addsf3
00A766  000000     NOP
00A768  BE0400     MOV.D W0, W8
00A76A  90004E     MOV [W14+8], W0
00A76C  900240     MOV [W0+8], W4
00A76E  9002D0     MOV [W0+10], W5
00A770  90004E     MOV [W14+8], W0
00A772  9000D0     MOV [W0+10], W1
00A774  900040     MOV [W0+8], W0
00A776  BE0100     MOV.D W0, W2
00A778  BE0004     MOV.D W4, W0
00A77A  022C36     CALL ___mulsf3
00A77C  000000     NOP
00A77E  BE0100     MOV.D W0, W2
00A780  BE0008     MOV.D W8, W0
00A782  022A6C     CALL ___addsf3
00A784  000000     NOP
00A786  BE0400     MOV.D W0, W8
00A788  90004E     MOV [W14+8], W0
00A78A  900260     MOV [W0+12], W4
00A78C  9002F0     MOV [W0+14], W5
00A78E  90004E     MOV [W14+8], W0
00A790  9000F0     MOV [W0+14], W1
00A792  900060     MOV [W0+12], W0
00A794  BE0100     MOV.D W0, W2
00A796  BE0004     MOV.D W4, W0
00A798  022C36     CALL ___mulsf3
00A79A  000000     NOP
00A79C  BE0100     MOV.D W0, W2
00A79E  BE0008     MOV.D W8, W0
00A7A0  022A6C     CALL ___addsf3
00A7A2  000000     NOP
00A7A4  BE8F00     MOV.D W0, [W14]
99:                    if(square_sum == 1.0) { return; } // Fast return
00A7A6  200002     MOV #0x0, W2
00A7A8  23F803     MOV #0x3F80, W3
00A7AA  BE001E     MOV.D [W14], W0
00A7AC  0225A4     CALL ___lesf2
00A7AE  000000     NOP
00A7B0  EB0080     CLR W1
00A7B2  500F81     SUB W0, W1, [W15]
00A7B4  320033     BRA Z, 0xA81C
00A81C  000000     NOP
100:               
101:                   recip_norm = 1.0/sqrtf(square_sum); // Multiplication faster than division
00A7B6  BE001E     MOV.D [W14], W0
00A7B8  023050     CALL _sqrtfx
00A7BA  000000     NOP
00A7BC  BE0100     MOV.D W0, W2
00A7BE  200000     MOV #0x0, W0
00A7C0  23F801     MOV #0x3F80, W1
00A7C2  022E80     CALL ___divsf3x
00A7C4  000000     NOP
00A7C6  980720     MOV W0, [W14+4]
00A7C8  980731     MOV W1, [W14+6]
102:                   a->w = a->w*recip_norm;
00A7CA  90004E     MOV [W14+8], W0
00A7CC  BE0010     MOV.D [W0], W0
00A7CE  90012E     MOV [W14+4], W2
00A7D0  9001BE     MOV [W14+6], W3
00A7D2  022C36     CALL ___mulsf3
00A7D4  000000     NOP
00A7D6  90014E     MOV [W14+8], W2
00A7D8  BE8900     MOV.D W0, [W2]
103:                   a->x = a->x*recip_norm;
00A7DA  90004E     MOV [W14+8], W0
00A7DC  9000B0     MOV [W0+6], W1
00A7DE  900020     MOV [W0+4], W0
00A7E0  90012E     MOV [W14+4], W2
00A7E2  9001BE     MOV [W14+6], W3
00A7E4  022C36     CALL ___mulsf3
00A7E6  000000     NOP
00A7E8  90014E     MOV [W14+8], W2
00A7EA  980120     MOV W0, [W2+4]
00A7EC  980131     MOV W1, [W2+6]
104:                   a->y = a->y*recip_norm;
00A7EE  90004E     MOV [W14+8], W0
00A7F0  9000D0     MOV [W0+10], W1
00A7F2  900040     MOV [W0+8], W0
00A7F4  90012E     MOV [W14+4], W2
00A7F6  9001BE     MOV [W14+6], W3
00A7F8  022C36     CALL ___mulsf3
00A7FA  000000     NOP
00A7FC  90014E     MOV [W14+8], W2
00A7FE  980140     MOV W0, [W2+8]
00A800  980151     MOV W1, [W2+10]
105:                   a->z = a->z*recip_norm;
00A802  90004E     MOV [W14+8], W0
00A804  9000F0     MOV [W0+14], W1
00A806  900060     MOV [W0+12], W0
00A808  90012E     MOV [W14+4], W2
00A80A  9001BE     MOV [W14+6], W3
00A80C  022C36     CALL ___mulsf3
00A80E  000000     NOP
00A810  90014E     MOV [W14+8], W2
00A812  980160     MOV W0, [W2+12]
00A814  980171     MOV W1, [W2+14]
00A816  370003     BRA 0xA81E
106:               
107:               }
00A81E  BE044F     MOV.D [--W15], W8
00A820  FA8000     ULNK
00A822  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/ppool.c  ----------------------------------------------
1:                 /**
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Packet Pool
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v 0.1
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu         2012-02-04      Initial implementation
38:                 *  Humphrey Hu         2012-02-08      Restructured to allow requesting of
39:                 *                                      separate items 
40:                 *  Humphrey Hu         2012-02-13      Fixed initialization bug
41:                 *                      
42:                 * Notes:
43:                 *  
44:                 */
45:                 
46:                #include "ppool.h"
47:                #include "mac_packet.h"
48:                #include "carray.h"
49:                #include <stdlib.h>
50:                
51:                // ================ CONSTANTS =================================================
52:                
53:                #define NUM_CUTOFFS         (3)
54:                #define NUM_PACKETS         (30)
55:                #define MAX_PAYLOAD_SIZE    (117)
56:                
57:                /** Sort in ascending order
58:                 * 117 is max data size (127 - 8 - 2 for MPDU and payload headers)
59:                 */
60:                static unsigned int CUTOFFS[NUM_CUTOFFS] = {12, 86, MAX_PAYLOAD_SIZE};
61:                static unsigned int QUANTITIES[NUM_CUTOFFS] = {10, 4, 2};
62:                static unsigned char is_initialized = 0;
63:                
64:                // ================ STATIC VARIABLES ==========================================
65:                /** FastQueue object pools */
66:                static CircArray packet_pool, payload_pools[NUM_CUTOFFS];
67:                
68:                // ================ FUNCTION STUBS ============================================
69:                
70:                static inline int ppoolFindOffsetIndex(unsigned int size);
71:                
72:                // ================ PUBLIC FUNCTIONS ==========================================
73:                
74:                // Initialize the module
75:                unsigned int ppoolInit(void) {
00B83C  FA000E     LNK #0xE
76:                
77:                    unsigned int i, j;
78:                    MacPacket packet;
79:                    Payload pld;
80:                    CircArray fq;
81:                
82:                    if(is_initialized) { return 1; }
00B83E  221EE0     MOV #0x21EE, W0
00B840  784090     MOV.B [W0], W1
00B842  EB4000     CLR.B W0
00B844  50CF80     SUB.B W1, W0, [W15]
00B846  320002     BRA Z, 0xB84C
00B848  200010     MOV #0x1, W0
00B84A  370076     BRA 0xB938
83:                    
84:                    packet_pool = carrayCreate(NUM_PACKETS);
00B84C  2001E0     MOV #0x1E, W0
00B84E  028F1C     CALL carrayCreate
00B850  000000     NOP
00B852  890F80     MOV W0, packet_pool
85:                    if(packet_pool == NULL) { 
00B854  810F81     MOV packet_pool, W1
00B856  EB0000     CLR W0
00B858  508F80     SUB W1, W0, [W15]
00B85A  3A0002     BRA NZ, 0xB860
86:                        return 0; 
00B85C  EB0000     CLR W0
00B85E  37006C     BRA 0xB938
87:                    }
88:                    
89:                    for(i = 0; i < NUM_CUTOFFS; i++) {
00B860  EB0000     CLR W0
00B862  780F00     MOV W0, [W14]
00B864  370019     BRA 0xB898
00B896  E80F1E     INC [W14], [W14]
00B898  78009E     MOV [W14], W1
00B89A  200020     MOV #0x2, W0
00B89C  508F80     SUB W1, W0, [W15]
00B89E  36FFE3     BRA LEU, 0xB866
90:                        payload_pools[i] = carrayCreate(QUANTITIES[i]);
00B866  78001E     MOV [W14], W0
00B868  400080     ADD W0, W0, W1
00B86A  221DE0     MOV #0x21DE, W0
00B86C  408000     ADD W1, W0, W0
00B86E  780010     MOV [W0], W0
00B870  028F1C     CALL carrayCreate
00B872  000000     NOP
00B874  780080     MOV W0, W1
00B876  78001E     MOV [W14], W0
00B878  400100     ADD W0, W0, W2
00B87A  221F20     MOV #0x21F2, W0
00B87C  410000     ADD W2, W0, W0
00B87E  780801     MOV W1, [W0]
91:                        if(payload_pools[i] == NULL) { 
00B880  78001E     MOV [W14], W0
00B882  400080     ADD W0, W0, W1
00B884  221F20     MOV #0x21F2, W0
00B886  408000     ADD W1, W0, W0
00B888  780090     MOV [W0], W1
00B88A  EB0000     CLR W0
00B88C  508F80     SUB W1, W0, [W15]
00B88E  3A0003     BRA NZ, 0xB896
92:                            ppoolClose();
00B890  070055     RCALL ppoolClose
93:                            return 0; 
00B892  EB0000     CLR W0
00B894  370051     BRA 0xB938
94:                        }
95:                    }
96:                        
97:                    for(i = 0; i < NUM_PACKETS; i++) {
00B8A0  EB0000     CLR W0
00B8A2  780F00     MOV W0, [W14]
00B8A4  37000C     BRA 0xB8BE
00B8BC  E80F1E     INC [W14], [W14]
00B8BE  78009E     MOV [W14], W1
00B8C0  2001D0     MOV #0x1D, W0
00B8C2  508F80     SUB W1, W0, [W15]
00B8C4  36FFF0     BRA LEU, 0xB8A6
00B8C6  370001     BRA 0xB8CA
98:                        packet = macCreateDataPacket();
00B8A6  0285B4     CALL macCreateDataPacket
00B8A8  000000     NOP
00B8AA  980720     MOV W0, [W14+4]
99:                        if(packet == NULL) {
00B8AC  9000AE     MOV [W14+4], W1
00B8AE  EB0000     CLR W0
00B8B0  508F80     SUB W1, W0, [W15]
00B8B2  32000A     BRA Z, 0xB8C8
100:                           break;
00B8C8  000000     NOP
101:                       }
102:                       carrayAddHead(packet_pool, packet);
00B8B4  810F80     MOV packet_pool, W0
00B8B6  9000AE     MOV [W14+4], W1
00B8B8  02904E     CALL carrayAddHead
00B8BA  000000     NOP
103:                   }
104:                   unsigned int num, size;
105:                   for(i = 0; i < NUM_CUTOFFS; i++) {
00B8CA  EB0000     CLR W0
00B8CC  780F00     MOV W0, [W14]
00B8CE  37002C     BRA 0xB928
00B926  E80F1E     INC [W14], [W14]
00B928  78009E     MOV [W14], W1
00B92A  200020     MOV #0x2, W0
00B92C  508F80     SUB W1, W0, [W15]
00B92E  36FFD0     BRA LEU, 0xB8D0
106:                       fq = payload_pools[i];
00B8D0  78001E     MOV [W14], W0
00B8D2  400080     ADD W0, W0, W1
00B8D4  221F20     MOV #0x21F2, W0
00B8D6  408000     ADD W1, W0, W0
00B8D8  780090     MOV [W0], W1
00B8DA  980731     MOV W1, [W14+6]
107:                       num = QUANTITIES[i];
00B8DC  78001E     MOV [W14], W0
00B8DE  400080     ADD W0, W0, W1
00B8E0  221DE0     MOV #0x21DE, W0
00B8E2  408000     ADD W1, W0, W0
00B8E4  780090     MOV [W0], W1
00B8E6  980741     MOV W1, [W14+8]
108:                       size = CUTOFFS[i];
00B8E8  78001E     MOV [W14], W0
00B8EA  400080     ADD W0, W0, W1
00B8EC  221D80     MOV #0x21D8, W0
00B8EE  408000     ADD W1, W0, W0
00B8F0  780090     MOV [W0], W1
00B8F2  980751     MOV W1, [W14+10]
109:                       for(j = 0; j < num; j++) {
00B8F4  EB0000     CLR W0
00B8F6  980710     MOV W0, [W14+2]
00B8F8  370010     BRA 0xB91A
00B914  90001E     MOV [W14+2], W0
00B916  E80000     INC W0, W0
00B918  980710     MOV W0, [W14+2]
00B91A  90009E     MOV [W14+2], W1
00B91C  90004E     MOV [W14+8], W0
00B91E  508F80     SUB W1, W0, [W15]
00B920  39FFEC     BRA NC, 0xB8FA
00B922  370001     BRA 0xB926
110:                           pld = payCreateEmpty(size);
00B8FA  90005E     MOV [W14+10], W0
00B8FC  784000     MOV.B W0, W0
00B8FE  02C960     CALL payCreateEmpty
00B900  000000     NOP
00B902  980760     MOV W0, [W14+12]
111:                           if(pld == NULL) {
00B904  9000EE     MOV [W14+12], W1
00B906  EB0000     CLR W0
00B908  508F80     SUB W1, W0, [W15]
00B90A  32000C     BRA Z, 0xB924
112:                               break;
00B924  000000     NOP
113:                           }
114:                           carrayAddHead(fq, pld);
00B90C  9000EE     MOV [W14+12], W1
00B90E  90003E     MOV [W14+6], W0
00B910  02904E     CALL carrayAddHead
00B912  000000     NOP
115:                       }
116:                   }
117:                   
118:                   is_initialized = 1;
00B930  221EE1     MOV #0x21EE, W1
00B932  B3C010     MOV #0x1, W0
00B934  784880     MOV.B W0, [W1]
119:                   return 1;
00B936  200010     MOV #0x1, W0
120:                   
121:               }
00B938  FA8000     ULNK
00B93A  060000     RETURN
122:               
123:               void ppoolClose(void) {
00B93C  FA0008     LNK #0x8
124:               
125:                   unsigned int i;
126:                   MacPacket packet;
127:                   Payload pld;
128:                   CircArray fq;
129:                   
130:                   if(packet_pool != NULL) {
00B93E  810F81     MOV packet_pool, W1
00B940  EB0000     CLR W0
00B942  508F80     SUB W1, W0, [W15]
00B944  320011     BRA Z, 0xB968
131:                       while(!carrayIsEmpty(packet_pool)) {
00B946  370007     BRA 0xB956
00B956  810F80     MOV packet_pool, W0
00B958  02937A     CALL carrayIsEmpty
00B95A  000000     NOP
00B95C  EB0080     CLR W1
00B95E  500F81     SUB W0, W1, [W15]
00B960  32FFF3     BRA Z, 0xB948
132:                           packet = carrayPopTail(packet_pool);
00B948  810F80     MOV packet_pool, W0
00B94A  029102     CALL carrayPopTail
00B94C  000000     NOP
00B94E  980710     MOV W0, [W14+2]
133:                           macDeletePacket(packet);
00B950  90001E     MOV [W14+2], W0
00B952  02861E     CALL macDeletePacket
00B954  000000     NOP
134:                       }           
135:                       carrayDelete(packet_pool);
00B962  810F80     MOV packet_pool, W0
00B964  028F72     CALL carrayDelete
00B966  000000     NOP
136:                   }
137:                   
138:                   for(i = 0; i < NUM_CUTOFFS; i++) {
00B968  EB0000     CLR W0
00B96A  780F00     MOV W0, [W14]
00B96C  37001C     BRA 0xB9A6
00B9A4  E80F1E     INC [W14], [W14]
00B9A6  78009E     MOV [W14], W1
00B9A8  200020     MOV #0x2, W0
00B9AA  508F80     SUB W1, W0, [W15]
00B9AC  36FFE0     BRA LEU, 0xB96E
139:                       fq = payload_pools[i];
00B96E  78001E     MOV [W14], W0
00B970  400080     ADD W0, W0, W1
00B972  221F20     MOV #0x21F2, W0
00B974  408000     ADD W1, W0, W0
00B976  780090     MOV [W0], W1
00B978  980721     MOV W1, [W14+4]
140:                       if(fq != NULL) {
00B97A  9000AE     MOV [W14+4], W1
00B97C  EB0000     CLR W0
00B97E  508F80     SUB W1, W0, [W15]
00B980  320011     BRA Z, 0xB9A4
141:                           while(!carrayIsEmpty(fq)) {
00B982  370007     BRA 0xB992
00B992  90002E     MOV [W14+4], W0
00B994  02937A     CALL carrayIsEmpty
00B996  000000     NOP
00B998  EB0080     CLR W1
00B99A  500F81     SUB W0, W1, [W15]
00B99C  32FFF3     BRA Z, 0xB984
142:                               pld = carrayPopTail(fq);
00B984  90002E     MOV [W14+4], W0
00B986  029102     CALL carrayPopTail
00B988  000000     NOP
00B98A  980730     MOV W0, [W14+6]
143:                               payDelete(pld);
00B98C  90003E     MOV [W14+6], W0
00B98E  02CB22     CALL payDelete
00B990  000000     NOP
144:                           }
145:                           carrayDelete(fq);
00B99E  90002E     MOV [W14+4], W0
00B9A0  028F72     CALL carrayDelete
00B9A2  000000     NOP
146:                       }
147:                   }
148:                   
149:               }
00B9AE  FA8000     ULNK
00B9B0  060000     RETURN
150:               
151:               // Request a MacPacket with payload capacity of appropriate size
152:               // Note that a request is only fulfilled if there is a packet in the
153:               // smallest appropriate size category, ie. the largest packets will
154:               // never be allocated to small requests.
155:               
156:               MacPacket ppoolRequestFullPacket(unsigned int size) {
00B9B2  FA0006     LNK #0x6
00B9B4  980720     MOV W0, [W14+4]
157:               
158:                   MacPacket packet;
159:                   Payload pld;
160:               
161:                   packet = ppoolRequestPacket();
00B9B6  070019     RCALL ppoolRequestPacket
00B9B8  780F00     MOV W0, [W14]
162:                   if(packet == NULL) { return NULL; }
00B9BA  78009E     MOV [W14], W1
00B9BC  EB0000     CLR W0
00B9BE  508F80     SUB W1, W0, [W15]
00B9C0  3A0002     BRA NZ, 0xB9C6
00B9C2  EB0000     CLR W0
00B9C4  370010     BRA 0xB9E6
163:                   
164:                   pld = ppoolRequestPayload(size); 
00B9C6  90002E     MOV [W14+4], W0
00B9C8  07001E     RCALL ppoolRequestPayload
00B9CA  980710     MOV W0, [W14+2]
165:                   if(pld == NULL) {
00B9CC  90009E     MOV [W14+2], W1
00B9CE  EB0000     CLR W0
00B9D0  508F80     SUB W1, W0, [W15]
00B9D2  3A0004     BRA NZ, 0xB9DC
166:                       // Assume that we don't have to check the return value
167:                       ppoolReturnPacket(packet);        
00B9D4  78001E     MOV [W14], W0
00B9D6  07005C     RCALL ppoolReturnPacket
168:                       return NULL;
00B9D8  EB0000     CLR W0
00B9DA  370005     BRA 0xB9E6
169:                   }
170:                   
171:                   macSetPayload(packet, pld);
00B9DC  90009E     MOV [W14+2], W1
00B9DE  78001E     MOV [W14], W0
00B9E0  0286CC     CALL macSetPayload
00B9E2  000000     NOP
172:               
173:                   return packet;
00B9E4  78001E     MOV [W14], W0
174:                   
175:               }
00B9E6  FA8000     ULNK
00B9E8  060000     RETURN
176:               
177:               MacPacket ppoolRequestPacket(void) {
00B9EA  FA0002     LNK #0x2
178:                   
179:                   MacPacket packet;
180:                   
181:                   packet = (MacPacket) carrayPopTail(packet_pool);    // Get a packet
00B9EC  810F80     MOV packet_pool, W0
00B9EE  029102     CALL carrayPopTail
00B9F0  000000     NOP
00B9F2  780F00     MOV W0, [W14]
182:                   if(packet == NULL) {    // Check for failure
00B9F4  78009E     MOV [W14], W1
00B9F6  EB0000     CLR W0
00B9F8  508F80     SUB W1, W0, [W15]
00B9FA  3A0002     BRA NZ, 0xBA00
183:                       return NULL;
00B9FC  EB0000     CLR W0
00B9FE  370001     BRA 0xBA02
184:                   }
185:                   
186:                   return packet;
00BA00  78001E     MOV [W14], W0
187:               
188:               }
00BA02  FA8000     ULNK
00BA04  060000     RETURN
189:               
190:               Payload ppoolRequestPayload(unsigned int size) {
00BA06  FA0008     LNK #0x8
00BA08  980730     MOV W0, [W14+6]
191:               
192:                   int index;
193:                   Payload pld;
194:                   CircArray payq;
195:                   
196:                   index = ppoolFindOffsetIndex(size);
00BA0A  90003E     MOV [W14+6], W0
00BA0C  070075     RCALL ppoolFindOffsetIndex
00BA0E  780F00     MOV W0, [W14]
197:                   if(index < 0) {
00BA10  78009E     MOV [W14], W1
00BA12  EB0000     CLR W0
00BA14  508F80     SUB W1, W0, [W15]
00BA16  3D0002     BRA GE, 0xBA1C
198:                       return NULL;
00BA18  EB0000     CLR W0
00BA1A  370015     BRA 0xBA46
199:                   }
200:                   
201:                   payq = payload_pools[index]; // Retrieve appropriate payload pool
00BA1C  78001E     MOV [W14], W0
00BA1E  400080     ADD W0, W0, W1
00BA20  221F20     MOV #0x21F2, W0
00BA22  408000     ADD W1, W0, W0
00BA24  780090     MOV [W0], W1
00BA26  980711     MOV W1, [W14+2]
202:                   pld = (Payload) carrayPopTail(payq);  // Get a payload
00BA28  90001E     MOV [W14+2], W0
00BA2A  029102     CALL carrayPopTail
00BA2C  000000     NOP
00BA2E  980720     MOV W0, [W14+4]
203:                   if(pld == NULL) {   // Check for failure
00BA30  9000AE     MOV [W14+4], W1
00BA32  EB0000     CLR W0
00BA34  508F80     SUB W1, W0, [W15]
00BA36  3A0002     BRA NZ, 0xBA3C
204:                       return NULL;
00BA38  EB0000     CLR W0
00BA3A  370005     BRA 0xBA46
205:                   }
206:                   pld->data_length = size;
00BA3C  90003E     MOV [W14+6], W0
00BA3E  784000     MOV.B W0, W0
00BA40  9000AE     MOV [W14+4], W1
00BA42  784880     MOV.B W0, [W1]
207:                   return pld;
00BA44  90002E     MOV [W14+4], W0
208:               
209:               }
00BA46  FA8000     ULNK
00BA48  060000     RETURN
210:               
211:               // Return a combined packet + payload to the pool
212:               unsigned int ppoolReturnFullPacket(MacPacket packet) {
00BA4A  FA0004     LNK #0x4
00BA4C  980710     MOV W0, [W14+2]
213:               
214:                   Payload pld;
215:               
216:                   if(packet == NULL) { return 0; }    // Don't deal with damaged returns
00BA4E  90009E     MOV [W14+2], W1
00BA50  EB0000     CLR W0
00BA52  508F80     SUB W1, W0, [W15]
00BA54  3A0002     BRA NZ, 0xBA5A
00BA56  EB0000     CLR W0
00BA58  370019     BRA 0xBA8C
217:                   pld = macGetPayload(packet);
00BA5A  90001E     MOV [W14+2], W0
00BA5C  0286E6     CALL macGetPayload
00BA5E  000000     NOP
00BA60  780F00     MOV W0, [W14]
218:                   if(pld == NULL) { return 0; }
00BA62  78009E     MOV [W14], W1
00BA64  EB0000     CLR W0
00BA66  508F80     SUB W1, W0, [W15]
00BA68  3A0002     BRA NZ, 0xBA6E
00BA6A  EB0000     CLR W0
00BA6C  37000F     BRA 0xBA8C
219:                   
220:                   if(!ppoolReturnPayload(pld)) {    // Try to return packet
00BA6E  78001E     MOV [W14], W0
00BA70  07001D     RCALL ppoolReturnPayload
00BA72  EB0080     CLR W1
00BA74  500F81     SUB W0, W1, [W15]
00BA76  3A0002     BRA NZ, 0xBA7C
221:                       return 0;   // Check for failure
00BA78  EB0000     CLR W0
00BA7A  370008     BRA 0xBA8C
222:                   }
223:                   if(!ppoolReturnPacket(packet)) {  // Try to return payload
00BA7C  90001E     MOV [W14+2], W0
00BA7E  070008     RCALL ppoolReturnPacket
00BA80  EB0080     CLR W1
00BA82  500F81     SUB W0, W1, [W15]
00BA84  3A0002     BRA NZ, 0xBA8A
224:                       return 0;   // Sort of screwed since we already returned packet...oh well
00BA86  EB0000     CLR W0
00BA88  370001     BRA 0xBA8C
225:                   }    
226:                   return 1;
00BA8A  200010     MOV #0x1, W0
227:                   
228:               }
00BA8C  FA8000     ULNK
00BA8E  060000     RETURN
229:               
230:               unsigned int ppoolReturnPacket(MacPacket packet) {
00BA90  FA0002     LNK #0x2
00BA92  780F00     MOV W0, [W14]
231:               
232:                   if(!carrayAddTail(packet_pool, packet)) {
00BA94  810F80     MOV packet_pool, W0
00BA96  78009E     MOV [W14], W1
00BA98  028F9A     CALL carrayAddTail
00BA9A  000000     NOP
00BA9C  EB0080     CLR W1
00BA9E  500F81     SUB W0, W1, [W15]
00BAA0  3A0002     BRA NZ, 0xBAA6
233:                       return 0;   // Check for failure
00BAA2  EB0000     CLR W0
00BAA4  370001     BRA 0xBAA8
234:                   }
235:                   return 1;
00BAA6  200010     MOV #0x1, W0
236:               
237:               }
00BAA8  FA8000     ULNK
00BAAA  060000     RETURN
238:               
239:               unsigned int ppoolReturnPayload(Payload pld) {
00BAAC  FA0006     LNK #0x6
00BAAE  980720     MOV W0, [W14+4]
240:               
241:                   CircArray fq;
242:                   int index;
243:               
244:                   if(pld == NULL) { return 0; }   // Can't return NULLs
00BAB0  9000AE     MOV [W14+4], W1
00BAB2  EB0000     CLR W0
00BAB4  508F80     SUB W1, W0, [W15]
00BAB6  3A0002     BRA NZ, 0xBABC
00BAB8  EB0000     CLR W0
00BABA  37001C     BRA 0xBAF4
245:               
246:                   index = ppoolFindOffsetIndex(payGetDataLength(pld));
00BABC  90002E     MOV [W14+4], W0
00BABE  02CAD2     CALL payGetDataLength
00BAC0  000000     NOP
00BAC2  FB8000     ZE W0, W0
00BAC4  070019     RCALL ppoolFindOffsetIndex
00BAC6  780F00     MOV W0, [W14]
247:                   if(index < 0) { return 0; }     // Invalid payload size
00BAC8  78009E     MOV [W14], W1
00BACA  EB0000     CLR W0
00BACC  508F80     SUB W1, W0, [W15]
00BACE  3D0002     BRA GE, 0xBAD4
00BAD0  EB0000     CLR W0
00BAD2  370010     BRA 0xBAF4
248:                   
249:                   fq = payload_pools[index];
00BAD4  78001E     MOV [W14], W0
00BAD6  400080     ADD W0, W0, W1
00BAD8  221F20     MOV #0x21F2, W0
00BADA  408000     ADD W1, W0, W0
00BADC  780090     MOV [W0], W1
00BADE  980711     MOV W1, [W14+2]
250:                   if(!carrayAddTail(fq, pld)) {
00BAE0  9000AE     MOV [W14+4], W1
00BAE2  90001E     MOV [W14+2], W0
00BAE4  028F9A     CALL carrayAddTail
00BAE6  000000     NOP
00BAE8  EB0080     CLR W1
00BAEA  500F81     SUB W0, W1, [W15]
00BAEC  3A0002     BRA NZ, 0xBAF2
251:                       return 0;   // Check for failure
00BAEE  EB0000     CLR W0
00BAF0  370001     BRA 0xBAF4
252:                   }
253:                   return 1;
00BAF2  200010     MOV #0x1, W0
254:                   
255:               }
00BAF4  FA8000     ULNK
00BAF6  060000     RETURN
256:               
257:               // ================ PRIVATE FUNCTIONS =========================================
258:               /**
259:                * Finds the index corresponding to a payload size
260:                *
261:                * @param size Payload size to search for
262:                * @return int -1 if not found, otherwise index corresponding to payload
263:                */
264:               static inline int ppoolFindOffsetIndex(unsigned int size) {
00BAF8  FA0004     LNK #0x4
00BAFA  980710     MOV W0, [W14+2]
265:                   int i;
266:                   for(i = 0; i < NUM_CUTOFFS; i++) {
00BAFC  EB0000     CLR W0
00BAFE  780F00     MOV W0, [W14]
00BB00  37000B     BRA 0xBB18
00BB16  E80F1E     INC [W14], [W14]
00BB18  78009E     MOV [W14], W1
00BB1A  200020     MOV #0x2, W0
00BB1C  508F80     SUB W1, W0, [W15]
00BB1E  34FFF1     BRA LE, 0xBB02
267:                       if(CUTOFFS[i] >= size) {
00BB02  78001E     MOV [W14], W0
00BB04  400080     ADD W0, W0, W1
00BB06  221D80     MOV #0x21D8, W0
00BB08  408000     ADD W1, W0, W0
00BB0A  780090     MOV [W0], W1
00BB0C  90001E     MOV [W14+2], W0
00BB0E  508F80     SUB W1, W0, [W15]
00BB10  390002     BRA NC, 0xBB16
268:                           return i;
00BB12  78001E     MOV [W14], W0
00BB14  370006     BRA 0xBB22
269:                       }
270:                   }
271:                   return -1;
00BB20  EB8000     SETM W0
272:                   
273:               }
00BB22  FA8000     ULNK
00BB24  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/pid.c  ------------------------------------------------
1:                 /*
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Generalized integer PID module
31:                 *
32:                 * by Andrew Pullin
33:                 *
34:                 * v.0.1
35:                 *
36:                 * Revisions:
37:                 *  Andrew Pullin    2012-06-03    Initial release
38:                 *
39:                 * Notes:
40:                 *  - For DSP hardware PID, the user MUST set the abcCoeffs and controlHists
41:                 *    pointers for the dspPID variable. Those arrays are declared in special
42:                 *    X and Y section memory, and cannot be allocated dynamically.
43:                 */
44:                
45:                #include "pid.h"
46:                #include "pid_hw.h"
47:                #include <stdlib.h> // for malloc
48:                
49:                
50:                #define ABS(my_val) ((my_val) < 0) ? -(my_val) : (my_val)
51:                
52:                //This is an option to force the PID outputs back to zero when there is no input.
53:                //This was an attempt to stop bugs w/ motor twitching, or controller wandering.
54:                //It may not be needed anymore.
55:                #define PID_ZEROING_ENABLE 1
56:                
57:                //Default gains
58:                #ifdef PID_SOFTWARE
59:                #define SOFT_GAIN_SCALER 512
60:                #elif defined PID_HARDWARE
61:                #include <dsp.h>
62:                #define MOTOR_PID_SCALER 32
63:                #endif
64:                
65:                #define FF_SCALER 1024;
66:                
67:                //////////////////////////
68:                
69:                void pidUpdate(pidObj *pid, int feedback) {
00D0B2  FA0008     LNK #0x8
00D0B4  980720     MOV W0, [W14+4]
00D0B6  980731     MOV W1, [W14+6]
70:                    pid->error = pid->input - feedback;
00D0B8  90002E     MOV [W14+4], W0
00D0BA  780090     MOV [W0], W1
00D0BC  90003E     MOV [W14+6], W0
00D0BE  508000     SUB W1, W0, W0
00D0C0  DE80CF     ASR W0, #15, W1
00D0C2  90012E     MOV [W14+4], W2
00D0C4  981140     MOV W0, [W2+40]
00D0C6  981151     MOV W1, [W2+42]
71:                #ifdef PID_SOFTWARE
72:                    pid->p = (long) pid->Kp * pid->error;
73:                    pid->i = (long) pid->Ki * pid->iState;
74:                    //Filtered derivative action applied directly to measurement
75:                    pid->d = ((long) pid->Kd * (long) pid->d * (long) SOFT_GAIN_SCALER) /
76:                             ((long) pid->Kd + (long) pid->Kp * (long) pid->N) -
77:                             ((long) pid->Kd * (long) pid->Kp * (long) pid->N *
78:                             ((long) feedback - (long) pid->y_old)) / ((long) pid->Kd +
79:                             (long) pid->Kp * (long) pid->N);
80:                
81:                    pid->preSat = ((pid->p + pid->i + pid->d) * (long) pid->maxVal) /
82:                            ((long) SOFT_GAIN_SCALER * (long)(pid->inputOffset));
83:                
84:                    pid->iState += (long)(pid->error) + (long) (pid->Kaw) *
85:                                   ((long) (pid->output) - (long) (pid->preSat)) /
86:                                   ((long) SOFT_GAIN_SCALER);
87:                    pid->y_old = feedback;
88:                
89:                #elif defined PID_HARDWARE
90:                    pid->dspPID.controlReference = pid->input;
91:                    pid->preSat = pidHWRun(&(pid->dspPID), feedback); //Do PID calculate via DSP lib
92:                #endif
93:                
94:                    //Feedforward term
95:                    long fftemp = (long)(pid->Kff)*(long)(pid->input);
00D0C8  90002E     MOV [W14+4], W0
00D0CA  901830     MOV [W0+54], W0
00D0CC  B90161     MUL.SU W0, #1, W2
00D0CE  90002E     MOV [W14+4], W0
00D0D0  780010     MOV [W0], W0
00D0D2  DE80CF     ASR W0, #15, W1
00D0D4  B99A00     MUL.SS W3, W0, W4
00D0D6  780204     MOV W4, W4
00D0D8  B98B02     MUL.SS W1, W2, W6
00D0DA  780286     MOV W6, W5
00D0DC  420205     ADD W4, W5, W4
00D0DE  B81000     MUL.UU W2, W0, W0
00D0E0  420201     ADD W4, W1, W4
00D0E2  780084     MOV W4, W1
00D0E4  BE8F00     MOV.D W0, [W14]
00D0E6  BE8F00     MOV.D W0, [W14]
96:                    fftemp = fftemp / (long)FF_SCALER;
00D0E8  BE001E     MOV.D [W14], W0
00D0EA  B81160     MUL.UU W2, #0, W2
00D0EC  500F82     SUB W0, W2, [W15]
00D0EE  588F83     SUBB W1, W3, [W15]
00D0F0  3D0004     BRA GE, 0xD0FA
00D0F2  203FF2     MOV #0x3FF, W2
00D0F4  200003     MOV #0x0, W3
00D0F6  410000     ADD W2, W0, W0
00D0F8  498081     ADDC W3, W1, W1
00D0FA  DD0946     SL W1, #6, W2
00D0FC  DE004A     LSR W0, #10, W0
00D0FE  710000     IOR W2, W0, W0
00D100  DE88CA     ASR W1, #10, W1
00D102  BE8F00     MOV.D W0, [W14]
97:                    pid->preSat += fftemp;
00D104  90002E     MOV [W14+4], W0
00D106  9000E0     MOV [W0+12], W1
00D108  900050     MOV [W0+10], W0
00D10A  40013E     ADD W0, [W14++], W2
00D10C  4881AE     ADDC W1, [W14--], W3
00D10E  BE0002     MOV.D W2, W0
00D110  90012E     MOV [W14+4], W2
00D112  980150     MOV W0, [W2+10]
00D114  980161     MOV W1, [W2+12]
98:                
99:                    if (pid->preSat  >  pid->satValPos) {
00D116  90002E     MOV [W14+4], W0
00D118  900150     MOV [W0+10], W2
00D11A  9001E0     MOV [W0+12], W3
00D11C  90002E     MOV [W14+4], W0
00D11E  901860     MOV [W0+60], W0
00D120  DE80CF     ASR W0, #15, W1
00D122  510F80     SUB W2, W0, [W15]
00D124  598F81     SUBB W3, W1, [W15]
00D126  340005     BRA LE, 0xD132
100:                       pid->output = pid->satValPos;
00D128  90002E     MOV [W14+4], W0
00D12A  9018E0     MOV [W0+60], W1
00D12C  90002E     MOV [W14+4], W0
00D12E  981021     MOV W1, [W0+36]
00D130  370014     BRA 0xD15A
101:                   }
102:                   else if (pid->preSat  <  pid->satValNeg) {
00D132  90002E     MOV [W14+4], W0
00D134  900150     MOV [W0+10], W2
00D136  9001E0     MOV [W0+12], W3
00D138  90002E     MOV [W14+4], W0
00D13A  901870     MOV [W0+62], W0
00D13C  DE80CF     ASR W0, #15, W1
00D13E  510F80     SUB W2, W0, [W15]
00D140  598F81     SUBB W3, W1, [W15]
00D142  3D0005     BRA GE, 0xD14E
103:                       pid->output = pid->satValNeg;
00D144  90002E     MOV [W14+4], W0
00D146  9018F0     MOV [W0+62], W1
00D148  90002E     MOV [W14+4], W0
00D14A  981021     MOV W1, [W0+36]
00D14C  370006     BRA 0xD15A
104:                   }
105:                   else {
106:                       pid->output = pid->preSat;
00D14E  90002E     MOV [W14+4], W0
00D150  9000E0     MOV [W0+12], W1
00D152  900050     MOV [W0+10], W0
00D154  780080     MOV W0, W1
00D156  90002E     MOV [W14+4], W0
00D158  981021     MOV W1, [W0+36]
107:                   }
108:               }
00D15A  FA8000     ULNK
00D15C  060000     RETURN
109:               
110:               void pidInitPIDObj(pidObj* pid, int Kp, int Ki, int Kd, int Kaw, int Kff) {
00D15E  FA000C     LNK #0xC
00D160  780F00     MOV W0, [W14]
00D162  980711     MOV W1, [W14+2]
00D164  980722     MOV W2, [W14+4]
00D166  980733     MOV W3, [W14+6]
00D168  980744     MOV W4, [W14+8]
00D16A  980755     MOV W5, [W14+10]
111:                   pid->input = 0;
00D16C  78001E     MOV [W14], W0
00D16E  EB0080     CLR W1
00D170  780801     MOV W1, [W0]
112:                   pid->dState = 0;
00D172  78011E     MOV [W14], W2
00D174  B80060     MUL.UU W0, #0, W0
00D176  980110     MOV W0, [W2+2]
00D178  980121     MOV W1, [W2+4]
113:                   pid->iState = 0;
00D17A  78011E     MOV [W14], W2
00D17C  B80060     MUL.UU W0, #0, W0
00D17E  980130     MOV W0, [W2+6]
00D180  980141     MOV W1, [W2+8]
114:                   pid->output = 0;
00D182  78001E     MOV [W14], W0
00D184  EB0080     CLR W1
00D186  981021     MOV W1, [W0+36]
115:                   pid->y_old = 0;
00D188  78001E     MOV [W14], W0
00D18A  EB0080     CLR W1
00D18C  981011     MOV W1, [W0+34]
116:                   pid->p = 0;
00D18E  78011E     MOV [W14], W2
00D190  B80060     MUL.UU W0, #0, W0
00D192  980170     MOV W0, [W2+14]
00D194  980901     MOV W1, [W2+16]
117:                   pid->i = 0;
00D196  78011E     MOV [W14], W2
00D198  B80060     MUL.UU W0, #0, W0
00D19A  980910     MOV W0, [W2+18]
00D19C  980921     MOV W1, [W2+20]
118:                   pid->d = 0;
00D19E  78011E     MOV [W14], W2
00D1A0  B80060     MUL.UU W0, #0, W0
00D1A2  980930     MOV W0, [W2+22]
00D1A4  980941     MOV W1, [W2+24]
119:                   //This is just a guess for the derivative filter time constant
120:                   pid->N = 5;
00D1A6  78009E     MOV [W14], W1
00D1A8  B3C050     MOV #0x5, W0
00D1AA  9860E0     MOV.B W0, [W1+38]
121:                   pid->Kp = Kp;
00D1AC  78001E     MOV [W14], W0
00D1AE  90009E     MOV [W14+2], W1
00D1B0  980851     MOV W1, [W0+26]
122:                   pid->Ki = Ki;
00D1B2  78001E     MOV [W14], W0
00D1B4  9000AE     MOV [W14+4], W1
00D1B6  980861     MOV W1, [W0+28]
123:                   pid->Kd = Kd;
00D1B8  78001E     MOV [W14], W0
00D1BA  9000BE     MOV [W14+6], W1
00D1BC  980871     MOV W1, [W0+30]
124:                   pid->Kaw = Kaw;
00D1BE  78001E     MOV [W14], W0
00D1C0  9000CE     MOV [W14+8], W1
00D1C2  981001     MOV W1, [W0+32]
125:                   pid->Kff = Kff;
00D1C4  78001E     MOV [W14], W0
00D1C6  9000DE     MOV [W14+10], W1
00D1C8  981831     MOV W1, [W0+54]
126:                   pid->onoff = PID_OFF;
00D1CA  78009E     MOV [W14], W1
00D1CC  EB4000     CLR.B W0
00D1CE  9860F0     MOV.B W0, [W1+39]
127:                   pid->error = 0;
00D1D0  78011E     MOV [W14], W2
00D1D2  B80060     MUL.UU W0, #0, W0
00D1D4  981140     MOV W0, [W2+40]
00D1D6  981151     MOV W1, [W2+42]
128:               #ifdef PID_HARDWARE
129:                   pidHWSetFracCoeffs(&(pid->dspPID), pid->Kp, pid->Ki, pid->Kd);
130:                   if((pid->dspPID.abcCoefficients != NULL) &&
131:                           (pid->dspPID.controlHistory != NULL) ){
132:                       PIDInit(&(pid->dspPID));
133:                   }
134:               #endif
135:               }
00D1D8  FA8000     ULNK
00D1DA  060000     RETURN
136:               
137:               void pidSetInput(pidObj* pid, int input_val) {
00D1DC  FA0004     LNK #0x4
00D1DE  780F00     MOV W0, [W14]
00D1E0  980711     MOV W1, [W14+2]
138:                   pid->input = input_val;
00D1E2  78001E     MOV [W14], W0
00D1E4  90009E     MOV [W14+2], W1
00D1E6  780801     MOV W1, [W0]
139:                   //zero out running PID values
140:                   pid->iState = 0;
00D1E8  78011E     MOV [W14], W2
00D1EA  B80060     MUL.UU W0, #0, W0
00D1EC  980130     MOV W0, [W2+6]
00D1EE  980141     MOV W1, [W2+8]
141:                   pid->dState = 0;
00D1F0  78011E     MOV [W14], W2
00D1F2  B80060     MUL.UU W0, #0, W0
00D1F4  980110     MOV W0, [W2+2]
00D1F6  980121     MOV W1, [W2+4]
142:                   pid->p = 0;
00D1F8  78011E     MOV [W14], W2
00D1FA  B80060     MUL.UU W0, #0, W0
00D1FC  980170     MOV W0, [W2+14]
00D1FE  980901     MOV W1, [W2+16]
143:                   pid->i = 0;
00D200  78011E     MOV [W14], W2
00D202  B80060     MUL.UU W0, #0, W0
00D204  980910     MOV W0, [W2+18]
00D206  980921     MOV W1, [W2+20]
144:                   pid->d = 0;
00D208  78011E     MOV [W14], W2
00D20A  B80060     MUL.UU W0, #0, W0
00D20C  980930     MOV W0, [W2+22]
00D20E  980941     MOV W1, [W2+24]
145:                   //Seed the IIR filter; (TODO)
146:                   pid->y_old = input_val;
00D210  78001E     MOV [W14], W0
00D212  90009E     MOV [W14+2], W1
00D214  981011     MOV W1, [W0+34]
147:               }
00D216  FA8000     ULNK
00D218  060000     RETURN
148:               
149:               void pidSetGains(pidObj* pid, int Kp, int Ki, int Kd, int Kaw, int Kff) {
00D21A  FA000C     LNK #0xC
00D21C  780F00     MOV W0, [W14]
00D21E  980711     MOV W1, [W14+2]
00D220  980722     MOV W2, [W14+4]
00D222  980733     MOV W3, [W14+6]
00D224  980744     MOV W4, [W14+8]
00D226  980755     MOV W5, [W14+10]
150:                   //Gains to our pidObj are always set
151:                   pid->Kp = Kp;
00D228  78001E     MOV [W14], W0
00D22A  90009E     MOV [W14+2], W1
00D22C  980851     MOV W1, [W0+26]
152:                   pid->Ki = Ki;
00D22E  78001E     MOV [W14], W0
00D230  9000AE     MOV [W14+4], W1
00D232  980861     MOV W1, [W0+28]
153:                   pid->Kd = Kd;
00D234  78001E     MOV [W14], W0
00D236  9000BE     MOV [W14+6], W1
00D238  980871     MOV W1, [W0+30]
154:                   pid->Kaw = Kaw;
00D23A  78001E     MOV [W14], W0
00D23C  9000CE     MOV [W14+8], W1
00D23E  981001     MOV W1, [W0+32]
155:                   pid->Kff = Kff;
00D240  78001E     MOV [W14], W0
00D242  9000DE     MOV [W14+10], W1
00D244  981831     MOV W1, [W0+54]
156:               
157:                   //If we are using the DSP core PID, we need to recalculate gain coeffs
158:               #ifdef PID_HARDWARE
159:                   //Gains are retrieved from the PID container object,
160:                   //and need special setup for the DSP type PID calculation
161:                   pidHWSetFracCoeffs(&(pid->dspPID), pid->Kp, pid->Ki, pid->Kd);
162:               #endif
163:               }
00D246  FA8000     ULNK
00D248  060000     RETURN
164:               
165:               void pidOnOff(pidObj *pid, unsigned char state){
00D24A  FA0004     LNK #0x4
00D24C  780F00     MOV W0, [W14]
00D24E  984721     MOV.B W1, [W14+2]
166:                   pid->onoff = state;
00D250  90402E     MOV.B [W14+2], W0
00D252  78009E     MOV [W14], W1
00D254  9860F0     MOV.B W0, [W1+39]
167:               }
00D256  FA8000     ULNK
00D258  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/payload_queue.c  --------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Queue (FIFO) for Payload
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-08-03     Initial release
38:                 *                      
39:                 * Notes:
40:                 *
41:                 */
42:                
43:                #include "queue.h"
44:                #include "payload_queue.h"
45:                #include "payload.h"
46:                #include "p33Fxxxx.h"
47:                #include <stdio.h>      // for NULL
48:                #include <stdlib.h>     // for malloc
49:                
50:                
51:                /*-----------------------------------------------------------------------------
52:                 *          Public functions
53:                -----------------------------------------------------------------------------*/
54:                
55:                PayQueue pqInit(int max_size) {
00E0A2  FA0004     LNK #0x4
00E0A4  980710     MOV W0, [W14+2]
56:                    Queue pq = queueInit(max_size);
00E0A6  90001E     MOV [W14+2], W0
00E0A8  02BB26     CALL queueInit
00E0AA  000000     NOP
00E0AC  780F00     MOV W0, [W14]
57:                    return pq;
00E0AE  78001E     MOV [W14], W0
58:                }
00E0B0  FA8000     ULNK
00E0B2  060000     RETURN
59:                
60:                void pqPush(PayQueue pq, Payload pld) {
00E0B4  FA0006     LNK #0x6
00E0B6  980710     MOV W0, [W14+2]
00E0B8  980721     MOV W1, [W14+4]
61:                
62:                    Payload pay;
63:                
64:                    if (queueIsFull(pq)) {
00E0BA  90001E     MOV [W14+2], W0
00E0BC  02BDA2     CALL queueIsFull
00E0BE  000000     NOP
00E0C0  EB0080     CLR W1
00E0C2  500F81     SUB W0, W1, [W15]
00E0C4  320007     BRA Z, 0xE0D4
65:                        pay = (Payload)queuePop(pq);
00E0C6  90001E     MOV [W14+2], W0
00E0C8  02BCDC     CALL queuePop
00E0CA  000000     NOP
00E0CC  780F00     MOV W0, [W14]
66:                        payDelete(pay);
00E0CE  78001E     MOV [W14], W0
00E0D0  02CB22     CALL payDelete
00E0D2  000000     NOP
67:                    }
68:                
69:                    queueAppend(pq, pld);
00E0D4  9000AE     MOV [W14+4], W1
00E0D6  90001E     MOV [W14+2], W0
00E0D8  02BBFC     CALL queueAppend
00E0DA  000000     NOP
70:                
71:                }
00E0DC  FA8000     ULNK
00E0DE  060000     RETURN
72:                
73:                Payload pqPop(PayQueue queue) {
00E0E0  FA0002     LNK #0x2
00E0E2  780F00     MOV W0, [W14]
74:                    return (Payload)queuePop(queue);
00E0E4  78001E     MOV [W14], W0
00E0E6  02BCDC     CALL queuePop
00E0E8  000000     NOP
75:                }
00E0EA  FA8000     ULNK
00E0EC  060000     RETURN
76:                
77:                int pqIsFull(PayQueue queue) {
00E0EE  FA0002     LNK #0x2
00E0F0  780F00     MOV W0, [W14]
78:                    return queueIsFull(queue);
00E0F2  78001E     MOV [W14], W0
00E0F4  02BDA2     CALL queueIsFull
00E0F6  000000     NOP
79:                }
00E0F8  FA8000     ULNK
00E0FA  060000     RETURN
80:                
81:                int pqIsEmpty(PayQueue queue) {
00E0FC  FA0002     LNK #0x2
00E0FE  780F00     MOV W0, [W14]
82:                    return queueIsEmpty(queue);
00E100  78001E     MOV [W14], W0
00E102  02BDC8     CALL queueIsEmpty
00E104  000000     NOP
83:                }
00E106  FA8000     ULNK
00E108  060000     RETURN
84:                
85:                
86:                int pqGetSize(PayQueue queue) {
00E10A  FA0002     LNK #0x2
00E10C  780F00     MOV W0, [W14]
87:                    return queueGetSize(queue);
00E10E  78001E     MOV [W14], W0
00E110  02BDDE     CALL queueGetSize
00E112  000000     NOP
88:                }
00E114  FA8000     ULNK
00E116  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/payload.c  --------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Payload
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-06-05    Initial release
38:                 *                      
39:                 * Notes:
40:                 */
41:                
42:                #include "payload.h"
43:                #include "utils.h"
44:                #include <stdlib.h>     // for malloc
45:                #include <stdarg.h>     // variable number of arguments
46:                
47:                #define STATUS_POS              0
48:                #define TYPE_POS                1
49:                
50:                Payload payCreate(unsigned char data_length, unsigned char *data,
51:                                  unsigned char status, unsigned char type) {
00C934  FA0008     LNK #0x8
00C936  984720     MOV.B W0, [W14+2]
00C938  980721     MOV W1, [W14+4]
00C93A  984762     MOV.B W2, [W14+6]
00C93C  984773     MOV.B W3, [W14+7]
52:                
53:                    Payload pld = payCreateEmpty(data_length);
00C93E  90402E     MOV.B [W14+2], W0
00C940  07000F     RCALL payCreateEmpty
00C942  780F00     MOV W0, [W14]
54:                    paySetStatus(pld, status);
00C944  9040EE     MOV.B [W14+6], W1
00C946  78001E     MOV [W14], W0
00C948  0700DC     RCALL paySetStatus
55:                    paySetType(pld, type);
00C94A  9040FE     MOV.B [W14+7], W1
00C94C  78001E     MOV [W14], W0
00C94E  0700C7     RCALL paySetType
56:                    payAppendData(pld, 0, data_length, data);
00C950  9001AE     MOV [W14+4], W3
00C952  90412E     MOV.B [W14+2], W2
00C954  EB4080     CLR.B W1
00C956  78001E     MOV [W14], W0
00C958  070073     RCALL payAppendData
57:                    return pld;
00C95A  78001E     MOV [W14], W0
58:                }
00C95C  FA8000     ULNK
00C95E  060000     RETURN
59:                
60:                
61:                Payload payCreateEmpty(unsigned char data_length){
00C960  FA0006     LNK #0x6
00C962  984740     MOV.B W0, [W14+4]
62:                    Payload pld = (Payload)malloc(sizeof(PayloadStruct));
00C964  200060     MOV #0x6, W0
00C966  0233BA     CALL _malloc
00C968  000000     NOP
00C96A  780F00     MOV W0, [W14]
63:                	if(pld == NULL) {
00C96C  78009E     MOV [W14], W1
00C96E  EB0000     CLR W0
00C970  508F80     SUB W1, W0, [W15]
00C972  3A0002     BRA NZ, 0xC978
64:                		return NULL;
00C974  EB0000     CLR W0
00C976  370019     BRA 0xC9AA
65:                	}
66:                    
67:                    unsigned char* data = (unsigned char*)malloc(data_length + PAYLOAD_HEADER_LENGTH);
00C978  90404E     MOV.B [W14+4], W0
00C97A  FB8000     ZE W0, W0
00C97C  E88000     INC2 W0, W0
00C97E  0233BA     CALL _malloc
00C980  000000     NOP
00C982  980710     MOV W0, [W14+2]
68:                	if(data == NULL) {
00C984  90009E     MOV [W14+2], W1
00C986  EB0000     CLR W0
00C988  508F80     SUB W1, W0, [W15]
00C98A  3A0005     BRA NZ, 0xC996
69:                		free(pld);
00C98C  78001E     MOV [W14], W0
00C98E  0234EC     CALL _free
00C990  000000     NOP
70:                		return NULL;
00C992  EB0000     CLR W0
00C994  37000A     BRA 0xC9AA
71:                	}
72:                    pld->pld_data = data;
00C996  78001E     MOV [W14], W0
00C998  90009E     MOV [W14+2], W1
00C99A  980011     MOV W1, [W0+2]
73:                    pld->data_length = data_length;
00C99C  78001E     MOV [W14], W0
00C99E  9040CE     MOV.B [W14+4], W1
00C9A0  784801     MOV.B W1, [W0]
74:                    pld->iter_index = 0;
00C9A2  78009E     MOV [W14], W1
00C9A4  EB4000     CLR.B W0
00C9A6  9840C0     MOV.B W0, [W1+4]
75:                    return pld;
00C9A8  78001E     MOV [W14], W0
76:                }
00C9AA  FA8000     ULNK
00C9AC  060000     RETURN
77:                
78:                
79:                Payload payClone(Payload pld) {
00C9AE  FA0002     LNK #0x2
00C9B0  BE9F88     MOV.D W8, [W15++]
00C9B2  781F8A     MOV W10, [W15++]
00C9B4  780F00     MOV W0, [W14]
80:                    return payCreate(payGetDataLength(pld), payGetData(pld), payGetStatus(pld), payGetType(pld));
00C9B6  78001E     MOV [W14], W0
00C9B8  07009C     RCALL payGetType
00C9BA  784480     MOV.B W0, W9
00C9BC  78001E     MOV [W14], W0
00C9BE  0700AA     RCALL payGetStatus
00C9C0  784400     MOV.B W0, W8
00C9C2  78001E     MOV [W14], W0
00C9C4  07006D     RCALL payGetData
00C9C6  780500     MOV W0, W10
00C9C8  78001E     MOV [W14], W0
00C9CA  070083     RCALL payGetDataLength
00C9CC  784189     MOV.B W9, W3
00C9CE  784108     MOV.B W8, W2
00C9D0  78008A     MOV W10, W1
00C9D2  07FFB0     RCALL payCreate
81:                }
00C9D4  78054F     MOV [--W15], W10
00C9D6  BE044F     MOV.D [--W15], W8
00C9D8  FA8000     ULNK
00C9DA  060000     RETURN
82:                
83:                unsigned char payNextElement(Payload pld) {
00C9DC  FA0002     LNK #0x2
00C9DE  780F00     MOV W0, [W14]
84:                    if (pld->iter_index >= pld->data_length + PAYLOAD_HEADER_LENGTH) {
00C9E0  78001E     MOV [W14], W0
00C9E2  904040     MOV.B [W0+4], W0
00C9E4  FB8080     ZE W0, W1
00C9E6  78001E     MOV [W14], W0
00C9E8  784010     MOV.B [W0], W0
00C9EA  FB8000     ZE W0, W0
00C9EC  E88000     INC2 W0, W0
00C9EE  508F80     SUB W1, W0, [W15]
00C9F0  350002     BRA LT, 0xC9F6
85:                        return -1;
00C9F2  EBC000     SETM.B W0
00C9F4  37000A     BRA 0xCA0A
86:                    }
87:                    return pld->pld_data[pld->iter_index++];
00C9F6  78001E     MOV [W14], W0
00C9F8  900110     MOV [W0+2], W2
00C9FA  78001E     MOV [W14], W0
00C9FC  9040C0     MOV.B [W0+4], W1
00C9FE  FB8001     ZE W1, W0
00CA00  410000     ADD W2, W0, W0
00CA02  784010     MOV.B [W0], W0
00CA04  E84081     INC.B W1, W1
00CA06  78011E     MOV [W14], W2
00CA08  984141     MOV.B W1, [W2+4]
88:                }
00CA0A  FA8000     ULNK
00CA0C  060000     RETURN
89:                
90:                void payInitIterator(Payload pld) {
00CA0E  FA0002     LNK #0x2
00CA10  780F00     MOV W0, [W14]
91:                    pld->iter_index = 0;
00CA12  78009E     MOV [W14], W1
00CA14  EB4000     CLR.B W0
00CA16  9840C0     MOV.B W0, [W1+4]
92:                }
00CA18  FA8000     ULNK
00CA1A  060000     RETURN
93:                
94:                unsigned char payReadByte(Payload pld, unsigned char loc) {
00CA1C  FA0004     LNK #0x4
00CA1E  780F00     MOV W0, [W14]
00CA20  984721     MOV.B W1, [W14+2]
95:                    return pld->pld_data[loc+PAYLOAD_HEADER_LENGTH];
00CA22  78001E     MOV [W14], W0
00CA24  900090     MOV [W0+2], W1
00CA26  90402E     MOV.B [W14+2], W0
00CA28  FB8000     ZE W0, W0
00CA2A  E88000     INC2 W0, W0
00CA2C  408000     ADD W1, W0, W0
00CA2E  784010     MOV.B [W0], W0
96:                }
00CA30  FA8000     ULNK
00CA32  060000     RETURN
97:                
98:                unsigned char* payToString(Payload pld) {
00CA34  FA0002     LNK #0x2
00CA36  780F00     MOV W0, [W14]
99:                    return pld->pld_data;
00CA38  78001E     MOV [W14], W0
00CA3A  900010     MOV [W0+2], W0
100:               }
00CA3C  FA8000     ULNK
00CA3E  060000     RETURN
101:               
102:               
103:               void payAppendData(Payload pld, char loc, 
104:                               unsigned char data_length, unsigned char *data) {
00CA40  FA0006     LNK #0x6
00CA42  780F00     MOV W0, [W14]
00CA44  984721     MOV.B W1, [W14+2]
00CA46  984732     MOV.B W2, [W14+3]
00CA48  980723     MOV W3, [W14+4]
105:                   while(data_length--) {
00CA4A  37000F     BRA 0xCA6A
00CA6A  90403E     MOV.B [W14+3], W0
00CA6C  FB8000     ZE W0, W0
00CA6E  EA0000     NEG W0, W0
00CA70  DE004F     LSR W0, #15, W0
00CA72  784080     MOV.B W0, W1
00CA74  90403E     MOV.B [W14+3], W0
00CA76  E94000     DEC.B W0, W0
00CA78  984730     MOV.B W0, [W14+3]
00CA7A  EB4000     CLR.B W0
00CA7C  50CF80     SUB.B W1, W0, [W15]
00CA7E  3AFFE6     BRA NZ, 0xCA4C
106:                       pld->pld_data[PAYLOAD_HEADER_LENGTH + loc++] = *(data++);
00CA4C  78001E     MOV [W14], W0
00CA4E  900090     MOV [W0+2], W1
00CA50  90402E     MOV.B [W14+2], W0
00CA52  FB0000     SE W0, W0
00CA54  E88000     INC2 W0, W0
00CA56  408080     ADD W1, W0, W1
00CA58  90002E     MOV [W14+4], W0
00CA5A  784010     MOV.B [W0], W0
00CA5C  784880     MOV.B W0, [W1]
00CA5E  90402E     MOV.B [W14+2], W0
00CA60  E84000     INC.B W0, W0
00CA62  984720     MOV.B W0, [W14+2]
00CA64  90002E     MOV [W14+4], W0
00CA66  E80000     INC W0, W0
00CA68  980720     MOV W0, [W14+4]
107:                   }
108:               
109:               }
00CA80  FA8000     ULNK
00CA82  060000     RETURN
110:               
111:               void payWriteByte(Payload pld, unsigned char loc, unsigned char data) {
00CA84  FA0004     LNK #0x4
00CA86  780F00     MOV W0, [W14]
00CA88  984721     MOV.B W1, [W14+2]
00CA8A  984732     MOV.B W2, [W14+3]
112:               
113:                   pld->pld_data[loc+PAYLOAD_HEADER_LENGTH] = data;
00CA8C  78001E     MOV [W14], W0
00CA8E  900090     MOV [W0+2], W1
00CA90  90402E     MOV.B [W14+2], W0
00CA92  FB8000     ZE W0, W0
00CA94  E88000     INC2 W0, W0
00CA96  408000     ADD W1, W0, W0
00CA98  9040BE     MOV.B [W14+3], W1
00CA9A  784801     MOV.B W1, [W0]
114:               
115:               }
00CA9C  FA8000     ULNK
00CA9E  060000     RETURN
116:               
117:               unsigned char* payGetData(Payload pld) {
00CAA0  FA0002     LNK #0x2
00CAA2  780F00     MOV W0, [W14]
118:                   return pld->pld_data + PAYLOAD_HEADER_LENGTH;
00CAA4  78001E     MOV [W14], W0
00CAA6  900010     MOV [W0+2], W0
00CAA8  E88000     INC2 W0, W0
119:               }
00CAAA  FA8000     ULNK
00CAAC  060000     RETURN
120:               
121:               
122:               void paySetData(Payload pld, unsigned char data_length, unsigned char *data) {
00CAAE  FA0006     LNK #0x6
00CAB0  780F00     MOV W0, [W14]
00CAB2  984721     MOV.B W1, [W14+2]
00CAB4  980722     MOV W2, [W14+4]
123:                   payAppendData(pld, 0, data_length, data);
00CAB6  9001AE     MOV [W14+4], W3
00CAB8  90412E     MOV.B [W14+2], W2
00CABA  EB4080     CLR.B W1
00CABC  78001E     MOV [W14], W0
00CABE  07FFC0     RCALL payAppendData
124:               }
00CAC0  FA8000     ULNK
00CAC2  060000     RETURN
125:               
126:               
127:               unsigned char payGetPayloadLength(Payload pld) {
00CAC4  FA0002     LNK #0x2
00CAC6  780F00     MOV W0, [W14]
128:                   return pld->data_length + PAYLOAD_HEADER_LENGTH;
00CAC8  78001E     MOV [W14], W0
00CACA  784010     MOV.B [W0], W0
00CACC  E8C000     INC2.B W0, W0
129:               }
00CACE  FA8000     ULNK
00CAD0  060000     RETURN
130:               
131:               unsigned char payGetDataLength(Payload pld) {
00CAD2  FA0002     LNK #0x2
00CAD4  780F00     MOV W0, [W14]
132:                   return pld->data_length;
00CAD6  78001E     MOV [W14], W0
00CAD8  784010     MOV.B [W0], W0
133:               }
00CADA  FA8000     ULNK
00CADC  060000     RETURN
134:               
135:               void paySetType(Payload pld, unsigned char type) {
00CADE  FA0004     LNK #0x4
00CAE0  780F00     MOV W0, [W14]
00CAE2  984721     MOV.B W1, [W14+2]
136:                   pld->pld_data[TYPE_POS] = type;
00CAE4  78001E     MOV [W14], W0
00CAE6  900010     MOV [W0+2], W0
00CAE8  E80000     INC W0, W0
00CAEA  9040AE     MOV.B [W14+2], W1
00CAEC  784801     MOV.B W1, [W0]
137:               }
00CAEE  FA8000     ULNK
00CAF0  060000     RETURN
138:               
139:               unsigned char payGetType(Payload pld) {
00CAF2  FA0002     LNK #0x2
00CAF4  780F00     MOV W0, [W14]
140:                   return pld->pld_data[TYPE_POS];
00CAF6  78001E     MOV [W14], W0
00CAF8  900010     MOV [W0+2], W0
00CAFA  E80000     INC W0, W0
00CAFC  784010     MOV.B [W0], W0
141:               }
00CAFE  FA8000     ULNK
00CB00  060000     RETURN
142:               
143:               void paySetStatus(Payload pld, unsigned char status){
00CB02  FA0004     LNK #0x4
00CB04  780F00     MOV W0, [W14]
00CB06  984721     MOV.B W1, [W14+2]
144:                   pld->pld_data[STATUS_POS] = status;
00CB08  78001E     MOV [W14], W0
00CB0A  900010     MOV [W0+2], W0
00CB0C  9040AE     MOV.B [W14+2], W1
00CB0E  784801     MOV.B W1, [W0]
145:               }
00CB10  FA8000     ULNK
00CB12  060000     RETURN
146:               
147:               unsigned char payGetStatus(Payload pld) {
00CB14  FA0002     LNK #0x2
00CB16  780F00     MOV W0, [W14]
148:                   return pld->pld_data[STATUS_POS];
00CB18  78001E     MOV [W14], W0
00CB1A  900010     MOV [W0+2], W0
00CB1C  784010     MOV.B [W0], W0
149:               }
00CB1E  FA8000     ULNK
00CB20  060000     RETURN
150:               
151:               void payDelete(Payload pld) {
00CB22  FA0002     LNK #0x2
00CB24  780F00     MOV W0, [W14]
152:                   free(pld->pld_data);
00CB26  78001E     MOV [W14], W0
00CB28  900010     MOV [W0+2], W0
00CB2A  0234EC     CALL _free
00CB2C  000000     NOP
153:                   free(pld);
00CB2E  78001E     MOV [W14], W0
00CB30  0234EC     CALL _free
00CB32  000000     NOP
154:               }
00CB34  FA8000     ULNK
00CB36  060000     RETURN
155:               
156:               
157:               
158:               
159:               
160:               
161:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/packet_queue.c  ---------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Queue (FIFO) for Packets
31:                 *
32:                 * by Aaron M. Hoover
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Aaron M. Hoover 2010-09-02     Initial release
38:                 *                      
39:                 * Notes:
40:                 *
41:                 */
42:                
43:                #include "p33Fxxxx.h"
44:                #include "queue.h"
45:                #include "packet_queue.h"
46:                #include "radio.h"
47:                #include "utils.h"
48:                #include <stdio.h>      // for NULL
49:                #include <stdlib.h>     // for malloc
50:                
51:                
52:                /*-----------------------------------------------------------------------------
53:                 *          Public functions
54:                -----------------------------------------------------------------------------*/
55:                
56:                PacketQueue pktqInit(int max_size) {
00E016  FA0004     LNK #0x4
00E018  980710     MOV W0, [W14+2]
57:                
58:                    Queue pq = queueInit(max_size);
00E01A  90001E     MOV [W14+2], W0
00E01C  02BB26     CALL queueInit
00E01E  000000     NOP
00E020  780F00     MOV W0, [W14]
59:                    return pq;
00E022  78001E     MOV [W14], W0
60:                
61:                }
00E024  FA8000     ULNK
00E026  060000     RETURN
62:                
63:                void pktqPush(PacketQueue pq, MacPacket mp) {
00E028  FA0006     LNK #0x6
00E02A  980710     MOV W0, [W14+2]
00E02C  980721     MOV W1, [W14+4]
64:                
65:                    MacPacket p;
66:                
67:                    if (queueIsFull(pq)) {
00E02E  90001E     MOV [W14+2], W0
00E030  02BDA2     CALL queueIsFull
00E032  000000     NOP
00E034  EB0080     CLR W1
00E036  500F81     SUB W0, W1, [W15]
00E038  32000B     BRA Z, 0xE050
68:                        p = (MacPacket)queuePop(pq);
00E03A  90001E     MOV [W14+2], W0
00E03C  02BCDC     CALL queuePop
00E03E  000000     NOP
00E040  780F00     MOV W0, [W14]
69:                        payDelete(p->payload);
00E042  78001E     MOV [W14], W0
00E044  900060     MOV [W0+12], W0
00E046  02CB22     CALL payDelete
00E048  000000     NOP
70:                        macDeletePacket(p);
00E04A  78001E     MOV [W14], W0
00E04C  02861E     CALL macDeletePacket
00E04E  000000     NOP
71:                    }
72:                
73:                    queueAppend(pq, mp);
00E050  9000AE     MOV [W14+4], W1
00E052  90001E     MOV [W14+2], W0
00E054  02BBFC     CALL queueAppend
00E056  000000     NOP
74:                
75:                }
00E058  FA8000     ULNK
00E05A  060000     RETURN
76:                
77:                MacPacket pktqPop(PacketQueue queue) {
00E05C  FA0002     LNK #0x2
00E05E  780F00     MOV W0, [W14]
78:                
79:                    return (MacPacket)queuePop(queue);
00E060  78001E     MOV [W14], W0
00E062  02BCDC     CALL queuePop
00E064  000000     NOP
80:                
81:                }
00E066  FA8000     ULNK
00E068  060000     RETURN
82:                
83:                MacPacket pktqGetFront(PacketQueue queue) {
00E06A  FA0002     LNK #0x2
00E06C  780F00     MOV W0, [W14]
84:                
85:                    return (MacPacket)queueGetFront(queue);
00E06E  78001E     MOV [W14], W0
00E070  02BD84     CALL queueGetFront
00E072  000000     NOP
86:                }
00E074  FA8000     ULNK
00E076  060000     RETURN
87:                
88:                int pktqIsFull(PacketQueue queue) {
00E078  FA0002     LNK #0x2
00E07A  780F00     MOV W0, [W14]
89:                
90:                    return queueIsFull(queue);
00E07C  78001E     MOV [W14], W0
00E07E  02BDA2     CALL queueIsFull
00E080  000000     NOP
91:                
92:                }
00E082  FA8000     ULNK
00E084  060000     RETURN
93:                
94:                int pktqIsEmpty(PacketQueue queue) {
00E086  FA0002     LNK #0x2
00E088  780F00     MOV W0, [W14]
95:                
96:                    return queueIsEmpty(queue);
00E08A  78001E     MOV [W14], W0
00E08C  02BDC8     CALL queueIsEmpty
00E08E  000000     NOP
97:                
98:                }
00E090  FA8000     ULNK
00E092  060000     RETURN
99:                
100:               
101:               int pktqGetSize(PacketQueue queue) {
00E094  FA0002     LNK #0x2
00E096  780F00     MOV W0, [W14]
102:               
103:                   return queueGetSize(queue);
00E098  78001E     MOV [W14], W0
00E09A  02BDDE     CALL queueGetSize
00E09C  000000     NOP
104:               
105:               }
00E09E  FA8000     ULNK
00E0A0  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/ovcamHS.s  --------------------------------------------
                                                  1:     ;
                                                  2:     ; Copyright (c) 2007-2011, Regents of the University of California
                                                  3:     ; All rights reserved.
                                                  4:     ;
                                                  5:     ; Redistribution and use in source and binary forms, with or without
                                                  6:     ; modification, are permitted provided that the following conditions are met:
                                                  7:     ;
                                                  8:     ; - Redistributions of source code must retain the above copyright notice,
                                                  9:     ;   this list of conditions and the following disclaimer.
                                                  10:    ; - Redistributions in binary form must reproduce the above copyright notice,
                                                  11:    ;   this list of conditions and the following disclaimer in the documentation
                                                  12:    ;   and/or other materials provided with the distribution.
                                                  13:    ; - Neither the name of the University of California, Berkeley nor the names
                                                  14:    ;   of its contributors may be used to endorse or promote products derived
                                                  15:    ;   from this software without specific prior written permission.
                                                  16:    ;
                                                  17:    ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                  18:    ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                  19:    ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                  20:    ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
                                                  21:    ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                                                  22:    ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
                                                  23:    ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
                                                  24:    ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
                                                  25:    ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                                                  26:    ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                                                  27:    ; POSSIBILITY OF SUCH DAMAGE.
                                                  28:    ;
                                                  29:    ;
                                                  30:    ; OmniVision OV7660 Camera (ovcam) Interface
                                                  31:    ;
                                                  32:    ; by Fernando L. Garcia Bermudez
                                                  33:    ;
                                                  34:    ; v.beta
                                                  35:    ;
                                                  36:    ; Revisions:
                                                  37:    ;  Fernando L. Garcia Bermudez     2007-11-30    Initial release
                                                  38:    ;  Humphrey Hu                     2011-10-14    Added capture of a specified
                                                  39:    ;                                                number of pixels.
                                                  40:    ;
                                                  41:    
                                                  42:    #include p33Fxxxx.inc
                                                  43:    
                                                  44:    
                                                  45:    ; Symbol definitions
                                                  46:    .equiv  tmp,           w0
                                                  47:    .equiv  arg1,           w1
                                                  48:    .equiv  row_ptr,        w2
                                                  49:    .equiv  row_len,        w3
                                                  50:    .equiv  frame_ptr,      w8
                                                  51:    .equiv  row_counter,    w9
                                                  52:    
                                                  53:    .equiv  VSYNC_PORT,     PORTD
                                                  54:    .equiv  VSYNC_PIN,      8
                                                  55:    .equiv  HREF_PORT,      PORTF
                                                  56:    .equiv  HREF_PIN,       0
                                                  57:    .equiv  PIXEL,          PORTD
                                                  58:    
                                                  59:    
                                                  60:    ;------------------------------------------------------------------------------
                                                  61:    ;           Public functions
                                                  62:    ;------------------------------------------------------------------------------
                                                  63:    
                                                  64:    .global _ovcamGetRow
                                                  65:    .global _ovcamGetPixels
                                                  66:    ;.global _ovcamGetFrame
                                                  67:    
                                                  68:    ; After waiting for the start of a new row, it captures the first pixel with
                                                  69:    ; slightly different timing than all subsequent ones, saving these to
                                                  70:    ; consecutive addresses starting at the one passed as a pointer to the current
                                                  71:    ; row's first element.
                                                  72:    _ovcamGetRow:
                                                  73:    
                                                  74:    ; Save row pointer in row_ptr
00E1E8  780100     MOV W0, W2                     75:                mov     tmp, row_ptr
                                                  76:    
                                                  77:    ; Wait until a new row starts
00E1EA  AB02E0     BTST PORTF, #0                 78:    wROWe:      btst    HREF_PORT, #HREF_PIN
00E1EC  3AFFFE     BRA NZ, 0xE1EA                 79:                bra     NZ, wROWe
00E1EE  AB02E0     BTST PORTF, #0                 80:    wROWs:      btst    HREF_PORT, #HREF_PIN
00E1F0  32FFFE     BRA Z, 0xE1EE                  81:                bra     Z, wROWs
                                                  82:    
                                                  83:    ; Capture image row
00E1F2  8016A0     MOV PORTD, W0                  84:                mov     PIXEL, tmp      ; init
00E1F4  785900     MOV.B W0, [W2++]               85:                mov.b   tmp, [row_ptr++]
00E1F6  000000     NOP                            86:                nop
00E1F8  000000     NOP                            87:                nop
00E1FA  000000     NOP                            88:                nop
00E1FC  000000     NOP                            89:                nop
00E1FE  8016A0     MOV PORTD, W0                  90:    getROW:     mov     PIXEL, tmp      ; rest
00E200  785900     MOV.B W0, [W2++]               91:                mov.b   tmp, [row_ptr++]
00E202  000000     NOP                            92:                nop
00E204  000000     NOP                            93:                nop
00E206  000000     NOP                            94:                nop
00E208  AB02E0     BTST PORTF, #0                 95:                btst    HREF_PORT, #HREF_PIN
00E20A  3AFFF9     BRA NZ, 0xE1FE                 96:                bra     NZ, getROW
                                                  97:    
00E20C  060000     RETURN                         98:                return
                                                  99:    
                                                  100:   _ovcamGetPixels:
                                                  101:   
                                                  102:   ; Save row pointer in row_ptr
00E20E  780100     MOV W0, W2                     103:               mov     tmp, row_ptr
00E210  780181     MOV W1, W3                     104:               mov     arg1, row_len
                                                  105:   ; Wait until a new row starts
00E212  AB02E0     BTST PORTF, #0                 106:   wPIXe:      btst    HREF_PORT, #HREF_PIN
00E214  3AFFFE     BRA NZ, 0xE212                 107:               bra     NZ, wPIXe
00E216  AB02E0     BTST PORTF, #0                 108:   wPIXs:      btst    HREF_PORT, #HREF_PIN
00E218  32FFFE     BRA Z, 0xE216                  109:               bra     Z, wPIXs
                                                  110:   
                                                  111:   
                                                  112:   ; Capture arg # of pixels
                                                  113:   ; N = Number of cycles per loop
                                                  114:   ; N = 8*A for Ax subsample (1 out of A pixels captured)
                                                  115:   
00E21A  8016A0     MOV PORTD, W0                  116:               mov     PIXEL, tmp      ; init
00E21C  785900     MOV.B W0, [W2++]               117:               mov.b   tmp, [row_ptr++]
00E21E  090002     REPEAT #0x2                    118:               repeat  #2 ;N - 6
00E220  000000     NOP                            119:               nop
                                                  120:   
00E222  8016A0     MOV PORTD, W0                  121:   getPIX:     mov     PIXEL, tmp      ; rest
00E224  785900     MOV.B W0, [W2++]               122:               mov.b   tmp, [row_ptr++]
00E226  090001     REPEAT #0x1                    123:               repeat  #1  ;N - 7
00E228  000000     NOP                            124:               nop
00E22A  E90183     DEC W3, W3                     125:               dec     row_len, row_len
00E22C  3AFFFA     BRA NZ, 0xE222                 126:               bra     NZ, getPIX
                                                  127:   
00E22E  060000     RETURN                         128:               return
                                                  129:   
                                                  130:   
                                                  131:   ; TODO (fgb): Throws an address error, need to make sure how to iterate through
                                                  132:   ;             the rows of the array, which is probably causing the problem.
                                                  133:   ; TODO (fgb): Image sizes should be passed as arguments
                                                  134:   ;_ovcamGetFrame:
                                                  135:   ;
                                                  136:   ;; Save frame pointer in frame_ptr
                                                  137:   ;            mov     tmp, frame_ptr
                                                  138:   ;
                                                  139:   ;; Wait until a new frame starts
                                                  140:   ;wFRAMEe:    btst    VSYNC_PORT, #VSYNC_PIN
                                                  141:   ;            bra     NZ, wROWe
                                                  142:   ;wFRAMEs:    btst    VSYNC_PORT, #VSYNC_PIN
                                                  143:   ;            bra     Z, wROWs
                                                  144:   ;
                                                  145:   ;; Capture image frame
                                                  146:   ;            mov     #100, row_counter
                                                  147:   ;
                                                  148:   ;getFRAME:   mov     frame_ptr, tmp
                                                  149:   ;            call    _ovcamGetRow
                                                  150:   ;            add     #160, frame_ptr
                                                  151:   ;            dec     row_counter, row_counter
                                                  152:   ;            bra     NZ, getFRAME
                                                  153:   ;
                                                  154:   ;            return
                                                  155:   
                                                  156:   
                                                  157:   .end
---  C:/Users/Cameron/Documents/Git/imageproc-lib/ovcam.c  ----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2007-2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * OmniVision OV7660 Camera (ovcam) Configuration Interface (SCCB)
31:                 *
32:                 * by Fernando L. Garcia Bermudez
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Fernando L. Garcia Bermudez     2007-9-10    Initial release
38:                 *
39:                 * Notes:
40:                 *  - Uses an I2C(SCCB) port for configuring the camera.
41:                 */
42:                
43:                #include "p33Fxxxx.h"
44:                #include "i2c.h"
45:                #include "ovcam.h"
46:                #include "utils.h"
47:                
48:                
49:                // I2Cx Registers
50:                #if (defined(__IMAGEPROC1) || defined(__IMAGEPROC2))
51:                
52:                    #define I2C_TRN         I2C1TRN
53:                    #define I2C_RCV         I2C1RCV
54:                    #define I2C_BRG         I2C1BRG
55:                    #define I2C_STATbits    I2C1STATbits
56:                    #define I2C_CON         I2C1CON
57:                    #define I2C_CONbits     I2C1CONbits
58:                
59:                #endif
60:                
61:                // Device Slave Addresses
62:                #define IDADDR_W    0x42
63:                #define IDADDR_R    0x43
64:                
65:                /* OV7660 Control Registers */
66:                
67:                // Common Control
68:                #define COM1    0x04
69:                #define COM2    0x09
70:                #define COM3    0x0C
71:                #define COM5    0x0E
72:                #define COM6    0x0F
73:                #define COM7    0x12
74:                #define COM8    0x13
75:                #define COM9    0x14
76:                #define COM10   0x15
77:                #define COM11   0x3B
78:                #define COM12   0x3C
79:                #define COM13   0x3D
80:                #define COM15   0x40
81:                #define COM16   0x41
82:                #define COM17   0x42
83:                
84:                // Data Format
85:                #define CLKRC   0x11
86:                #define PSHFT   0x1B
87:                #define TSLB    0x3A
88:                #define MVFP    0x1E
89:                
90:                #define HREF    0x32
91:                #define HSTART  0x17
92:                #define HSTOP   0x18
93:                
94:                #define VREF    0x03
95:                #define VSTRT   0x19
96:                #define VSTOP   0x1A
97:                
98:                // Edge Enhancement
99:                #define EDGE    0x3F
100:               #define DSPC2   0xA0
101:               
102:               // Banding Filter
103:               #define BD50ST  0x9D
104:               #define BD60ST  0x9E
105:               #define HV      0x69
106:               
107:               #define DBLV    0x6B
108:               
109:               // Gain/Exposure
110:               #define GAIN    0x00
111:               #define BLUE    0x01
112:               #define RED     0x02
113:               
114:               #define AECH    0x10
115:               
116:               #define AEW     0x24
117:               #define AEB     0x25
118:               
119:               // Dummy Line
120:               #define DM_LNL  0x92
121:               #define DM_LNH  0x93
122:               
123:               // Array
124:               #define CHLF    0x33
125:               #define ARBLM   0x34
126:               
127:               // Matrix Coefficients
128:               #define MTX1    0x4F
129:               #define MTX2    0x50
130:               #define MTX3    0x51
131:               #define MTX4    0x52
132:               #define MTX5    0x53
133:               #define MTX6    0x54
134:               #define MTX7    0x55
135:               #define MTX8    0x56
136:               #define MTX9    0x57
137:               #define MTXS    0x58
138:               
139:               // ADC
140:               #define ACOM    0x38
141:               #define OFON    0x39
142:               
143:               
144:               /*----------------------------------------------------------------------------
145:                *          Declaration of private functions
146:                ---------------------------------------------------------------------------*/
147:               static void ovcamSetupPeripheral(void);
148:               //static void ovcamSetupOV7660 (void);
149:               static inline void ovcamWriteByte (unsigned char byte);
150:               static inline unsigned char ovcamReadByte (void);
151:               static inline void ovcamNACK (void);
152:               static inline void ovcamStartTx (void);
153:               static inline void ovcamStopTx (void);
154:               static inline void ovcamWaitTillIdle (void);
155:               
156:               
157:               /*-----------------------------------------------------------------------------
158:                *          Public functions
159:               -----------------------------------------------------------------------------*/
160:               
161:               void ovcamSetup(void)
162:               {
009D2C  FA0000     LNK #0x0
163:                   ovcamSetupPeripheral();
009D2E  070026     RCALL ovcamSetupPeripheral
164:                   ovcamTurnOn();
009D30  07FFF9     RCALL ovcamTurnOn
165:                   delay_us(5000); // Wait for the camera to boot
009D32  213880     MOV #0x1388, W0
009D34  02E262     CALL _delay_us
009D36  000000     NOP
166:                   ovcamSetupOV7660();
009D38  070029     RCALL ovcamSetupOV7660
167:               }
009D3A  FA8000     ULNK
009D3C  060000     RETURN
168:               
169:               void ovcamWriteRegister (unsigned char subaddr, unsigned char data)
170:               {
009D3E  FA0002     LNK #0x2
009D40  784F00     MOV.B W0, [W14]
009D42  984711     MOV.B W1, [W14+1]
171:                   ovcamStartTx();
009D44  07019B     RCALL ovcamStartTx
172:                   ovcamWriteByte(IDADDR_W);
009D46  B3C420     MOV #0x42, W0
009D48  07016B     RCALL ovcamWriteByte
173:                   ovcamWriteByte(subaddr);
009D4A  78401E     MOV.B [W14], W0
009D4C  070169     RCALL ovcamWriteByte
174:                   ovcamWriteByte(data);
009D4E  90401E     MOV.B [W14+1], W0
009D50  070167     RCALL ovcamWriteByte
175:                   ovcamStopTx();
009D52  07019E     RCALL ovcamStopTx
176:               }
009D54  FA8000     ULNK
009D56  060000     RETURN
177:               
178:               unsigned char ovcamReadRegister (unsigned char subaddr)
179:               {
009D58  FA0004     LNK #0x4
009D5A  984720     MOV.B W0, [W14+2]
180:                   unsigned char data;
181:               
182:                   ovcamStartTx();
009D5C  07018F     RCALL ovcamStartTx
183:                   ovcamWriteByte(IDADDR_W);
009D5E  B3C420     MOV #0x42, W0
009D60  07015F     RCALL ovcamWriteByte
184:                   ovcamWriteByte(subaddr);
009D62  90402E     MOV.B [W14+2], W0
009D64  07015D     RCALL ovcamWriteByte
185:                   ovcamStopTx();
009D66  070194     RCALL ovcamStopTx
186:               
187:                   ovcamStartTx();
009D68  070189     RCALL ovcamStartTx
188:                   ovcamWriteByte(IDADDR_R);
009D6A  B3C430     MOV #0x43, W0
009D6C  070159     RCALL ovcamWriteByte
189:                   data = ovcamReadByte();
009D6E  07016E     RCALL ovcamReadByte
009D70  784F00     MOV.B W0, [W14]
190:                   ovcamNACK();
009D72  070179     RCALL ovcamNACK
191:                   ovcamStopTx();
009D74  07018D     RCALL ovcamStopTx
192:               
193:                   return data;
009D76  78401E     MOV.B [W14], W0
194:               }
009D78  FA8000     ULNK
009D7A  060000     RETURN
195:               
196:               /*-----------------------------------------------------------------------------
197:                *          Private functions (for internal use only)
198:               -----------------------------------------------------------------------------*/
199:               
200:               // Initializes the I2Cx bus for configuring the camera.
201:               static void ovcamSetupPeripheral(void)
202:               {
009D7C  FA0000     LNK #0x0
203:                   I2C_BRG = 363; // Fcy(1/Fscl - 1/1111111)-1
009D7E  2016B0     MOV #0x16B, W0
009D80  881020     MOV W0, I2C1BRG
204:                   I2C_CON = I2C1_ON & I2C1_IDLE_CON & I2C1_CLK_HLD & I2C1_IPMI_DIS &
009D82  2C2200     MOV #0xC220, W0
009D84  881030     MOV W0, I2C1CON
205:                             I2C1_7BIT_ADD & I2C1_SLW_DIS & I2C1_SM_DIS & I2C1_GCALL_DIS &
206:                             I2C1_STR_DIS &  I2C1_NACK & I2C1_ACK_DIS & I2C1_RCV_DIS &
207:                             I2C1_STOP_DIS & I2C1_RESTART_DIS & I2C1_START_DIS;
208:               
209:                   ovcamWaitTillIdle();
009D86  07018E     RCALL ovcamWaitTillIdle
210:               }
009D88  FA8000     ULNK
009D8A  060000     RETURN
211:               
212:               // Configures the OV7660 camera.
213:               //
214:               // The initial reset is to be followed by at least 5ms of settling time. After
215:               // that, the contents of all important registers are set to the required
216:               // values. It seems that even though one needs to change only a few values
217:               // from their defaults, the rest of the rewrites are necessary for proper
218:               // functioning. Since some of the registers are undocumented in the datasheet,
219:               // they might be calibration data (provided by the manufacturer). More testing
220:               // is needed to make sure this is the right interpretation.
221:               void ovcamSetupOV7660 (void)
222:               {
009D8C  FA0000     LNK #0x0
223:                   // SCCB Register Reset
224:                   ovcamWriteRegister(COM7,0x80);
009D8E  B3C801     MOV #0x80, W1
009D90  B3C120     MOV #0x12, W0
009D92  07FFD5     RCALL ovcamWriteRegister
225:                   delay_us(5000); // Wait for the camera to boot
009D94  213880     MOV #0x1388, W0
009D96  02E262     CALL _delay_us
009D98  000000     NOP
226:               
227:                   // Pixel Clock, Banding Filter, Exposure, Gain
228:                   ovcamWriteRegister(CLKRC,0x81); // PCLK = (XCLK/2)/2
009D9A  B3C811     MOV #0x81, W1
009D9C  B3C110     MOV #0x11, W0
009D9E  07FFCF     RCALL ovcamWriteRegister
229:                   ovcamWriteRegister(DM_LNL,0x48);
009DA0  B3C481     MOV #0x48, W1
009DA2  B3C920     MOV #0x92, W0
009DA4  07FFCC     RCALL ovcamWriteRegister
230:                   ovcamWriteRegister(DM_LNH,0x01);
009DA6  B3C011     MOV #0x1, W1
009DA8  B3C930     MOV #0x93, W0
009DAA  07FFC9     RCALL ovcamWriteRegister
231:                   ovcamWriteRegister(BD50ST,0x62);
009DAC  B3C621     MOV #0x62, W1
009DAE  B3C9D0     MOV #0x9D, W0
009DB0  07FFC6     RCALL ovcamWriteRegister
232:                   ovcamWriteRegister(BD60ST,0x52);
009DB2  B3C521     MOV #0x52, W1
009DB4  B3C9E0     MOV #0x9E, W0
009DB6  07FFC3     RCALL ovcamWriteRegister
233:                   ovcamWriteRegister(COM11,0x02); // 60Hz Banding Filter
009DB8  B3C021     MOV #0x2, W1
009DBA  B3C3B0     MOV #0x3B, W0
009DBC  07FFC0     RCALL ovcamWriteRegister
234:                   ovcamWriteRegister(COM8,0xF2); // Banding Filter ON
009DBE  B3CF21     MOV #0xF2, W1
009DC0  B3C130     MOV #0x13, W0
009DC2  07FFBD     RCALL ovcamWriteRegister
235:                   ovcamWriteRegister(AECH,0x00);
009DC4  EB4080     CLR.B W1
009DC6  B3C100     MOV #0x10, W0
009DC8  07FFBA     RCALL ovcamWriteRegister
236:                   ovcamWriteRegister(GAIN,0x00);
009DCA  EB4080     CLR.B W1
009DCC  EB4000     CLR.B W0
009DCE  07FFB7     RCALL ovcamWriteRegister
237:                   ovcamWriteRegister(BLUE,0x80);
009DD0  B3C801     MOV #0x80, W1
009DD2  B3C010     MOV #0x1, W0
009DD4  07FFB4     RCALL ovcamWriteRegister
238:                   ovcamWriteRegister(RED,0x80);
009DD6  B3C801     MOV #0x80, W1
009DD8  B3C020     MOV #0x2, W0
009DDA  07FFB1     RCALL ovcamWriteRegister
239:                   ovcamWriteRegister(COM8,0xF7); // AGC Gain + AWB + AEC Exposure
009DDC  B3CF71     MOV #0xF7, W1
009DDE  B3C130     MOV #0x13, W0
009DE0  07FFAE     RCALL ovcamWriteRegister
240:               
241:                   // Format
242:                   ovcamWriteRegister(COM7,0x10); // QVGA & YUV
009DE2  B3C101     MOV #0x10, W1
009DE4  B3C120     MOV #0x12, W0
009DE6  07FFAB     RCALL ovcamWriteRegister
243:                   ovcamWriteRegister(COM1,0x24); // QQVGA + HREF skip 3/4 rows (every other in QQVGA)
009DE8  B3C241     MOV #0x24, W1
009DEA  B3C040     MOV #0x4, W0
009DEC  07FFA8     RCALL ovcamWriteRegister
244:                   ovcamWriteRegister(COM3,0x02); // Horizontal no pixel average + VarioPixel Off (extra)
009DEE  B3C021     MOV #0x2, W1
009DF0  B3C0C0     MOV #0xC, W0
009DF2  07FFA5     RCALL ovcamWriteRegister
245:               
246:                   // Windowing
247:                   ovcamWriteRegister(HSTART,0x23); // Horizontal Frame Start (8 MSb's)
009DF4  B3C231     MOV #0x23, W1
009DF6  B3C170     MOV #0x17, W0
009DF8  07FFA2     RCALL ovcamWriteRegister
248:                   ovcamWriteRegister(HSTOP,0x4B);  // Horizontal Frame Stop (8 MSb's)
009DFA  B3C4B1     MOV #0x4B, W1
009DFC  B3C180     MOV #0x18, W0
009DFE  07FF9F     RCALL ovcamWriteRegister
249:                   ovcamWriteRegister(HREF,0xBF);   // 3 LSb's for Horizontal Frame Start/Stop
009E00  B3CBF1     MOV #0xBF, W1
009E02  B3C320     MOV #0x32, W0
009E04  07FF9C     RCALL ovcamWriteRegister
250:                   ovcamWriteRegister(VSTRT,0x02);  // Vertical Frame Start (8 MSb's)
009E06  B3C021     MOV #0x2, W1
009E08  B3C190     MOV #0x19, W0
009E0A  07FF99     RCALL ovcamWriteRegister
251:                   ovcamWriteRegister(VSTOP,0x3E);  // Vertical Frame Stop (8 MSb's)
009E0C  B3C3E1     MOV #0x3E, W1
009E0E  B3C1A0     MOV #0x1A, W0
009E10  07FF96     RCALL ovcamWriteRegister
252:                   ovcamWriteRegister(VREF,0x00);   // 2 LSb's for Vertical Frame Start/Stop
009E12  EB4080     CLR.B W1
009E14  B3C030     MOV #0x3, W0
009E16  07FF93     RCALL ovcamWriteRegister
253:               
254:                   ovcamWriteRegister(COM5,0x84); // Enable higher frame rates
009E18  B3C841     MOV #0x84, W1
009E1A  B3C0E0     MOV #0xE, W0
009E1C  07FF90     RCALL ovcamWriteRegister
255:                   ovcamWriteRegister(COM6,0x62); // Reset all timing on format change + BLC input
009E1E  B3C621     MOV #0x62, W1
009E20  B3C0F0     MOV #0xF, W0
009E22  07FF8D     RCALL ovcamWriteRegister
256:                   ovcamWriteRegister(COM10,0x02); // VSYNC Negative
009E24  B3C021     MOV #0x2, W1
009E26  B3C150     MOV #0x15, W0
009E28  07FF8A     RCALL ovcamWriteRegister
257:                   ovcamWriteRegister(0x16,0x02);
009E2A  B3C021     MOV #0x2, W1
009E2C  B3C160     MOV #0x16, W0
009E2E  07FF87     RCALL ovcamWriteRegister
258:                   ovcamWriteRegister(PSHFT,0x01);
009E30  B3C011     MOV #0x1, W1
009E32  B3C1B0     MOV #0x1B, W0
009E34  07FF84     RCALL ovcamWriteRegister
259:                   ovcamWriteRegister(MVFP,0x39); // Mirror On and VFLIP On
009E36  B3C391     MOV #0x39, W1
009E38  B3C1E0     MOV #0x1E, W0
009E3A  07FF81     RCALL ovcamWriteRegister
260:                   ovcamWriteRegister(0x29,0x3C); // 20 for internal regulator
009E3C  B3C3C1     MOV #0x3C, W1
009E3E  B3C290     MOV #0x29, W0
009E40  07FF7E     RCALL ovcamWriteRegister
261:                   ovcamWriteRegister(CHLF,0x00);
009E42  EB4080     CLR.B W1
009E44  B3C330     MOV #0x33, W0
009E46  07FF7B     RCALL ovcamWriteRegister
262:                   ovcamWriteRegister(ARBLM,0x07);
009E48  B3C071     MOV #0x7, W1
009E4A  B3C340     MOV #0x34, W0
009E4C  07FF78     RCALL ovcamWriteRegister
263:                   ovcamWriteRegister(0x35,0x84);
009E4E  B3C841     MOV #0x84, W1
009E50  B3C350     MOV #0x35, W0
009E52  07FF75     RCALL ovcamWriteRegister
264:                   ovcamWriteRegister(0x36,0x00);
009E54  EB4080     CLR.B W1
009E56  B3C360     MOV #0x36, W0
009E58  07FF72     RCALL ovcamWriteRegister
265:                   ovcamWriteRegister(ACOM,0x13);
009E5A  B3C131     MOV #0x13, W1
009E5C  B3C380     MOV #0x38, W0
009E5E  07FF6F     RCALL ovcamWriteRegister
266:                   ovcamWriteRegister(OFON,0x43);
009E60  B3C431     MOV #0x43, W1
009E62  B3C390     MOV #0x39, W0
009E64  07FF6C     RCALL ovcamWriteRegister
267:                   ovcamWriteRegister(TSLB,0x00); // YUYV output
009E66  EB4080     CLR.B W1
009E68  B3C3A0     MOV #0x3A, W0
009E6A  07FF69     RCALL ovcamWriteRegister
268:                   ovcamWriteRegister(COM12,0x6C);
009E6C  B3C6C1     MOV #0x6C, W1
009E6E  B3C3C0     MOV #0x3C, W0
009E70  07FF66     RCALL ovcamWriteRegister
269:                   ovcamWriteRegister(COM13,0x90); // Gamma used for raw data before interpolation
009E72  B3C901     MOV #0x90, W1
009E74  B3C3D0     MOV #0x3D, W0
009E76  07FF63     RCALL ovcamWriteRegister
270:                   ovcamWriteRegister(EDGE,0x29);
009E78  B3C291     MOV #0x29, W1
009E7A  B3C3F0     MOV #0x3F, W0
009E7C  07FF60     RCALL ovcamWriteRegister
271:                   ovcamWriteRegister(COM15,0xC1); // Output Range 00-FF
009E7E  B3CC11     MOV #0xC1, W1
009E80  B3C400     MOV #0x40, W0
009E82  07FF5D     RCALL ovcamWriteRegister
272:                   ovcamWriteRegister(COM16,0x20); // Edge Enhancement for YUV
009E84  B3C201     MOV #0x20, W1
009E86  B3C410     MOV #0x41, W0
009E88  07FF5A     RCALL ovcamWriteRegister
273:                   ovcamWriteRegister(DBLV,0x0A);
009E8A  B3C0A1     MOV #0xA, W1
009E8C  B3C6B0     MOV #0x6B, W0
009E8E  07FF57     RCALL ovcamWriteRegister
274:                   ovcamWriteRegister(0xA1,0xC8);
009E90  B3CC81     MOV #0xC8, W1
009E92  B3CA10     MOV #0xA1, W0
009E94  07FF54     RCALL ovcamWriteRegister
275:               
276:                   ovcamWriteRegister(HV,0x40);
009E96  B3C401     MOV #0x40, W1
009E98  B3C690     MOV #0x69, W0
009E9A  07FF51     RCALL ovcamWriteRegister
277:                   ovcamWriteRegister(0x43,0xF0);
009E9C  B3CF01     MOV #0xF0, W1
009E9E  B3C430     MOV #0x43, W0
009EA0  07FF4E     RCALL ovcamWriteRegister
278:                   ovcamWriteRegister(0x44,0x10);
009EA2  B3C101     MOV #0x10, W1
009EA4  B3C440     MOV #0x44, W0
009EA6  07FF4B     RCALL ovcamWriteRegister
279:                   ovcamWriteRegister(0x45,0x78);
009EA8  B3C781     MOV #0x78, W1
009EAA  B3C450     MOV #0x45, W0
009EAC  07FF48     RCALL ovcamWriteRegister
280:                   ovcamWriteRegister(0x46,0xA8);
009EAE  B3CA81     MOV #0xA8, W1
009EB0  B3C460     MOV #0x46, W0
009EB2  07FF45     RCALL ovcamWriteRegister
281:                   ovcamWriteRegister(0x47,0x60);
009EB4  B3C601     MOV #0x60, W1
009EB6  B3C470     MOV #0x47, W0
009EB8  07FF42     RCALL ovcamWriteRegister
282:                   ovcamWriteRegister(0x48,0x80);
009EBA  B3C801     MOV #0x80, W1
009EBC  B3C480     MOV #0x48, W0
009EBE  07FF3F     RCALL ovcamWriteRegister
283:                   ovcamWriteRegister(0x59,0xBA);
009EC0  B3CBA1     MOV #0xBA, W1
009EC2  B3C590     MOV #0x59, W0
009EC4  07FF3C     RCALL ovcamWriteRegister
284:                   ovcamWriteRegister(0x5A,0x9A);
009EC6  B3C9A1     MOV #0x9A, W1
009EC8  B3C5A0     MOV #0x5A, W0
009ECA  07FF39     RCALL ovcamWriteRegister
285:                   ovcamWriteRegister(0x5B,0x22);
009ECC  B3C221     MOV #0x22, W1
009ECE  B3C5B0     MOV #0x5B, W0
009ED0  07FF36     RCALL ovcamWriteRegister
286:                   ovcamWriteRegister(0x5C,0xB9);
009ED2  B3CB91     MOV #0xB9, W1
009ED4  B3C5C0     MOV #0x5C, W0
009ED6  07FF33     RCALL ovcamWriteRegister
287:                   ovcamWriteRegister(0x5D,0x9B);
009ED8  B3C9B1     MOV #0x9B, W1
009EDA  B3C5D0     MOV #0x5D, W0
009EDC  07FF30     RCALL ovcamWriteRegister
288:                   ovcamWriteRegister(0x5E,0x10);
009EDE  B3C101     MOV #0x10, W1
009EE0  B3C5E0     MOV #0x5E, W0
009EE2  07FF2D     RCALL ovcamWriteRegister
289:                   ovcamWriteRegister(0x5F,0xE0);
009EE4  B3CE01     MOV #0xE0, W1
009EE6  B3C5F0     MOV #0x5F, W0
009EE8  07FF2A     RCALL ovcamWriteRegister
290:                   ovcamWriteRegister(0x60,0x85); // 05 for advanced AWB
009EEA  B3C851     MOV #0x85, W1
009EEC  B3C600     MOV #0x60, W0
009EEE  07FF27     RCALL ovcamWriteRegister
291:                   ovcamWriteRegister(0x61,0x60);
009EF0  B3C601     MOV #0x60, W1
009EF2  B3C610     MOV #0x61, W0
009EF4  07FF24     RCALL ovcamWriteRegister
292:                   ovcamWriteRegister(0x9F,0x9D);
009EF6  B3C9D1     MOV #0x9D, W1
009EF8  B3C9F0     MOV #0x9F, W0
009EFA  07FF21     RCALL ovcamWriteRegister
293:                   ovcamWriteRegister(DSPC2,0xA0);
009EFC  B3CA01     MOV #0xA0, W1
009EFE  B3CA00     MOV #0xA0, W0
009F00  07FF1E     RCALL ovcamWriteRegister
294:               
295:                   // Matrix Coefficients
296:                   ovcamWriteRegister(MTX1,0x66);
009F02  B3C661     MOV #0x66, W1
009F04  B3C4F0     MOV #0x4F, W0
009F06  07FF1B     RCALL ovcamWriteRegister
297:                   ovcamWriteRegister(MTX2,0x6B);
009F08  B3C6B1     MOV #0x6B, W1
009F0A  B3C500     MOV #0x50, W0
009F0C  07FF18     RCALL ovcamWriteRegister
298:                   ovcamWriteRegister(MTX3,0x05);
009F0E  B3C051     MOV #0x5, W1
009F10  B3C510     MOV #0x51, W0
009F12  07FF15     RCALL ovcamWriteRegister
299:                   ovcamWriteRegister(MTX4,0x19);
009F14  B3C191     MOV #0x19, W1
009F16  B3C520     MOV #0x52, W0
009F18  07FF12     RCALL ovcamWriteRegister
300:                   ovcamWriteRegister(MTX5,0x40);
009F1A  B3C401     MOV #0x40, W1
009F1C  B3C530     MOV #0x53, W0
009F1E  07FF0F     RCALL ovcamWriteRegister
301:                   ovcamWriteRegister(MTX6,0x59);
009F20  B3C591     MOV #0x59, W1
009F22  B3C540     MOV #0x54, W0
009F24  07FF0C     RCALL ovcamWriteRegister
302:                   ovcamWriteRegister(MTX7,0x40);
009F26  B3C401     MOV #0x40, W1
009F28  B3C550     MOV #0x55, W0
009F2A  07FF09     RCALL ovcamWriteRegister
303:                   ovcamWriteRegister(MTX8,0x40);
009F2C  B3C401     MOV #0x40, W1
009F2E  B3C560     MOV #0x56, W0
009F30  07FF06     RCALL ovcamWriteRegister
304:                   ovcamWriteRegister(MTX9,0x40);
009F32  B3C401     MOV #0x40, W1
009F34  B3C570     MOV #0x57, W0
009F36  07FF03     RCALL ovcamWriteRegister
305:                   ovcamWriteRegister(MTXS,0x0D);
009F38  B3C0D1     MOV #0xD, W1
009F3A  B3C580     MOV #0x58, W0
009F3C  07FF00     RCALL ovcamWriteRegister
306:               
307:                   ovcamWriteRegister(0x8B,0xCC);
009F3E  B3CCC1     MOV #0xCC, W1
009F40  B3C8B0     MOV #0x8B, W0
009F42  07FEFD     RCALL ovcamWriteRegister
308:                   ovcamWriteRegister(0x8C,0xCC);
009F44  B3CCC1     MOV #0xCC, W1
009F46  B3C8C0     MOV #0x8C, W0
009F48  07FEFA     RCALL ovcamWriteRegister
309:                   ovcamWriteRegister(0x8D,0xCF);
009F4A  B3CCF1     MOV #0xCF, W1
009F4C  B3C8D0     MOV #0x8D, W0
009F4E  07FEF7     RCALL ovcamWriteRegister
310:               
311:                   // Gamma Curve
312:                   // GSP
313:                   ovcamWriteRegister(0x6C,0x40);
009F50  B3C401     MOV #0x40, W1
009F52  B3C6C0     MOV #0x6C, W0
009F54  07FEF4     RCALL ovcamWriteRegister
314:                   ovcamWriteRegister(0x6D,0x30);
009F56  B3C301     MOV #0x30, W1
009F58  B3C6D0     MOV #0x6D, W0
009F5A  07FEF1     RCALL ovcamWriteRegister
315:                   ovcamWriteRegister(0x6E,0x4B);
009F5C  B3C4B1     MOV #0x4B, W1
009F5E  B3C6E0     MOV #0x6E, W0
009F60  07FEEE     RCALL ovcamWriteRegister
316:                   ovcamWriteRegister(0x6F,0x60);
009F62  B3C601     MOV #0x60, W1
009F64  B3C6F0     MOV #0x6F, W0
009F66  07FEEB     RCALL ovcamWriteRegister
317:                   ovcamWriteRegister(0x70,0x70);
009F68  B3C701     MOV #0x70, W1
009F6A  B3C700     MOV #0x70, W0
009F6C  07FEE8     RCALL ovcamWriteRegister
318:                   ovcamWriteRegister(0x71,0x70);
009F6E  B3C701     MOV #0x70, W1
009F70  B3C710     MOV #0x71, W0
009F72  07FEE5     RCALL ovcamWriteRegister
319:                   ovcamWriteRegister(0x72,0x70);
009F74  B3C701     MOV #0x70, W1
009F76  B3C720     MOV #0x72, W0
009F78  07FEE2     RCALL ovcamWriteRegister
320:                   ovcamWriteRegister(0x73,0x70);
009F7A  B3C701     MOV #0x70, W1
009F7C  B3C730     MOV #0x73, W0
009F7E  07FEDF     RCALL ovcamWriteRegister
321:                   ovcamWriteRegister(0x74,0x60);
009F80  B3C601     MOV #0x60, W1
009F82  B3C740     MOV #0x74, W0
009F84  07FEDC     RCALL ovcamWriteRegister
322:                   ovcamWriteRegister(0x75,0x60);
009F86  B3C601     MOV #0x60, W1
009F88  B3C750     MOV #0x75, W0
009F8A  07FED9     RCALL ovcamWriteRegister
323:                   ovcamWriteRegister(0x76,0x50);
009F8C  B3C501     MOV #0x50, W1
009F8E  B3C760     MOV #0x76, W0
009F90  07FED6     RCALL ovcamWriteRegister
324:                   ovcamWriteRegister(0x77,0x48);
009F92  B3C481     MOV #0x48, W1
009F94  B3C770     MOV #0x77, W0
009F96  07FED3     RCALL ovcamWriteRegister
325:                   ovcamWriteRegister(0x78,0x3A);
009F98  B3C3A1     MOV #0x3A, W1
009F9A  B3C780     MOV #0x78, W0
009F9C  07FED0     RCALL ovcamWriteRegister
326:                   ovcamWriteRegister(0x79,0x2E);
009F9E  B3C2E1     MOV #0x2E, W1
009FA0  B3C790     MOV #0x79, W0
009FA2  07FECD     RCALL ovcamWriteRegister
327:                   ovcamWriteRegister(0x7A,0x28);
009FA4  B3C281     MOV #0x28, W1
009FA6  B3C7A0     MOV #0x7A, W0
009FA8  07FECA     RCALL ovcamWriteRegister
328:                   ovcamWriteRegister(0x7B,0x22);
009FAA  B3C221     MOV #0x22, W1
009FAC  B3C7B0     MOV #0x7B, W0
009FAE  07FEC7     RCALL ovcamWriteRegister
329:                   // GST
330:                   ovcamWriteRegister(0x7C,0x04);
009FB0  B3C041     MOV #0x4, W1
009FB2  B3C7C0     MOV #0x7C, W0
009FB4  07FEC4     RCALL ovcamWriteRegister
331:                   ovcamWriteRegister(0x7D,0x07);
009FB6  B3C071     MOV #0x7, W1
009FB8  B3C7D0     MOV #0x7D, W0
009FBA  07FEC1     RCALL ovcamWriteRegister
332:                   ovcamWriteRegister(0x7E,0x10);
009FBC  B3C101     MOV #0x10, W1
009FBE  B3C7E0     MOV #0x7E, W0
009FC0  07FEBE     RCALL ovcamWriteRegister
333:                   ovcamWriteRegister(0x7F,0x28);
009FC2  B3C281     MOV #0x28, W1
009FC4  B3C7F0     MOV #0x7F, W0
009FC6  07FEBB     RCALL ovcamWriteRegister
334:                   ovcamWriteRegister(0x80,0x36);
009FC8  B3C361     MOV #0x36, W1
009FCA  B3C800     MOV #0x80, W0
009FCC  07FEB8     RCALL ovcamWriteRegister
335:                   ovcamWriteRegister(0x81,0x44);
009FCE  B3C441     MOV #0x44, W1
009FD0  B3C810     MOV #0x81, W0
009FD2  07FEB5     RCALL ovcamWriteRegister
336:                   ovcamWriteRegister(0x82,0x52);
009FD4  B3C521     MOV #0x52, W1
009FD6  B3C820     MOV #0x82, W0
009FD8  07FEB2     RCALL ovcamWriteRegister
337:                   ovcamWriteRegister(0x83,0x60);
009FDA  B3C601     MOV #0x60, W1
009FDC  B3C830     MOV #0x83, W0
009FDE  07FEAF     RCALL ovcamWriteRegister
338:                   ovcamWriteRegister(0x84,0x6C);
009FE0  B3C6C1     MOV #0x6C, W1
009FE2  B3C840     MOV #0x84, W0
009FE4  07FEAC     RCALL ovcamWriteRegister
339:                   ovcamWriteRegister(0x85,0x78);
009FE6  B3C781     MOV #0x78, W1
009FE8  B3C850     MOV #0x85, W0
009FEA  07FEA9     RCALL ovcamWriteRegister
340:                   ovcamWriteRegister(0x86,0x8C);
009FEC  B3C8C1     MOV #0x8C, W1
009FEE  B3C860     MOV #0x86, W0
009FF0  07FEA6     RCALL ovcamWriteRegister
341:                   ovcamWriteRegister(0x87,0x9E);
009FF2  B3C9E1     MOV #0x9E, W1
009FF4  B3C870     MOV #0x87, W0
009FF6  07FEA3     RCALL ovcamWriteRegister
342:                   ovcamWriteRegister(0x88,0xBB);
009FF8  B3CBB1     MOV #0xBB, W1
009FFA  B3C880     MOV #0x88, W0
009FFC  07FEA0     RCALL ovcamWriteRegister
343:                   ovcamWriteRegister(0x89,0xD2);
009FFE  B3CD21     MOV #0xD2, W1
00A000  B3C890     MOV #0x89, W0
00A002  07FE9D     RCALL ovcamWriteRegister
344:                   ovcamWriteRegister(0x8A,0xE6);
00A004  B3CE61     MOV #0xE6, W1
00A006  B3C8A0     MOV #0x8A, W0
00A008  07FE9A     RCALL ovcamWriteRegister
345:               
346:                   ovcamWriteRegister(COM9,0x2E); // Automatic Gain Ceiling (AGC) is 4x + Drop frame policy
00A00A  B3C2E1     MOV #0x2E, W1
00A00C  B3C140     MOV #0x14, W0
00A00E  07FE97     RCALL ovcamWriteRegister
347:                   ovcamWriteRegister(AEW,0x68);
00A010  B3C681     MOV #0x68, W1
00A012  B3C240     MOV #0x24, W0
00A014  07FE94     RCALL ovcamWriteRegister
348:                   ovcamWriteRegister(AEB,0x58);
00A016  B3C581     MOV #0x58, W1
00A018  B3C250     MOV #0x25, W0
00A01A  07FE91     RCALL ovcamWriteRegister
349:               }
00A01C  FA8000     ULNK
00A01E  060000     RETURN
350:               
351:               // Sends a byte to the camera.
352:               //
353:               // Parameters : byte to send.
354:               static inline void ovcamWriteByte (unsigned char byte)
355:               {
00A020  FA0002     LNK #0x2
00A022  784F00     MOV.B W0, [W14]
356:                   I2C_TRN = byte;
00A024  78409E     MOV.B [W14], W1
00A026  FB8001     ZE W1, W0
00A028  881010     MOV W0, I2C1TRN
357:                   while(I2C_STATbits.TRSTAT);
00A02A  000000     NOP
00A02C  801041     MOV I2C1STAT, W1
00A02E  240000     MOV #0x4000, W0
00A030  608080     AND W1, W0, W1
00A032  EB0000     CLR W0
00A034  508F80     SUB W1, W0, [W15]
00A036  3AFFFA     BRA NZ, 0xA02C
358:                   ovcamWaitTillIdle();
00A038  070035     RCALL ovcamWaitTillIdle
359:                   while(I2C_STATbits.ACKSTAT);
00A03A  000000     NOP
00A03C  801041     MOV I2C1STAT, W1
00A03E  280000     MOV #0x8000, W0
00A040  608080     AND W1, W0, W1
00A042  EB0000     CLR W0
00A044  508F80     SUB W1, W0, [W15]
00A046  3AFFFA     BRA NZ, 0xA03C
360:               }
00A048  FA8000     ULNK
00A04A  060000     RETURN
361:               
362:               // Receives a byte from the camera.
363:               //
364:               // Returns : received byte.
365:               static inline unsigned char ovcamReadByte (void)
366:               {
00A04C  FA0000     LNK #0x0
367:                   I2C_CONbits.RCEN = 1;
00A04E  A86206     BSET I2C1CON, #3
368:                   while(I2C_CONbits.RCEN);
00A050  000000     NOP
00A052  801030     MOV I2C1CON, W0
00A054  6000E8     AND W0, #0x8, W1
00A056  EB0000     CLR W0
00A058  508F80     SUB W1, W0, [W15]
00A05A  3AFFFB     BRA NZ, 0xA052
369:                   I2C_STATbits.I2COV = 0;
00A05C  A9C208     BCLR I2C1STAT, #6
370:                   return(I2C_RCV);
00A05E  801000     MOV I2C1RCV, W0
00A060  784000     MOV.B W0, W0
371:               }
00A062  FA8000     ULNK
00A064  060000     RETURN
372:               
373:               // Sends NACK to the camera.
374:               static inline void ovcamNACK (void)
375:               {
00A066  FA0000     LNK #0x0
376:                   I2C_CONbits.ACKDT = 1;
00A068  A8A206     BSET I2C1CON, #5
377:                   I2C_CONbits.ACKEN = 1;
00A06A  A88206     BSET I2C1CON, #4
378:                   while(I2C_CONbits.ACKEN);
00A06C  000000     NOP
00A06E  801030     MOV I2C1CON, W0
00A070  6000F0     AND W0, #0x10, W1
00A072  EB0000     CLR W0
00A074  508F80     SUB W1, W0, [W15]
00A076  3AFFFB     BRA NZ, 0xA06E
379:               }
00A078  FA8000     ULNK
00A07A  060000     RETURN
380:               
381:               // Starts communication with the camera.
382:               static inline void ovcamStartTx (void)
383:               {
00A07C  FA0000     LNK #0x0
384:                   I2C_CONbits.SEN = 1;
00A07E  A80206     BSET I2C1CON, #0
385:                   while(I2C_CONbits.SEN);
00A080  000000     NOP
00A082  801030     MOV I2C1CON, W0
00A084  6000E1     AND W0, #0x1, W1
00A086  EB0000     CLR W0
00A088  508F80     SUB W1, W0, [W15]
00A08A  3AFFFB     BRA NZ, 0xA082
386:               }
00A08C  FA8000     ULNK
00A08E  060000     RETURN
387:               
388:               // Stops communication with the camera.
389:               static inline void ovcamStopTx (void)
390:               {
00A090  FA0000     LNK #0x0
391:                   I2C_CONbits.PEN = 1;
00A092  A84206     BSET I2C1CON, #2
392:                   while(I2C_CONbits.PEN);
00A094  000000     NOP
00A096  801030     MOV I2C1CON, W0
00A098  6000E4     AND W0, #0x4, W1
00A09A  EB0000     CLR W0
00A09C  508F80     SUB W1, W0, [W15]
00A09E  3AFFFB     BRA NZ, 0xA096
393:               }
00A0A0  FA8000     ULNK
00A0A2  060000     RETURN
394:               
395:               // Wait until I2C sus is inactive
396:               static inline void ovcamWaitTillIdle (void)
397:               {
00A0A4  FA0000     LNK #0x0
398:                   while(I2C_CONbits.SEN || I2C_CONbits.PEN || I2C_CONbits.RCEN ||
00A0A6  000000     NOP
00A0A8  801030     MOV I2C1CON, W0
00A0AA  6000E1     AND W0, #0x1, W1
00A0AC  EB0000     CLR W0
00A0AE  508F80     SUB W1, W0, [W15]
00A0B0  3AFFFB     BRA NZ, 0xA0A8
00A0B2  801030     MOV I2C1CON, W0
00A0B4  6000E4     AND W0, #0x4, W1
00A0B6  EB0000     CLR W0
00A0B8  508F80     SUB W1, W0, [W15]
00A0BA  3AFFF6     BRA NZ, 0xA0A8
00A0BC  801030     MOV I2C1CON, W0
00A0BE  6000E8     AND W0, #0x8, W1
00A0C0  EB0000     CLR W0
00A0C2  508F80     SUB W1, W0, [W15]
00A0C4  3AFFF1     BRA NZ, 0xA0A8
00A0C6  801030     MOV I2C1CON, W0
00A0C8  6000E2     AND W0, #0x2, W1
00A0CA  EB0000     CLR W0
00A0CC  508F80     SUB W1, W0, [W15]
00A0CE  3AFFEC     BRA NZ, 0xA0A8
399:                         I2C_CONbits.RSEN || I2C_CONbits.ACKEN || I2C_STATbits.TRSTAT);
00A0D0  801030     MOV I2C1CON, W0
00A0D2  6000F0     AND W0, #0x10, W1
00A0D4  EB0000     CLR W0
00A0D6  508F80     SUB W1, W0, [W15]
00A0D8  3AFFE7     BRA NZ, 0xA0A8
00A0DA  801041     MOV I2C1STAT, W1
00A0DC  240000     MOV #0x4000, W0
00A0DE  608080     AND W1, W0, W1
00A0E0  EB0000     CLR W0
00A0E2  508F80     SUB W1, W0, [W15]
00A0E4  3AFFE1     BRA NZ, 0xA0A8
400:               }
00A0E6  FA8000     ULNK
00A0E8  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/mac_packet.c  -----------------------------------------
1:                 /*
2:                  * Copyright (c) 2010-2011, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * IEEE 802.15.4 PPDU and MPDU Utilities
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu         2011-07-27    Initial implementation
38:                 *
39:                 * Notes:
40:                 *
41:                 * To Do:
42:                 *
43:                 */
44:                
45:                 #include "mac_packet.h"
46:                 #include "payload.h"
47:                 #include <stdlib.h>
48:                #include <string.h>
49:                
50:                 #define MAC_PHY_LEN_POS            (0)
51:                 #define MAC_FCF_LB_POS             (1)
52:                 #define MAC_FCF_HB_POS             (2)
53:                 #define MAC_SEQ_NUM_POS            (3)
54:                
55:                 #define MPDU_HEADER_BASE_LENGTH    (3)
56:                 #define MAC_CRC_LENGTH             (2)
57:                
58:                 MacPacket macCreateEmpty(void) {
008546  FA0002     LNK #0x2
59:                
60:                    MacPacket packet = (MacPacket)malloc(sizeof(MacPacketStruct));
008548  200140     MOV #0x14, W0
00854A  0233BA     CALL _malloc
00854C  000000     NOP
00854E  780F00     MOV W0, [W14]
61:                    if(packet == NULL) {
008550  78009E     MOV [W14], W1
008552  EB0000     CLR W0
008554  508F80     SUB W1, W0, [W15]
008556  3A0002     BRA NZ, 0x855C
62:                        return NULL;
008558  EB0000     CLR W0
00855A  37002A     BRA 0x85B0
63:                    }
64:                
65:                    // Default values
66:                    packet->frame_ctrl.bits.sec_en = MAC_SEC_DISABLED;
00855C  78001E     MOV [W14], W0
00855E  780110     MOV [W0], W2
008560  2FFF71     MOV #0xFFF7, W1
008562  610081     AND W2, W1, W1
008564  780801     MOV W1, [W0]
67:                    packet->frame_ctrl.bits.frm_pending = MAC_FRAME_COMPLETE;
008566  78001E     MOV [W14], W0
008568  780110     MOV [W0], W2
00856A  2FFEF1     MOV #0xFFEF, W1
00856C  610081     AND W2, W1, W1
00856E  780801     MOV W1, [W0]
68:                    packet->frame_ctrl.bits.ack_req = MAC_ACK_REQUIRED;
008570  78001E     MOV [W14], W0
008572  780110     MOV [W0], W2
008574  200201     MOV #0x20, W1
008576  710081     IOR W2, W1, W1
008578  780801     MOV W1, [W0]
69:                    packet->frame_ctrl.bits.pan_id_comp = MAC_INTRAPAN_ON;
00857A  78001E     MOV [W14], W0
00857C  780110     MOV [W0], W2
00857E  200401     MOV #0x40, W1
008580  710081     IOR W2, W1, W1
008582  780801     MOV W1, [W0]
70:                    packet->frame_ctrl.bits.dest_addr_mode = MAC_DEST_ADDR_MODE_16BIT;
008584  78001E     MOV [W14], W0
008586  780110     MOV [W0], W2
008588  2F3FF1     MOV #0xF3FF, W1
00858A  610101     AND W2, W1, W2
00858C  208001     MOV #0x800, W1
00858E  710081     IOR W2, W1, W1
008590  780801     MOV W1, [W0]
71:                    packet->frame_ctrl.bits.frm_version = MAC_FIRMWARE_2006;
008592  78001E     MOV [W14], W0
008594  780110     MOV [W0], W2
008596  2CFFF1     MOV #0xCFFF, W1
008598  610101     AND W2, W1, W2
00859A  210001     MOV #0x1000, W1
00859C  710081     IOR W2, W1, W1
00859E  780801     MOV W1, [W0]
72:                    packet->frame_ctrl.bits.src_addr_mode = MAC_SRC_ADDR_MODE_16BIT;
0085A0  78001E     MOV [W14], W0
0085A2  780110     MOV [W0], W2
0085A4  23FFF1     MOV #0x3FFF, W1
0085A6  610101     AND W2, W1, W2
0085A8  280001     MOV #0x8000, W1
0085AA  710081     IOR W2, W1, W1
0085AC  780801     MOV W1, [W0]
73:                
74:                    return packet;
0085AE  78001E     MOV [W14], W0
75:                
76:                }
0085B0  FA8000     ULNK
0085B2  060000     RETURN
77:                
78:                MacPacket macCreateDataPacket() {
0085B4  FA0002     LNK #0x2
79:                
80:                    MacPacket packet = macCreateEmpty();
0085B6  07FFC7     RCALL macCreateEmpty
0085B8  780F00     MOV W0, [W14]
81:                    if(packet == NULL) {
0085BA  78009E     MOV [W14], W1
0085BC  EB0000     CLR W0
0085BE  508F80     SUB W1, W0, [W15]
0085C0  3A0002     BRA NZ, 0x85C6
82:                        return NULL;
0085C2  EB0000     CLR W0
0085C4  370007     BRA 0x85D4
83:                    }
84:                    packet->frame_ctrl.bits.packet_type = MAC_PACKET_TYPE_DATA;
0085C6  78001E     MOV [W14], W0
0085C8  780110     MOV [W0], W2
0085CA  2FFF81     MOV #0xFFF8, W1
0085CC  610081     AND W2, W1, W1
0085CE  A00001     BSET W1, #0
0085D0  780801     MOV W1, [W0]
85:                    return packet;
0085D2  78001E     MOV [W14], W0
86:                
87:                }
0085D4  FA8000     ULNK
0085D6  060000     RETURN
88:                
89:                MacPacket macCreateBeaconPacket() {
0085D8  FA0002     LNK #0x2
90:                
91:                    MacPacket packet = macCreateEmpty();
0085DA  07FFB5     RCALL macCreateEmpty
0085DC  780F00     MOV W0, [W14]
92:                    if(packet == NULL) {
0085DE  78009E     MOV [W14], W1
0085E0  EB0000     CLR W0
0085E2  508F80     SUB W1, W0, [W15]
0085E4  3A0002     BRA NZ, 0x85EA
93:                        return NULL;
0085E6  EB0000     CLR W0
0085E8  370006     BRA 0x85F6
94:                    }
95:                    packet->frame_ctrl.bits.packet_type = MAC_PACKET_TYPE_BEACON;
0085EA  78001E     MOV [W14], W0
0085EC  780110     MOV [W0], W2
0085EE  2FFF81     MOV #0xFFF8, W1
0085F0  610081     AND W2, W1, W1
0085F2  780801     MOV W1, [W0]
96:                    return packet;
0085F4  78001E     MOV [W14], W0
97:                
98:                }
0085F6  FA8000     ULNK
0085F8  060000     RETURN
99:                
100:               MacPacket macCreateCommandPacket() {
0085FA  FA0002     LNK #0x2
101:               
102:                   MacPacket packet = macCreateEmpty();
0085FC  07FFA4     RCALL macCreateEmpty
0085FE  780F00     MOV W0, [W14]
103:                   if(packet == NULL) {
008600  78009E     MOV [W14], W1
008602  EB0000     CLR W0
008604  508F80     SUB W1, W0, [W15]
008606  3A0002     BRA NZ, 0x860C
104:                       return NULL;
008608  EB0000     CLR W0
00860A  370007     BRA 0x861A
105:                   }
106:                   packet->frame_ctrl.bits.packet_type = MAC_PACKET_TYPE_COMMAND;
00860C  78001E     MOV [W14], W0
00860E  780110     MOV [W0], W2
008610  2FFF81     MOV #0xFFF8, W1
008612  610081     AND W2, W1, W1
008614  B30031     IOR #0x3, W1
008616  780801     MOV W1, [W0]
107:                   return packet;
008618  78001E     MOV [W14], W0
108:               
109:               }
00861A  FA8000     ULNK
00861C  060000     RETURN
110:               
111:               void macDeletePacket(MacPacket packet) {
00861E  FA0002     LNK #0x2
008620  780F00     MOV W0, [W14]
112:               
113:                   free(packet);
008622  78001E     MOV [W14], W0
008624  0234EC     CALL _free
008626  000000     NOP
114:               
115:               }
008628  FA8000     ULNK
00862A  060000     RETURN
116:               
117:               void macSetSeqNum(MacPacket packet, char seq_num) {
00862C  FA0004     LNK #0x4
00862E  780F00     MOV W0, [W14]
008630  984721     MOV.B W1, [W14+2]
118:               
119:                   packet->seq_num = seq_num;
008632  90402E     MOV.B [W14+2], W0
008634  78009E     MOV [W14], W1
008636  9840A0     MOV.B W0, [W1+2]
120:               
121:               }
008638  FA8000     ULNK
00863A  060000     RETURN
122:               
123:               void macSetDestAddr(MacPacket packet, unsigned int dest_addr) {
00863C  FA0004     LNK #0x4
00863E  780F00     MOV W0, [W14]
008640  980711     MOV W1, [W14+2]
124:               
125:                   packet->dest_addr.val = dest_addr;
008642  78001E     MOV [W14], W0
008644  90009E     MOV [W14+2], W1
008646  980031     MOV W1, [W0+6]
126:               
127:               }
008648  FA8000     ULNK
00864A  060000     RETURN
128:               
129:               void macSetDestPan(MacPacket packet, unsigned int dest_pan) {
00864C  FA0004     LNK #0x4
00864E  780F00     MOV W0, [W14]
008650  980711     MOV W1, [W14+2]
130:               
131:                   packet->dest_pan_id.val = dest_pan;
008652  78001E     MOV [W14], W0
008654  90009E     MOV [W14+2], W1
008656  980021     MOV W1, [W0+4]
132:               
133:               }
008658  FA8000     ULNK
00865A  060000     RETURN
134:               
135:               void macSetSrc(MacPacket packet, unsigned int src_pan_id, unsigned int src_addr) {
00865C  FA0006     LNK #0x6
00865E  780F00     MOV W0, [W14]
008660  980711     MOV W1, [W14+2]
008662  980722     MOV W2, [W14+4]
136:               
137:                   packet->src_pan_id.val = src_pan_id;
008664  78001E     MOV [W14], W0
008666  90009E     MOV [W14+2], W1
008668  980041     MOV W1, [W0+8]
138:                   packet->src_addr.val = src_addr;
00866A  78001E     MOV [W14], W0
00866C  9000AE     MOV [W14+4], W1
00866E  980051     MOV W1, [W0+10]
139:               
140:               }
008670  FA8000     ULNK
008672  060000     RETURN
141:               
142:               unsigned int macGetSrcAddr(MacPacket packet) {
008674  FA0002     LNK #0x2
008676  780F00     MOV W0, [W14]
143:               
144:                   return packet->src_addr.val;
008678  78001E     MOV [W14], W0
00867A  900050     MOV [W0+10], W0
145:               
146:               }
00867C  FA8000     ULNK
00867E  060000     RETURN
147:               
148:               unsigned int macGetSrcPan(MacPacket packet) {
008680  FA0004     LNK #0x4
008682  980710     MOV W0, [W14+2]
149:               
150:                   unsigned char src_pan_compression;
151:               
152:                   src_pan_compression = packet->frame_ctrl.bits.src_addr_mode
008684  90001E     MOV [W14+2], W0
008686  780090     MOV [W0], W1
008688  2C0000     MOV #0xC000, W0
00868A  608080     AND W1, W0, W1
00868C  EB0000     CLR W0
00868E  508F80     SUB W1, W0, [W15]
008690  320010     BRA Z, 0x86B2
0086AE  200010     MOV #0x1, W0
0086B0  370001     BRA 0x86B4
0086B2  EB0000     CLR W0
0086B4  784F00     MOV.B W0, [W14]
153:                       && packet->frame_ctrl.bits.dest_addr_mode && packet->frame_ctrl.bits.pan_id_comp;
008692  90001E     MOV [W14+2], W0
008694  780090     MOV [W0], W1
008696  20C000     MOV #0xC00, W0
008698  608080     AND W1, W0, W1
00869A  EB0000     CLR W0
00869C  508F80     SUB W1, W0, [W15]
00869E  320009     BRA Z, 0x86B2
0086A0  90001E     MOV [W14+2], W0
0086A2  780090     MOV [W0], W1
0086A4  200400     MOV #0x40, W0
0086A6  608080     AND W1, W0, W1
0086A8  EB0000     CLR W0
0086AA  508F80     SUB W1, W0, [W15]
0086AC  320002     BRA Z, 0x86B2
154:               
155:                   if(src_pan_compression) {
0086B6  78409E     MOV.B [W14], W1
0086B8  EB4000     CLR.B W0
0086BA  50CF80     SUB.B W1, W0, [W15]
0086BC  320003     BRA Z, 0x86C4
156:                       return packet->dest_pan_id.val;
0086BE  90001E     MOV [W14+2], W0
0086C0  900020     MOV [W0+4], W0
0086C2  370002     BRA 0x86C8
157:                   }
158:                   return packet->src_pan_id.val;
0086C4  90001E     MOV [W14+2], W0
0086C6  900040     MOV [W0+8], W0
159:               }
0086C8  FA8000     ULNK
0086CA  060000     RETURN
160:               
161:               void macSetPayload(MacPacket packet, Payload pld) {
0086CC  FA0004     LNK #0x4
0086CE  780F00     MOV W0, [W14]
0086D0  980711     MOV W1, [W14+2]
162:               
163:                   packet->payload = pld;
0086D2  78001E     MOV [W14], W0
0086D4  90009E     MOV [W14+2], W1
0086D6  980061     MOV W1, [W0+12]
164:                   packet->payload_length = payGetPayloadLength(pld);
0086D8  90001E     MOV [W14+2], W0
0086DA  02CAC4     CALL payGetPayloadLength
0086DC  000000     NOP
0086DE  78009E     MOV [W14], W1
0086E0  9848E0     MOV.B W0, [W1+14]
165:               
166:               }
0086E2  FA8000     ULNK
0086E4  060000     RETURN
167:               
168:               Payload macGetPayload(MacPacket packet) {
0086E6  FA0002     LNK #0x2
0086E8  780F00     MOV W0, [W14]
169:               
170:                   return packet->payload;
0086EA  78001E     MOV [W14], W0
0086EC  900060     MOV [W0+12], W0
171:               
172:               }
0086EE  FA8000     ULNK
0086F0  060000     RETURN
173:               
174:               unsigned int macReadPhyLength(unsigned char* frame) {
0086F2  FA0002     LNK #0x2
0086F4  780F00     MOV W0, [W14]
175:               
176:                   return frame[0];
0086F6  78001E     MOV [W14], W0
0086F8  784010     MOV.B [W0], W0
0086FA  FB8000     ZE W0, W0
177:               
178:               }
0086FC  FA8000     ULNK
0086FE  060000     RETURN
179:               
180:               unsigned int macReadDataLength(unsigned char* frame) {
008700  FA001A     LNK #0x1A
008702  980F40     MOV W0, [W14+24]
181:               
182:                   MacPacketStruct packet;
183:                   unsigned char header_length, phy_length, src_pan_compression;
184:               
185:                   header_length = MPDU_HEADER_BASE_LENGTH; // Account for phy_length and frame_ctrl bytes
008704  B3C030     MOV #0x3, W0
008706  784F00     MOV.B W0, [W14]
186:                   phy_length = frame[MAC_PHY_LEN_POS]; // Read PHY payload length from PPDU
008708  90084E     MOV [W14+24], W0
00870A  784090     MOV.B [W0], W1
00870C  984711     MOV.B W1, [W14+1]
187:                   packet.frame_ctrl.val.byte.LB = frame[MAC_FCF_LB_POS];
00870E  90084E     MOV [W14+24], W0
008710  E80000     INC W0, W0
008712  784010     MOV.B [W0], W0
008714  4700E4     ADD W14, #0x4, W1
008716  784880     MOV.B W0, [W1]
188:                   packet.frame_ctrl.val.byte.HB = frame[MAC_FCF_HB_POS];
008718  90084E     MOV [W14+24], W0
00871A  E88000     INC2 W0, W0
00871C  784010     MOV.B [W0], W0
00871E  4700E4     ADD W14, #0x4, W1
008720  984090     MOV.B W0, [W1+1]
189:               
190:                   if(packet.frame_ctrl.bits.dest_addr_mode == MAC_DEST_ADDR_MODE_NONE) {
008722  470064     ADD W14, #0x4, W0
008724  780090     MOV [W0], W1
008726  20C000     MOV #0xC00, W0
008728  608080     AND W1, W0, W1
00872A  EB0000     CLR W0
00872C  508F80     SUB W1, W0, [W15]
00872E  320014     BRA Z, 0x8758
191:                       header_length += 0; // No destination address
008758  000000     NOP
192:                   } else if(packet.frame_ctrl.bits.dest_addr_mode == MAC_DEST_ADDR_MODE_16BIT) {
008730  470064     ADD W14, #0x4, W0
008732  780090     MOV [W0], W1
008734  20C000     MOV #0xC00, W0
008736  608080     AND W1, W0, W1
008738  208000     MOV #0x800, W0
00873A  508F80     SUB W1, W0, [W15]
00873C  3A0003     BRA NZ, 0x8744
193:                       header_length += 4; // Destination address + PAN
00873E  78411E     MOV.B [W14], W2
008740  414F64     ADD.B W2, #0x4, [W14]
008742  37000B     BRA 0x875A
194:                   } else if(packet.frame_ctrl.bits.dest_addr_mode == MAC_DEST_ADDR_MODE_64BIT) {
008744  470064     ADD W14, #0x4, W0
008746  780090     MOV [W0], W1
008748  20C000     MOV #0xC00, W0
00874A  608080     AND W1, W0, W1
00874C  20C000     MOV #0xC00, W0
00874E  508F80     SUB W1, W0, [W15]
008750  3A0004     BRA NZ, 0x875A
195:                       header_length += 10; // Destination address + PAN
008752  78401E     MOV.B [W14], W0
008754  404F6A     ADD.B W0, #0xA, [W14]
008756  370001     BRA 0x875A
196:                   }
197:               
198:                   // If both addresses are present and intra-PAN mode is on, source PAN is dropped
199:                   src_pan_compression = packet.frame_ctrl.bits.src_addr_mode
00875A  470064     ADD W14, #0x4, W0
00875C  780090     MOV [W0], W1
00875E  2C0000     MOV #0xC000, W0
008760  608080     AND W1, W0, W1
008762  EB0000     CLR W0
008764  508F80     SUB W1, W0, [W15]
008766  320010     BRA Z, 0x8788
008784  200010     MOV #0x1, W0
008786  370001     BRA 0x878A
008788  EB0000     CLR W0
00878A  984720     MOV.B W0, [W14+2]
200:                       && packet.frame_ctrl.bits.dest_addr_mode && packet.frame_ctrl.bits.pan_id_comp;
008768  470064     ADD W14, #0x4, W0
00876A  780090     MOV [W0], W1
00876C  20C000     MOV #0xC00, W0
00876E  608080     AND W1, W0, W1
008770  EB0000     CLR W0
008772  508F80     SUB W1, W0, [W15]
008774  320009     BRA Z, 0x8788
008776  470064     ADD W14, #0x4, W0
008778  780090     MOV [W0], W1
00877A  200400     MOV #0x40, W0
00877C  608080     AND W1, W0, W1
00877E  EB0000     CLR W0
008780  508F80     SUB W1, W0, [W15]
008782  320002     BRA Z, 0x8788
201:               
202:                   if(packet.frame_ctrl.bits.src_addr_mode == MAC_SRC_ADDR_MODE_NONE) {
00878C  470064     ADD W14, #0x4, W0
00878E  780090     MOV [W0], W1
008790  2C0000     MOV #0xC000, W0
008792  608080     AND W1, W0, W1
008794  EB0000     CLR W0
008796  508F80     SUB W1, W0, [W15]
008798  320021     BRA Z, 0x87DC
203:                       header_length += 0; // No source address
0087DC  000000     NOP
204:                   } else if(packet.frame_ctrl.bits.src_addr_mode == MAC_SRC_ADDR_MODE_16BIT) {
00879A  470064     ADD W14, #0x4, W0
00879C  780090     MOV [W0], W1
00879E  2C0000     MOV #0xC000, W0
0087A0  608080     AND W1, W0, W1
0087A2  280000     MOV #0x8000, W0
0087A4  508F80     SUB W1, W0, [W15]
0087A6  3A0009     BRA NZ, 0x87BA
205:                       if(src_pan_compression) {
0087A8  9040AE     MOV.B [W14+2], W1
0087AA  EB4000     CLR.B W0
0087AC  50CF80     SUB.B W1, W0, [W15]
0087AE  3A0002     BRA NZ, 0x87B4
206:                           header_length += 0; // No source PAN
0087B4  000000     NOP
207:                       } else {
208:                           header_length += 2; // Source pan included
0087B0  E8CF1E     INC2.B [W14], [W14]
0087B2  370001     BRA 0x87B6
209:                       }
210:                       header_length += 2; // Plus source address
0087B6  E8CF1E     INC2.B [W14], [W14]
0087B8  370012     BRA 0x87DE
211:                   }
212:                   else if(packet.frame_ctrl.bits.src_addr_mode == MAC_SRC_ADDR_MODE_64BIT) {
0087BA  470064     ADD W14, #0x4, W0
0087BC  780090     MOV [W0], W1
0087BE  2C0000     MOV #0xC000, W0
0087C0  608080     AND W1, W0, W1
0087C2  2C0000     MOV #0xC000, W0
0087C4  508F80     SUB W1, W0, [W15]
0087C6  3A000B     BRA NZ, 0x87DE
213:                       if(src_pan_compression) {
0087C8  9040AE     MOV.B [W14+2], W1
0087CA  EB4000     CLR.B W0
0087CC  50CF80     SUB.B W1, W0, [W15]
0087CE  3A0002     BRA NZ, 0x87D4
214:                           header_length += 0; // No source PAN
0087D4  000000     NOP
215:                       } else {
216:                           header_length += 2; // Source pan included
0087D0  E8CF1E     INC2.B [W14], [W14]
0087D2  370001     BRA 0x87D6
217:                       }
218:                       header_length += 8; // Plus source address
0087D6  78409E     MOV.B [W14], W1
0087D8  40CF68     ADD.B W1, #0x8, [W14]
0087DA  370001     BRA 0x87DE
219:                   }
220:               
221:                   return phy_length - header_length - MAC_CRC_LENGTH; // Calculate payload length
0087DE  90401E     MOV.B [W14+1], W0
0087E0  FB8080     ZE W0, W1
0087E2  78411E     MOV.B [W14], W2
0087E4  FB8002     ZE W2, W0
0087E6  508000     SUB W1, W0, W0
0087E8  E98000     DEC2 W0, W0
222:               
223:               }
0087EA  FA8000     ULNK
0087EC  060000     RETURN
224:               
225:               unsigned int macReadFrame(unsigned char* frame, MacPacket packet) {
0087EE  FA000C     LNK #0xC
0087F0  781F88     MOV W8, [W15++]
0087F2  980740     MOV W0, [W14+8]
0087F4  980751     MOV W1, [W14+10]
226:               
227:                   unsigned char i, header_length, phy_length, src_pan_compression;
228:                   unsigned int data_length;
229:                   Payload pld;
230:               
231:                   if(packet == NULL) { return 0; }
0087F6  9000DE     MOV [W14+10], W1
0087F8  EB0000     CLR W0
0087FA  508F80     SUB W1, W0, [W15]
0087FC  3A0002     BRA NZ, 0x8802
0087FE  EB0000     CLR W0
008800  37011D     BRA 0x8A3C
232:                   pld = macGetPayload(packet);
008802  90005E     MOV [W14+10], W0
008804  07FF70     RCALL macGetPayload
008806  980710     MOV W0, [W14+2]
233:                   if(pld == NULL) { return 0; }
008808  90009E     MOV [W14+2], W1
00880A  EB0000     CLR W0
00880C  508F80     SUB W1, W0, [W15]
00880E  3A0002     BRA NZ, 0x8814
008810  EB0000     CLR W0
008812  370114     BRA 0x8A3C
234:               
235:                   header_length = MPDU_HEADER_BASE_LENGTH;
008814  B3C030     MOV #0x3, W0
008816  984710     MOV.B W0, [W14+1]
236:                   phy_length = frame[MAC_PHY_LEN_POS]; // Read PHY payload length from PPDU
008818  90004E     MOV [W14+8], W0
00881A  784090     MOV.B [W0], W1
00881C  984741     MOV.B W1, [W14+4]
237:                   packet->frame_ctrl.val.byte.LB = frame[MAC_FCF_LB_POS];
00881E  90004E     MOV [W14+8], W0
008820  E80000     INC W0, W0
008822  784010     MOV.B [W0], W0
008824  9000DE     MOV [W14+10], W1
008826  784880     MOV.B W0, [W1]
238:                   packet->frame_ctrl.val.byte.HB = frame[MAC_FCF_HB_POS];
008828  90004E     MOV [W14+8], W0
00882A  E88000     INC2 W0, W0
00882C  784010     MOV.B [W0], W0
00882E  9000DE     MOV [W14+10], W1
008830  984090     MOV.B W0, [W1+1]
239:                   packet->seq_num = frame[MAC_SEQ_NUM_POS];
008832  90004E     MOV [W14+8], W0
008834  400063     ADD W0, #0x3, W0
008836  784010     MOV.B [W0], W0
008838  9000DE     MOV [W14+10], W1
00883A  9840A0     MOV.B W0, [W1+2]
240:               
241:                   i = MAC_SEQ_NUM_POS + 1; // Begin counting bytes
00883C  B3C040     MOV #0x4, W0
00883E  784F00     MOV.B W0, [W14]
242:               
243:                   // Read destination addresses
244:                   if(packet->frame_ctrl.bits.dest_addr_mode == MAC_DEST_ADDR_MODE_NONE) {
008840  90005E     MOV [W14+10], W0
008842  780090     MOV [W0], W1
008844  20C000     MOV #0xC00, W0
008846  608080     AND W1, W0, W1
008848  EB0000     CLR W0
00884A  508F80     SUB W1, W0, [W15]
00884C  3A000D     BRA NZ, 0x8868
245:                       packet->dest_pan_id.byte.LB = 0;
00884E  9000DE     MOV [W14+10], W1
008850  EB4000     CLR.B W0
008852  9840C0     MOV.B W0, [W1+4]
246:                       packet->dest_pan_id.byte.HB = 0;
008854  9000DE     MOV [W14+10], W1
008856  EB4000     CLR.B W0
008858  9840D0     MOV.B W0, [W1+5]
247:                       packet->dest_addr.byte.LB = 0;
00885A  9000DE     MOV [W14+10], W1
00885C  EB4000     CLR.B W0
00885E  9840E0     MOV.B W0, [W1+6]
248:                       packet->dest_addr.byte.HB = 0;
008860  9000DE     MOV [W14+10], W1
008862  EB4000     CLR.B W0
008864  9840F0     MOV.B W0, [W1+7]
008866  370041     BRA 0x88EA
249:                   } else if(packet->frame_ctrl.bits.dest_addr_mode == MAC_DEST_ADDR_MODE_16BIT) {
008868  90005E     MOV [W14+10], W0
00886A  780090     MOV [W0], W1
00886C  20C000     MOV #0xC00, W0
00886E  608080     AND W1, W0, W1
008870  208000     MOV #0x800, W0
008872  508F80     SUB W1, W0, [W15]
008874  3A0024     BRA NZ, 0x88BE
250:                       header_length += 4;
008876  90401E     MOV.B [W14+1], W0
008878  404064     ADD.B W0, #0x4, W0
00887A  984710     MOV.B W0, [W14+1]
251:                       packet->dest_pan_id.byte.LB = frame[i++];
00887C  78409E     MOV.B [W14], W1
00887E  FB8001     ZE W1, W0
008880  9000CE     MOV [W14+8], W1
008882  408000     ADD W1, W0, W0
008884  784010     MOV.B [W0], W0
008886  9000DE     MOV [W14+10], W1
008888  9840C0     MOV.B W0, [W1+4]
00888A  E84F1E     INC.B [W14], [W14]
252:                       packet->dest_pan_id.byte.HB = frame[i++];
00888C  78409E     MOV.B [W14], W1
00888E  FB8001     ZE W1, W0
008890  9000CE     MOV [W14+8], W1
008892  408000     ADD W1, W0, W0
008894  784010     MOV.B [W0], W0
008896  9000DE     MOV [W14+10], W1
008898  9840D0     MOV.B W0, [W1+5]
00889A  E84F1E     INC.B [W14], [W14]
253:                       packet->dest_addr.byte.LB = frame[i++];
00889C  78409E     MOV.B [W14], W1
00889E  FB8001     ZE W1, W0
0088A0  9000CE     MOV [W14+8], W1
0088A2  408000     ADD W1, W0, W0
0088A4  784010     MOV.B [W0], W0
0088A6  9000DE     MOV [W14+10], W1
0088A8  9840E0     MOV.B W0, [W1+6]
0088AA  E84F1E     INC.B [W14], [W14]
254:                       packet->dest_addr.byte.HB = frame[i++];
0088AC  78409E     MOV.B [W14], W1
0088AE  FB8001     ZE W1, W0
0088B0  9000CE     MOV [W14+8], W1
0088B2  408000     ADD W1, W0, W0
0088B4  784010     MOV.B [W0], W0
0088B6  9000DE     MOV [W14+10], W1
0088B8  9840F0     MOV.B W0, [W1+7]
0088BA  E84F1E     INC.B [W14], [W14]
0088BC  370016     BRA 0x88EA
255:                   } else if(packet->frame_ctrl.bits.dest_addr_mode == MAC_DEST_ADDR_MODE_64BIT) {
0088BE  90005E     MOV [W14+10], W0
0088C0  780090     MOV [W0], W1
0088C2  20C000     MOV #0xC00, W0
0088C4  608080     AND W1, W0, W1
0088C6  20C000     MOV #0xC00, W0
0088C8  508F80     SUB W1, W0, [W15]
0088CA  3A000F     BRA NZ, 0x88EA
256:                       // Not supported by packet object yet!
257:                       packet->dest_pan_id.byte.LB = 0;
0088CC  9000DE     MOV [W14+10], W1
0088CE  EB4000     CLR.B W0
0088D0  9840C0     MOV.B W0, [W1+4]
258:                       packet->dest_pan_id.byte.HB = 0;
0088D2  9000DE     MOV [W14+10], W1
0088D4  EB4000     CLR.B W0
0088D6  9840D0     MOV.B W0, [W1+5]
259:                       packet->dest_addr.byte.LB = 0;
0088D8  9000DE     MOV [W14+10], W1
0088DA  EB4000     CLR.B W0
0088DC  9840E0     MOV.B W0, [W1+6]
260:                       packet->dest_addr.byte.HB = 0;
0088DE  9000DE     MOV [W14+10], W1
0088E0  EB4000     CLR.B W0
0088E2  9840F0     MOV.B W0, [W1+7]
261:                       header_length += 10;
0088E4  90401E     MOV.B [W14+1], W0
0088E6  40406A     ADD.B W0, #0xA, W0
0088E8  984710     MOV.B W0, [W14+1]
262:                   }
263:               
264:                   // If both addresses are present and intra-PAN mode is on, source PAN is dropped
265:                   src_pan_compression = packet->frame_ctrl.bits.src_addr_mode
0088EA  90005E     MOV [W14+10], W0
0088EC  780090     MOV [W0], W1
0088EE  2C0000     MOV #0xC000, W0
0088F0  608080     AND W1, W0, W1
0088F2  EB0000     CLR W0
0088F4  508F80     SUB W1, W0, [W15]
0088F6  320010     BRA Z, 0x8918
008914  200010     MOV #0x1, W0
008916  370001     BRA 0x891A
008918  EB0000     CLR W0
00891A  984750     MOV.B W0, [W14+5]
266:                       && packet->frame_ctrl.bits.dest_addr_mode && packet->frame_ctrl.bits.pan_id_comp;
0088F8  90005E     MOV [W14+10], W0
0088FA  780090     MOV [W0], W1
0088FC  20C000     MOV #0xC00, W0
0088FE  608080     AND W1, W0, W1
008900  EB0000     CLR W0
008902  508F80     SUB W1, W0, [W15]
008904  320009     BRA Z, 0x8918
008906  90005E     MOV [W14+10], W0
008908  780090     MOV [W0], W1
00890A  200400     MOV #0x40, W0
00890C  608080     AND W1, W0, W1
00890E  EB0000     CLR W0
008910  508F80     SUB W1, W0, [W15]
008912  320002     BRA Z, 0x8918
267:               
268:                   // Read source addresses
269:                   if(packet->frame_ctrl.bits.src_addr_mode == MAC_SRC_ADDR_MODE_NONE) {
00891C  90005E     MOV [W14+10], W0
00891E  780090     MOV [W0], W1
008920  2C0000     MOV #0xC000, W0
008922  608080     AND W1, W0, W1
008924  EB0000     CLR W0
008926  508F80     SUB W1, W0, [W15]
008928  3A000D     BRA NZ, 0x8944
270:                       packet->src_pan_id.byte.LB = 0;
00892A  9000DE     MOV [W14+10], W1
00892C  EB4000     CLR.B W0
00892E  984880     MOV.B W0, [W1+8]
271:                       packet->src_pan_id.byte.HB = 0;
008930  9000DE     MOV [W14+10], W1
008932  EB4000     CLR.B W0
008934  984890     MOV.B W0, [W1+9]
272:                       packet->src_addr.byte.LB = 0;
008936  9000DE     MOV [W14+10], W1
008938  EB4000     CLR.B W0
00893A  9848A0     MOV.B W0, [W1+10]
273:                       packet->src_addr.byte.HB = 0;
00893C  9000DE     MOV [W14+10], W1
00893E  EB4000     CLR.B W0
008940  9848B0     MOV.B W0, [W1+11]
008942  370061     BRA 0x8A06
274:                   } else if(packet->frame_ctrl.bits.src_addr_mode == MAC_SRC_ADDR_MODE_16BIT) {
008944  90005E     MOV [W14+10], W0
008946  780090     MOV [W0], W1
008948  2C0000     MOV #0xC000, W0
00894A  608080     AND W1, W0, W1
00894C  280000     MOV #0x8000, W0
00894E  508F80     SUB W1, W0, [W15]
008950  3A0032     BRA NZ, 0x89B6
275:                       if(src_pan_compression) {
008952  9040DE     MOV.B [W14+5], W1
008954  EB4000     CLR.B W0
008956  50CF80     SUB.B W1, W0, [W15]
008958  320007     BRA Z, 0x8968
276:                           header_length += 0;
277:                           packet->src_pan_id.byte.LB = 0; //packet->dest_pan_id.byte.LB;
00895A  9000DE     MOV [W14+10], W1
00895C  EB4000     CLR.B W0
00895E  984880     MOV.B W0, [W1+8]
278:                           packet->src_pan_id.byte.HB = 0; //packet->dest_pan_id.byte.HB;
008960  9000DE     MOV [W14+10], W1
008962  EB4000     CLR.B W0
008964  984890     MOV.B W0, [W1+9]
008966  370013     BRA 0x898E
279:                       } else {
280:                           header_length += 2;
008968  90401E     MOV.B [W14+1], W0
00896A  E8C000     INC2.B W0, W0
00896C  984710     MOV.B W0, [W14+1]
281:                           packet->src_pan_id.byte.LB = frame[i++];
00896E  78409E     MOV.B [W14], W1
008970  FB8001     ZE W1, W0
008972  9000CE     MOV [W14+8], W1
008974  408000     ADD W1, W0, W0
008976  784010     MOV.B [W0], W0
008978  9000DE     MOV [W14+10], W1
00897A  984880     MOV.B W0, [W1+8]
00897C  E84F1E     INC.B [W14], [W14]
282:                           packet->src_pan_id.byte.HB = frame[i++];
00897E  78409E     MOV.B [W14], W1
008980  FB8001     ZE W1, W0
008982  9000CE     MOV [W14+8], W1
008984  408000     ADD W1, W0, W0
008986  784010     MOV.B [W0], W0
008988  9000DE     MOV [W14+10], W1
00898A  984890     MOV.B W0, [W1+9]
00898C  E84F1E     INC.B [W14], [W14]
283:                       }
284:                       header_length += 2;
00898E  90401E     MOV.B [W14+1], W0
008990  E8C000     INC2.B W0, W0
008992  984710     MOV.B W0, [W14+1]
285:                       packet->src_addr.byte.LB = frame[i++];
008994  78409E     MOV.B [W14], W1
008996  FB8001     ZE W1, W0
008998  9000CE     MOV [W14+8], W1
00899A  408000     ADD W1, W0, W0
00899C  784010     MOV.B [W0], W0
00899E  9000DE     MOV [W14+10], W1
0089A0  9848A0     MOV.B W0, [W1+10]
0089A2  E84F1E     INC.B [W14], [W14]
286:                       packet->src_addr.byte.HB = frame[i++];
0089A4  78409E     MOV.B [W14], W1
0089A6  FB8001     ZE W1, W0
0089A8  9000CE     MOV [W14+8], W1
0089AA  408000     ADD W1, W0, W0
0089AC  784010     MOV.B [W0], W0
0089AE  9000DE     MOV [W14+10], W1
0089B0  9848B0     MOV.B W0, [W1+11]
0089B2  E84F1E     INC.B [W14], [W14]
0089B4  370028     BRA 0x8A06
287:                   }
288:                   else if(packet->frame_ctrl.bits.src_addr_mode == MAC_SRC_ADDR_MODE_64BIT) {
0089B6  90005E     MOV [W14+10], W0
0089B8  780090     MOV [W0], W1
0089BA  2C0000     MOV #0xC000, W0
0089BC  608080     AND W1, W0, W1
0089BE  2C0000     MOV #0xC000, W0
0089C0  508F80     SUB W1, W0, [W15]
0089C2  3A0021     BRA NZ, 0x8A06
289:                       // Not supported by packet object yet!
290:                       if(src_pan_compression) {
0089C4  9040DE     MOV.B [W14+5], W1
0089C6  EB4000     CLR.B W0
0089C8  50CF80     SUB.B W1, W0, [W15]
0089CA  320007     BRA Z, 0x89DA
291:                           header_length += 0;
292:                           packet->src_pan_id.byte.LB = 0;
0089CC  9000DE     MOV [W14+10], W1
0089CE  EB4000     CLR.B W0
0089D0  984880     MOV.B W0, [W1+8]
293:                           packet->src_pan_id.byte.HB = 0;
0089D2  9000DE     MOV [W14+10], W1
0089D4  EB4000     CLR.B W0
0089D6  984890     MOV.B W0, [W1+9]
0089D8  370013     BRA 0x8A00
294:                       } else {
295:                           header_length += 2;
0089DA  90401E     MOV.B [W14+1], W0
0089DC  E8C000     INC2.B W0, W0
0089DE  984710     MOV.B W0, [W14+1]
296:                           packet->src_pan_id.byte.LB = frame[i++];
0089E0  78409E     MOV.B [W14], W1
0089E2  FB8001     ZE W1, W0
0089E4  9000CE     MOV [W14+8], W1
0089E6  408000     ADD W1, W0, W0
0089E8  784010     MOV.B [W0], W0
0089EA  9000DE     MOV [W14+10], W1
0089EC  984880     MOV.B W0, [W1+8]
0089EE  E84F1E     INC.B [W14], [W14]
297:                           packet->src_pan_id.byte.HB = frame[i++];
0089F0  78409E     MOV.B [W14], W1
0089F2  FB8001     ZE W1, W0
0089F4  9000CE     MOV [W14+8], W1
0089F6  408000     ADD W1, W0, W0
0089F8  784010     MOV.B [W0], W0
0089FA  9000DE     MOV [W14+10], W1
0089FC  984890     MOV.B W0, [W1+9]
0089FE  E84F1E     INC.B [W14], [W14]
298:                       }
299:                       header_length += 8;
008A00  90401E     MOV.B [W14+1], W0
008A02  404068     ADD.B W0, #0x8, W0
008A04  984710     MOV.B W0, [W14+1]
300:                   }
301:               
302:                   data_length = phy_length - header_length - MAC_CRC_LENGTH; // Calculate payload length
008A06  90404E     MOV.B [W14+4], W0
008A08  FB8080     ZE W0, W1
008A0A  90401E     MOV.B [W14+1], W0
008A0C  FB8000     ZE W0, W0
008A0E  508000     SUB W1, W0, W0
008A10  E98000     DEC2 W0, W0
008A12  980730     MOV W0, [W14+6]
303:               
304:                   memcpy(payToString(pld), frame + i, data_length);
008A14  78409E     MOV.B [W14], W1
008A16  FB8001     ZE W1, W0
008A18  9000CE     MOV [W14+8], W1
008A1A  408400     ADD W1, W0, W8
008A1C  90001E     MOV [W14+2], W0
008A1E  02CA34     CALL payToString
008A20  000000     NOP
008A22  90013E     MOV [W14+6], W2
008A24  780088     MOV W8, W1
008A26  023582     CALL _memcpy
008A28  000000     NOP
305:               
306:                   pld->data_length = data_length - PAYLOAD_HEADER_LENGTH; // macSetPayload requires accurate payload length
008A2A  90003E     MOV [W14+6], W0
008A2C  784000     MOV.B W0, W0
008A2E  E9C000     DEC2.B W0, W0
008A30  90009E     MOV [W14+2], W1
008A32  784880     MOV.B W0, [W1]
307:                   macSetPayload(packet, pld);
008A34  90009E     MOV [W14+2], W1
008A36  90005E     MOV [W14+10], W0
008A38  07FE49     RCALL macSetPayload
308:               
309:                   return 1;
008A3A  200010     MOV #0x1, W0
310:               
311:                }
008A3C  78044F     MOV [--W15], W8
008A3E  FA8000     ULNK
008A40  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/lcd.c  ------------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * LCD Module for MikroElectronika/Exp16 Dev Board
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-05-26    Initial release
38:                 *                      
39:                 * Notes:
40:                 *  - MCU resources required for this module:
41:                 *   A 4-bit LCD for Mikroelektronika dev board (40 MIPS) is connected to
42:                *       D4:D7 - RB4:RB7
43:                *       EN - RB3
44:                *       RS - RB2
45:                *    A 8-bit LCD for Explore 16 Dev board (40 MIPS) is connected to
46:                *       D0:D7 - RE0:RE7
47:                *       RW - RD5
48:                *       EN - RD4
49:                *       RS - B15
50:                *       
51:                */
52:                
53:                /******************************************************************************
54:                
55:                *
56:                * Usage:
57:                *   1. Run lcdSetup first
58:                *   2. The print(str) function will print the first 32 characters in str.
59:                *      of str on the LCD. It takes about 1ms for 2*16 LCD (2.5ms fro 4*20 LCD)
60:                *      to finish the function. Very slow....
61:                *   3. Here is an example.
62:                *
63:                *   #include <stdio.h>
64:                *   #include  "lcd.h"
65:                *
66:                *   char foo[32];
67:                *   int age = 32;
68:                *
69:                *   lcdSetup(2,16);     // 2 rows and 16 cols
70:                *   sprintf(foo, "Aaron is %o years old.", age); // print age in octal.    
71:                *   print(foo)  
72:                *   
73:                *   It will print on your LCD the following
74:                *   "Aaron is 40 year"
75:                *   "s old.          "
76:                *
77:                *   4. lcdSendString can be used alternatively for print.
78:                *   5. Important Note: If you would like to have more advanced output 
79:                *      behaviors such as automatic shifting, scrolling up and down, etc, 
80:                *      please please please implement them by yourself and share them 
81:                *      with me. :D Thanks.
82:                *
83:                ******************************************************************************/
84:                
85:                #include "ports.h"
86:                #include "lcd.h"
87:                #include "utils.h"
88:                
89:                
90:                /*****	LCD COMMAND FUCNTION PROTOTYPES  *****/
91:                //#define cursor_right()        lcdSendCmd( 0x14 )
92:                //#define cursor_left()         lcdSendCmd( 0x10 )
93:                //#define display_shift()       lcdSendCmd( 0x1C )
94:                //#define home_clr()            lcdSendCmd( 0x01 ) 
95:                //#define home_it()             lcdSendCmd( 0x02 ) 
96:                //#define go_to_line_2()        lcdSendCmd( 0xC0 ) 
97:                
98:                
99:                #if defined(__MIKRO)
100:                   //LCD Registers addresses
101:                   #define LCD_EN      0x08
102:                   #define LCD_RS      0x04
103:               
104:                   // We want not to change RB8 - RB15 in this module.
105:                   // By casting LATB in (unsigned char*), we only use lower
106:                   // eight bits of LATB ports.
107:                   unsigned char* lcd_port_ = (unsigned char*)&LATB;
108:               #elif defined(__EXP16DEV)
109:                   #define  LCD_RW  _LATD5       // LCD R/W signal
110:                   #define  LCD_RS  _LATB15      // LCD RS signal
111:                   #define  LCD_EN  _LATD4 
112:               
113:                   // We want not to change RB8 - RB15 in this module.
114:                   // By casting LATB in (unsigned char*), we only use lower
115:                   // eight bits of LATB ports.
116:                   unsigned char* lcd_port_ = (unsigned char*)&LATE;
117:               #endif
118:               
119:               #define LCD_SEND_DELAY      40      // microseconds
120:               #define LCD_EN_HOLD()       Nop(); Nop(); Nop() // to hold EN signal 
121:               
122:               
123:               
124:               /*-----------------------------------------------------------------------------
125:                *          Static Variables
126:               -----------------------------------------------------------------------------*/
127:                   
128:               static unsigned char lcd_rows_ = 2; 
129:               static unsigned char lcd_cols_ = 16;
130:               
131:               
132:               /*-----------------------------------------------------------------------------
133:                *          Declaration of static functions
134:               -----------------------------------------------------------------------------*/
135:               
136:               static void lcdReset(void);
137:               static void lcdSendCmd (char cmd);
138:               static void lcdSendData (char data);
139:               
140:               
141:               /*-----------------------------------------------------------------------------
142:                *          Public functions
143:               -----------------------------------------------------------------------------*/
144:               
145:               void lcdSetup(unsigned char rows, unsigned char cols) {
00E230  FA0002     LNK #0x2
00E232  784F00     MOV.B W0, [W14]
00E234  984711     MOV.B W1, [W14+1]
146:               
147:                   lcd_rows_ = rows;
00E236  2222E0     MOV #0x222E, W0
00E238  78481E     MOV.B [W14], [W0]
148:                   lcd_cols_ = cols;
00E23A  2222F0     MOV #0x222F, W0
00E23C  90409E     MOV.B [W14+1], W1
00E23E  784801     MOV.B W1, [W0]
149:               
150:                   #if defined(__MIKRO)
151:                       lcdReset();             // Call LCD reset
152:                       lcdSendCmd(0x28);       // 4-bit mode - 2 (or 4) lines - 5x7 font.
153:                       lcdSendCmd(0x0C);       // Display no cursor - no blink.
154:                       lcdSendCmd(0x06);       // Automatic Increment - No Display shift.
155:                       lcdSendCmd(0x80);       // Address DDRAM with 0 offset 80h.
156:                   #elif defined(__EXP16DEV)
157:                       lcdReset();
158:                       lcdSendCmd(0x38);       // 8-bit mode - 2 (or 4) lines - 5x7 font.
159:                       lcdSendCmd(0x0C);       // Display no cursor - no blink.
160:                       lcdSendCmd(0x06);       // Automatic Increment - No Display shift.
161:                       lcdSendCmd(0x80);       // Address DDRAM with 0 offset 80h.
162:                       lcd_rows_ = 2;
163:                       lcd_cols_ = 16;
164:                   #endif
165:               
166:               
167:               }
00E240  FA8000     ULNK
00E242  060000     RETURN
168:               
169:               
170:               void lcdSendString(char *var) {
00E244  FA0002     LNK #0x2
00E246  780F00     MOV W0, [W14]
171:                   #if (defined(__MIKRO) || defined(__EXP16DEV))
172:                   unsigned char count = 0;
173:                 
174:                   lcdSendCmd(0x80);           // move to first row & first col
175:                   while (*var) {              //till string ends
176:                       lcdSendData(*var++);    //send characters one by one
177:                       count++;
178:                       if (count == lcd_cols_) {
179:                           lcdSendCmd(0xc0);   // move to second row
180:                       } else if (count == lcd_cols_*2) {
181:                           lcdSendCmd(0x94);   // move to third row
182:                       } else if (count == lcd_cols_*3) {
183:                           lcdSendCmd(0xd4);   // move to fourth row
184:                       } else if (count == lcd_cols_*4) {
185:                           break;
186:                       }
187:                   }
188:               
189:                   while (count < lcd_rows_ * lcd_cols_) {
190:                       lcdSendData(' ');       // put space for the rest 
191:                       count++;
192:                       if (count == lcd_cols_) {
193:                           lcdSendCmd(0xc0);
194:                       } else if (count == lcd_cols_*2) {
195:                           lcdSendCmd(0x94);
196:                       } else if (count == lcd_cols_*3) {
197:                           lcdSendCmd(0xd4);
198:                       }
199:                   }
200:                   #endif
201:               }
00E248  FA8000     ULNK
00E24A  060000     RETURN
202:               
203:               
204:               /*-----------------------------------------------------------------------------
205:                * ----------------------------------------------------------------------------
206:                * The functions below are intended for internal use, i.e., private methods.
207:                * Users are recommended to use functions defined above.
208:                * ----------------------------------------------------------------------------
209:               -----------------------------------------------------------------------------*/
210:               
211:               /*****************************************************************************
212:               * Function Name : lcdReset
213:               * Description   : Reset LCD.  Use this funtion to initialize LCD.
214:               * Parameters    : None
215:               * Return Value  : None                                                     
216:               *****************************************************************************/
217:               static void lcdReset(void) {
00E24C  FA0000     LNK #0x0
218:               #if defined(__MIKRO)
219:                   *lcd_port_ = 0xff;      // may not need this line
220:                   delay_ms(20);           // may not need this line
221:                   *lcd_port_ = 0x30 | LCD_EN;
222:                   *lcd_port_ = 0x30;
223:                   delay_ms(10);           // 5ms may work
224:                   *lcd_port_ = 0x30 | LCD_EN;
225:                   *lcd_port_ = 0x30;
226:                   delay_ms(1);            // 200us may work
227:                   *lcd_port_ = 0x30 | LCD_EN;
228:                   *lcd_port_ = 0x30;
229:                   delay_ms(1);            // 200us may work
230:                   *lcd_port_ = 0x20 | LCD_EN;
231:                   *lcd_port_ = 0x20;
232:                   delay_ms(1);            // 200us may work
233:               
234:               #elif defined(__EXP16DEV)
235:                   //*lcd_port_ = 0x00;
236:                   delay_ms(1);
237:                   *lcd_port_ = 0x38;	
238:                   LCD_EN = 1;	
239:                   LCD_EN_HOLD();
240:                   LCD_EN = 0;          // toggle E signal
241:                   delay_ms(5);         // 5ms delay
242:                   *lcd_port_ = 0x38;	    
243:                   LCD_EN = 1;	
244:                   LCD_EN_HOLD();
245:                   LCD_EN = 0;         // toggle E signal
246:                   delay_us(200);      // 200uS delay
247:                   *lcd_port_ = 0x38;	    
248:                   LCD_EN = 1;	
249:                   LCD_EN_HOLD();
250:                   LCD_EN = 0;         // toggle E signal
251:                   delay_us(200);      // 200uS delay
252:                   *lcd_port_ = 0x38;	    
253:                   LCD_EN = 1;	
254:                   LCD_EN_HOLD();
255:                   LCD_EN = 0;         // toggle E signal
256:                   delay_us(200);      // 200uS delay    
257:               
258:               #endif    
259:               
260:               }
00E24E  FA8000     ULNK
00E250  060000     RETURN
261:               
262:               /*****************************************************************************
263:               * Function Name : lcdSendCmd
264:               * Description   : Send a command to control LCD. 
265:               * Parameters    : cmd is a command character.
266:               * Return Value  : None                                                     
267:               *****************************************************************************/
268:               static void lcdSendCmd (char cmd) {
00E252  FA0002     LNK #0x2
00E254  784F00     MOV.B W0, [W14]
269:               #if defined(__MIKRO)        
270:                   *lcd_port_ = (cmd & 0xf0) | LCD_EN;
271:                   *lcd_port_ = (cmd & 0xf0);
272:                   *lcd_port_ = ((cmd<<4) & 0xf0) | LCD_EN;
273:                   *lcd_port_ = ((cmd<<4) & 0xf0);
274:                   delay_us(LCD_SEND_DELAY);
275:               #elif defined(__EXP16DEV)
276:                   *lcd_port_ = cmd;           // command byte to lcd
277:                   LCD_RW = 0;                 // ensure RW is 0
278:                   LCD_EN = 1;                 // toggle E line
279:                   LCD_RS = 0;
280:                   LCD_EN_HOLD();
281:                   LCD_EN = 0;                 // toggle E line
282:                   delay_us(LCD_SEND_DELAY); 
283:               #endif    
284:               }
00E256  FA8000     ULNK
00E258  060000     RETURN
285:               
286:               
287:               /******************************************************************************
288:               * Function Name : lcdSendData
289:               * Description   : Send a data to LCD to display.  Address automatically 
290:               *                 increases for the next data to be sent.
291:               * Parameters    : data is a character to be displayed on LCD.
292:               * Return Value  : None                                                     
293:               *******************************************************************************/
294:               static void lcdSendData(char data) {
00E25A  FA0002     LNK #0x2
00E25C  784F00     MOV.B W0, [W14]
295:               #if defined(__MIKRO)     
296:                   *lcd_port_ = (data & 0xf0) | LCD_EN | LCD_RS;
297:                   *lcd_port_ = (data & 0xf0) | LCD_RS;
298:                   *lcd_port_ = ((data << 4) & 0xf0) | LCD_EN | LCD_RS;
299:                   *lcd_port_ = ((data << 4) & 0xf0) | LCD_RS;
300:                   delay_us(LCD_SEND_DELAY);
301:               #elif defined(__EXP16DEV)     
302:                   LCD_RW = 0;       	    // ensure RW is 0, may not need
303:                   LCD_RS = 1;             // assert register select to 1
304:                   *lcd_port_ = data;      // data byte to lcd
305:                   LCD_EN = 1;	
306:                   LCD_EN_HOLD(); 
307:                   LCD_RS = 0;             // negate register select to 0
308:                   LCD_EN = 0;             // toggle E signal
309:                   delay_us(1000);
310:               #endif
311:               }
00E25E  FA8000     ULNK
00E260  060000     RETURN
312:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/larray.c  ---------------------------------------------
1:                 /**
2:                 * Copyright (c) 2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Managed Array Data Structure
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v 0.2
35:                *
36:                * Revisions:
37:                *  Humphrey Hu         2012-02-04    Initial implementation
38:                *  Humphrey Hu         2012-02-06    Added size querying                
39:                */
40:                
41:                #include "larray.h"
42:                #include <stdlib.h>
43:                
44:                // ==== Function Prototypes ===================================================
45:                unsigned int findEmpty(LinArrayItem item, void *args);
46:                
47:                // ==== Public Functions ======================================================
48:                LinArray larrayCreate(unsigned int size) {
00CEEA  FA0004     LNK #0x4
00CEEC  980710     MOV W0, [W14+2]
49:                
50:                    LinArray larray;
51:                    
52:                    larray = (LinArray) malloc(sizeof(LinArrayStruct));
00CEEE  200060     MOV #0x6, W0
00CEF0  0233BA     CALL _malloc
00CEF2  000000     NOP
00CEF4  780F00     MOV W0, [W14]
53:                    if(larray == NULL) { return NULL; }
00CEF6  78009E     MOV [W14], W1
00CEF8  EB0000     CLR W0
00CEFA  508F80     SUB W1, W0, [W15]
00CEFC  3A0002     BRA NZ, 0xCF02
00CEFE  EB0000     CLR W0
00CF00  370018     BRA 0xCF32
54:                
55:                    larray->items = (LinArrayItem*) calloc(size, sizeof(LinArrayItem));
00CF02  200021     MOV #0x2, W1
00CF04  90001E     MOV [W14+2], W0
00CF06  023556     CALL _calloc
00CF08  000000     NOP
00CF0A  780080     MOV W0, W1
00CF0C  78001E     MOV [W14], W0
00CF0E  980021     MOV W1, [W0+4]
56:                    if(larray->items == NULL) {
00CF10  78001E     MOV [W14], W0
00CF12  9000A0     MOV [W0+4], W1
00CF14  EB0000     CLR W0
00CF16  508F80     SUB W1, W0, [W15]
00CF18  3A0005     BRA NZ, 0xCF24
57:                        free(larray);
00CF1A  78001E     MOV [W14], W0
00CF1C  0234EC     CALL _free
00CF1E  000000     NOP
58:                        return NULL;
00CF20  EB0000     CLR W0
00CF22  370007     BRA 0xCF32
59:                    }
60:                    
61:                    larray->max_size = size;
00CF24  78001E     MOV [W14], W0
00CF26  90009E     MOV [W14+2], W1
00CF28  780801     MOV W1, [W0]
62:                    larray->size = 0;
00CF2A  78001E     MOV [W14], W0
00CF2C  EB0080     CLR W1
00CF2E  980011     MOV W1, [W0+2]
63:                    return larray;
00CF30  78001E     MOV [W14], W0
64:                    
65:                }
00CF32  FA8000     ULNK
00CF34  060000     RETURN
66:                
67:                LinArrayItem larrayReplace(LinArray larray, unsigned int index, LinArrayItem item) {
00CF36  FA0008     LNK #0x8
00CF38  980710     MOV W0, [W14+2]
00CF3A  980721     MOV W1, [W14+4]
00CF3C  980732     MOV W2, [W14+6]
68:                
69:                    LinArrayItem orig;
70:                
71:                    if(index >= larray->max_size) { return NULL; }
00CF3E  90001E     MOV [W14+2], W0
00CF40  780090     MOV [W0], W1
00CF42  90002E     MOV [W14+4], W0
00CF44  508F80     SUB W1, W0, [W15]
00CF46  3E0002     BRA GTU, 0xCF4C
00CF48  EB0000     CLR W0
00CF4A  370020     BRA 0xCF8C
72:                    
73:                    orig = larray->items[index];
00CF4C  90001E     MOV [W14+2], W0
00CF4E  9000A0     MOV [W0+4], W1
00CF50  90002E     MOV [W14+4], W0
00CF52  400000     ADD W0, W0, W0
00CF54  408000     ADD W1, W0, W0
00CF56  780F10     MOV [W0], [W14]
74:                    larray->items[index] = item;
00CF58  90001E     MOV [W14+2], W0
00CF5A  9000A0     MOV [W0+4], W1
00CF5C  90002E     MOV [W14+4], W0
00CF5E  400000     ADD W0, W0, W0
00CF60  408000     ADD W1, W0, W0
00CF62  9000BE     MOV [W14+6], W1
00CF64  780801     MOV W1, [W0]
75:                
76:                    if(item == NULL) { larray->size--; }
00CF66  9000BE     MOV [W14+6], W1
00CF68  EB0000     CLR W0
00CF6A  508F80     SUB W1, W0, [W15]
00CF6C  3A0005     BRA NZ, 0xCF78
00CF6E  90001E     MOV [W14+2], W0
00CF70  900010     MOV [W0+2], W0
00CF72  E90080     DEC W0, W1
00CF74  90001E     MOV [W14+2], W0
00CF76  980011     MOV W1, [W0+2]
77:                    if(orig == NULL) { larray->size++; }
00CF78  78009E     MOV [W14], W1
00CF7A  EB0000     CLR W0
00CF7C  508F80     SUB W1, W0, [W15]
00CF7E  3A0005     BRA NZ, 0xCF8A
00CF80  90001E     MOV [W14+2], W0
00CF82  900010     MOV [W0+2], W0
00CF84  E80080     INC W0, W1
00CF86  90001E     MOV [W14+2], W0
00CF88  980011     MOV W1, [W0+2]
78:                
79:                    return orig;
00CF8A  78001E     MOV [W14], W0
80:                
81:                }
00CF8C  FA8000     ULNK
00CF8E  060000     RETURN
82:                
83:                LinArrayItem larrayRetrieve(LinArray larray, unsigned int index) {
00CF90  FA0004     LNK #0x4
00CF92  780F00     MOV W0, [W14]
00CF94  980711     MOV W1, [W14+2]
84:                
85:                    if(index >= larray->max_size) { return NULL; }
00CF96  78001E     MOV [W14], W0
00CF98  780090     MOV [W0], W1
00CF9A  90001E     MOV [W14+2], W0
00CF9C  508F80     SUB W1, W0, [W15]
00CF9E  3E0002     BRA GTU, 0xCFA4
00CFA0  EB0000     CLR W0
00CFA2  370006     BRA 0xCFB0
86:                    
87:                    return larray->items[index];
00CFA4  78001E     MOV [W14], W0
00CFA6  9000A0     MOV [W0+4], W1
00CFA8  90001E     MOV [W14+2], W0
00CFAA  400000     ADD W0, W0, W0
00CFAC  408000     ADD W1, W0, W0
00CFAE  780010     MOV [W0], W0
88:                
89:                }
00CFB0  FA8000     ULNK
00CFB2  060000     RETURN
90:                
91:                unsigned int larrayFindFirst(LinArray larray, LinArrayItemTest equals, 
92:                                            void *args, unsigned int *index,
93:                                            LinArrayItem *item) {
00CFB4  FA000A     LNK #0xA
00CFB6  780F00     MOV W0, [W14]
00CFB8  980711     MOV W1, [W14+2]
00CFBA  980722     MOV W2, [W14+4]
00CFBC  980733     MOV W3, [W14+6]
00CFBE  980744     MOV W4, [W14+8]
94:                
95:                    return larrayFindN(larray, equals, args, index, item, 1);
00CFC0  200015     MOV #0x1, W5
00CFC2  90024E     MOV [W14+8], W4
00CFC4  9001BE     MOV [W14+6], W3
00CFC6  90012E     MOV [W14+4], W2
00CFC8  90009E     MOV [W14+2], W1
00CFCA  78001E     MOV [W14], W0
00CFCC  070002     RCALL larrayFindN
96:                    
97:                }
00CFCE  FA8000     ULNK
00CFD0  060000     RETURN
98:                
99:                unsigned int larrayFindN(LinArray larray, LinArrayItemTest equals,
100:                                       void *args, unsigned int *indices, 
101:                                       LinArrayItem *items, unsigned int n) {
00CFD2  FA0012     LNK #0x12
00CFD4  980730     MOV W0, [W14+6]
00CFD6  980741     MOV W1, [W14+8]
00CFD8  980752     MOV W2, [W14+10]
00CFDA  980763     MOV W3, [W14+12]
00CFDC  980774     MOV W4, [W14+14]
00CFDE  980F05     MOV W5, [W14+16]
102:                                       
103:                   unsigned int i, j;
104:                   LinArrayItem curr;
105:                   
106:                   j = 0;
00CFE0  EB0000     CLR W0
00CFE2  980710     MOV W0, [W14+2]
107:                   
108:                   for(i = 0; i < larray->max_size; i++) {
00CFE4  EB0000     CLR W0
00CFE6  780F00     MOV W0, [W14]
00CFE8  370021     BRA 0xD02C
00D02A  E80F1E     INC [W14], [W14]
00D02C  90003E     MOV [W14+6], W0
00D02E  780090     MOV [W0], W1
00D030  78001E     MOV [W14], W0
00D032  508F80     SUB W1, W0, [W15]
00D034  3EFFDA     BRA GTU, 0xCFEA
00D036  370001     BRA 0xD03A
109:                       curr = larray->items[i];
00CFEA  90003E     MOV [W14+6], W0
00CFEC  9000A0     MOV [W0+4], W1
00CFEE  78001E     MOV [W14], W0
00CFF0  400000     ADD W0, W0, W0
00CFF2  408000     ADD W1, W0, W0
00CFF4  780090     MOV [W0], W1
00CFF6  980721     MOV W1, [W14+4]
110:                       if(equals(curr, args)) {
00CFF8  90014E     MOV [W14+8], W2
00CFFA  9000DE     MOV [W14+10], W1
00CFFC  90002E     MOV [W14+4], W0
00CFFE  010002     CALL W2
00D000  EB0080     CLR W1
00D002  500F81     SUB W0, W1, [W15]
00D004  32000E     BRA Z, 0xD022
111:                           indices[j] = i;
00D006  90001E     MOV [W14+2], W0
00D008  400000     ADD W0, W0, W0
00D00A  9000EE     MOV [W14+12], W1
00D00C  408000     ADD W1, W0, W0
00D00E  78081E     MOV [W14], [W0]
112:                           items[j] = curr;
00D010  90001E     MOV [W14+2], W0
00D012  400000     ADD W0, W0, W0
00D014  9000FE     MOV [W14+14], W1
00D016  408000     ADD W1, W0, W0
00D018  9000AE     MOV [W14+4], W1
00D01A  780801     MOV W1, [W0]
113:                           j++;
00D01C  90001E     MOV [W14+2], W0
00D01E  E80000     INC W0, W0
00D020  980710     MOV W0, [W14+2]
114:                       }
115:                       if(j >= n) {
00D022  90009E     MOV [W14+2], W1
00D024  90080E     MOV [W14+16], W0
00D026  508F80     SUB W1, W0, [W15]
00D028  310007     BRA C, 0xD038
116:                           break;
00D038  000000     NOP
117:                       }    
118:                   }
119:                   return j;
00D03A  90001E     MOV [W14+2], W0
120:                                       
121:               }
00D03C  FA8000     ULNK
00D03E  060000     RETURN
122:               
123:               unsigned int larrayFindEmpty(LinArray larray, unsigned int *index) {
00D040  FA0006     LNK #0x6
00D042  980710     MOV W0, [W14+2]
00D044  980721     MOV W1, [W14+4]
124:               
125:                   LinArrayItem dummy;
126:               
127:                   return larrayFindFirst(larray, &findEmpty, NULL, index, &dummy);
00D046  78020E     MOV W14, W4
00D048  9001AE     MOV [W14+4], W3
00D04A  EB0100     CLR W2
00D04C  2D09C1     MOV #0xD09C, W1
00D04E  90001E     MOV [W14+2], W0
00D050  07FFB1     RCALL larrayFindFirst
128:                   
129:               }
00D052  FA8000     ULNK
00D054  060000     RETURN
130:               
131:               unsigned int larrayIsEmpty(LinArray larray) {
00D056  FA0002     LNK #0x2
00D058  780F00     MOV W0, [W14]
132:               
133:                   return larray->size == 0;
00D05A  78001E     MOV [W14], W0
00D05C  900110     MOV [W0+2], W2
00D05E  200010     MOV #0x1, W0
00D060  EB0080     CLR W1
00D062  510F81     SUB W2, W1, [W15]
00D064  320001     BRA Z, 0xD068
00D066  EB0000     CLR W0
134:               
135:               }
00D068  FA8000     ULNK
00D06A  060000     RETURN
136:               
137:               unsigned int larrayIsFull(LinArray larray) {
00D06C  FA0002     LNK #0x2
00D06E  780F00     MOV W0, [W14]
138:               
139:                   return larray->size == larray->max_size;
00D070  78001E     MOV [W14], W0
00D072  900110     MOV [W0+2], W2
00D074  78001E     MOV [W14], W0
00D076  780090     MOV [W0], W1
00D078  200010     MOV #0x1, W0
00D07A  510F81     SUB W2, W1, [W15]
00D07C  320001     BRA Z, 0xD080
00D07E  EB0000     CLR W0
140:               
141:               }
00D080  FA8000     ULNK
00D082  060000     RETURN
142:               
143:               unsigned int larrayGetSize(LinArray larray) {
00D084  FA0002     LNK #0x2
00D086  780F00     MOV W0, [W14]
144:               
145:                   return larray->size;
00D088  78001E     MOV [W14], W0
00D08A  900010     MOV [W0+2], W0
146:               
147:               }
00D08C  FA8000     ULNK
00D08E  060000     RETURN
148:               
149:               unsigned int larrayGetMaxSize(LinArray larray) {
00D090  FA0002     LNK #0x2
00D092  780F00     MOV W0, [W14]
150:               
151:                   return larray->max_size;
00D094  78001E     MOV [W14], W0
00D096  780010     MOV [W0], W0
152:                   
153:               }
00D098  FA8000     ULNK
00D09A  060000     RETURN
154:               
155:               // ==== Private Functions =====================================================
156:               
157:               unsigned int findEmpty(LinArrayItem item, void *args) {
00D09C  FA0004     LNK #0x4
00D09E  780F00     MOV W0, [W14]
00D0A0  980711     MOV W1, [W14+2]
158:               
159:                   return item == NULL;
00D0A2  200010     MOV #0x1, W0
00D0A4  78011E     MOV [W14], W2
00D0A6  EB0080     CLR W1
00D0A8  510F81     SUB W2, W1, [W15]
00D0AA  320001     BRA Z, 0xD0AE
00D0AC  EB0000     CLR W0
160:               
161:               }
00D0AE  FA8000     ULNK
00D0B0  060000     RETURN
162:               
163:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/ipspi1.c  ---------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Wrapper of SPI read/write functionality
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanlay S. Baek     2010-8-10    Initial release
38:                 *
39:                 * Notes:
40:                 *  - Uses an SPI bus (SPI1 for ImageProc2, SPI2 for MikroElectronika).
41:                 *  - TODO (stanbaek) : Implement DMA for SPI.
42:                 */
43:                
44:                #include "ipspi1.h"
45:                #include "utils.h"
46:                #include <stdio.h>
47:                #include "lcd.h"
48:                
49:                #if defined(__MIKRO)
50:                    #define SPI_BUF         SPI2BUF
51:                    #define SPI_CON1bits    SPI2CON1bits
52:                    #define SPI_CON2        SPI2CON2
53:                    #define SPI_STATbits    SPI2STATbits
54:                    #define SPI_CS          _LATG9
55:                    #define SLPTR           _LATF0      
56:                #elif defined(__EXP16DEV)
57:                    #define SPI_BUF         SPI2BUF
58:                    #define SPI_CON1bits    SPI2CON1bits
59:                    #define SPI_CON2        SPI2CON2
60:                    #define SPI_STATbits    SPI2STATbits
61:                    #define SPI_CS          _LATG9
62:                    #define SLPTR           _LATB1
63:                #elif defined(__BASESTATION)
64:                    #define SPI_BUF         SPI2BUF
65:                    #define SPI_CON1bits    SPI2CON1bits
66:                    #define SPI_CON2        SPI2CON2
67:                    #define SPI_STATbits    SPI2STATbits
68:                    #define SPI_CS          _LATG9
69:                    #define SLPTR           _LATE5
70:                #else
71:                    #define SPI_BUF         SPI1BUF
72:                    #define SPI_CON1bits    SPI1CON1bits
73:                    #define SPI_CON2        SPI1CON2
74:                    #define SPI_STATbits    SPI1STATbits
75:                    #define SPI_CS          _LATB2
76:                    #define SLPTR           _LATB15
77:                #endif
78:                
79:                
80:                /******************************************************************************
81:                * Function Name : configSPI 
82:                * Description   : This routine sets up SPI bus for this module
83:                * Parameters    : None
84:                * Return Value  : None
85:                *******************************************************************************/
86:                void ipspi1Config(void) {
00DED4  FA0000     LNK #0x0
87:                
88:                    // SPI interrupt is not used.
89:                    //IFS0bits.SPI2IF = 0; // Clear the Interrupt Flag
90:                    //IEC0bits.SPI2IE = 0; // Disable the Interrupt
91:                
92:                    // SPI1CON1 Register Settings
93:                    SPI_CON1bits.DISSCK = 0; // Internal Serial Clock is Enabled
00DED6  A98243     BCLR 0x243, #4
94:                    SPI_CON1bits.DISSDO = 0; // SDOx pin is controlled by the module
00DED8  A96243     BCLR 0x243, #3
95:                    SPI_CON1bits.MODE16 = 0; // Communication is byte-wide (8 bits)
00DEDA  A94243     BCLR 0x243, #2
96:                    SPI_CON1bits.SMP = 0; // Input data is sampled at middle of data output time
00DEDC  A92243     BCLR 0x243, #1
97:                    SPI_CON1bits.SSEN = 0; // SS1 pin is used
00DEDE  A9E242     BCLR SPI1CON1, #7
98:                    SPI_CON1bits.CKE = 1; // Serial output data changes on transition
00DEE0  A80243     BSET 0x243, #0
99:                                        // from active clock state to idle clock state
100:                   SPI_CON1bits.CKP = 0; // Idle state for clock is a low level;
00DEE2  A9C242     BCLR SPI1CON1, #6
101:                                           // active state is a high level
102:                   SPI_CON1bits.MSTEN = 1; // Master mode Enabled
00DEE4  A8A242     BSET SPI1CON1, #5
103:               
104:                   // Set up SCK frequency of 1.25Mhz for 40 MIPS
105:                   SPI_CON1bits.SPRE = 0b000; // Secondary prescale    8:1
00DEE6  801211     MOV SPI1CON1, W1
00DEE8  2FFE30     MOV #0xFFE3, W0
00DEEA  608000     AND W1, W0, W0
00DEEC  881210     MOV W0, SPI1CON1
106:                   SPI_CON1bits.PPRE = 0b10; // Primary prescale       4:1
00DEEE  801211     MOV SPI1CON1, W1
00DEF0  2FFFC0     MOV #0xFFFC, W0
00DEF2  608000     AND W1, W0, W0
00DEF4  A01000     BSET W0, #1
00DEF6  881210     MOV W0, SPI1CON1
107:               
108:                   // SPI2CON2 Register Settings
109:                   SPI_CON2 = 0x0000; // Framed SPI2 support disabled
00DEF8  EB0000     CLR W0
00DEFA  881220     MOV W0, SPI1CON2
110:               
111:                   // SPI2STAT Register Settings
112:                   SPI_STATbits.SPISIDL = 1; // Discontinue module when device enters idle mode
00DEFC  A8A241     BSET 0x241, #5
113:                   SPI_STATbits.SPIROV = 0; // Clear Overflow
00DEFE  A9C240     BCLR SPI1STAT, #6
114:                   SPI_STATbits.SPIEN = 1; // Enable SPI module
00DF00  A8E241     BSET 0x241, #7
115:               }
00DF02  FA8000     ULNK
00DF04  060000     RETURN
116:               
117:               /******************************************************************************
118:               * Function Name :   ipspi1GetByte 
119:               * Description   :   This function will read single byte from SPI bus. 
120:               * Parameters    :   None 
121:               * Return Value  :   contents of SPIBUF register                           
122:               ******************************************************************************/
123:               byte ipspi1GetByte(void) {
00DF06  FA0000     LNK #0x0
124:                   SPI_STATbits.SPIROV = 0;
00DF08  A9C240     BCLR SPI1STAT, #6
125:                   SPI_BUF = 0x00;     // initiate bus cycle
00DF0A  EB0000     CLR W0
00DF0C  881240     MOV W0, SPI1BUF
126:                   while(SPI_STATbits.SPITBF);
00DF0E  000000     NOP
00DF10  801200     MOV SPI1STAT, W0
00DF12  6000E2     AND W0, #0x2, W1
00DF14  EB0000     CLR W0
00DF16  508F80     SUB W1, W0, [W15]
00DF18  3AFFFB     BRA NZ, 0xDF10
127:                   while(!SPI_STATbits.SPIRBF);
00DF1A  000000     NOP
00DF1C  801200     MOV SPI1STAT, W0
00DF1E  6000E1     AND W0, #0x1, W1
00DF20  EB0000     CLR W0
00DF22  508F80     SUB W1, W0, [W15]
00DF24  32FFFB     BRA Z, 0xDF1C
128:                   return (SPI_BUF & 0xff);    // return byte read 
00DF26  801240     MOV SPI1BUF, W0
00DF28  784000     MOV.B W0, W0
129:               }
00DF2A  FA8000     ULNK
00DF2C  060000     RETURN
130:               
131:               /******************************************************************************
132:               * Function Name : ipspi1PutByte
133:               * Description   : This routine writes a single byte to SPI bus.                                 
134:               * Parameters    : Single data byte for SPI bus          
135:               * Return Value  : contents of SPIBUF register
136:               *******************************************************************************/
137:               byte ipspi1PutByte(byte dout) {   
00DF2E  FA0004     LNK #0x4
00DF30  984720     MOV.B W0, [W14+2]
138:                   byte c;
139:                   SPI_BUF = dout;   // initiate SPI bus cycle by byte write 
00DF32  90402E     MOV.B [W14+2], W0
00DF34  FB8000     ZE W0, W0
00DF36  881240     MOV W0, SPI1BUF
140:                   while(SPI_STATbits.SPITBF);
00DF38  000000     NOP
00DF3A  801200     MOV SPI1STAT, W0
00DF3C  6000E2     AND W0, #0x2, W1
00DF3E  EB0000     CLR W0
00DF40  508F80     SUB W1, W0, [W15]
00DF42  3AFFFB     BRA NZ, 0xDF3A
141:                   while(!SPI_STATbits.SPIRBF);
00DF44  000000     NOP
00DF46  801200     MOV SPI1STAT, W0
00DF48  6000E1     AND W0, #0x1, W1
00DF4A  EB0000     CLR W0
00DF4C  508F80     SUB W1, W0, [W15]
00DF4E  32FFFB     BRA Z, 0xDF46
142:                   c = SPI_BUF;    // read out to avoid overflow 
00DF50  801240     MOV SPI1BUF, W0
00DF52  784F00     MOV.B W0, [W14]
143:                   return c;
00DF54  78401E     MOV.B [W14], W0
144:               }
00DF56  FA8000     ULNK
00DF58  060000     RETURN
145:               
146:               /******************************************************************************
147:               * Function Name : ipspi1ChipSelect
148:               * Description   : This routine toggles the chip select pin
149:               * Parameters    : Single Boolean value indicating whether to select the chip
150:               * Return Value  : None 
151:               *******************************************************************************/
152:               void ipspi1ChipSelect(byte select) {
00DF5A  FA0002     LNK #0x2
00DF5C  784F00     MOV.B W0, [W14]
153:                   SPI_CS = select;
00DF5E  78409E     MOV.B [W14], W1
00DF60  60C061     AND.B W1, #0x1, W0
00DF62  FB8000     ZE W0, W0
00DF64  600061     AND W0, #0x1, W0
00DF66  DD0042     SL W0, #2, W0
00DF68  801652     MOV LATB, W2
00DF6A  2FFFB1     MOV #0xFFFB, W1
00DF6C  610081     AND W2, W1, W1
00DF6E  708000     IOR W1, W0, W0
00DF70  881650     MOV W0, LATB
154:               }
00DF72  FA8000     ULNK
00DF74  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/init_default.c  ---------------------------------------
1:                 /*
2:                  * Copyright (c) 2010-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Default Initialization Routines
31:                 *
32:                 * by Fernando L. Garcia Bermudez & Stanley S. Baek
33:                 *
34:                 * v.1.0
35:                 *
36:                 * Revisions:
37:                 *  Fernando L. Garcia Bermudez     2010-6-21   Initial release
38:                 *  Stanley S. Baek                 2010-6-25   Expanded to even more boards
39:                 *
40:                 */
41:                
42:                #include "p33Fxxxx.h"
43:                #include "adc.h"
44:                
45:                
46:                /* Configuration Bits (macros defined in processor header) */
47:                #if !defined(__BOOTLOAD)
48:                
49:                    #if defined(__EXP16DEV)
50:                        // Primary OSC (XT, HS, EC) w/ PLL
51:                        _FOSCSEL(FNOSC_PRIPLL);
52:                
53:                        // XT oscillator & CLK Switch./Mon. Dis & OSC2 as CLK Out
54:                        _FOSC(FCKSM_CSDCMD & OSCIOFNC_OFF & POSCMD_XT);
55:                
56:                        // Watchdog Timer Disabled
57:                        _FWDT(FWDTEN_OFF);
58:                
59:                    #else
60:                        // Primary OSC (XT, HS, EC) w/PLL & 2-Speed Startup Enabled (for fast EC)
61:                        _FOSCSEL(FNOSC_PRIPLL & IESO_ON);
62:                
63:                        // EC oscillator & CLK Switch./Mon. Dis & OSC2 as CLK Out
64:                        _FOSC(POSCMD_EC & FCKSM_CSDCMD & OSCIOFNC_OFF);
65:                
66:                        // Watchdog Timer Disabled
67:                        _FWDT(FWDTEN_OFF);
68:                    #endif
69:                
70:                #endif // !defined(__BOOTLOAD)
71:                
72:                
73:                void SetupClock(void)
74:                {
00E118  FA0000     LNK #0x0
75:                #if !defined(__BOOTLOAD)
76:                
77:                    #if defined(__EXP16DEV)
78:                        // Setup for 40MIPS(Fcy) w/8MHz XT(Fin): Fcy = Fin * (M/(2 * N1 * N2))
79:                        // Configure Oscillator to operate the device at 40Mhz
80:                        // Fosc= Fin*M/(N1*N2), Fcy=Fosc/2
81:                        // Fosc= 8M*40(2*2)=80Mhz for 8M input clock
82:                        PLLFBD=38; // M=40
83:                        CLKDIVbits.PLLPOST=0; // N1=2
84:                        CLKDIVbits.PLLPRE=0; // N2=2
85:                        OSCTUN=0; // Tune FRC oscillator, if FRC is used
86:                        RCONbits.SWDTEN=0; // Disable Watch Dog Timer
87:                    #else
88:                        // Setup for 40MIPS(Fcy) w/40MHz XT(Fin): Fcy = Fin * (M/(2 * N1 * N2))
89:                        _PLLDIV = 6;  // M = 8
00E11A  803A31     MOV PLLFBD, W1
00E11C  2FE000     MOV #0xFE00, W0
00E11E  608000     AND W1, W0, W0
00E120  B30060     IOR #0x6, W0
00E122  883A30     MOV W0, PLLFBD
90:                        _PLLPRE = 0;  // N1 = 2
00E124  803A21     MOV CLKDIV, W1
00E126  2FFE00     MOV #0xFFE0, W0
00E128  608000     AND W1, W0, W0
00E12A  883A20     MOV W0, CLKDIV
91:                        _PLLPOST = 0; // N2 = 2
00E12C  803A21     MOV CLKDIV, W1
00E12E  2FF3F0     MOV #0xFF3F, W0
00E130  608000     AND W1, W0, W0
00E132  883A20     MOV W0, CLKDIV
92:                    #endif //defined(__EXP16DEV)
93:                
94:                #endif //!defined(__BOOTLOAD)
95:                }
00E134  FA8000     ULNK
00E136  060000     RETURN
96:                
97:                
98:                void SwitchClocks(void)
99:                {
00E138  FA0000     LNK #0x0
100:               #if !defined(__BOOTLOAD)
101:               
102:                   //Wait for PLL to lock
103:                   while(OSCCONbits.LOCK!=1);
00E13A  000000     NOP
00E13C  803A11     MOV OSCCON, W1
00E13E  200200     MOV #0x20, W0
00E140  608080     AND W1, W0, W1
00E142  EB0000     CLR W0
00E144  508F80     SUB W1, W0, [W15]
00E146  32FFFA     BRA Z, 0xE13C
104:               
105:               #endif //!defined(__BOOTLOAD)
106:               }
00E148  FA8000     ULNK
00E14A  060000     RETURN
107:               
108:               
109:               void SetupPorts(void)
110:               {
00E14C  FA0000     LNK #0x0
111:                   // Disabling all potential ADC AIO's to enable DIO's
112:                   // (will enable the needed ones in SetupADC())
113:                   AD1PCFGL = ENABLE_ALL_DIG_0_15;
00E14E  EB8000     SETM W0
00E150  881960     MOV W0, AD1PCFGL
114:                   AD2PCFGL = ENABLE_ALL_DIG_0_15;
00E152  EB8000     SETM W0
00E154  881B60     MOV W0, AD2PCFGL
115:               
116:               #if defined(__IMAGEPROC1)
117:               
118:                   // LEDs: RB3(AN3), RD11(ext int), and RF0-1 are outputs
119:                   LATB  = 0x0000;
120:                   TRISB = 0b1111111111110111; // A/D Conv: RB0-2(A/D Conv) are analog inputs
121:                   LATD  = 0x000;
122:                   TRISD = 0b011111111111; // Data: RD0-7(PIXEL) and Sync: RD8-10(VSYNC/HREF/
123:                                           // PCLK) remain inputs for the camera
124:                   LATF  = 0x00;
125:                   TRISF = 0b1111100; // Switches: RF2-3, Batt Supervisor: RF6(ext int) are
126:                                      // all inputs
127:               
128:                   // Camera PWDN: RC13-14 are outputs
129:                   LATC  = 0x0000;
130:                   TRISC = 0b1001111111111111;
131:               
132:                   // DFMEM: SPI2 Slave Select is an output (RG9)
133:                   LATG  = 0b0000000000;
134:                   TRISG = 0b0111111111;
135:               
136:                   // PWM: RE2 is an output managed thru the peripheral
137:                   // PWM outputs (*not* hardware PWM)
138:                   // All 8 pins (RE0 - RE7) are outputs
139:                   LATE  = 0b00000000;
140:                   TRISE = 0b00000000;
141:               
142:               
143:               #elif defined(__IMAGEPROC2)
144:               
145:                   // LEDs: RB12-14 are outputs
146:                   // SPI1 Slave Select is an output (RB2)
147:                   // SLPTR for Radio is an output (RB15)
148:                   // A/D Conv: RB-1, RB5, and RB8 are analog inputs
149:                   LATB  = 0x0000;
00E156  EB0000     CLR W0
00E158  881650     MOV W0, LATB
150:                   TRISB = 0b0000111111111011;
00E15A  20FFB0     MOV #0xFFB, W0
00E15C  881630     MOV W0, TRISB
151:               
152:                   // Camera PWDN: RC14 is an output
153:                   LATC  = 0x0000;
00E15E  EB0000     CLR W0
00E160  881680     MOV W0, LATC
154:                   TRISC = 0b1011111111111111;
00E162  2BFFF0     MOV #0xBFFF, W0
00E164  881660     MOV W0, TRISC
155:               
156:                   // OVCAM: RD0-7(PIXEL), RC13(VSYNC), RF0(HREF), and RF1(PCLK) are inputs
157:                   // RD8-RD11 are used for external interrupt
158:                   // Batt Supervisor: RD9(ext int) is an input
159:                   LATD = 0x0000;
00E166  EB0000     CLR W0
00E168  8816B0     MOV W0, LATD
160:                   TRISD = 0xffff;
00E16A  EB8000     SETM W0
00E16C  881690     MOV W0, TRISD
161:               
162:                   // DFMEM: SPI2 Slave Select is an output (RG9)
163:                   LATG  = 0b0000000000;
00E16E  EB0000     CLR W0
00E170  881740     MOV W0, LATG
164:                   TRISG = 0b0111111111;
00E172  201FF0     MOV #0x1FF, W0
00E174  881720     MOV W0, TRISG
165:               
166:                   // PWMs: RE0, RE2, RE4, and RE6 are outputs managed thru the peripheral
167:                   // PWM outputs (*not* hardware PWM)
168:                   // All 8 pins (RE0 - RE7) are outputs
169:                   LATE  = 0b00000000;
00E176  EB0000     CLR W0
00E178  8816E0     MOV W0, LATE
170:                   TRISE = 0b00000000;
00E17A  EB0000     CLR W0
00E17C  8816C0     MOV W0, TRISE
171:               
172:               
173:               #elif defined(__BASESTATION) || defined(__BASESTATION2)
174:               
175:                   // RD0-RD3 are used for LEDs
176:                   // RD11 is input (Radio Interrupt)
177:                   LATD = 0x0000;
178:                   TRISD = 0b0000100000000000;
179:               
180:                   // RE5 is output (Radio SLP_TR)
181:                   LATE = 0x0000;
182:                   TRISE = 0x0000;
183:               
184:                   // RADIO: SPI2 Slave Select is an output (RG9)
185:                   LATG  = 0b0000000000;
186:                   TRISG = 0b0111111111;
187:               
188:               #elif defined(__MIKRO)
189:               
190:                   // LCD: RB0-RB7 are outputs
191:                   // DEBUG RB8 - RB15 are outputs
192:                   LATB  = 0x0000;
193:                   TRISB = 0x0000;
194:               
195:                   // RD0-RD7 are used for camera input data
196:                   // RD8-RD11 are used for external interrupt
197:                   LATD = 0x0000;
198:                   TRISD = 0xffff;
199:               
200:                   // SLPTR for Radio (RF0)
201:                   LATF = 0x0000;
202:                   TRISF = 0xfffe;
203:               
204:                   // Radio: SPI2 Slave Select is an output (RG9)
205:                   LATG  = 0b0000000000;
206:                   TRISG = 0b0111111111;
207:               
208:                   // PWM outputs (*not* hardware PWM)
209:                   // All 8 pins (RE0 - RE7) are outputs
210:                   LATE  = 0b00000000;
211:                   TRISE = 0b00000000;
212:               
213:               
214:               #elif defined(__EXP16DEV)
215:               
216:                   // LEDs (D3-D10/RA0-RA7)
217:                   LATA = 0x0000;
218:                   TRISA = 0xFF00;
219:               
220:                   // LCD control pins RS (RB15)
221:                   // SLPTR for Radio (RB1)
222:                   LATB = 0x0000;
223:                   TRISB = 0b0111111111111101;
224:               
225:                   // LCD control pins RW(RD5), EN(RD4)
226:                   LATD = 0x0000;
227:                   TRISD = 0xffcf;
228:               
229:                   // LCD module: RE0-RE7 are outputs
230:                   LATE  = 0x0000;
231:                   TRISE = 0xff00;
232:               
233:                   // Radio: SPI2 Slave Select is an output (RG9)
234:                   LATG  = 0b0000000000;
235:                   TRISG = 0b0111111111;
236:               
237:               #endif
238:               }
00E17E  FA8000     ULNK
00E180  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/i2c_driver.c  -----------------------------------------
1:                 /*
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * I2C driver
31:                 *
32:                 * by Andrew Pullin
33:                 *
34:                 * v.0.1
35:                 *
36:                 * Revisions:
37:                 *  Andrew Pullin   2012-5-28   Centralized I2C machinery.
38:                 *
39:                 * Notes:
40:                 *  - This file is derived from the I2C machinery previously in gyro/xl.
41:                 *  - TODO (apullin): Module configuration might get centralized.
42:                 */
43:                
44:                #include "i2c_driver.h"
45:                #include "i2c.h"
46:                #include "generic_typedefs.h"
47:                #include "utils.h"
48:                #include <stdio.h>
49:                
50:                
51:                //////////////   Private declarations  ////////////////
52:                //void i2cConfig(void);
53:                
54:                
55:                ///////////////   Public functions  //////////////////
56:                //This is the PUBLIC setup function;
57:                //void i2cSetup(void){
58:                //    i2cConfig();
59:                //    //Do any other setup....
60:                //}
61:                
62:                void i2cStartTx(unsigned char channel){
00D6F8  FA0002     LNK #0x2
00D6FA  784F00     MOV.B W0, [W14]
63:                    if (channel == 1) { StartI2C1(); while(I2C1CONbits.SEN); }
00D6FC  78409E     MOV.B [W14], W1
00D6FE  B3C010     MOV #0x1, W0
00D700  50CF80     SUB.B W1, W0, [W15]
00D702  3A0009     BRA NZ, 0xD716
00D704  0222DE     CALL _StartI2C1
00D706  000000     NOP
00D708  000000     NOP
00D70A  801030     MOV I2C1CON, W0
00D70C  6000E1     AND W0, #0x1, W1
00D70E  EB0000     CLR W0
00D710  508F80     SUB W1, W0, [W15]
00D712  3AFFFB     BRA NZ, 0xD70A
00D714  370008     BRA 0xD726
64:                    else              { StartI2C2(); while(I2C2CONbits.SEN); }
00D716  0222E2     CALL _StartI2C2
00D718  000000     NOP
00D71A  000000     NOP
00D71C  8010B0     MOV I2C2CON, W0
00D71E  6000E1     AND W0, #0x1, W1
00D720  EB0000     CLR W0
00D722  508F80     SUB W1, W0, [W15]
00D724  3AFFFB     BRA NZ, 0xD71C
65:                }
00D726  FA8000     ULNK
00D728  060000     RETURN
66:                
67:                void i2cEndTx(unsigned char channel){
00D72A  FA0002     LNK #0x2
00D72C  784F00     MOV.B W0, [W14]
68:                    if (channel == 1) { StopI2C1(); while(I2C1CONbits.PEN); }
00D72E  78409E     MOV.B [W14], W1
00D730  B3C010     MOV #0x1, W0
00D732  50CF80     SUB.B W1, W0, [W15]
00D734  3A0009     BRA NZ, 0xD748
00D736  0222E6     CALL _StopI2C1
00D738  000000     NOP
00D73A  000000     NOP
00D73C  801030     MOV I2C1CON, W0
00D73E  6000E4     AND W0, #0x4, W1
00D740  EB0000     CLR W0
00D742  508F80     SUB W1, W0, [W15]
00D744  3AFFFB     BRA NZ, 0xD73C
00D746  370008     BRA 0xD758
69:                    else              { StopI2C2(); while(I2C2CONbits.PEN); }
00D748  0222EA     CALL _StopI2C2
00D74A  000000     NOP
00D74C  000000     NOP
00D74E  8010B0     MOV I2C2CON, W0
00D750  6000E4     AND W0, #0x4, W1
00D752  EB0000     CLR W0
00D754  508F80     SUB W1, W0, [W15]
00D756  3AFFFB     BRA NZ, 0xD74E
70:                }
00D758  FA8000     ULNK
00D75A  060000     RETURN
71:                
72:                void i2cSendNACK(unsigned char channel){
00D75C  FA0002     LNK #0x2
00D75E  784F00     MOV.B W0, [W14]
73:                    if (channel == 1) { NotAckI2C1(); while(I2C1CONbits.ACKEN); }
00D760  78409E     MOV.B [W14], W1
00D762  B3C010     MOV #0x1, W0
00D764  50CF80     SUB.B W1, W0, [W15]
00D766  3A0009     BRA NZ, 0xD77A
00D768  0222C6     CALL _NotAckI2C1
00D76A  000000     NOP
00D76C  000000     NOP
00D76E  801030     MOV I2C1CON, W0
00D770  6000F0     AND W0, #0x10, W1
00D772  EB0000     CLR W0
00D774  508F80     SUB W1, W0, [W15]
00D776  3AFFFB     BRA NZ, 0xD76E
00D778  370008     BRA 0xD78A
74:                    else              { NotAckI2C2(); while(I2C2CONbits.ACKEN); }
00D77A  0222CC     CALL _NotAckI2C2
00D77C  000000     NOP
00D77E  000000     NOP
00D780  8010B0     MOV I2C2CON, W0
00D782  6000F0     AND W0, #0x10, W1
00D784  EB0000     CLR W0
00D786  508F80     SUB W1, W0, [W15]
00D788  3AFFFB     BRA NZ, 0xD780
75:                }
00D78A  FA8000     ULNK
00D78C  060000     RETURN
76:                
77:                unsigned char i2cReceiveByte(unsigned char channel) {
00D78E  FA0002     LNK #0x2
00D790  784F00     MOV.B W0, [W14]
78:                    if (channel == 1) { return MasterReadI2C1(); }
00D792  78409E     MOV.B [W14], W1
00D794  B3C010     MOV #0x1, W0
00D796  50CF80     SUB.B W1, W0, [W15]
00D798  3A0003     BRA NZ, 0xD7A0
00D79A  0221DA     CALL _MasterReadI2C1
00D79C  000000     NOP
00D79E  370002     BRA 0xD7A4
79:                    else              { return MasterReadI2C2(); }
00D7A0  0221E8     CALL _MasterReadI2C2
00D7A2  000000     NOP
80:                }
00D7A4  FA8000     ULNK
00D7A6  060000     RETURN
81:                
82:                void i2cSendByte(unsigned char channel, unsigned char byte) {
00D7A8  FA0002     LNK #0x2
00D7AA  784F00     MOV.B W0, [W14]
00D7AC  984711     MOV.B W1, [W14+1]
83:                    if (channel == 1) {
00D7AE  78409E     MOV.B [W14], W1
00D7B0  B3C010     MOV #0x1, W0
00D7B2  50CF80     SUB.B W1, W0, [W15]
00D7B4  3A0012     BRA NZ, 0xD7DA
84:                        MasterWriteI2C1(byte);
00D7B6  90401E     MOV.B [W14+1], W0
00D7B8  0221F6     CALL _MasterWriteI2C1
00D7BA  000000     NOP
85:                        while(I2C1STATbits.TRSTAT);
00D7BC  000000     NOP
00D7BE  801041     MOV I2C1STAT, W1
00D7C0  240000     MOV #0x4000, W0
00D7C2  608080     AND W1, W0, W1
00D7C4  EB0000     CLR W0
00D7C6  508F80     SUB W1, W0, [W15]
00D7C8  3AFFFA     BRA NZ, 0xD7BE
86:                        while(I2C1STATbits.ACKSTAT);
00D7CA  000000     NOP
00D7CC  801041     MOV I2C1STAT, W1
00D7CE  280000     MOV #0x8000, W0
00D7D0  608080     AND W1, W0, W1
00D7D2  EB0000     CLR W0
00D7D4  508F80     SUB W1, W0, [W15]
00D7D6  3AFFFA     BRA NZ, 0xD7CC
00D7D8  370011     BRA 0xD7FC
87:                    } else {
88:                        MasterWriteI2C2(byte);
00D7DA  90401E     MOV.B [W14+1], W0
00D7DC  02221E     CALL _MasterWriteI2C2
00D7DE  000000     NOP
89:                        while(I2C2STATbits.TRSTAT);
00D7E0  000000     NOP
00D7E2  8010C1     MOV I2C2STAT, W1
00D7E4  240000     MOV #0x4000, W0
00D7E6  608080     AND W1, W0, W1
00D7E8  EB0000     CLR W0
00D7EA  508F80     SUB W1, W0, [W15]
00D7EC  3AFFFA     BRA NZ, 0xD7E2
90:                        while(I2C2STATbits.ACKSTAT);
00D7EE  000000     NOP
00D7F0  8010C1     MOV I2C2STAT, W1
00D7F2  280000     MOV #0x8000, W0
00D7F4  608080     AND W1, W0, W1
00D7F6  EB0000     CLR W0
00D7F8  508F80     SUB W1, W0, [W15]
00D7FA  3AFFFA     BRA NZ, 0xD7F0
91:                    }
92:                }
00D7FC  FA8000     ULNK
00D7FE  060000     RETURN
93:                
94:                unsigned int i2cReadString(unsigned char channel, unsigned length,
95:                                           unsigned char * data, unsigned int data_wait) {
00D800  FA0008     LNK #0x8
00D802  784F00     MOV.B W0, [W14]
00D804  980711     MOV W1, [W14+2]
00D806  980722     MOV W2, [W14+4]
00D808  980733     MOV W3, [W14+6]
96:                    if (channel == 1) { return MastergetsI2C1(length, data, data_wait); }
00D80A  78409E     MOV.B [W14], W1
00D80C  B3C010     MOV #0x1, W0
00D80E  50CF80     SUB.B W1, W0, [W15]
00D810  3A0006     BRA NZ, 0xD81E
00D812  90013E     MOV [W14+6], W2
00D814  9000AE     MOV [W14+4], W1
00D816  90001E     MOV [W14+2], W0
00D818  022246     CALL _MastergetsI2C1
00D81A  000000     NOP
00D81C  370005     BRA 0xD828
97:                    else              { return MastergetsI2C2(length, data, data_wait); }
00D81E  90013E     MOV [W14+6], W2
00D820  9000AE     MOV [W14+4], W1
00D822  90001E     MOV [W14+2], W0
00D824  022286     CALL _MastergetsI2C2
00D826  000000     NOP
98:                }
00D828  FA8000     ULNK
00D82A  060000     RETURN
99:                
100:               ///////////////   Private functions  //////////////////
101:               //void i2cConfig(void) {
102:               //    //Configuration is actually done by each module independently.
103:               //    //This may change in the future.
104:               //}
---  C:/Users/Cameron/Documents/Git/imageproc-lib/gyro.c  -----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * InvenSense ITG-3200 3-axis MEMS gyro IC Interface
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.1.0
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2010-05-30    Initial release
38:                 *
39:                 * Notes:
40:                 *  - This module uses an I2C port for communicating with the gyroscope chip
41:                 */
42:                
43:                #include "ports.h"      // for external interrupt
44:                #include "i2c.h"
45:                #include "gyro.h"
46:                #include "utils.h"
47:                #include "string.h"
48:                
49:                #define GYRO_ADDR_RD        0b11010001
50:                #define GYRO_ADDR_WR        0b11010000
51:                
52:                // Register addresses
53:                #define REG_WHO_AM_I            (0x00)
54:                #define REG_SMPLRT_DIV          (0x15)
55:                #define REG_DLPF_FS             (0x16)
56:                #define REG_INT_CFG             (0x17)
57:                #define REG_INT_STATUS          (0x1A)
58:                #define REG_TEMP_OUT_H          (0x1B)
59:                #define REG_TEMP_OUT_L          (0x1C)
60:                #define REG_GYRO_XOUT_H         (0x1D)
61:                #define REG_GYRO_XOUT_L         (0x1E)
62:                #define REG_GYRO_YOUT_H         (0x1F)
63:                #define REG_GYRO_YOUT_L         (0x20)
64:                #define REG_GYRO_ZOUT_H         (0x21)
65:                #define REG_GYRO_ZOUT_L         (0x22)
66:                #define REG_PWR_MGM             (0x3E)
67:                
68:                #define LSB2DEG             (0.0695652174)        // 14.375 LSB/(deg/s)
69:                #define LSB2RAD             (0.00121414209)
70:                
71:                #define DEFAULT_DEAD_ZONE   (0)             // Initial dead zone (0 disabled)
72:                #define INITIAL_CALIB_NUM   (300)           // Initial calibration samples
73:                #define I2C_TIMEOUT_BYTES   (200)           // Number of bytes for I2C timeout
74:                
75:                /*-----------------------------------------------------------------------------
76:                 *          Static Variables
77:                -----------------------------------------------------------------------------*/
78:                static unsigned char is_ready = 0;
79:                
80:                // data storage for receiving data
81:                static union gyrodata {
82:                    unsigned char chr_data[8];
83:                    int int_data[4];
84:                } GyroData;
85:                
86:                
87:                // calibration parameters for gyroscope
88:                static union {
89:                    float fdata[3];
90:                    unsigned char cdata[12];
91:                } GyroOffset;
92:                
93:                static int offsets[3];
94:                static int dead_zone; // Dead zone cutoff
95:                
96:                /*-----------------------------------------------------------------------------
97:                 *          Declaration of static functions
98:                -----------------------------------------------------------------------------*/
99:                static void gyroWrite(unsigned char regaddr, unsigned char data );
100:               static void gyroHandleISR(void);
101:               static inline unsigned int gyroReadString(unsigned length, unsigned char * data,
102:                                                  unsigned int data_wait);
103:               static inline void gyroSendByte( unsigned char byte );
104:               static inline unsigned char gyroReceiveByte(void);
105:               static inline void gyroSendNACK(void);
106:               static inline void gyroStartTx(void);
107:               static inline void gyroEndTx(void);
108:               static inline void gyroSetupPeripheral(void);
109:               static int applyDeadZone(int val);
110:               
111:               /*-----------------------------------------------------------------------------
112:                *          Public functions
113:               -----------------------------------------------------------------------------*/
114:               
115:               
116:               void gyroSetup(void) {
0093F0  FA0000     LNK #0x0
117:               
118:                   // setup I2C port
119:                   gyroSetupPeripheral();
0093F2  07023C     RCALL gyroSetupPeripheral
120:               
121:                   // external interrupt configuration.
122:                   // it is NOT USED at this moment.
123:                   ConfigINT1(RISING_EDGE_INT & EXT_INT_DISABLE & EXT_INT_PRI_3);
0093F4  2FFE30     MOV #0xFFE3, W0
0093F6  022314     CALL _ConfigINT1
0093F8  000000     NOP
124:               
125:                   dead_zone = DEFAULT_DEAD_ZONE;
0093FA  EB0000     CLR W0
0093FC  890900     MOV W0, dead_zone
126:               
127:                   delay_ms(25);   // power up delay, may not need...
0093FE  200190     MOV #0x19, W0
009400  02E270     CALL msELAPSED
009402  000000     NOP
128:                   //gyroWrite(REG_DLPF_FS, 0x1A);  // 2000 deg/sec, 1 kHz Sampling rate, 98Hz LPF
129:                   gyroWrite(REG_DLPF_FS, 0x19);  // 2000 deg/sec, 1 kHz Sampling rate, 196Hz LPF
009404  B3C191     MOV #0x19, W1
009406  B3C160     MOV #0x16, W0
009408  0701EE     RCALL gyroWrite
130:                   gyroWrite(REG_INT_CFG, 0x00);  // interrupt disabled
00940A  EB4080     CLR.B W1
00940C  B3C170     MOV #0x17, W0
00940E  0701EB     RCALL gyroWrite
131:                   gyroWrite(REG_PWR_MGM, 0x03);
009410  B3C031     MOV #0x3, W1
009412  B3C3E0     MOV #0x3E, W0
009414  0701E8     RCALL gyroWrite
132:                   delay_ms(1);   // PLL Settling time
009416  200010     MOV #0x1, W0
009418  02E270     CALL msELAPSED
00941A  000000     NOP
133:               
134:                   is_ready = 1;
00941C  221041     MOV #0x2104, W1
00941E  B3C010     MOV #0x1, W0
009420  784880     MOV.B W0, [W1]
135:               
136:                   gyroRunCalib(INITIAL_CALIB_NUM);  // quick calibration. better to run this with > 1000.
009422  2012C0     MOV #0x12C, W0
009424  070040     RCALL gyroRunCalib
137:               }
009426  FA8000     ULNK
009428  060000     RETURN
138:               
139:               void gyroSetDeadZone(int cutoff) {
00942A  FA0002     LNK #0x2
00942C  780F00     MOV W0, [W14]
140:               
141:                   if(cutoff < 0) { cutoff = -cutoff; }    // Correct negative inputs
00942E  78009E     MOV [W14], W1
009430  EB0000     CLR W0
009432  508F80     SUB W1, W0, [W15]
009434  3D0001     BRA GE, 0x9438
009436  EA0F1E     NEG [W14], [W14]
142:                   dead_zone = cutoff;
009438  78001E     MOV [W14], W0
00943A  890900     MOV W0, dead_zone
143:               
144:               }
00943C  FA8000     ULNK
00943E  060000     RETURN
145:               
146:               void gyroSetSampleRate(unsigned char rate) {
009440  FA0002     LNK #0x2
009442  784F00     MOV.B W0, [W14]
147:                   gyroWrite(REG_DLPF_FS, rate);
009444  78409E     MOV.B [W14], W1
009446  B3C160     MOV #0x16, W0
009448  0701CE     RCALL gyroWrite
148:               }
00944A  FA8000     ULNK
00944C  060000     RETURN
149:               
150:               void gyroSetIntEn(unsigned char flag) {
00944E  FA0002     LNK #0x2
009450  784F00     MOV.B W0, [W14]
151:                   _INT1IE = flag;
009452  78409E     MOV.B [W14], W1
009454  60C061     AND.B W1, #0x1, W0
009456  FB8000     ZE W0, W0
009458  600061     AND W0, #0x1, W0
00945A  DD0044     SL W0, #4, W0
00945C  8004B2     MOV IEC1, W2
00945E  2FFEF1     MOV #0xFFEF, W1
009460  610081     AND W2, W1, W1
009462  708000     IOR W1, W0, W0
009464  8804B0     MOV W0, IEC1
152:               }
009466  FA8000     ULNK
009468  060000     RETURN
153:               
154:               void gyroSleep(void) {
00946A  FA0000     LNK #0x0
155:                   gyroWrite(REG_PWR_MGM, 0x78);
00946C  B3C781     MOV #0x78, W1
00946E  B3C3E0     MOV #0x3E, W0
009470  0701BA     RCALL gyroWrite
156:               }
009472  FA8000     ULNK
009474  060000     RETURN
157:               
158:               void gyroWake(void) {
009476  FA0000     LNK #0x0
159:                   gyroWrite(REG_PWR_MGM, 0x03);
009478  B3C031     MOV #0x3, W1
00947A  B3C3E0     MOV #0x3E, W0
00947C  0701B4     RCALL gyroWrite
160:               }
00947E  FA8000     ULNK
009480  060000     RETURN
161:               
162:               unsigned char* gyroGetCalibParam(void) {
009482  FA0000     LNK #0x0
163:                   return GyroOffset.cdata;
009484  2210E0     MOV #0x210E, W0
164:               }
009486  FA8000     ULNK
009488  060000     RETURN
165:               
166:               void gyroGetOffsets(int* data){
00948A  FA0002     LNK #0x2
00948C  780F00     MOV W0, [W14]
167:                   data[0] = offsets[0];
00948E  8108D1     MOV offsets, W1
009490  78001E     MOV [W14], W0
009492  780801     MOV W1, [W0]
168:                   data[1] = offsets[1];
009494  E8801E     INC2 [W14], W0
009496  8108E1     MOV 0x211C, W1
009498  780801     MOV W1, [W0]
169:                   data[2] = offsets[2];
00949A  78009E     MOV [W14], W1
00949C  408064     ADD W1, #0x4, W0
00949E  8108F1     MOV 0x211E, W1
0094A0  780801     MOV W1, [W0]
170:               }
0094A2  FA8000     ULNK
0094A4  060000     RETURN
171:               
172:               void gyroRunCalib(unsigned int count){
0094A6  FA0016     LNK #0x16
0094A8  BE9F88     MOV.D W8, [W15++]
0094AA  980F20     MOV W0, [W14+20]
173:               
174:                   unsigned int i;
175:                   long x_acc, y_acc, z_acc;
176:                   x_acc = 0;
0094AC  B80060     MUL.UU W0, #0, W0
0094AE  980710     MOV W0, [W14+2]
0094B0  980721     MOV W1, [W14+4]
177:                   y_acc = 0;
0094B2  B80060     MUL.UU W0, #0, W0
0094B4  980730     MOV W0, [W14+6]
0094B6  980741     MOV W1, [W14+8]
178:                   z_acc = 0;
0094B8  B80060     MUL.UU W0, #0, W0
0094BA  980750     MOV W0, [W14+10]
0094BC  980761     MOV W1, [W14+12]
179:               
180:                   CRITICAL_SECTION_START
0094BE  800210     MOV SR, W0
0094C0  DE0045     LSR W0, #5, W0
0094C2  604067     AND.B W0, #0x7, W0
0094C4  984F60     MOV.B W0, [W14+14]
0094C6  800290     MOV DISICNT, W0
0094C8  980F00     MOV W0, [W14+16]
0094CA  FC3FFF     DISI #0x3FFF
0094CC  800211     MOV SR, W1
0094CE  200E00     MOV #0xE0, W0
0094D0  708000     IOR W1, W0, W0
0094D2  880210     MOV W0, SR
0094D4  90080E     MOV [W14+16], W0
0094D6  880290     MOV W0, DISICNT
0094D8  880000     MOV W0, WREG0
181:               
182:                   for (i = 0; i < count; ++i) {
0094DA  EB0000     CLR W0
0094DC  780F00     MOV W0, [W14]
0094DE  370020     BRA 0x9520
00951E  E80F1E     INC [W14], [W14]
009520  90082E     MOV [W14+20], W0
009522  78009E     MOV [W14], W1
009524  508F80     SUB W1, W0, [W15]
009526  39FFDC     BRA NC, 0x94E0
183:                       gyroReadXYZ();
0094E0  070145     RCALL gyroReadXYZ
184:                       x_acc += GyroData.int_data[1];
0094E2  221060     MOV #0x2106, W0
0094E4  900010     MOV [W0+2], W0
0094E6  DE80CF     ASR W0, #15, W1
0094E8  90011E     MOV [W14+2], W2
0094EA  9001AE     MOV [W14+4], W3
0094EC  400002     ADD W0, W2, W0
0094EE  488083     ADDC W1, W3, W1
0094F0  980710     MOV W0, [W14+2]
0094F2  980721     MOV W1, [W14+4]
185:                       y_acc += GyroData.int_data[2];
0094F4  221060     MOV #0x2106, W0
0094F6  900020     MOV [W0+4], W0
0094F8  DE80CF     ASR W0, #15, W1
0094FA  90013E     MOV [W14+6], W2
0094FC  9001CE     MOV [W14+8], W3
0094FE  400002     ADD W0, W2, W0
009500  488083     ADDC W1, W3, W1
009502  980730     MOV W0, [W14+6]
009504  980741     MOV W1, [W14+8]
186:                       z_acc += GyroData.int_data[3];
009506  221060     MOV #0x2106, W0
009508  900030     MOV [W0+6], W0
00950A  DE80CF     ASR W0, #15, W1
00950C  90015E     MOV [W14+10], W2
00950E  9001EE     MOV [W14+12], W3
009510  400002     ADD W0, W2, W0
009512  488083     ADDC W1, W3, W1
009514  980750     MOV W0, [W14+10]
009516  980761     MOV W1, [W14+12]
187:                       delay_ms(1); // Sample at around 1kHz
009518  200010     MOV #0x1, W0
00951A  02E270     CALL msELAPSED
00951C  000000     NOP
188:                   }
189:               
190:                   CRITICAL_SECTION_END
009528  800290     MOV DISICNT, W0
00952A  980F10     MOV W0, [W14+18]
00952C  FC3FFF     DISI #0x3FFF
00952E  90486E     MOV.B [W14+14], W0
009530  604067     AND.B W0, #0x7, W0
009532  FB8000     ZE W0, W0
009534  600067     AND W0, #0x7, W0
009536  DD0045     SL W0, #5, W0
009538  800212     MOV SR, W2
00953A  2FF1F1     MOV #0xFF1F, W1
00953C  610081     AND W2, W1, W1
00953E  708000     IOR W1, W0, W0
009540  880210     MOV W0, SR
009542  90081E     MOV [W14+18], W0
009544  880290     MOV W0, DISICNT
009546  880000     MOV W0, WREG0
191:               
192:                   offsets[0] = x_acc/count;
009548  90082E     MOV [W14+20], W0
00954A  200001     MOV #0x0, W1
00954C  BE0100     MOV.D W0, W2
00954E  90001E     MOV [W14+2], W0
009550  9000AE     MOV [W14+4], W1
009552  022586     CALL ___divsi3
009554  000000     NOP
009556  780000     MOV W0, W0
009558  8908D0     MOV W0, offsets
193:                   offsets[1] = y_acc/count;
00955A  90082E     MOV [W14+20], W0
00955C  200001     MOV #0x0, W1
00955E  BE0100     MOV.D W0, W2
009560  90003E     MOV [W14+6], W0
009562  9000CE     MOV [W14+8], W1
009564  022586     CALL ___divsi3
009566  000000     NOP
009568  780000     MOV W0, W0
00956A  8908E0     MOV W0, 0x211C
194:                   offsets[2] = z_acc/count;
00956C  90082E     MOV [W14+20], W0
00956E  200001     MOV #0x0, W1
009570  BE0100     MOV.D W0, W2
009572  90005E     MOV [W14+10], W0
009574  9000EE     MOV [W14+12], W1
009576  022586     CALL ___divsi3
009578  000000     NOP
00957A  780000     MOV W0, W0
00957C  8908F0     MOV W0, 0x211E
195:               
196:                   GyroOffset.fdata[0] = 1.0*x_acc/count;
00957E  90001E     MOV [W14+2], W0
009580  9000AE     MOV [W14+4], W1
009582  022624     CALL ___floatsisf
009584  000000     NOP
009586  BE0400     MOV.D W0, W8
009588  90082E     MOV [W14+20], W0
00958A  200001     MOV #0x0, W1
00958C  022640     CALL ___floatunsisf
00958E  000000     NOP
009590  BE0100     MOV.D W0, W2
009592  BE0008     MOV.D W8, W0
009594  022E80     CALL ___divsf3x
009596  000000     NOP
009598  890870     MOV W0, GyroOffset
00959A  890881     MOV W1, 0x2110
197:                   GyroOffset.fdata[1] = 1.0*y_acc/count;
00959C  90003E     MOV [W14+6], W0
00959E  9000CE     MOV [W14+8], W1
0095A0  022624     CALL ___floatsisf
0095A2  000000     NOP
0095A4  BE0400     MOV.D W0, W8
0095A6  90082E     MOV [W14+20], W0
0095A8  200001     MOV #0x0, W1
0095AA  022640     CALL ___floatunsisf
0095AC  000000     NOP
0095AE  BE0100     MOV.D W0, W2
0095B0  BE0008     MOV.D W8, W0
0095B2  022E80     CALL ___divsf3x
0095B4  000000     NOP
0095B6  890890     MOV W0, 0x2112
0095B8  8908A1     MOV W1, 0x2114
198:                   GyroOffset.fdata[2] = 1.0*z_acc/count;
0095BA  90005E     MOV [W14+10], W0
0095BC  9000EE     MOV [W14+12], W1
0095BE  022624     CALL ___floatsisf
0095C0  000000     NOP
0095C2  BE0400     MOV.D W0, W8
0095C4  90082E     MOV [W14+20], W0
0095C6  200001     MOV #0x0, W1
0095C8  022640     CALL ___floatunsisf
0095CA  000000     NOP
0095CC  BE0100     MOV.D W0, W2
0095CE  BE0008     MOV.D W8, W0
0095D0  022E80     CALL ___divsf3x
0095D2  000000     NOP
0095D4  8908B0     MOV W0, 0x2116
0095D6  8908C1     MOV W1, 0x2118
199:               
200:               }
0095D8  BE044F     MOV.D [--W15], W8
0095DA  FA8000     ULNK
0095DC  060000     RETURN
201:               
202:               float gyroGetFloatTemp(void) {
0095DE  FA0000     LNK #0x0
203:                   
204:                   return (35 + (gyroGetIntTemp() + 13200) / 280.0);
0095E0  07000F     RCALL gyroGetIntTemp
0095E2  233901     MOV #0x3390, W1
0095E4  400001     ADD W0, W1, W0
0095E6  DE80CF     ASR W0, #15, W1
0095E8  022624     CALL ___floatsisf
0095EA  000000     NOP
0095EC  200002     MOV #0x0, W2
0095EE  2438C3     MOV #0x438C, W3
0095F0  022E80     CALL ___divsf3x
0095F2  000000     NOP
0095F4  200002     MOV #0x0, W2
0095F6  2420C3     MOV #0x420C, W3
0095F8  022A6C     CALL ___addsf3
0095FA  000000     NOP
205:               }
0095FC  FA8000     ULNK
0095FE  060000     RETURN
206:               
207:               int gyroGetIntTemp(void) {
009600  FA0000     LNK #0x0
208:                   return GyroData.int_data[0];
009602  221060     MOV #0x2106, W0
009604  780010     MOV [W0], W0
209:               }
009606  FA8000     ULNK
009608  060000     RETURN
210:               
211:               void gyroReadTemp(void) {
00960A  FA0002     LNK #0x2
212:                   unsigned char temp_data[2];
213:               
214:                   gyroStartTx();
00960C  070119     RCALL gyroStartTx
215:                   gyroSendByte(GYRO_ADDR_WR);
00960E  B3CD00     MOV #0xD0, W0
009610  070102     RCALL gyroSendByte
216:                   gyroSendByte(REG_TEMP_OUT_H);
009612  B3C1B0     MOV #0x1B, W0
009614  070100     RCALL gyroSendByte
217:                   gyroEndTx();
009616  07011F     RCALL gyroEndTx
218:                   gyroStartTx();
009618  070113     RCALL gyroStartTx
219:                   gyroSendByte(GYRO_ADDR_RD);
00961A  B3CD10     MOV #0xD1, W0
00961C  0700FC     RCALL gyroSendByte
220:                   gyroReadString(2, temp_data, I2C_TIMEOUT_BYTES);
00961E  200C82     MOV #0xC8, W2
009620  78008E     MOV W14, W1
009622  200020     MOV #0x2, W0
009624  0700ED     RCALL gyroReadString
221:                   gyroEndTx();
009626  070117     RCALL gyroEndTx
222:               
223:                   GyroData.chr_data[0] = temp_data[1];
009628  90401E     MOV.B [W14+1], W0
00962A  221061     MOV #0x2106, W1
00962C  784880     MOV.B W0, [W1]
224:                   GyroData.chr_data[1] = temp_data[0];
00962E  78401E     MOV.B [W14], W0
009630  221061     MOV #0x2106, W1
009632  984090     MOV.B W0, [W1+1]
225:               }
009634  FA8000     ULNK
009636  060000     RETURN
226:               
227:               void gyroGetIntXYZ(int* data) {
009638  FA0002     LNK #0x2
00963A  781F88     MOV W8, [W15++]
00963C  780F00     MOV W0, [W14]
228:               
229:                   data[0] = gyroGetIntX();
00963E  07000C     RCALL gyroGetIntX
009640  78009E     MOV [W14], W1
009642  780880     MOV W0, [W1]
230:                   data[1] = gyroGetIntY();
009644  E8841E     INC2 [W14], W8
009646  070010     RCALL gyroGetIntY
009648  780C00     MOV W0, [W8]
231:                   data[2] = gyroGetIntZ();
00964A  78001E     MOV [W14], W0
00964C  400464     ADD W0, #0x4, W8
00964E  070014     RCALL gyroGetIntZ
009650  780C00     MOV W0, [W8]
232:               
233:               }
009652  78044F     MOV [--W15], W8
009654  FA8000     ULNK
009656  060000     RETURN
234:               
235:               int gyroGetIntX(void) {
009658  FA0000     LNK #0x0
236:                   return applyDeadZone(GyroData.int_data[1] - offsets[0]);
00965A  221060     MOV #0x2106, W0
00965C  900090     MOV [W0+2], W1
00965E  8108D0     MOV offsets, W0
009660  508000     SUB W1, W0, W0
009662  070111     RCALL applyDeadZone
237:               }
009664  FA8000     ULNK
009666  060000     RETURN
238:               
239:               int gyroGetIntY(void) {
009668  FA0000     LNK #0x0
240:                   return applyDeadZone(GyroData.int_data[2] - offsets[1]);
00966A  221060     MOV #0x2106, W0
00966C  9000A0     MOV [W0+4], W1
00966E  8108E0     MOV 0x211C, W0
009670  508000     SUB W1, W0, W0
009672  070109     RCALL applyDeadZone
241:               }
009674  FA8000     ULNK
009676  060000     RETURN
242:               
243:               int gyroGetIntZ(void) {
009678  FA0000     LNK #0x0
244:                   return applyDeadZone(GyroData.int_data[3] - offsets[2]);
00967A  221060     MOV #0x2106, W0
00967C  9000B0     MOV [W0+6], W1
00967E  8108F0     MOV 0x211E, W0
009680  508000     SUB W1, W0, W0
009682  070101     RCALL applyDeadZone
245:               }
009684  FA8000     ULNK
009686  060000     RETURN
246:               
247:               void gyroGetRadXYZ(float* data) {
009688  FA0002     LNK #0x2
00968A  781F88     MOV W8, [W15++]
00968C  780F00     MOV W0, [W14]
248:                   data[0] = gyroGetRadX();
00968E  07000D     RCALL gyroGetRadX
009690  78011E     MOV [W14], W2
009692  BE8900     MOV.D W0, [W2]
249:                   data[1] = gyroGetRadY();
009694  78001E     MOV [W14], W0
009696  400464     ADD W0, #0x4, W8
009698  070013     RCALL gyroGetRadY
00969A  BE8C00     MOV.D W0, [W8]
250:                   data[2] = gyroGetRadZ();
00969C  78001E     MOV [W14], W0
00969E  400468     ADD W0, #0x8, W8
0096A0  07001A     RCALL gyroGetRadZ
0096A2  BE8C00     MOV.D W0, [W8]
251:               }
0096A4  78044F     MOV [--W15], W8
0096A6  FA8000     ULNK
0096A8  060000     RETURN
252:               
253:               float gyroGetRadX(void) {
0096AA  FA0000     LNK #0x0
254:                   return LSB2RAD*gyroGetIntX();
0096AC  07FFD5     RCALL gyroGetIntX
0096AE  DE80CF     ASR W0, #15, W1
0096B0  022624     CALL ___floatsisf
0096B2  000000     NOP
0096B4  223D92     MOV #0x23D9, W2
0096B6  23A9F3     MOV #0x3A9F, W3
0096B8  022C36     CALL ___mulsf3
0096BA  000000     NOP
255:               }
0096BC  FA8000     ULNK
0096BE  060000     RETURN
256:               
257:               float gyroGetRadY(void) {
0096C0  FA0000     LNK #0x0
258:                   return LSB2RAD*gyroGetIntY();
0096C2  07FFD2     RCALL gyroGetIntY
0096C4  DE80CF     ASR W0, #15, W1
0096C6  022624     CALL ___floatsisf
0096C8  000000     NOP
0096CA  223D92     MOV #0x23D9, W2
0096CC  23A9F3     MOV #0x3A9F, W3
0096CE  022C36     CALL ___mulsf3
0096D0  000000     NOP
259:               }
0096D2  FA8000     ULNK
0096D4  060000     RETURN
260:               
261:               float gyroGetRadZ(void) {
0096D6  FA0000     LNK #0x0
262:                   return LSB2RAD*gyroGetIntZ();
0096D8  07FFCF     RCALL gyroGetIntZ
0096DA  DE80CF     ASR W0, #15, W1
0096DC  022624     CALL ___floatsisf
0096DE  000000     NOP
0096E0  223D92     MOV #0x23D9, W2
0096E2  23A9F3     MOV #0x3A9F, W3
0096E4  022C36     CALL ___mulsf3
0096E6  000000     NOP
263:               }
0096E8  FA8000     ULNK
0096EA  060000     RETURN
264:               
265:               void gyroGetDegXYZ(float* data) {
0096EC  FA0002     LNK #0x2
0096EE  781F88     MOV W8, [W15++]
0096F0  780F00     MOV W0, [W14]
266:                   data[0] = gyroGetDegX();
0096F2  07000D     RCALL gyroGetDegX
0096F4  78011E     MOV [W14], W2
0096F6  BE8900     MOV.D W0, [W2]
267:                   data[1] = gyroGetDegY();
0096F8  78001E     MOV [W14], W0
0096FA  400464     ADD W0, #0x4, W8
0096FC  070013     RCALL gyroGetDegY
0096FE  BE8C00     MOV.D W0, [W8]
268:                   data[2] = gyroGetDegZ();
009700  78001E     MOV [W14], W0
009702  400468     ADD W0, #0x8, W8
009704  07001A     RCALL gyroGetDegZ
009706  BE8C00     MOV.D W0, [W8]
269:               }
009708  78044F     MOV [--W15], W8
00970A  FA8000     ULNK
00970C  060000     RETURN
270:               
271:               float gyroGetDegX(void) {
00970E  FA0000     LNK #0x0
272:                   return LSB2DEG*gyroGetIntX();
009710  07FFA3     RCALL gyroGetIntX
009712  DE80CF     ASR W0, #15, W1
009714  022624     CALL ___floatsisf
009716  000000     NOP
009718  278352     MOV #0x7835, W2
00971A  23D8E3     MOV #0x3D8E, W3
00971C  022C36     CALL ___mulsf3
00971E  000000     NOP
273:               }
009720  FA8000     ULNK
009722  060000     RETURN
274:               
275:               float gyroGetDegY(void) {
009724  FA0000     LNK #0x0
276:                   return LSB2DEG*gyroGetIntY();
009726  07FFA0     RCALL gyroGetIntY
009728  DE80CF     ASR W0, #15, W1
00972A  022624     CALL ___floatsisf
00972C  000000     NOP
00972E  278352     MOV #0x7835, W2
009730  23D8E3     MOV #0x3D8E, W3
009732  022C36     CALL ___mulsf3
009734  000000     NOP
277:               }
009736  FA8000     ULNK
009738  060000     RETURN
278:               
279:               float gyroGetDegZ(void) {
00973A  FA0000     LNK #0x0
280:                   return LSB2DEG*gyroGetIntZ();
00973C  07FF9D     RCALL gyroGetIntZ
00973E  DE80CF     ASR W0, #15, W1
009740  022624     CALL ___floatsisf
009742  000000     NOP
009744  278352     MOV #0x7835, W2
009746  23D8E3     MOV #0x3D8E, W3
009748  022C36     CALL ___mulsf3
00974A  000000     NOP
281:               }
00974C  FA8000     ULNK
00974E  060000     RETURN
282:               
283:               unsigned char* gyroToString(void) {
009750  FA0000     LNK #0x0
284:                   return GyroData.chr_data + 2;
009752  221080     MOV #0x2108, W0
285:               }
009754  FA8000     ULNK
009756  060000     RETURN
286:               
287:               void gyroDumpData(unsigned char* buffer) {
009758  FA0002     LNK #0x2
00975A  780F00     MOV W0, [W14]
288:                   memcpy(buffer, GyroData.chr_data + 2, 6);
00975C  221080     MOV #0x2108, W0
00975E  200062     MOV #0x6, W2
009760  780080     MOV W0, W1
009762  78001E     MOV [W14], W0
009764  023582     CALL _memcpy
009766  000000     NOP
289:               }
009768  FA8000     ULNK
00976A  060000     RETURN
290:               
291:               //void gyroDumpData(unsigned char* buffer) {
292:               //
293:               //    int i;
294:               //    for (i = 0; i < 6; i++) {
295:               //        buffer[i] = GyroData.chr_data[2 + i];
296:               //    }
297:               //}
298:               
299:               
300:               unsigned char* gyroReadXYZ(void) {
00976C  FA0006     LNK #0x6
301:                   unsigned char gyro_data[6];
302:                   gyroStartTx();
00976E  070068     RCALL gyroStartTx
303:                   gyroSendByte(GYRO_ADDR_WR);
009770  B3CD00     MOV #0xD0, W0
009772  070051     RCALL gyroSendByte
304:                   gyroSendByte(0x1d);
009774  B3C1D0     MOV #0x1D, W0
009776  07004F     RCALL gyroSendByte
305:                   gyroEndTx();
009778  07006E     RCALL gyroEndTx
306:                   gyroStartTx();
00977A  070062     RCALL gyroStartTx
307:                   gyroSendByte(GYRO_ADDR_RD);
00977C  B3CD10     MOV #0xD1, W0
00977E  07004B     RCALL gyroSendByte
308:                   gyroReadString(6, gyro_data, I2C_TIMEOUT_BYTES);
009780  200C82     MOV #0xC8, W2
009782  78008E     MOV W14, W1
009784  200060     MOV #0x6, W0
009786  07003C     RCALL gyroReadString
309:                   gyroEndTx();
009788  070066     RCALL gyroEndTx
310:               
311:                   GyroData.chr_data[2] = gyro_data[1];
00978A  90401E     MOV.B [W14+1], W0
00978C  221061     MOV #0x2106, W1
00978E  9840A0     MOV.B W0, [W1+2]
312:                   GyroData.chr_data[3] = gyro_data[0];
009790  78401E     MOV.B [W14], W0
009792  221061     MOV #0x2106, W1
009794  9840B0     MOV.B W0, [W1+3]
313:                   GyroData.chr_data[4] = gyro_data[3];
009796  90403E     MOV.B [W14+3], W0
009798  221061     MOV #0x2106, W1
00979A  9840C0     MOV.B W0, [W1+4]
314:                   GyroData.chr_data[5] = gyro_data[2];
00979C  90402E     MOV.B [W14+2], W0
00979E  221061     MOV #0x2106, W1
0097A0  9840D0     MOV.B W0, [W1+5]
315:                   GyroData.chr_data[6] = gyro_data[5];
0097A2  90405E     MOV.B [W14+5], W0
0097A4  221061     MOV #0x2106, W1
0097A6  9840E0     MOV.B W0, [W1+6]
316:                   GyroData.chr_data[7] = gyro_data[4];
0097A8  90404E     MOV.B [W14+4], W0
0097AA  221061     MOV #0x2106, W1
0097AC  9840F0     MOV.B W0, [W1+7]
317:               
318:                   return GyroData.chr_data + 2;
0097AE  221080     MOV #0x2108, W0
319:               }
0097B0  FA8000     ULNK
0097B2  060000     RETURN
320:               
321:               void gyroGetXYZ(unsigned char *data) {
0097B4  FA0002     LNK #0x2
0097B6  780F00     MOV W0, [W14]
322:                   gyroReadXYZ();
0097B8  07FFD9     RCALL gyroReadXYZ
323:                   gyroDumpData(data);
0097BA  78001E     MOV [W14], W0
0097BC  07FFCD     RCALL gyroDumpData
324:               }
0097BE  FA8000     ULNK
0097C0  060000     RETURN
325:               
326:               
327:               /*-----------------------------------------------------------------------------
328:                * ----------------------------------------------------------------------------
329:                * The functions below are intended for internal use, i.e., private methods.
330:                * Users are recommended to use functions defined above.
331:                * ----------------------------------------------------------------------------
332:               -----------------------------------------------------------------------------*/
333:               
334:               /******************************************************************************
335:                * Interrupt handler for Gyroscope
336:                * ****************************************************************************/
337:               void __attribute__((interrupt, no_auto_psv)) _INT1Interrupt(void) {
0097C2  F80036     PUSH RCOUNT
0097C4  BE9F80     MOV.D W0, [W15++]
0097C6  BE9F82     MOV.D W2, [W15++]
0097C8  BE9F84     MOV.D W4, [W15++]
0097CA  BE9F86     MOV.D W6, [W15++]
0097CC  FA0000     LNK #0x0
338:                   gyroHandleISR();
0097CE  070008     RCALL gyroHandleISR
339:                   _INT1IF = 0;    // Clear the interrupt flag
0097D0  A98086     BCLR IFS1, #4
340:               }
0097D2  FA8000     ULNK
0097D4  BE034F     MOV.D [--W15], W6
0097D6  BE024F     MOV.D [--W15], W4
0097D8  BE014F     MOV.D [--W15], W2
0097DA  BE004F     MOV.D [--W15], W0
0097DC  F90036     POP RCOUNT
0097DE  064000     RETFIE
341:               
342:               /*****************************************************************************
343:               * Function Name : gyroHandleISR
344:               * Description   : Need to implement this function if interrupt is used.
345:               * Parameters    : None
346:               * Return Value  : None
347:               *****************************************************************************/
348:               static void gyroHandleISR(void) {
0097E0  FA0000     LNK #0x0
349:                   return;
350:               }
0097E2  FA8000     ULNK
0097E4  060000     RETURN
351:               
352:               
353:               /*****************************************************************************
354:               * Function Name : gyroWrite
355:               * Description   : Write a data to a register
356:               * Parameters    : regaddr - address of register
357:               *                 data - value to be written to the register
358:               * Return Value  : None
359:               *****************************************************************************/
360:               static void gyroWrite(unsigned char regaddr, unsigned char data ){
0097E6  FA0002     LNK #0x2
0097E8  784F00     MOV.B W0, [W14]
0097EA  984711     MOV.B W1, [W14+1]
361:                   gyroStartTx();
0097EC  070029     RCALL gyroStartTx
362:                   gyroSendByte(GYRO_ADDR_WR);
0097EE  B3CD00     MOV #0xD0, W0
0097F0  070012     RCALL gyroSendByte
363:                   gyroSendByte(regaddr);
0097F2  78401E     MOV.B [W14], W0
0097F4  070010     RCALL gyroSendByte
364:                   gyroSendByte(data);
0097F6  90401E     MOV.B [W14+1], W0
0097F8  07000E     RCALL gyroSendByte
365:                   gyroEndTx();
0097FA  07002D     RCALL gyroEndTx
366:               }
0097FC  FA8000     ULNK
0097FE  060000     RETURN
367:               
368:               /*****************************************************************************
369:               * Function Name : gyroReadString
370:               * Description   : It reads predetermined data string length from the I2C bus.
371:               * Parameters    : length is the string length to read
372:               *                 data is the storage for received gyro data
373:               *                 data_wait is the timeout value
374:               * Return Value  : Number of bytes read before timeout.
375:               *****************************************************************************/
376:               static inline unsigned int gyroReadString(unsigned length, unsigned char * data,
377:                                                  unsigned int data_wait) {
009800  FA0006     LNK #0x6
009802  780F00     MOV W0, [W14]
009804  980711     MOV W1, [W14+2]
009806  980722     MOV W2, [W14+4]
378:                   return MastergetsI2C2(length, data, data_wait);
009808  90012E     MOV [W14+4], W2
00980A  90009E     MOV [W14+2], W1
00980C  78001E     MOV [W14], W0
00980E  022286     CALL _MastergetsI2C2
009810  000000     NOP
379:               }
009812  FA8000     ULNK
009814  060000     RETURN
380:               
381:               
382:               /*****************************************************************************
383:               * Function Name : gyroSendByte
384:               * Description   : Send a byte to gyroscope
385:               * Parameters    : byte - a byte to send
386:               * Return Value  : None
387:               *****************************************************************************/
388:               static inline void gyroSendByte( unsigned char byte ) {
009816  FA0002     LNK #0x2
009818  784F00     MOV.B W0, [W14]
389:                   MasterWriteI2C2(byte);
00981A  78401E     MOV.B [W14], W0
00981C  02221E     CALL _MasterWriteI2C2
00981E  000000     NOP
390:                   while(I2C2STATbits.TRSTAT);
009820  000000     NOP
009822  8010C1     MOV I2C2STAT, W1
009824  240000     MOV #0x4000, W0
009826  608080     AND W1, W0, W1
009828  EB0000     CLR W0
00982A  508F80     SUB W1, W0, [W15]
00982C  3AFFFA     BRA NZ, 0x9822
391:                   while(I2C2STATbits.ACKSTAT);
00982E  000000     NOP
009830  8010C1     MOV I2C2STAT, W1
009832  280000     MOV #0x8000, W0
009834  608080     AND W1, W0, W1
009836  EB0000     CLR W0
009838  508F80     SUB W1, W0, [W15]
00983A  3AFFFA     BRA NZ, 0x9830
392:               }
00983C  FA8000     ULNK
00983E  060000     RETURN
393:               
394:               /*****************************************************************************
395:               * Function Name : gyroReceiveByte
396:               * Description   : Receive a byte from gyroscope
397:               * Parameters    : None
398:               * Return Value  : None
399:               *****************************************************************************/
400:               static inline unsigned char gyroReceiveByte(void) {
401:                   return MasterReadI2C2();
402:               }
403:               
404:               /*****************************************************************************
405:               * Function Name : gyroSendNACK
406:               * Description   : Send NACK to gyroscope
407:               * Parameters    : None
408:               * Return Value  : None
409:               *****************************************************************************/
410:               static inline void gyroSendNACK(void){
411:                   NotAckI2C2();
412:                   while(I2C2CONbits.ACKEN);
413:               }
414:               
415:               /*****************************************************************************
416:               * Function Name : gyroStartTx
417:               * Description   : Start I2C transmission
418:               * Parameters    : None
419:               * Return Value  : None
420:               *****************************************************************************/
421:               static inline void gyroStartTx(void){
009840  FA0000     LNK #0x0
422:                   StartI2C2();
009842  0222E2     CALL _StartI2C2
009844  000000     NOP
423:                   while(I2C2CONbits.SEN);
009846  000000     NOP
009848  8010B0     MOV I2C2CON, W0
00984A  6000E1     AND W0, #0x1, W1
00984C  EB0000     CLR W0
00984E  508F80     SUB W1, W0, [W15]
009850  3AFFFB     BRA NZ, 0x9848
424:               }
009852  FA8000     ULNK
009854  060000     RETURN
425:               
426:               /*****************************************************************************
427:               * Function Name : gyroEndTx
428:               * Description   : End I2C transmission
429:               * Parameters    : None
430:               * Return Value  : None
431:               *****************************************************************************/
432:               static inline void gyroEndTx(void){
009856  FA0000     LNK #0x0
433:                   StopI2C2();
009858  0222EA     CALL _StopI2C2
00985A  000000     NOP
434:                   while(I2C2CONbits.PEN);
00985C  000000     NOP
00985E  8010B0     MOV I2C2CON, W0
009860  6000E4     AND W0, #0x4, W1
009862  EB0000     CLR W0
009864  508F80     SUB W1, W0, [W15]
009866  3AFFFB     BRA NZ, 0x985E
435:               }
009868  FA8000     ULNK
00986A  060000     RETURN
436:               
437:               /*****************************************************************************
438:               * Function Name : gyroSetupPeripheral
439:               * Description   : Setup I2C for gyroscope
440:               * Parameters    : None
441:               * Return Value  : None
442:               *****************************************************************************/
443:               static inline void gyroSetupPeripheral(void) {
00986C  FA0004     LNK #0x4
444:                   unsigned int I2C2CONvalue, I2C2BRGvalue;
445:                   I2C2CONvalue = I2C2_ON & I2C2_IDLE_CON & I2C2_CLK_HLD &
00986E  2C2200     MOV #0xC220, W0
009870  780F00     MOV W0, [W14]
446:                                  I2C2_IPMI_DIS & I2C2_7BIT_ADD & I2C2_SLW_DIS &
447:                                  I2C2_SM_DIS & I2C2_GCALL_DIS & I2C2_STR_DIS &
448:                                  I2C2_NACK & I2C2_ACK_DIS & I2C2_RCV_DIS &
449:                                  I2C2_STOP_DIS & I2C2_RESTART_DIS & I2C2_START_DIS;
450:               
451:                   // BRG = Fcy(1/Fscl - 1/10000000)-1, Fscl = 400KHz
452:                   I2C2BRGvalue = 95;
009872  2005F0     MOV #0x5F, W0
009874  980710     MOV W0, [W14+2]
453:                   OpenI2C2(I2C2CONvalue, I2C2BRGvalue);
009876  90009E     MOV [W14+2], W1
009878  78001E     MOV [W14], W0
00987A  0222D8     CALL _OpenI2C2
00987C  000000     NOP
454:                   IdleI2C2();
00987E  0221A8     CALL _IdleI2C2
009880  000000     NOP
455:               }
009882  FA8000     ULNK
009884  060000     RETURN
456:               
457:               // Dead zone a value
458:               static int applyDeadZone(int val) {
009886  FA0002     LNK #0x2
009888  780F00     MOV W0, [W14]
459:               
460:                   if(val < dead_zone && val > -dead_zone) { val = 0; }
00988A  810900     MOV dead_zone, W0
00988C  78009E     MOV [W14], W1
00988E  508F80     SUB W1, W0, [W15]
009890  3D0007     BRA GE, 0x98A0
009892  810900     MOV dead_zone, W0
009894  EA0080     NEG W0, W1
009896  78001E     MOV [W14], W0
009898  508F80     SUB W1, W0, [W15]
00989A  3D0002     BRA GE, 0x98A0
00989C  EB0000     CLR W0
00989E  780F00     MOV W0, [W14]
461:                   return val;
0098A0  78001E     MOV [W14], W0
462:               
463:               }
0098A2  FA8000     ULNK
0098A4  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/dfmem.c  ----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2008-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * ATMEL DataFlash Memory (dfmem) Interface
31:                 *
32:                 * by Fernando L. Garcia Bermudez
33:                 *
34:                 * v.1.0 beta
35:                 *
36:                 * Revisions:
37:                 *  Fernando L. Garcia Bermudez 2008-7-23   Initial release
38:                 *                              2010-7-19   Blocking read/writes tested
39:                 *  Stanley S. Baek             2010-8-30   Added buffer read/writes and sector
40:                 *                                          erase for improving writing speeds.
41:                 *  Andrew Pullin               2011-6-7    Added ability to query for chip
42:                 *  w/Fernando L. Garcia Bermudez           size and flags to handle them.
43:                 *  Andrew Pullin               2011-9-23   Added ability for deep power-down.
44:                 *                              2012-4-8    Adding auto flash geometry and
45:                 *                                          some telemetry helper functions.
46:                 *
47:                 * Notes:
48:                 *  - Uses an SPI port for communicating with the memory chip.
49:                 */
50:                
51:                #include "p33Fxxxx.h"
52:                #include "spi.h"
53:                #include "dfmem.h"
54:                #include "utils.h"
55:                #include <stdlib.h>
56:                #include <string.h>
57:                
58:                
59:                #if (defined(__IMAGEPROC1) || defined(__IMAGEPROC2) || defined(__MIKRO) || defined(__EXP16DEV))
60:                // MIKRO & EXP16DEV has no FLASHMEM, but needs this for compile
61:                
62:                    // SPIx pins
63:                    #define SPI_CS          _LATG9
64:                
65:                    // SPIx Registers
66:                    #define SPI_BUF         SPI2BUF
67:                    #define SPI_CON1        SPI2CON1
68:                    #define SPI_CON2        SPI2CON2
69:                    #define SPI_STAT        SPI2STAT
70:                    #define SPI_STATbits    SPI2STATbits
71:                
72:                #endif
73:                
74:                // Flash geometry
75:                // 8 Mbit
76:                #define FLASH_8MBIT_MAX_SECTOR              16
77:                #define FLASH_8MBIT_MAX_PAGES               4096
78:                #define FLASH_8MBIT_BUFFERSIZE              264
79:                #define FLASH_8MBIT_BYTES_PER_PAGE          264
80:                #define FLASH_8MBIT_PAGES_PER_BLOCK         8
81:                #define FLASH_8MBIT_BLOCKS_PER_SECTOR       32
82:                #define FLASH_8MBIT_PAGES_PER_SECTOR        256  //Calculated; not directly in datasheet
83:                #define FLASH_8MBIT_BYTE_ADDRESS_BITS       9
84:                
85:                // 16 Mbit
86:                #define FLASH_16MBIT_MAX_SECTOR             16
87:                #define FLASH_16MBIT_MAX_PAGES              4096
88:                #define FLASH_16MBIT_BUFFERSIZE             528
89:                #define FLASH_16MBIT_BYTES_PER_PAGE         528
90:                #define FLASH_16MBIT_PAGES_PER_BLOCK        8
91:                #define FLASH_16MBIT_BLOCKS_PER_SECTOR      32
92:                #define FLASH_16MBIT_PAGES_PER_SECTOR       256  //Calculated; not directly in datasheet
93:                #define FLASH_16MBIT_BYTE_ADDRESS_BITS      10
94:                
95:                // 32 Mbit
96:                #define FLASH_32MBIT_MAX_SECTOR             64
97:                #define FLASH_32MBIT_MAX_PAGES              8192
98:                #define FLASH_32MBIT_BUFFERSIZE             528
99:                #define FLASH_32MBIT_BYTES_PER_PAGE         528
100:               #define FLASH_32MBIT_PAGES_PER_BLOCK        8
101:               #define FLASH_32MBIT_BLOCKS_PER_SECTOR      16   // --> THIS VALUE IS WRONG IN THE DATASHEET! 16 IS CORRECT.
102:               #define FLASH_32MBIT_PAGES_PER_SECTOR       128  //Calculated; not directly in datasheet
103:               #define FLASH_32MBIT_BYTE_ADDRESS_BITS      10
104:               
105:               // 64 Mbit
106:               #define FLASH_64MBIT_MAX_SECTOR             32
107:               #define FLASH_64MBIT_MAX_PAGES              8192
108:               #define FLASH_64MBIT_BUFFERSIZE             1056
109:               #define FLASH_64MBIT_BYTES_PER_PAGE         1056
110:               #define FLASH_64MBIT_PAGES_PER_BLOCK        8
111:               #define FLASH_64MBIT_BLOCKS_PER_SECTOR      32
112:               #define FLASH_64MBIT_PAGES_PER_SECTOR       256  //Calculated; not directly in datasheet
113:               #define FLASH_64MBIT_BYTE_ADDRESS_BITS      11
114:               
115:               // Commands
116:               #define WRITE_PAGE_VIA_BUFFER1              0x82
117:               #define WRITE_PAGE_VIA_BUFFER2              0x85
118:               #define WRITE_TO_BUFFER1                    0x84
119:               #define WRITE_TO_BUFFER2                    0x87
120:               #define WRITE_BUFFER1_TO_PAGE_NO_ERASE      0x88
121:               #define WRITE_BUFFER2_TO_PAGE_NO_ERASE      0x89
122:               #define WRITE_BUFFER1_TO_PAGE_WITH_ERASE    0x83
123:               #define WRITE_BUFFER2_TO_PAGE_WITH_ERASE    0x86
124:               
125:               #define READ_PAGE                           0xD2
126:               #define READ_PAGE_TO_BUFFER_1               0x53
127:               #define READ_PAGE_TO_BUFFER_2               0x55
128:               
129:               #define ERASE_PAGE      0x81
130:               #define ERASE_BLOCK     0x50
131:               #define ERASE_SECTOR    0x7C
132:               
133:               /*-----------------------------------------------------------------------------
134:                *          Private variables
135:               -----------------------------------------------------------------------------*/
136:               
137:               // Memory geometry
138:               static DfmemGeometryStruct dfmem_geo;
139:               
140:               // Placeholders
141:               static unsigned int currentBuffer = 0;
142:               static unsigned int currentBufferOffset = 0;
143:               static unsigned int nextPage = 0;
144:               
145:               enum FlashSizeType {
146:                   DFMEM_8MBIT    = 0b00101,
147:                   DFMEM_16MBIT   = 0b00110,
148:                   DFMEM_32MBIT   = 0b00111,
149:                   DFMEM_64MBIT   = 0b01000
150:                };
151:               
152:               union {
153:                   unsigned long address;
154:                   unsigned char chr_addr[4];
155:               } MemAddr;
156:               
157:               
158:               /*----------------------------------------------------------------------------
159:                *          Declaration of private functions
160:                ---------------------------------------------------------------------------*/
161:               
162:               static inline unsigned char dfmemExchangeByte (unsigned char byte);
163:               static inline void dfmemWriteByte (unsigned char byte);
164:               static inline unsigned char dfmemReadByte (void);
165:               static inline void dfmemSelectChip(void);
166:               static inline void dfmemDeselectChip(void);
167:               static void dfmemSetupPeripheral(void);
168:               static void dfmemGeometrySetup(void);
169:               
170:               
171:               /*-----------------------------------------------------------------------------
172:                *          Public functions
173:               -----------------------------------------------------------------------------*/
174:               
175:               void dfmemSetup(void)
176:               {
007988  FA0000     LNK #0x0
177:                   dfmemSetupPeripheral();
00798A  0702E3     RCALL dfmemSetupPeripheral
178:                   dfmemDeselectChip();
00798C  0702DE     RCALL dfmemDeselectChip
179:                   dfmemGeometrySetup();
00798E  0702EA     RCALL dfmemGeometrySetup
180:               }
007990  FA8000     ULNK
007992  060000     RETURN
181:               
182:               void dfmemWrite (unsigned char *data, unsigned int length, unsigned int page,
183:                       unsigned int byte, unsigned char buffer)
184:               {
007994  FA000C     LNK #0xC
007996  980710     MOV W0, [W14+2]
007998  980721     MOV W1, [W14+4]
00799A  980732     MOV W2, [W14+6]
00799C  980743     MOV W3, [W14+8]
00799E  984F24     MOV.B W4, [W14+10]
185:                   unsigned char command;
186:               
187:                   while(!dfmemIsReady());
0079A0  000000     NOP
0079A2  07018B     RCALL dfmemIsReady
0079A4  EB4080     CLR.B W1
0079A6  504F81     SUB.B W0, W1, [W15]
0079A8  32FFFC     BRA Z, 0x79A2
188:               
189:                   // Choose command dependent on buffer choice
190:                   if (buffer == 1) {
0079AA  9048AE     MOV.B [W14+10], W1
0079AC  B3C010     MOV #0x1, W0
0079AE  50CF80     SUB.B W1, W0, [W15]
0079B0  3A0003     BRA NZ, 0x79B8
191:                       command = WRITE_PAGE_VIA_BUFFER1;
0079B2  B3C820     MOV #0x82, W0
0079B4  784F00     MOV.B W0, [W14]
0079B6  370002     BRA 0x79BC
192:                   } else {
193:                       command = WRITE_PAGE_VIA_BUFFER2;
0079B8  B3C850     MOV #0x85, W0
0079BA  784F00     MOV.B W0, [W14]
194:                   }
195:               
196:                   // Restructure page/byte addressing
197:                   // 1 don't care bit + 13 page address bits + byte address bits
198:                   MemAddr.address = (((unsigned long)page) << dfmem_geo.byte_address_bits) + byte;
0079BC  90003E     MOV [W14+6], W0
0079BE  200001     MOV #0x0, W1
0079C0  810AF2     MOV dfmem_geo, W2
0079C2  BE0200     MOV.D W0, W4
0079C4  780302     MOV W2, W6
0079C6  E90306     DEC W6, W6
0079C8  330003     BRA N, 0x79D0
0079CA  420204     ADD W4, W4, W4
0079CC  4A8285     ADDC W5, W5, W5
0079CE  37FFFB     BRA 0x79C6
0079D0  BE0104     MOV.D W4, W2
0079D2  90004E     MOV [W14+8], W0
0079D4  200001     MOV #0x0, W1
0079D6  400002     ADD W0, W2, W0
0079D8  488083     ADDC W1, W3, W1
0079DA  890BA0     MOV W0, MemAddr
0079DC  890BB1     MOV W1, 0x2176
199:               
200:                   // Write data to memory
201:                   dfmemSelectChip();
0079DE  0702B1     RCALL dfmemSelectChip
202:                   dfmemWriteByte(command);
0079E0  78401E     MOV.B [W14], W0
0079E2  0702A4     RCALL dfmemWriteByte
203:                   dfmemWriteByte(MemAddr.chr_addr[2]);
0079E4  221760     MOV #0x2176, W0
0079E6  784010     MOV.B [W0], W0
0079E8  0702A1     RCALL dfmemWriteByte
204:                   dfmemWriteByte(MemAddr.chr_addr[1]);
0079EA  221750     MOV #0x2175, W0
0079EC  784010     MOV.B [W0], W0
0079EE  07029E     RCALL dfmemWriteByte
205:                   dfmemWriteByte(MemAddr.chr_addr[0]);
0079F0  221740     MOV #0x2174, W0
0079F2  784010     MOV.B [W0], W0
0079F4  07029B     RCALL dfmemWriteByte
206:               
207:                   while (length--) { dfmemWriteByte(*data++); }
0079F6  370006     BRA 0x7A04
0079F8  90001E     MOV [W14+2], W0
0079FA  784010     MOV.B [W0], W0
0079FC  90009E     MOV [W14+2], W1
0079FE  E80081     INC W1, W1
007A00  980711     MOV W1, [W14+2]
007A02  070294     RCALL dfmemWriteByte
007A04  90002E     MOV [W14+4], W0
007A06  EA0080     NEG W0, W1
007A08  90002E     MOV [W14+4], W0
007A0A  708000     IOR W1, W0, W0
007A0C  DE004F     LSR W0, #15, W0
007A0E  784080     MOV.B W0, W1
007A10  90002E     MOV [W14+4], W0
007A12  E90000     DEC W0, W0
007A14  980720     MOV W0, [W14+4]
007A16  EB4000     CLR.B W0
007A18  50CF80     SUB.B W1, W0, [W15]
007A1A  3AFFEE     BRA NZ, 0x79F8
208:                   dfmemDeselectChip();
007A1C  070296     RCALL dfmemDeselectChip
209:               }
007A1E  FA8000     ULNK
007A20  060000     RETURN
210:               
211:               void dfmemWriteBuffer (unsigned char *data, unsigned int length,
212:                       unsigned int byte, unsigned char buffer)
213:               {
007A22  FA000A     LNK #0xA
007A24  980710     MOV W0, [W14+2]
007A26  980721     MOV W1, [W14+4]
007A28  980732     MOV W2, [W14+6]
007A2A  984F03     MOV.B W3, [W14+8]
214:                   unsigned char command;
215:               
216:                   // Choose command dependent on buffer choice
217:                   if (buffer == 1) {
007A2C  90488E     MOV.B [W14+8], W1
007A2E  B3C010     MOV #0x1, W0
007A30  50CF80     SUB.B W1, W0, [W15]
007A32  3A0003     BRA NZ, 0x7A3A
218:                       command = WRITE_TO_BUFFER1;
007A34  B3C840     MOV #0x84, W0
007A36  784F00     MOV.B W0, [W14]
007A38  370002     BRA 0x7A3E
219:                   } else {
220:                       command = WRITE_TO_BUFFER2;
007A3A  B3C870     MOV #0x87, W0
007A3C  784F00     MOV.B W0, [W14]
221:                   }
222:               
223:                   // Restructure page/byte addressing
224:                   // 14 don't care bit + byte address bits
225:                   MemAddr.address = (unsigned long)byte;
007A3E  90003E     MOV [W14+6], W0
007A40  200001     MOV #0x0, W1
007A42  890BA0     MOV W0, MemAddr
007A44  890BB1     MOV W1, 0x2176
226:               
227:                   // Write data to memory
228:                   dfmemSelectChip();
007A46  07027D     RCALL dfmemSelectChip
229:               
230:                   dfmemWriteByte(command);
007A48  78401E     MOV.B [W14], W0
007A4A  070270     RCALL dfmemWriteByte
231:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007A4C  221760     MOV #0x2176, W0
007A4E  784010     MOV.B [W0], W0
007A50  07026D     RCALL dfmemWriteByte
232:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007A52  221750     MOV #0x2175, W0
007A54  784010     MOV.B [W0], W0
007A56  07026A     RCALL dfmemWriteByte
233:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007A58  221740     MOV #0x2174, W0
007A5A  784010     MOV.B [W0], W0
007A5C  070267     RCALL dfmemWriteByte
234:               
235:                   while (length--) { dfmemWriteByte(*data++); }
007A5E  370006     BRA 0x7A6C
007A60  90001E     MOV [W14+2], W0
007A62  784010     MOV.B [W0], W0
007A64  90009E     MOV [W14+2], W1
007A66  E80081     INC W1, W1
007A68  980711     MOV W1, [W14+2]
007A6A  070260     RCALL dfmemWriteByte
007A6C  90002E     MOV [W14+4], W0
007A6E  EA0080     NEG W0, W1
007A70  90002E     MOV [W14+4], W0
007A72  708000     IOR W1, W0, W0
007A74  DE004F     LSR W0, #15, W0
007A76  784080     MOV.B W0, W1
007A78  90002E     MOV [W14+4], W0
007A7A  E90000     DEC W0, W0
007A7C  980720     MOV W0, [W14+4]
007A7E  EB4000     CLR.B W0
007A80  50CF80     SUB.B W1, W0, [W15]
007A82  3AFFEE     BRA NZ, 0x7A60
236:               
237:                   dfmemDeselectChip();
007A84  070262     RCALL dfmemDeselectChip
238:               }
007A86  FA8000     ULNK
007A88  060000     RETURN
239:               
240:               void dfmemWriteBuffer2MemoryNoErase (unsigned int page, unsigned char buffer)
241:               {
007A8A  FA0006     LNK #0x6
007A8C  980710     MOV W0, [W14+2]
007A8E  984741     MOV.B W1, [W14+4]
242:                   unsigned char command;
243:               
244:                   while(!dfmemIsReady());
007A90  000000     NOP
007A92  070113     RCALL dfmemIsReady
007A94  EB4080     CLR.B W1
007A96  504F81     SUB.B W0, W1, [W15]
007A98  32FFFC     BRA Z, 0x7A92
245:               
246:                   // Choose command dependent on buffer choice
247:                   if (buffer == 1) {
007A9A  9040CE     MOV.B [W14+4], W1
007A9C  B3C010     MOV #0x1, W0
007A9E  50CF80     SUB.B W1, W0, [W15]
007AA0  3A0003     BRA NZ, 0x7AA8
248:                       command = WRITE_BUFFER1_TO_PAGE_NO_ERASE;
007AA2  B3C880     MOV #0x88, W0
007AA4  784F00     MOV.B W0, [W14]
007AA6  370002     BRA 0x7AAC
249:                   } else {
250:                       command = WRITE_BUFFER2_TO_PAGE_NO_ERASE;
007AA8  B3C890     MOV #0x89, W0
007AAA  784F00     MOV.B W0, [W14]
251:                   }
252:               
253:                   // Restructure page/byte addressing
254:                   // 1 don't care bit + 13 page address bits + don't care bits
255:                   MemAddr.address = ((unsigned long)page) << dfmem_geo.byte_address_bits;
007AAC  90001E     MOV [W14+2], W0
007AAE  200001     MOV #0x0, W1
007AB0  810AF2     MOV dfmem_geo, W2
007AB2  780182     MOV W2, W3
007AB4  E90183     DEC W3, W3
007AB6  330003     BRA N, 0x7ABE
007AB8  400000     ADD W0, W0, W0
007ABA  488081     ADDC W1, W1, W1
007ABC  37FFFB     BRA 0x7AB4
007ABE  890BA0     MOV W0, MemAddr
007AC0  890BB1     MOV W1, 0x2176
256:               
257:                   // Write data to memory
258:                   dfmemSelectChip();
007AC2  07023F     RCALL dfmemSelectChip
259:               
260:                   dfmemWriteByte(command);
007AC4  78401E     MOV.B [W14], W0
007AC6  070232     RCALL dfmemWriteByte
261:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007AC8  221760     MOV #0x2176, W0
007ACA  784010     MOV.B [W0], W0
007ACC  07022F     RCALL dfmemWriteByte
262:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007ACE  221750     MOV #0x2175, W0
007AD0  784010     MOV.B [W0], W0
007AD2  07022C     RCALL dfmemWriteByte
263:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007AD4  221740     MOV #0x2174, W0
007AD6  784010     MOV.B [W0], W0
007AD8  070229     RCALL dfmemWriteByte
264:               
265:                   currentBufferOffset = 0;
007ADA  EB0000     CLR W0
007ADC  890B80     MOV W0, currentBufferOffset
266:               
267:                   dfmemDeselectChip();
007ADE  070235     RCALL dfmemDeselectChip
268:               }
007AE0  FA8000     ULNK
007AE2  060000     RETURN
269:               
270:               void dfmemPush (unsigned char *data, unsigned int length, unsigned int page_reset)
271:               {
007AE4  FA0006     LNK #0x6
007AE6  780F00     MOV W0, [W14]
007AE8  980711     MOV W1, [W14+2]
007AEA  980722     MOV W2, [W14+4]
272:                   /*
273:                   static unsigned int page = 0;
274:                   static unsigned int byte = 0;
275:                   static unsigned char buffer = 0;
276:               
277:                   if (page_reset != 0xffff) {
278:                       page = page_reset;
279:                   }
280:               
281:                   if (length > 512 || length == 0) return;
282:               
283:                   if (length + byte > 512) {
284:                       dfmemWriteBuffer2MemoryNoErase(page++, buffer);
285:                       buffer ^= 0x01; // toggle buffer
286:                       byte = 0;
287:                   }
288:               
289:                   dfmemWriteBuffer(data, length, byte, buffer);
290:                   byte += length;
291:                   */
292:               
293:               }
007AEC  FA8000     ULNK
007AEE  060000     RETURN
294:               
295:               void dfmemRead (unsigned int page, unsigned int byte, unsigned int length,
296:                       unsigned char *data)
297:               {
007AF0  FA0008     LNK #0x8
007AF2  780F00     MOV W0, [W14]
007AF4  980711     MOV W1, [W14+2]
007AF6  980722     MOV W2, [W14+4]
007AF8  980733     MOV W3, [W14+6]
298:                   while(!dfmemIsReady());
007AFA  000000     NOP
007AFC  0700DE     RCALL dfmemIsReady
007AFE  EB4080     CLR.B W1
007B00  504F81     SUB.B W0, W1, [W15]
007B02  32FFFC     BRA Z, 0x7AFC
299:               
300:                   // Restructure page/byte addressing
301:                   // 1 don't care bit + 13 page address bits + byte address bits
302:                   MemAddr.address = (((unsigned long)page) << dfmem_geo.byte_address_bits) + byte;
007B04  78001E     MOV [W14], W0
007B06  200001     MOV #0x0, W1
007B08  810AF2     MOV dfmem_geo, W2
007B0A  BE0200     MOV.D W0, W4
007B0C  780302     MOV W2, W6
007B0E  E90306     DEC W6, W6
007B10  330003     BRA N, 0x7B18
007B12  420204     ADD W4, W4, W4
007B14  4A8285     ADDC W5, W5, W5
007B16  37FFFB     BRA 0x7B0E
007B18  BE0104     MOV.D W4, W2
007B1A  90001E     MOV [W14+2], W0
007B1C  200001     MOV #0x0, W1
007B1E  400002     ADD W0, W2, W0
007B20  488083     ADDC W1, W3, W1
007B22  890BA0     MOV W0, MemAddr
007B24  890BB1     MOV W1, 0x2176
303:               
304:                   // Read data from memory
305:                   dfmemSelectChip();
007B26  07020D     RCALL dfmemSelectChip
306:               
307:                   dfmemWriteByte(READ_PAGE);
007B28  B3CD20     MOV #0xD2, W0
007B2A  070200     RCALL dfmemWriteByte
308:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007B2C  221760     MOV #0x2176, W0
007B2E  784010     MOV.B [W0], W0
007B30  0701FD     RCALL dfmemWriteByte
309:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007B32  221750     MOV #0x2175, W0
007B34  784010     MOV.B [W0], W0
007B36  0701FA     RCALL dfmemWriteByte
310:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007B38  221740     MOV #0x2174, W0
007B3A  784010     MOV.B [W0], W0
007B3C  0701F7     RCALL dfmemWriteByte
311:               
312:                   dfmemWriteByte(0x00); // 4 don't care bytes
007B3E  EB4000     CLR.B W0
007B40  0701F5     RCALL dfmemWriteByte
313:                   dfmemWriteByte(0x00);
007B42  EB4000     CLR.B W0
007B44  0701F3     RCALL dfmemWriteByte
314:                   dfmemWriteByte(0x00);
007B46  EB4000     CLR.B W0
007B48  0701F1     RCALL dfmemWriteByte
315:                   dfmemWriteByte(0x00);
007B4A  EB4000     CLR.B W0
007B4C  0701EF     RCALL dfmemWriteByte
316:               
317:                   while (length--) { *data++ = dfmemReadByte(); }
007B4E  370006     BRA 0x7B5C
007B50  0701F3     RCALL dfmemReadByte
007B52  9000BE     MOV [W14+6], W1
007B54  784880     MOV.B W0, [W1]
007B56  90003E     MOV [W14+6], W0
007B58  E80000     INC W0, W0
007B5A  980730     MOV W0, [W14+6]
007B5C  90002E     MOV [W14+4], W0
007B5E  EA0080     NEG W0, W1
007B60  90002E     MOV [W14+4], W0
007B62  708000     IOR W1, W0, W0
007B64  DE004F     LSR W0, #15, W0
007B66  784080     MOV.B W0, W1
007B68  90002E     MOV [W14+4], W0
007B6A  E90000     DEC W0, W0
007B6C  980720     MOV W0, [W14+4]
007B6E  EB4000     CLR.B W0
007B70  50CF80     SUB.B W1, W0, [W15]
007B72  3AFFEE     BRA NZ, 0x7B50
318:               
319:                   dfmemDeselectChip();
007B74  0701EA     RCALL dfmemDeselectChip
320:               }
007B76  FA8000     ULNK
007B78  060000     RETURN
321:               
322:               void dfmemReadPage2Buffer (unsigned int page, unsigned char buffer)
323:               {
007B7A  FA0006     LNK #0x6
007B7C  980710     MOV W0, [W14+2]
007B7E  984741     MOV.B W1, [W14+4]
324:                   unsigned char command;
325:               
326:                   while(!dfmemIsReady());
007B80  000000     NOP
007B82  07009B     RCALL dfmemIsReady
007B84  EB4080     CLR.B W1
007B86  504F81     SUB.B W0, W1, [W15]
007B88  32FFFC     BRA Z, 0x7B82
327:               
328:                   // Choose command dependent on buffer choice
329:                   if (buffer == 1) {
007B8A  9040CE     MOV.B [W14+4], W1
007B8C  B3C010     MOV #0x1, W0
007B8E  50CF80     SUB.B W1, W0, [W15]
007B90  3A0003     BRA NZ, 0x7B98
330:                       command = READ_PAGE_TO_BUFFER_1;
007B92  B3C530     MOV #0x53, W0
007B94  784F00     MOV.B W0, [W14]
007B96  370002     BRA 0x7B9C
331:                   } else {
332:                       command = READ_PAGE_TO_BUFFER_2;
007B98  B3C550     MOV #0x55, W0
007B9A  784F00     MOV.B W0, [W14]
333:                   }
334:               
335:                   // 1 don't care bit + 13 page address bits + don't care bits
336:                   MemAddr.address = ((unsigned long)page) << dfmem_geo.byte_address_bits;
007B9C  90001E     MOV [W14+2], W0
007B9E  200001     MOV #0x0, W1
007BA0  810AF2     MOV dfmem_geo, W2
007BA2  780182     MOV W2, W3
007BA4  E90183     DEC W3, W3
007BA6  330003     BRA N, 0x7BAE
007BA8  400000     ADD W0, W0, W0
007BAA  488081     ADDC W1, W1, W1
007BAC  37FFFB     BRA 0x7BA4
007BAE  890BA0     MOV W0, MemAddr
007BB0  890BB1     MOV W1, 0x2176
337:               
338:                   // Write data to memory
339:                   dfmemSelectChip();
007BB2  0701C7     RCALL dfmemSelectChip
340:               
341:                   dfmemWriteByte(command);
007BB4  78401E     MOV.B [W14], W0
007BB6  0701BA     RCALL dfmemWriteByte
342:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007BB8  221760     MOV #0x2176, W0
007BBA  784010     MOV.B [W0], W0
007BBC  0701B7     RCALL dfmemWriteByte
343:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007BBE  221750     MOV #0x2175, W0
007BC0  784010     MOV.B [W0], W0
007BC2  0701B4     RCALL dfmemWriteByte
344:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007BC4  221740     MOV #0x2174, W0
007BC6  784010     MOV.B [W0], W0
007BC8  0701B1     RCALL dfmemWriteByte
345:               
346:                   dfmemDeselectChip();
007BCA  0701BF     RCALL dfmemDeselectChip
347:               }
007BCC  FA8000     ULNK
007BCE  060000     RETURN
348:               
349:               void dfmemErasePage (unsigned int page)
350:               {
007BD0  FA0002     LNK #0x2
007BD2  780F00     MOV W0, [W14]
351:                   while(!dfmemIsReady());
007BD4  000000     NOP
007BD6  070071     RCALL dfmemIsReady
007BD8  EB4080     CLR.B W1
007BDA  504F81     SUB.B W0, W1, [W15]
007BDC  32FFFC     BRA Z, 0x7BD6
352:               
353:                   // Restructure page/byte addressing
354:                   MemAddr.address = ((unsigned long)page) << dfmem_geo.byte_address_bits;
007BDE  78001E     MOV [W14], W0
007BE0  200001     MOV #0x0, W1
007BE2  810AF2     MOV dfmem_geo, W2
007BE4  780182     MOV W2, W3
007BE6  E90183     DEC W3, W3
007BE8  330003     BRA N, 0x7BF0
007BEA  400000     ADD W0, W0, W0
007BEC  488081     ADDC W1, W1, W1
007BEE  37FFFB     BRA 0x7BE6
007BF0  890BA0     MOV W0, MemAddr
007BF2  890BB1     MOV W1, 0x2176
355:               
356:                   // Write data to memory
357:                   dfmemSelectChip();
007BF4  0701A6     RCALL dfmemSelectChip
358:               
359:                   dfmemWriteByte(ERASE_PAGE);
007BF6  B3C810     MOV #0x81, W0
007BF8  070199     RCALL dfmemWriteByte
360:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007BFA  221760     MOV #0x2176, W0
007BFC  784010     MOV.B [W0], W0
007BFE  070196     RCALL dfmemWriteByte
361:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007C00  221750     MOV #0x2175, W0
007C02  784010     MOV.B [W0], W0
007C04  070193     RCALL dfmemWriteByte
362:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007C06  221740     MOV #0x2174, W0
007C08  784010     MOV.B [W0], W0
007C0A  070190     RCALL dfmemWriteByte
363:               
364:                   dfmemDeselectChip();
007C0C  07019E     RCALL dfmemDeselectChip
365:               }
007C0E  FA8000     ULNK
007C10  060000     RETURN
366:               
367:               void dfmemEraseBlock (unsigned int page)
368:               {
007C12  FA0002     LNK #0x2
007C14  780F00     MOV W0, [W14]
369:                   while(!dfmemIsReady());
007C16  000000     NOP
007C18  070050     RCALL dfmemIsReady
007C1A  EB4080     CLR.B W1
007C1C  504F81     SUB.B W0, W1, [W15]
007C1E  32FFFC     BRA Z, 0x7C18
370:               
371:                   // Restructure page/byte addressing
372:                   MemAddr.address = ((unsigned long)page) << dfmem_geo.byte_address_bits;
007C20  78001E     MOV [W14], W0
007C22  200001     MOV #0x0, W1
007C24  810AF2     MOV dfmem_geo, W2
007C26  780182     MOV W2, W3
007C28  E90183     DEC W3, W3
007C2A  330003     BRA N, 0x7C32
007C2C  400000     ADD W0, W0, W0
007C2E  488081     ADDC W1, W1, W1
007C30  37FFFB     BRA 0x7C28
007C32  890BA0     MOV W0, MemAddr
007C34  890BB1     MOV W1, 0x2176
373:               
374:                   // Write data to memory
375:                   dfmemSelectChip();
007C36  070185     RCALL dfmemSelectChip
376:               
377:                   dfmemWriteByte(ERASE_BLOCK);
007C38  B3C500     MOV #0x50, W0
007C3A  070178     RCALL dfmemWriteByte
378:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007C3C  221760     MOV #0x2176, W0
007C3E  784010     MOV.B [W0], W0
007C40  070175     RCALL dfmemWriteByte
379:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007C42  221750     MOV #0x2175, W0
007C44  784010     MOV.B [W0], W0
007C46  070172     RCALL dfmemWriteByte
380:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007C48  221740     MOV #0x2174, W0
007C4A  784010     MOV.B [W0], W0
007C4C  07016F     RCALL dfmemWriteByte
381:               
382:                   dfmemDeselectChip();
007C4E  07017D     RCALL dfmemDeselectChip
383:               }
007C50  FA8000     ULNK
007C52  060000     RETURN
384:               
385:               void dfmemEraseSector (unsigned int page)
386:               {
007C54  FA0002     LNK #0x2
007C56  780F00     MOV W0, [W14]
387:                   while(!dfmemIsReady());
007C58  000000     NOP
007C5A  07002F     RCALL dfmemIsReady
007C5C  EB4080     CLR.B W1
007C5E  504F81     SUB.B W0, W1, [W15]
007C60  32FFFC     BRA Z, 0x7C5A
388:               
389:                   // Restructure page/byte addressing
390:                   MemAddr.address = ((unsigned long)page) << dfmem_geo.byte_address_bits;
007C62  78001E     MOV [W14], W0
007C64  200001     MOV #0x0, W1
007C66  810AF2     MOV dfmem_geo, W2
007C68  780182     MOV W2, W3
007C6A  E90183     DEC W3, W3
007C6C  330003     BRA N, 0x7C74
007C6E  400000     ADD W0, W0, W0
007C70  488081     ADDC W1, W1, W1
007C72  37FFFB     BRA 0x7C6A
007C74  890BA0     MOV W0, MemAddr
007C76  890BB1     MOV W1, 0x2176
391:               
392:                   // Write data to memory
393:                   dfmemSelectChip();
007C78  070164     RCALL dfmemSelectChip
394:               
395:                   dfmemWriteByte(ERASE_SECTOR);
007C7A  B3C7C0     MOV #0x7C, W0
007C7C  070157     RCALL dfmemWriteByte
396:                   dfmemWriteByte(MemAddr.chr_addr[2]);
007C7E  221760     MOV #0x2176, W0
007C80  784010     MOV.B [W0], W0
007C82  070154     RCALL dfmemWriteByte
397:                   dfmemWriteByte(MemAddr.chr_addr[1]);
007C84  221750     MOV #0x2175, W0
007C86  784010     MOV.B [W0], W0
007C88  070151     RCALL dfmemWriteByte
398:                   dfmemWriteByte(MemAddr.chr_addr[0]);
007C8A  221740     MOV #0x2174, W0
007C8C  784010     MOV.B [W0], W0
007C8E  07014E     RCALL dfmemWriteByte
399:               
400:                   dfmemDeselectChip();
007C90  07015C     RCALL dfmemDeselectChip
401:               }
007C92  FA8000     ULNK
007C94  060000     RETURN
402:               
403:               void dfmemEraseChip (void)
404:               {
007C96  FA0000     LNK #0x0
405:                   while(!dfmemIsReady());
007C98  000000     NOP
007C9A  07000F     RCALL dfmemIsReady
007C9C  EB4080     CLR.B W1
007C9E  504F81     SUB.B W0, W1, [W15]
007CA0  32FFFC     BRA Z, 0x7C9A
406:               
407:                   dfmemSelectChip();
007CA2  07014F     RCALL dfmemSelectChip
408:               
409:                   dfmemWriteByte(0xC7);
007CA4  B3CC70     MOV #0xC7, W0
007CA6  070142     RCALL dfmemWriteByte
410:                   dfmemWriteByte(0x94);
007CA8  B3C940     MOV #0x94, W0
007CAA  070140     RCALL dfmemWriteByte
411:                   dfmemWriteByte(0x80);
007CAC  B3C800     MOV #0x80, W0
007CAE  07013E     RCALL dfmemWriteByte
412:                   dfmemWriteByte(0x9A);
007CB0  B3C9A0     MOV #0x9A, W0
007CB2  07013C     RCALL dfmemWriteByte
413:               
414:                   dfmemDeselectChip();
007CB4  07014A     RCALL dfmemDeselectChip
415:               }
007CB6  FA8000     ULNK
007CB8  060000     RETURN
416:               
417:               unsigned char dfmemIsReady (void)
418:               {
007CBA  FA0000     LNK #0x0
419:                   return (dfmemGetStatus() >> 7);
007CBC  070005     RCALL dfmemGetStatus
007CBE  FB8000     ZE W0, W0
007CC0  DE0047     LSR W0, #7, W0
007CC2  784000     MOV.B W0, W0
420:               }
007CC4  FA8000     ULNK
007CC6  060000     RETURN
421:               
422:               unsigned char dfmemGetStatus (void)
423:               {
007CC8  FA0002     LNK #0x2
424:                   unsigned char byte;
425:               
426:                   dfmemSelectChip();
007CCA  07013B     RCALL dfmemSelectChip
427:               
428:                   dfmemWriteByte(0xD7);
007CCC  B3CD70     MOV #0xD7, W0
007CCE  07012E     RCALL dfmemWriteByte
429:                   byte = dfmemReadByte();
007CD0  070133     RCALL dfmemReadByte
007CD2  784F00     MOV.B W0, [W14]
430:               
431:                   dfmemDeselectChip();
007CD4  07013A     RCALL dfmemDeselectChip
432:               
433:                   return byte;
007CD6  78401E     MOV.B [W14], W0
434:               }
007CD8  FA8000     ULNK
007CDA  060000     RETURN
435:               
436:               // The manufacturer and device id command (0x9F) returns 4 bytes normally
437:               // (including info on id, family, density, etc.), but this functions returns
438:               // just the manufacturer id and discards the rest when deselecting the chip.
439:               unsigned char dfmemGetManufacturerID (void)
440:               {
007CDC  FA0002     LNK #0x2
441:                   unsigned char byte;
442:               
443:                   dfmemSelectChip();
007CDE  070131     RCALL dfmemSelectChip
444:               
445:                   dfmemWriteByte(0x9F);
007CE0  B3C9F0     MOV #0x9F, W0
007CE2  070124     RCALL dfmemWriteByte
446:                   byte = dfmemReadByte();
007CE4  070129     RCALL dfmemReadByte
007CE6  784F00     MOV.B W0, [W14]
447:               
448:                   dfmemDeselectChip();
007CE8  070130     RCALL dfmemDeselectChip
449:               
450:                   return byte;
007CEA  78401E     MOV.B [W14], W0
451:               }
007CEC  FA8000     ULNK
007CEE  060000     RETURN
452:               
453:               // The manufacturer and device id command (0x9F) returns 4 bytes normally
454:               // (including info on id, family, density, etc.), but this functions returns
455:               // only the 5 bits pertaining to the memory density.
456:               unsigned char dfmemGetChipSize (void)
457:               {
007CF0  FA0002     LNK #0x2
458:                   unsigned char byte;
459:               
460:                   dfmemSelectChip();
007CF2  070127     RCALL dfmemSelectChip
461:               
462:                   dfmemWriteByte(0x9F);
007CF4  B3C9F0     MOV #0x9F, W0
007CF6  07011A     RCALL dfmemWriteByte
463:                   byte = dfmemReadByte(); // Manufacturer ID, not needed
007CF8  07011F     RCALL dfmemReadByte
007CFA  784F00     MOV.B W0, [W14]
464:                   byte = dfmemReadByte() & 0b00011111;
007CFC  07011D     RCALL dfmemReadByte
007CFE  604F7F     AND.B W0, #0x1F, [W14]
465:               
466:                   dfmemDeselectChip();
007D00  070124     RCALL dfmemDeselectChip
467:               
468:                   return byte;
007D02  78401E     MOV.B [W14], W0
469:               }
007D04  FA8000     ULNK
007D06  060000     RETURN
470:               
471:               void dfmemDeepSleep()
472:               {
007D08  FA0000     LNK #0x0
473:                   dfmemSelectChip();
007D0A  07011B     RCALL dfmemSelectChip
474:               
475:                   dfmemWriteByte(0xB9);
007D0C  B3CB90     MOV #0xB9, W0
007D0E  07010E     RCALL dfmemWriteByte
476:               
477:                   dfmemDeselectChip();
007D10  07011C     RCALL dfmemDeselectChip
478:               }
007D12  FA8000     ULNK
007D14  060000     RETURN
479:               
480:               void dfmemResumeFromDeepSleep()
481:               {
007D16  FA0000     LNK #0x0
482:                   dfmemSelectChip();
007D18  070114     RCALL dfmemSelectChip
483:               
484:                   dfmemWriteByte(0xAB);
007D1A  B3CAB0     MOV #0xAB, W0
007D1C  070107     RCALL dfmemWriteByte
485:               
486:                   dfmemDeselectChip();
007D1E  070115     RCALL dfmemDeselectChip
487:               }
007D20  FA8000     ULNK
007D22  060000     RETURN
488:               
489:               void dfmemSave(unsigned char* data, unsigned int length)
490:               {
007D24  FA0004     LNK #0x4
007D26  780F00     MOV W0, [W14]
007D28  980711     MOV W1, [W14+2]
491:                   //If this write will fit into the buffer, then just put it there
492:                   if (currentBufferOffset + length >= dfmem_geo.buffer_size) {
007D2A  810B81     MOV currentBufferOffset, W1
007D2C  90001E     MOV [W14+2], W0
007D2E  408080     ADD W1, W0, W1
007D30  810B20     MOV 0x2164, W0
007D32  508F80     SUB W1, W0, [W15]
007D34  390012     BRA NC, 0x7D5A
493:                       dfmemWriteBuffer2MemoryNoErase(nextPage, currentBuffer);
007D36  810B70     MOV currentBuffer, W0
007D38  784000     MOV.B W0, W0
007D3A  810B92     MOV nextPage, W2
007D3C  784080     MOV.B W0, W1
007D3E  780002     MOV W2, W0
007D40  07FEA4     RCALL dfmemWriteBuffer2MemoryNoErase
494:                       currentBuffer = (currentBuffer) ? 0 : 1;
007D42  810B72     MOV currentBuffer, W2
007D44  200010     MOV #0x1, W0
007D46  EB0080     CLR W1
007D48  510F81     SUB W2, W1, [W15]
007D4A  320001     BRA Z, 0x7D4E
007D4C  EB0000     CLR W0
007D4E  890B70     MOV W0, currentBuffer
495:                       currentBufferOffset = 0;
007D50  EB0000     CLR W0
007D52  890B80     MOV W0, currentBufferOffset
496:                       nextPage++;
007D54  810B90     MOV nextPage, W0
007D56  E80000     INC W0, W0
007D58  890B90     MOV W0, nextPage
497:                   }
498:               
499:                   //We know there won't be an overrun here because of the previous 'if'
500:                   // TODO (fgb) : Shouldn't this happen only when the buffer is full,
501:                   //              probably calling dfmemSync?
502:                   dfmemWriteBuffer(data, length, currentBufferOffset, currentBuffer);
007D5A  810B70     MOV currentBuffer, W0
007D5C  784000     MOV.B W0, W0
007D5E  810B81     MOV currentBufferOffset, W1
007D60  784180     MOV.B W0, W3
007D62  780101     MOV W1, W2
007D64  90009E     MOV [W14+2], W1
007D66  78001E     MOV [W14], W0
007D68  07FE5C     RCALL dfmemWriteBuffer
503:                   currentBufferOffset += length;
007D6A  810B81     MOV currentBufferOffset, W1
007D6C  90001E     MOV [W14+2], W0
007D6E  408000     ADD W1, W0, W0
007D70  890B80     MOV W0, currentBufferOffset
504:               }
007D72  FA8000     ULNK
007D74  060000     RETURN
505:               
506:               void dfmemSync()
507:               {
007D76  FA0000     LNK #0x0
508:                   while(!dfmemIsReady());
007D78  000000     NOP
007D7A  07FF9F     RCALL dfmemIsReady
007D7C  EB4080     CLR.B W1
007D7E  504F81     SUB.B W0, W1, [W15]
007D80  32FFFC     BRA Z, 0x7D7A
509:               
510:                   //if currentBufferOffset == 0, then we don't need to write anything to be sync'd
511:                   if(currentBufferOffset != 0){
007D82  810B81     MOV currentBufferOffset, W1
007D84  EB0000     CLR W0
007D86  508F80     SUB W1, W0, [W15]
007D88  320012     BRA Z, 0x7DAE
512:                       dfmemWriteBuffer2MemoryNoErase(nextPage, currentBuffer);
007D8A  810B70     MOV currentBuffer, W0
007D8C  784000     MOV.B W0, W0
007D8E  810B92     MOV nextPage, W2
007D90  784080     MOV.B W0, W1
007D92  780002     MOV W2, W0
007D94  07FE7A     RCALL dfmemWriteBuffer2MemoryNoErase
513:                       currentBuffer = (currentBuffer) ? 0 : 1; //Toggle buffer number
007D96  810B72     MOV currentBuffer, W2
007D98  200010     MOV #0x1, W0
007D9A  EB0080     CLR W1
007D9C  510F81     SUB W2, W1, [W15]
007D9E  320001     BRA Z, 0x7DA2
007DA0  EB0000     CLR W0
007DA2  890B70     MOV W0, currentBuffer
514:                       currentBufferOffset = 0;
007DA4  EB0000     CLR W0
007DA6  890B80     MOV W0, currentBufferOffset
515:                       nextPage++;
007DA8  810B90     MOV nextPage, W0
007DAA  E80000     INC W0, W0
007DAC  890B90     MOV W0, nextPage
516:                   }
517:               }
007DAE  FA8000     ULNK
007DB0  060000     RETURN
518:               
519:               void dfmemReadSample(unsigned long sampNum, unsigned int sampLen, unsigned char *data)
520:               {
007DB2  FA000E     LNK #0xE
007DB4  980730     MOV W0, [W14+6]
007DB6  980741     MOV W1, [W14+8]
007DB8  980752     MOV W2, [W14+10]
007DBA  980763     MOV W3, [W14+12]
521:                   unsigned int samplesPerPage = dfmem_geo.bytes_per_page / sampLen; //round DOWN int division
007DBC  810B31     MOV 0x2166, W1
007DBE  90005E     MOV [W14+10], W0
007DC0  780100     MOV W0, W2
007DC2  090011     REPEAT #0x11
007DC4  D88082     DIV.UW W1, W2
007DC6  780F00     MOV W0, [W14]
522:                   unsigned int pagenum = sampNum / samplesPerPage;
007DC8  78001E     MOV [W14], W0
007DCA  200001     MOV #0x0, W1
007DCC  BE0100     MOV.D W0, W2
007DCE  90003E     MOV [W14+6], W0
007DD0  9000CE     MOV [W14+8], W1
007DD2  022D42     CALL ___udivsi3x
007DD4  000000     NOP
007DD6  980710     MOV W0, [W14+2]
523:                   unsigned int byteOffset = (sampNum - pagenum*samplesPerPage)*sampLen;
007DD8  90009E     MOV [W14+2], W1
007DDA  78001E     MOV [W14], W0
007DDC  B98800     MUL.SS W1, W0, W0
007DDE  780000     MOV W0, W0
007DE0  200001     MOV #0x0, W1
007DE2  90013E     MOV [W14+6], W2
007DE4  9001CE     MOV [W14+8], W3
007DE6  510000     SUB W2, W0, W0
007DE8  598081     SUBB W3, W1, W1
007DEA  780080     MOV W0, W1
007DEC  90005E     MOV [W14+10], W0
007DEE  B98800     MUL.SS W1, W0, W0
007DF0  780000     MOV W0, W0
007DF2  980720     MOV W0, [W14+4]
524:               
525:                   dfmemRead(pagenum, byteOffset, sampLen, data);
007DF4  9001EE     MOV [W14+12], W3
007DF6  90015E     MOV [W14+10], W2
007DF8  9000AE     MOV [W14+4], W1
007DFA  90001E     MOV [W14+2], W0
007DFC  07FE79     RCALL dfmemRead
526:               }
007DFE  FA8000     ULNK
007E00  060000     RETURN
527:               
528:               void dfmemEraseSectorsForSamples(unsigned long numSamples, unsigned int sampLen)
529:               {
007E02  FA0010     LNK #0x10
007E04  980750     MOV W0, [W14+10]
007E06  980761     MOV W1, [W14+12]
007E08  980772     MOV W2, [W14+14]
530:                   // TODO (apullin) : Add an explicit check to see if the number of saved
531:                   //                  samples will fit into memory!
532:                   LED_2 = 1;
007E0A  A8A2CB     BSET 0x2CB, #5
533:                   unsigned int firstPageOfSector, i;
534:               
535:                   //avoid trivial case
536:                   if(numSamples == 0){ return;}
007E0C  90015E     MOV [W14+10], W2
007E0E  9001EE     MOV [W14+12], W3
007E10  B80060     MUL.UU W0, #0, W0
007E12  510F80     SUB W2, W0, [W15]
007E14  598F81     SUBB W3, W1, [W15]
007E16  320062     BRA Z, 0x7EDC
007EDC  000000     NOP
537:               
538:                   //Saves to dfmem will NOT overlap page boundaries, so we need to do this level by level:
539:                   unsigned int samplesPerPage = dfmem_geo.bytes_per_page / sampLen; //round DOWN int division
007E18  810B31     MOV 0x2166, W1
007E1A  90007E     MOV [W14+14], W0
007E1C  780100     MOV W0, W2
007E1E  090011     REPEAT #0x11
007E20  D88082     DIV.UW W1, W2
007E22  980710     MOV W0, [W14+2]
540:                   unsigned int numPages = (numSamples + samplesPerPage - 1) / samplesPerPage; //round UP int division
007E24  90001E     MOV [W14+2], W0
007E26  B80161     MUL.UU W0, #1, W2
007E28  90005E     MOV [W14+10], W0
007E2A  9000EE     MOV [W14+12], W1
007E2C  400102     ADD W0, W2, W2
007E2E  488183     ADDC W1, W3, W3
007E30  EB8000     SETM W0
007E32  EB8080     SETM W1
007E34  400202     ADD W0, W2, W4
007E36  488283     ADDC W1, W3, W5
007E38  90001E     MOV [W14+2], W0
007E3A  200001     MOV #0x0, W1
007E3C  BE0100     MOV.D W0, W2
007E3E  BE0004     MOV.D W4, W0
007E40  022D42     CALL ___udivsi3x
007E42  000000     NOP
007E44  980720     MOV W0, [W14+4]
541:                   unsigned int numSectors = ( numPages + dfmem_geo.pages_per_sector-1) / dfmem_geo.pages_per_sector;
007E46  810B61     MOV 0x216C, W1
007E48  90002E     MOV [W14+4], W0
007E4A  408000     ADD W1, W0, W0
007E4C  E90080     DEC W0, W1
007E4E  810B60     MOV 0x216C, W0
007E50  780100     MOV W0, W2
007E52  090011     REPEAT #0x11
007E54  D88082     DIV.UW W1, W2
007E56  980730     MOV W0, [W14+6]
542:               
543:                   //At this point, it is impossible for numSectors == 0
544:                   //Sector 0a and 0b will be erased together always, for simplicity
545:                   //Note that numSectors will be the actual number of sectors to erase,
546:                   //   even though the sectors themselves are numbered starting at '0'
547:                   dfmemEraseSector(0); //Erase Sector 0a
007E58  EB0000     CLR W0
007E5A  07FEFC     RCALL dfmemEraseSector
548:                   dfmemEraseSector(8); //Erase Sector 0b
007E5C  200080     MOV #0x8, W0
007E5E  07FEFA     RCALL dfmemEraseSector
549:               
550:                   //Start erasing the rest from Sector 1:
551:                   for(i=1; i <= numSectors; i++){
007E60  200010     MOV #0x1, W0
007E62  780F00     MOV W0, [W14]
007E64  37001A     BRA 0x7E9A
007E98  E80F1E     INC [W14], [W14]
007E9A  90003E     MOV [W14+6], W0
007E9C  78009E     MOV [W14], W1
007E9E  508F80     SUB W1, W0, [W15]
007EA0  36FFE2     BRA LEU, 0x7E66
552:                       firstPageOfSector = dfmem_geo.pages_per_sector * i;
007E66  810B61     MOV 0x216C, W1
007E68  78001E     MOV [W14], W0
007E6A  B98800     MUL.SS W1, W0, W0
007E6C  780000     MOV W0, W0
007E6E  980740     MOV W0, [W14+8]
553:                       //hold off until dfmem is ready for secort erase command
554:                       while(!dfmemIsReady());
007E70  000000     NOP
007E72  07FF23     RCALL dfmemIsReady
007E74  EB4080     CLR.B W1
007E76  504F81     SUB.B W0, W1, [W15]
007E78  32FFFC     BRA Z, 0x7E72
555:                       //LED should blink indicating progress
556:                       LED_2 = ~LED_2;
007E7A  801650     MOV LATB, W0
007E7C  DE004D     LSR W0, #13, W0
007E7E  604061     AND.B W0, #0x1, W0
007E80  EAC000     COM.B W0, W0
007E82  604061     AND.B W0, #0x1, W0
007E84  FB8000     ZE W0, W0
007E86  600061     AND W0, #0x1, W0
007E88  DD004D     SL W0, #13, W0
007E8A  801652     MOV LATB, W2
007E8C  2DFFF1     MOV #0xDFFF, W1
007E8E  610081     AND W2, W1, W1
007E90  708000     IOR W1, W0, W0
007E92  881650     MOV W0, LATB
557:                       //Send actual erase command
558:                       dfmemEraseSector(firstPageOfSector);
007E94  90004E     MOV [W14+8], W0
007E96  07FEDE     RCALL dfmemEraseSector
559:                   }
560:               
561:                   //Leadout flash, should blink faster than above, indicating the last sector
562:                   while(!dfmemIsReady()){
007EA2  370010     BRA 0x7EC4
007EC4  07FEFA     RCALL dfmemIsReady
007EC6  EB4080     CLR.B W1
007EC8  504F81     SUB.B W0, W1, [W15]
007ECA  32FFEC     BRA Z, 0x7EA4
563:                       LED_2 = ~LED_2;
007EA4  801650     MOV LATB, W0
007EA6  DE004D     LSR W0, #13, W0
007EA8  604061     AND.B W0, #0x1, W0
007EAA  EAC000     COM.B W0, W0
007EAC  604061     AND.B W0, #0x1, W0
007EAE  FB8000     ZE W0, W0
007EB0  600061     AND W0, #0x1, W0
007EB2  DD004D     SL W0, #13, W0
007EB4  801652     MOV LATB, W2
007EB6  2DFFF1     MOV #0xDFFF, W1
007EB8  610081     AND W2, W1, W1
007EBA  708000     IOR W1, W0, W0
007EBC  881650     MOV W0, LATB
564:                       delay_ms(75);
007EBE  2004B0     MOV #0x4B, W0
007EC0  02E270     CALL msELAPSED
007EC2  000000     NOP
565:                   }
566:                   LED_2 = 0; //Green LED off
007ECC  A9A2CB     BCLR 0x2CB, #5
567:               
568:                   //Since we've erased, reset our place keeper vars
569:                   currentBuffer = 0;
007ECE  EB0000     CLR W0
007ED0  890B70     MOV W0, currentBuffer
570:                   currentBufferOffset = 0;
007ED2  EB0000     CLR W0
007ED4  890B80     MOV W0, currentBufferOffset
571:                   nextPage = 0;
007ED6  EB0000     CLR W0
007ED8  890B90     MOV W0, nextPage
007EDA  370001     BRA 0x7EDE
572:               }
007EDE  FA8000     ULNK
007EE0  060000     RETURN
573:               
574:               void dfmemGetGeometryParams(DfmemGeometry geo) {
007EE2  FA0002     LNK #0x2
007EE4  780F00     MOV W0, [W14]
575:               
576:                   if(geo == NULL) { return; }
007EE6  78009E     MOV [W14], W1
007EE8  EB0000     CLR W0
007EEA  508F80     SUB W1, W0, [W15]
007EEC  320006     BRA Z, 0x7EFA
007EFA  000000     NOP
577:               
578:                   memcpy(geo, &dfmem_geo, sizeof(DfmemGeometryStruct));
007EEE  200102     MOV #0x10, W2
007EF0  2215E1     MOV #0x215E, W1
007EF2  78001E     MOV [W14], W0
007EF4  023582     CALL _memcpy
007EF6  000000     NOP
007EF8  370001     BRA 0x7EFC
579:               
580:               }
007EFC  FA8000     ULNK
007EFE  060000     RETURN
581:               
582:               
583:               /*-----------------------------------------------------------------------------
584:                *          Private functions
585:               -----------------------------------------------------------------------------*/
586:               
587:               // Sends a byte to the memory chip and returns the byte read from it
588:               //
589:               // Parameters   :   byte to send.
590:               // Returns      :   received byte.
591:               static inline unsigned char dfmemExchangeByte (unsigned char byte)
592:               {
007F00  FA0002     LNK #0x2
007F02  784F00     MOV.B W0, [W14]
593:                   SPI_BUF = byte;
007F04  78409E     MOV.B [W14], W1
007F06  FB8001     ZE W1, W0
007F08  881340     MOV W0, SPI2BUF
594:                   while(SPI_STATbits.SPITBF);
007F0A  000000     NOP
007F0C  801300     MOV SPI2STAT, W0
007F0E  6000E2     AND W0, #0x2, W1
007F10  EB0000     CLR W0
007F12  508F80     SUB W1, W0, [W15]
007F14  3AFFFB     BRA NZ, 0x7F0C
595:                   while(!SPI_STATbits.SPIRBF);
007F16  000000     NOP
007F18  801300     MOV SPI2STAT, W0
007F1A  6000E1     AND W0, #0x1, W1
007F1C  EB0000     CLR W0
007F1E  508F80     SUB W1, W0, [W15]
007F20  32FFFB     BRA Z, 0x7F18
596:                   SPI_STATbits.SPIROV = 0;
007F22  A9C260     BCLR SPI2STAT, #6
597:                   return SPI_BUF;
007F24  801340     MOV SPI2BUF, W0
007F26  784000     MOV.B W0, W0
598:               }
007F28  FA8000     ULNK
007F2A  060000     RETURN
599:               
600:               // Sends a byte to the memory chip.
601:               //
602:               // It discards the byte it receives when transmitting this one as it should
603:               // not be important and so that it doesn't stay in the received queue.
604:               //
605:               // Parameters : byte to send.
606:               static inline void dfmemWriteByte (unsigned char byte)
607:               {
007F2C  FA0002     LNK #0x2
007F2E  784F00     MOV.B W0, [W14]
608:                   dfmemExchangeByte(byte);
007F30  78401E     MOV.B [W14], W0
007F32  07FFE6     RCALL dfmemExchangeByte
609:               }
007F34  FA8000     ULNK
007F36  060000     RETURN
610:               
611:               // Receives a byte from the memory chip.
612:               //
613:               // It sends a null byte so as to issue the required clock cycles for receiving
614:               // one from the memory.
615:               //
616:               // Returns : received byte.
617:               static inline unsigned char dfmemReadByte (void)
618:               {
007F38  FA0000     LNK #0x0
619:                   return dfmemExchangeByte(0x00);
007F3A  EB4000     CLR.B W0
007F3C  07FFE1     RCALL dfmemExchangeByte
620:               }
007F3E  FA8000     ULNK
007F40  060000     RETURN
621:               
622:               // Selects the memory chip.
623:               static inline void dfmemSelectChip(void) { SPI_CS = 0; }
007F42  FA0000     LNK #0x0
007F44  A922E9     BCLR 0x2E9, #1
007F46  FA8000     ULNK
007F48  060000     RETURN
624:               
625:               // Deselects the memory chip.
626:               static inline void dfmemDeselectChip(void) { SPI_CS = 1; }
007F4A  FA0000     LNK #0x0
007F4C  A822E9     BSET 0x2E9, #1
007F4E  FA8000     ULNK
007F50  060000     RETURN
627:               
628:               // Initializes the SPIx bus for communicating with the memory.
629:               //
630:               // The MCU is the SPI master and the clock isn't continuous.
631:               static void dfmemSetupPeripheral(void)
632:               {
007F52  FA0000     LNK #0x0
633:                   SPI_CON1 = ENABLE_SCK_PIN & ENABLE_SDO_PIN & SPI_MODE16_OFF & SPI_SMP_OFF &
007F54  2E1330     MOV #0xE133, W0
007F56  881310     MOV W0, SPI2CON1
634:                              SPI_CKE_ON & SLAVE_ENABLE_OFF & CLK_POL_ACTIVE_HIGH &
635:                              MASTER_ENABLE_ON & PRI_PRESCAL_1_1 & SEC_PRESCAL_4_1;
636:                   SPI_CON2 = FRAME_ENABLE_OFF & FRAME_SYNC_OUTPUT & FRAME_POL_ACTIVE_HIGH &
007F58  23FFD0     MOV #0x3FFD, W0
007F5A  881320     MOV W0, SPI2CON2
637:                              FRAME_SYNC_EDGE_PRECEDE;
638:                   SPI_STAT = SPI_ENABLE & SPI_IDLE_CON & SPI_RX_OVFLOW_CLR;
007F5C  2DFBF0     MOV #0xDFBF, W0
007F5E  881300     MOV W0, SPI2STAT
639:               }
007F60  FA8000     ULNK
007F62  060000     RETURN
640:               
641:               // Figures out memory geometry by querying its size
642:               static void dfmemGeometrySetup(void)
643:               {
007F64  FA0002     LNK #0x2
644:                   unsigned char size;
645:                   size = dfmemGetChipSize();
007F66  07FEC4     RCALL dfmemGetChipSize
007F68  784F00     MOV.B W0, [W14]
646:               
647:                   switch(size){
007F6A  78409E     MOV.B [W14], W1
007F6C  FB8001     ZE W1, W0
007F6E  B90161     MUL.SU W0, #1, W2
007F70  2FFFB0     MOV #0xFFFB, W0
007F72  2FFFF1     MOV #0xFFFF, W1
007F74  400002     ADD W0, W2, W0
007F76  488083     ADDC W1, W3, W1
007F78  200032     MOV #0x3, W2
007F7A  200003     MOV #0x0, W3
007F7C  500F82     SUB W0, W2, [W15]
007F7E  588F83     SUBB W1, W3, [W15]
007F80  3E0049     BRA GTU, 0x8014
007F82  016000     BRA W0
007F84  370003     BRA 0x7F8C
007F86  370013     BRA 0x7FAE
007F88  370023     BRA 0x7FD0
007F8A  370033     BRA 0x7FF2
648:                       case DFMEM_8MBIT:
649:                           dfmem_geo.max_sector        = FLASH_8MBIT_MAX_SECTOR;
007F8C  200100     MOV #0x10, W0
007F8E  890B00     MOV W0, 0x2160
650:                           dfmem_geo.max_pages         = FLASH_8MBIT_MAX_PAGES;
007F90  210000     MOV #0x1000, W0
007F92  890B10     MOV W0, 0x2162
651:                           dfmem_geo.buffer_size       = FLASH_8MBIT_BUFFERSIZE;
007F94  201080     MOV #0x108, W0
007F96  890B20     MOV W0, 0x2164
652:                           dfmem_geo.bytes_per_page    = FLASH_8MBIT_BYTES_PER_PAGE;
007F98  201080     MOV #0x108, W0
007F9A  890B30     MOV W0, 0x2166
653:                           dfmem_geo.pages_per_block   = FLASH_8MBIT_PAGES_PER_BLOCK;
007F9C  200080     MOV #0x8, W0
007F9E  890B40     MOV W0, 0x2168
654:                           dfmem_geo.blocks_per_sector = FLASH_8MBIT_BLOCKS_PER_SECTOR;
007FA0  200200     MOV #0x20, W0
007FA2  890B50     MOV W0, 0x216A
655:                           dfmem_geo.pages_per_sector  = FLASH_8MBIT_PAGES_PER_SECTOR;
007FA4  201000     MOV #0x100, W0
007FA6  890B60     MOV W0, 0x216C
656:                           dfmem_geo.byte_address_bits = FLASH_8MBIT_BYTE_ADDRESS_BITS;
007FA8  200090     MOV #0x9, W0
007FAA  890AF0     MOV W0, dfmem_geo
657:                           break;
007FAC  370034     BRA 0x8016
658:                       case DFMEM_16MBIT:
659:                           dfmem_geo.max_sector        = FLASH_16MBIT_MAX_SECTOR;
007FAE  200100     MOV #0x10, W0
007FB0  890B00     MOV W0, 0x2160
660:                           dfmem_geo.max_pages         = FLASH_16MBIT_MAX_PAGES;
007FB2  210000     MOV #0x1000, W0
007FB4  890B10     MOV W0, 0x2162
661:                           dfmem_geo.buffer_size       = FLASH_16MBIT_BUFFERSIZE;
007FB6  202100     MOV #0x210, W0
007FB8  890B20     MOV W0, 0x2164
662:                           dfmem_geo.bytes_per_page    = FLASH_16MBIT_BYTES_PER_PAGE;
007FBA  202100     MOV #0x210, W0
007FBC  890B30     MOV W0, 0x2166
663:                           dfmem_geo.pages_per_block   = FLASH_16MBIT_PAGES_PER_BLOCK;
007FBE  200080     MOV #0x8, W0
007FC0  890B40     MOV W0, 0x2168
664:                           dfmem_geo.blocks_per_sector = FLASH_16MBIT_BLOCKS_PER_SECTOR;
007FC2  200200     MOV #0x20, W0
007FC4  890B50     MOV W0, 0x216A
665:                           dfmem_geo.pages_per_sector  = FLASH_16MBIT_PAGES_PER_SECTOR;
007FC6  201000     MOV #0x100, W0
007FC8  890B60     MOV W0, 0x216C
666:                           dfmem_geo.byte_address_bits = FLASH_16MBIT_BYTE_ADDRESS_BITS;
007FCA  2000A0     MOV #0xA, W0
007FCC  890AF0     MOV W0, dfmem_geo
667:                           break;
007FCE  370023     BRA 0x8016
668:                       case DFMEM_32MBIT:
669:                           dfmem_geo.max_sector        = FLASH_32MBIT_MAX_SECTOR;
007FD0  200400     MOV #0x40, W0
007FD2  890B00     MOV W0, 0x2160
670:                           dfmem_geo.max_pages         = FLASH_32MBIT_MAX_PAGES;
007FD4  220000     MOV #0x2000, W0
007FD6  890B10     MOV W0, 0x2162
671:                           dfmem_geo.buffer_size       = FLASH_32MBIT_BUFFERSIZE;
007FD8  202100     MOV #0x210, W0
007FDA  890B20     MOV W0, 0x2164
672:                           dfmem_geo.bytes_per_page    = FLASH_32MBIT_BYTES_PER_PAGE;
007FDC  202100     MOV #0x210, W0
007FDE  890B30     MOV W0, 0x2166
673:                           dfmem_geo.pages_per_block   = FLASH_32MBIT_PAGES_PER_BLOCK;
007FE0  200080     MOV #0x8, W0
007FE2  890B40     MOV W0, 0x2168
674:                           dfmem_geo.blocks_per_sector = FLASH_32MBIT_BLOCKS_PER_SECTOR;
007FE4  200100     MOV #0x10, W0
007FE6  890B50     MOV W0, 0x216A
675:                           dfmem_geo.pages_per_sector  = FLASH_32MBIT_PAGES_PER_SECTOR;
007FE8  200800     MOV #0x80, W0
007FEA  890B60     MOV W0, 0x216C
676:                           dfmem_geo.byte_address_bits = FLASH_32MBIT_BYTE_ADDRESS_BITS;
007FEC  2000A0     MOV #0xA, W0
007FEE  890AF0     MOV W0, dfmem_geo
677:                           break;
007FF0  370012     BRA 0x8016
678:                       case DFMEM_64MBIT:
679:                           dfmem_geo.max_sector        = FLASH_64MBIT_MAX_SECTOR;
007FF2  200200     MOV #0x20, W0
007FF4  890B00     MOV W0, 0x2160
680:                           dfmem_geo.max_pages         = FLASH_64MBIT_MAX_PAGES;
007FF6  220000     MOV #0x2000, W0
007FF8  890B10     MOV W0, 0x2162
681:                           dfmem_geo.buffer_size       = FLASH_64MBIT_BUFFERSIZE;
007FFA  204200     MOV #0x420, W0
007FFC  890B20     MOV W0, 0x2164
682:                           dfmem_geo.bytes_per_page    = FLASH_64MBIT_BYTES_PER_PAGE;
007FFE  204200     MOV #0x420, W0
008000  890B30     MOV W0, 0x2166
683:                           dfmem_geo.pages_per_block   = FLASH_64MBIT_PAGES_PER_BLOCK;
008002  200080     MOV #0x8, W0
008004  890B40     MOV W0, 0x2168
684:                           dfmem_geo.blocks_per_sector = FLASH_64MBIT_BLOCKS_PER_SECTOR;
008006  200200     MOV #0x20, W0
008008  890B50     MOV W0, 0x216A
685:                           dfmem_geo.pages_per_sector  = FLASH_64MBIT_PAGES_PER_SECTOR;
00800A  201000     MOV #0x100, W0
00800C  890B60     MOV W0, 0x216C
686:                           dfmem_geo.byte_address_bits = FLASH_64MBIT_BYTE_ADDRESS_BITS;
00800E  2000B0     MOV #0xB, W0
008010  890AF0     MOV W0, dfmem_geo
687:                           break;
008012  370001     BRA 0x8016
688:                       default:
689:                           // TODO (apullin, fgb) : Do something. Probably communicate back with user.
690:                           break;
008014  000000     NOP
691:                   }
692:               }
008016  FA8000     ULNK
008018  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/dfilter_avg.c  ----------------------------------------
1:                 /*
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Averaging filter using a circular buffer
31:                 *
32:                 * by Andrew Pullin
33:                 *
34:                 * v.0.1
35:                 *
36:                 * Revisions:
37:                 *  Andrew Pullin   2012-5-28   Initial release.
38:                 */
39:                
40:                #include "dfilter_avg.h"
41:                #include <stdlib.h>
42:                
43:                
44:                ///////////////   Public functions  //////////////////
45:                
46:                void filterAvgCreate(filterAvgInt_t* filt, unsigned int length){
00DF76  FA0004     LNK #0x4
00DF78  780F00     MOV W0, [W14]
00DF7A  980711     MOV W1, [W14+2]
47:                    filt->data = calloc(length, sizeof(int)); //Initialize data to 0
00DF7C  200021     MOV #0x2, W1
00DF7E  90001E     MOV [W14+2], W0
00DF80  023556     CALL _calloc
00DF82  000000     NOP
00DF84  780080     MOV W0, W1
00DF86  78001E     MOV [W14], W0
00DF88  980021     MOV W1, [W0+4]
48:                    filt->windowLen = length;
00DF8A  78001E     MOV [W14], W0
00DF8C  90009E     MOV [W14+2], W1
00DF8E  780801     MOV W1, [W0]
49:                    filt->index = 0;
00DF90  78001E     MOV [W14], W0
00DF92  EB0080     CLR W1
00DF94  980011     MOV W1, [W0+2]
50:                    filt->accum = 0;
00DF96  78011E     MOV [W14], W2
00DF98  B80060     MUL.UU W0, #0, W0
00DF9A  980130     MOV W0, [W2+6]
00DF9C  980141     MOV W1, [W2+8]
51:                }
00DF9E  FA8000     ULNK
00DFA0  060000     RETURN
52:                
53:                void filterAvgUpdate(filterAvgInt_t* filt, int newval){
00DFA2  FA0004     LNK #0x4
00DFA4  780F00     MOV W0, [W14]
00DFA6  980711     MOV W1, [W14+2]
54:                    // Add new value to accumulation, subtract existing value that is
55:                    // going to be overwritten.
56:                    filt->accum += newval - filt->data[filt->index];
00DFA8  78001E     MOV [W14], W0
00DFAA  900130     MOV [W0+6], W2
00DFAC  9001C0     MOV [W0+8], W3
00DFAE  78001E     MOV [W14], W0
00DFB0  9000A0     MOV [W0+4], W1
00DFB2  78001E     MOV [W14], W0
00DFB4  900010     MOV [W0+2], W0
00DFB6  400000     ADD W0, W0, W0
00DFB8  408000     ADD W1, W0, W0
00DFBA  780010     MOV [W0], W0
00DFBC  90009E     MOV [W14+2], W1
00DFBE  508000     SUB W1, W0, W0
00DFC0  DE80CF     ASR W0, #15, W1
00DFC2  400002     ADD W0, W2, W0
00DFC4  488083     ADDC W1, W3, W1
00DFC6  78011E     MOV [W14], W2
00DFC8  980130     MOV W0, [W2+6]
00DFCA  980141     MOV W1, [W2+8]
57:                    // Set new value
58:                    filt->data[filt->index] = newval;
00DFCC  78001E     MOV [W14], W0
00DFCE  9000A0     MOV [W0+4], W1
00DFD0  78001E     MOV [W14], W0
00DFD2  900010     MOV [W0+2], W0
00DFD4  400000     ADD W0, W0, W0
00DFD6  408000     ADD W1, W0, W0
00DFD8  90009E     MOV [W14+2], W1
00DFDA  780801     MOV W1, [W0]
59:                    // Circularly increment index
60:                    filt->index = (filt->index + 1) % filt->windowLen;
00DFDC  78001E     MOV [W14], W0
00DFDE  900010     MOV [W0+2], W0
00DFE0  E80080     INC W0, W1
00DFE2  78001E     MOV [W14], W0
00DFE4  780010     MOV [W0], W0
00DFE6  780100     MOV W0, W2
00DFE8  090011     REPEAT #0x11
00DFEA  D88082     DIV.UW W1, W2
00DFEC  FD0080     EXCH W0, W1
00DFEE  780080     MOV W0, W1
00DFF0  78001E     MOV [W14], W0
00DFF2  980011     MOV W1, [W0+2]
61:                }
00DFF4  FA8000     ULNK
00DFF6  060000     RETURN
62:                
63:                // TODO (apullin) : more efficient calculation? DSP? delta?
64:                int filterAvgCalc(filterAvgInt_t* filt){
00DFF8  FA0002     LNK #0x2
00DFFA  780F00     MOV W0, [W14]
65:                    return (int)(filt->accum / (filt->windowLen));
00DFFC  78001E     MOV [W14], W0
00DFFE  900230     MOV [W0+6], W4
00E000  9002C0     MOV [W0+8], W5
00E002  78001E     MOV [W14], W0
00E004  780010     MOV [W0], W0
00E006  200001     MOV #0x0, W1
00E008  BE0100     MOV.D W0, W2
00E00A  BE0004     MOV.D W4, W0
00E00C  022586     CALL ___divsi3
00E00E  000000     NOP
00E010  780000     MOV W0, W0
66:                }
00E012  FA8000     ULNK
00E014  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/dfilter.c  --------------------------------------------
1:                 /*
2:                  * Copyright (c) 2011-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Digital filter module
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.alpha
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek             2011-01-28  Initial release
38:                 *  Fernando L. Garcia Bermudez 2012-04-24  Changed module name to dfilter, to
39:                 *                                          prevent collisions with Microchip's
40:                 *                                          dsp module.
41:                 *  Humphrey Hu                 2012-07-13  Switched to static allocation
42:                 */
43:                
44:                #include <stdlib.h>
45:                #include "dfilter.h"
46:                #include <string.h>
47:                
48:                //#define NaN(f) ( ((((char *)&f)[3] & 0x7f) == 0x7f ) && (((char *)&f)[2] & 0x80) )
49:                
50:                /*-----------------------------------------------------------------------------
51:                 *          Public functions
52:                -----------------------------------------------------------------------------*/
53:                float dfilterApply(DigitalFilter f, float x)
54:                {
00D3F6  FA000C     LNK #0xC
00D3F8  BE9F88     MOV.D W8, [W15++]
00D3FA  980730     MOV W0, [W14+6]
00D3FC  980742     MOV W2, [W14+8]
00D3FE  980753     MOV W3, [W14+10]
55:                    float y;
56:                    unsigned int i;
57:                        
58:                    f->xold[0] = x;
00D400  90003E     MOV [W14+6], W0
00D402  90014E     MOV [W14+8], W2
00D404  9001DE     MOV [W14+10], W3
00D406  982062     MOV W2, [W0+76]
00D408  982073     MOV W3, [W0+78]
59:                    f->yold[0] = 0.0;
00D40A  90013E     MOV [W14+6], W2
00D40C  B80060     MUL.UU W0, #0, W0
00D40E  981920     MOV W0, [W2+52]
00D410  981931     MOV W1, [W2+54]
60:                    y = 0;
00D412  B80060     MUL.UU W0, #0, W0
00D414  BE8F00     MOV.D W0, [W14]
61:                        
62:                    for (i = 0; i <= f->order; i++) {
00D416  EB0000     CLR W0
00D418  980720     MOV W0, [W14+4]
00D41A  37002D     BRA 0xD476
00D470  90002E     MOV [W14+4], W0
00D472  E80000     INC W0, W0
00D474  980720     MOV W0, [W14+4]
00D476  90003E     MOV [W14+6], W0
00D478  784010     MOV.B [W0], W0
00D47A  FB8080     ZE W0, W1
00D47C  90002E     MOV [W14+4], W0
00D47E  508F80     SUB W1, W0, [W15]
00D480  31FFCD     BRA C, 0xD41C
63:                        y += f->xcoef[i]*f->xold[i] + f->ycoef[i]*f->yold[i];
00D41C  9000BE     MOV [W14+6], W1
00D41E  90002E     MOV [W14+4], W0
00D420  E80000     INC W0, W0
00D422  DD0042     SL W0, #2, W0
00D424  408000     ADD W1, W0, W0
00D426  BE0210     MOV.D [W0], W4
00D428  9000BE     MOV [W14+6], W1
00D42A  90002E     MOV [W14+4], W0
00D42C  400073     ADD W0, #0x13, W0
00D42E  DD0042     SL W0, #2, W0
00D430  408000     ADD W1, W0, W0
00D432  BE0010     MOV.D [W0], W0
00D434  BE0100     MOV.D W0, W2
00D436  BE0004     MOV.D W4, W0
00D438  022C36     CALL ___mulsf3
00D43A  000000     NOP
00D43C  BE0400     MOV.D W0, W8
00D43E  9000BE     MOV [W14+6], W1
00D440  90002E     MOV [W14+4], W0
00D442  400067     ADD W0, #0x7, W0
00D444  DD0042     SL W0, #2, W0
00D446  408000     ADD W1, W0, W0
00D448  BE0210     MOV.D [W0], W4
00D44A  9000BE     MOV [W14+6], W1
00D44C  90002E     MOV [W14+4], W0
00D44E  40006D     ADD W0, #0xD, W0
00D450  DD0042     SL W0, #2, W0
00D452  408000     ADD W1, W0, W0
00D454  BE0010     MOV.D [W0], W0
00D456  BE0100     MOV.D W0, W2
00D458  BE0004     MOV.D W4, W0
00D45A  022C36     CALL ___mulsf3
00D45C  000000     NOP
00D45E  BE0100     MOV.D W0, W2
00D460  BE0008     MOV.D W8, W0
00D462  022A6C     CALL ___addsf3
00D464  000000     NOP
00D466  BE0100     MOV.D W0, W2
00D468  BE001E     MOV.D [W14], W0
00D46A  022A6C     CALL ___addsf3
00D46C  000000     NOP
00D46E  BE8F00     MOV.D W0, [W14]
64:                    }
65:                    
66:                    memmove(&f->xold[1], &f->xold[0], sizeof(float)*(f->order));
00D482  90003E     MOV [W14+6], W0
00D484  784010     MOV.B [W0], W0
00D486  FB8000     ZE W0, W0
00D488  DD0142     SL W0, #2, W2
00D48A  90003E     MOV [W14+6], W0
00D48C  2004C1     MOV #0x4C, W1
00D48E  408080     ADD W1, W0, W1
00D490  90003E     MOV [W14+6], W0
00D492  B004C0     ADD #0x4C, W0
00D494  400064     ADD W0, #0x4, W0
00D496  023590     CALL _memmove
00D498  000000     NOP
67:                    memmove(&f->yold[1], &f->yold[0], sizeof(float)*(f->order));
00D49A  90003E     MOV [W14+6], W0
00D49C  784010     MOV.B [W0], W0
00D49E  FB8000     ZE W0, W0
00D4A0  DD0142     SL W0, #2, W2
00D4A2  90003E     MOV [W14+6], W0
00D4A4  200341     MOV #0x34, W1
00D4A6  408080     ADD W1, W0, W1
00D4A8  90003E     MOV [W14+6], W0
00D4AA  B00340     ADD #0x34, W0
00D4AC  400064     ADD W0, #0x4, W0
00D4AE  023590     CALL _memmove
00D4B0  000000     NOP
68:                    
69:                    f->yold[1] = y;
00D4B2  90003E     MOV [W14+6], W0
00D4B4  BE011E     MOV.D [W14], W2
00D4B6  981842     MOV W2, [W0+56]
00D4B8  981853     MOV W3, [W0+58]
70:                
71:                    return y;
00D4BA  BE001E     MOV.D [W14], W0
72:                }
00D4BC  BE044F     MOV.D [--W15], W8
00D4BE  FA8000     ULNK
00D4C0  060000     RETURN
73:                
74:                
75:                DigitalFilter dfilterCreate(unsigned char order, FilterType type,
76:                                float* xcoeffs, float* ycoeffs)
77:                {
00D4C2  FA0008     LNK #0x8
00D4C4  784F00     MOV.B W0, [W14]
00D4C6  980711     MOV W1, [W14+2]
00D4C8  980722     MOV W2, [W14+4]
00D4CA  980733     MOV W3, [W14+6]
78:                    return NULL;
00D4CC  EB0000     CLR W0
79:                }
00D4CE  FA8000     ULNK
00D4D0  060000     RETURN
80:                
81:                void dfilterInit(DigitalFilter f, unsigned char order, FilterType type,
82:                                    float* xcoeffs, float* ycoeffs) {
00D4D2  FA000A     LNK #0xA
00D4D4  780F00     MOV W0, [W14]
00D4D6  984721     MOV.B W1, [W14+2]
00D4D8  980722     MOV W2, [W14+4]
00D4DA  980733     MOV W3, [W14+6]
00D4DC  980744     MOV W4, [W14+8]
83:                
84:                    memset(f, 0x00, sizeof(DigitalFilterStruct));
00D4DE  200642     MOV #0x64, W2
00D4E0  EB0080     CLR W1
00D4E2  78001E     MOV [W14], W0
00D4E4  0235B4     CALL _memset
00D4E6  000000     NOP
85:                    
86:                    if(order > MAX_FILTER_ORDER) { return; }
00D4E8  9040AE     MOV.B [W14+2], W1
00D4EA  B3C050     MOV #0x5, W0
00D4EC  50CF80     SUB.B W1, W0, [W15]
00D4EE  3E001D     BRA GTU, 0xD52A
00D52A  000000     NOP
87:                    f->order = order;
00D4F0  78001E     MOV [W14], W0
00D4F2  9040AE     MOV.B [W14+2], W1
00D4F4  784801     MOV.B W1, [W0]
88:                    f->type = type;
00D4F6  78001E     MOV [W14], W0
00D4F8  90012E     MOV [W14+4], W2
00D4FA  980012     MOV W2, [W0+2]
89:                    memcpy(&f->xcoef, xcoeffs, sizeof(float)*(order + 1));
00D4FC  90402E     MOV.B [W14+2], W0
00D4FE  FB8000     ZE W0, W0
00D500  E80000     INC W0, W0
00D502  DD0042     SL W0, #2, W0
00D504  780080     MOV W0, W1
00D506  78011E     MOV [W14], W2
00D508  410064     ADD W2, #0x4, W0
00D50A  780101     MOV W1, W2
00D50C  9000BE     MOV [W14+6], W1
00D50E  023582     CALL _memcpy
00D510  000000     NOP
90:                    memcpy(&f->ycoef, ycoeffs, sizeof(float)*(order + 1));
00D512  90402E     MOV.B [W14+2], W0
00D514  FB8000     ZE W0, W0
00D516  E80000     INC W0, W0
00D518  DD0042     SL W0, #2, W0
00D51A  780080     MOV W0, W1
00D51C  78011E     MOV [W14], W2
00D51E  41007C     ADD W2, #0x1C, W0
00D520  780101     MOV W1, W2
00D522  9000CE     MOV [W14+8], W1
00D524  023582     CALL _memcpy
00D526  000000     NOP
00D528  370001     BRA 0xD52C
91:                    
92:                }
00D52C  FA8000     ULNK
00D52E  060000     RETURN
93:                
94:                
95:                float* dfilterGetOutputValues(DigitalFilter f)
96:                {
00D530  FA0002     LNK #0x2
00D532  780F00     MOV W0, [W14]
97:                    return f->yold;
00D534  200341     MOV #0x34, W1
00D536  40801E     ADD W1, [W14], W0
98:                }
00D538  FA8000     ULNK
00D53A  060000     RETURN
99:                
100:               float* dfilterGetInputValues(DigitalFilter f)
101:               {
00D53C  FA0002     LNK #0x2
00D53E  780F00     MOV W0, [W14]
102:                   return f->xold;
00D540  2004C1     MOV #0x4C, W1
00D542  40801E     ADD W1, [W14], W0
103:               }
00D544  FA8000     ULNK
00D546  060000     RETURN
104:               
105:               float dfilterGetLatestOutputValue(DigitalFilter f)
106:               {
00D548  FA0002     LNK #0x2
00D54A  780F00     MOV W0, [W14]
107:                   return (f == NULL) ? 0.0 : f->yold[1];
00D54C  78009E     MOV [W14], W1
00D54E  EB0000     CLR W0
00D550  508F80     SUB W1, W0, [W15]
00D552  320004     BRA Z, 0xD55C
00D554  78001E     MOV [W14], W0
00D556  9018D0     MOV [W0+58], W1
00D558  901840     MOV [W0+56], W0
00D55A  370001     BRA 0xD55E
00D55C  B80060     MUL.UU W0, #0, W0
108:               }
00D55E  FA8000     ULNK
00D560  060000     RETURN
109:               
110:               float dfilterGetLatestInputValue(DigitalFilter f)
111:               {
00D562  FA0002     LNK #0x2
00D564  780F00     MOV W0, [W14]
112:                   return (f == NULL) ? 0.0 : f->xold[1];
00D566  78009E     MOV [W14], W1
00D568  EB0000     CLR W0
00D56A  508F80     SUB W1, W0, [W15]
00D56C  320004     BRA Z, 0xD576
00D56E  78001E     MOV [W14], W0
00D570  902890     MOV [W0+82], W1
00D572  902800     MOV [W0+80], W0
00D574  370001     BRA 0xD578
00D576  B80060     MUL.UU W0, #0, W0
113:               }
00D578  FA8000     ULNK
00D57A  060000     RETURN
114:               
115:               // TODO: Deprecate
116:               unsigned char dfilterGetIndex(DigitalFilter f)
117:               {
00D57C  FA0002     LNK #0x2
00D57E  780F00     MOV W0, [W14]
118:                   //return f->index;
119:                   return 0;
00D580  EB4000     CLR.B W0
120:               }
00D582  FA8000     ULNK
00D584  060000     RETURN
121:               
122:               void dfilterDelete(DigitalFilter f)
123:               {
00D586  FA0002     LNK #0x2
00D588  780F00     MOV W0, [W14]
124:                   return;
125:               }
00D58A  FA8000     ULNK
00D58C  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/delay.s  ----------------------------------------------
                                                  1:     ;
                                                  2:     ; Copyright (c) 2007-2010, Regents of the University of California
                                                  3:     ; All rights reserved.
                                                  4:     ;
                                                  5:     ; Redistribution and use in source and binary forms, with or without
                                                  6:     ; modification, are permitted provided that the following conditions are met:
                                                  7:     ;
                                                  8:     ; - Redistributions of source code must retain the above copyright notice,
                                                  9:     ;   this list of conditions and the following disclaimer.
                                                  10:    ; - Redistributions in binary form must reproduce the above copyright notice,
                                                  11:    ;   this list of conditions and the following disclaimer in the documentation
                                                  12:    ;   and/or other materials provided with the distribution.
                                                  13:    ; - Neither the name of the University of California, Berkeley nor the names
                                                  14:    ;   of its contributors may be used to endorse or promote products derived
                                                  15:    ;   from this software without specific prior written permission.
                                                  16:    ;
                                                  17:    ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                  18:    ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                  19:    ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                  20:    ; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
                                                  21:    ; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
                                                  22:    ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
                                                  23:    ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
                                                  24:    ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
                                                  25:    ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
                                                  26:    ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
                                                  27:    ; POSSIBILITY OF SUCH DAMAGE.
                                                  28:    ;
                                                  29:    ;
                                                  30:    ; Delay subroutines
                                                  31:    ;
                                                  32:    ; by Fernando L. Garcia Bermudez
                                                  33:    ;
                                                  34:    ; v.1.0
                                                  35:    ;
                                                  36:    ; Revisions:
                                                  37:    ;  Fernando L. Garcia Bermudez     2007-9-14    Mixed assembly-C implementation
                                                  38:    ;                                  2010-7-23    Full assembly implementation
                                                  39:    ;
                                                  40:    
                                                  41:    #include p33Fxxxx.inc
                                                  42:    
                                                  43:    ; Symbol definitions
                                                  44:    .equiv  time, w0
                                                  45:    .equiv  temp, w2
                                                  46:    
                                                  47:    
                                                  48:    ;------------------------------------------------------------------------------
                                                  49:    ;           Public functions
                                                  50:    ;------------------------------------------------------------------------------
                                                  51:    
                                                  52:    .global _delay_us
                                                  53:    .global _delay_ms
                                                  54:    
                                                  55:    ; Need to waste ~40 inst/us (for 40MIPS) and since assembly loop takes 5
                                                  56:    ; instructions, it should be repeated 8 times to elapse a us. Since temp is a
                                                  57:    ; 16-bit word, the maximum delay possible is ~8.2ms (time=8192).
                                                  58:    _delay_us:
                                                  59:    
00E262  B80168     MUL.UU W0, #8, W2              60:                mul.uu  time, #8, temp
00E264  B10022     SUB #0x2, W2                   61:                sub     #2, temp        ; #2 obtained testing btg delays
00E266  000000     NOP                            62:    ELAPSED:    nop
00E268  000000     NOP                            63:                nop
00E26A  E90102     DEC W2, W2                     64:                dec     temp, temp
00E26C  3AFFFC     BRA NZ, 0xE266                 65:                bra     NZ, ELAPSED
                                                  66:    
00E26E  060000     RETURN                         67:                return
                                                  68:    
                                                  69:    ; The inner loop, modelled after the _delay_us routine, is repeated "time"
                                                  70:    ; times wasting 1ms per iteration (1000us * 8 - 2 = 7998).
                                                  71:    _delay_ms:
                                                  72:    
00E270  21F3E2     MOV #0x1F3E, W2                73:    msELAPSED:  mov     #7998, temp
00E272  000000     NOP                            74:    usELAPSED:  nop
00E274  000000     NOP                            75:                nop
00E276  E90102     DEC W2, W2                     76:                dec     temp, temp
00E278  3AFFFC     BRA NZ, 0xE272                 77:                bra     NZ, usELAPSED
00E27A  E90000     DEC W0, W0                     78:                dec     time, time
00E27C  3AFFF9     BRA NZ, 0xE270                 79:                bra     NZ, msELAPSED
                                                  80:    
00E27E  060000     RETURN                         81:                return
                                                  82:    
                                                  83:    
                                                  84:    .end
---  C:/Users/Cameron/Documents/Git/imageproc-lib/counter.c  --------------------------------------------
1:                 /*
2:                  * Copyright (c) 2011, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Protected Counter Module
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v 1.0
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu 2011-09-03    Initial implementation
38:                 *                      
39:                 * Note:
40:                 *	- Uses 16-bit unsigned integer counters
41:                 */
42:                 
43:                // ==== REFERENCES ==========================================
44:                #include "counter.h"
45:                #include <stdlib.h>
46:                #include "utils.h"
47:                
48:                // ==== FUNCTION BODIES =====================================
49:                Counter cntrCreate(void) {
00D58E  FA0002     LNK #0x2
50:                   
51:                   Counter counter = (Counter) malloc(sizeof(CounterStruct));
00D590  200040     MOV #0x4, W0
00D592  0233BA     CALL _malloc
00D594  000000     NOP
00D596  780F00     MOV W0, [W14]
52:                   counter->valid = 1;
00D598  78009E     MOV [W14], W1
00D59A  B3C010     MOV #0x1, W0
00D59C  784880     MOV.B W0, [W1]
53:                   counter->value = 0;
00D59E  78001E     MOV [W14], W0
00D5A0  EB0080     CLR W1
00D5A2  980011     MOV W1, [W0+2]
54:                   return counter;
00D5A4  78001E     MOV [W14], W0
55:                   
56:                }
00D5A6  FA8000     ULNK
00D5A8  060000     RETURN
57:                
58:                void cntrDelete(Counter counter) {
00D5AA  FA0002     LNK #0x2
00D5AC  780F00     MOV W0, [W14]
59:                
60:                   if(counter != NULL) {
00D5AE  78009E     MOV [W14], W1
00D5B0  EB0000     CLR W0
00D5B2  508F80     SUB W1, W0, [W15]
00D5B4  320003     BRA Z, 0xD5BC
61:                   	free(counter);
00D5B6  78001E     MOV [W14], W0
00D5B8  0234EC     CALL _free
00D5BA  000000     NOP
62:                   }
63:                
64:                }
00D5BC  FA8000     ULNK
00D5BE  060000     RETURN
65:                
66:                unsigned int cntrRead(Counter counter) {
00D5C0  FA000A     LNK #0xA
00D5C2  980740     MOV W0, [W14+8]
67:                
68:                   unsigned int val;
69:                   CRITICAL_SECTION_START;
00D5C4  800210     MOV SR, W0
00D5C6  DE0045     LSR W0, #5, W0
00D5C8  604067     AND.B W0, #0x7, W0
00D5CA  784F00     MOV.B W0, [W14]
00D5CC  800290     MOV DISICNT, W0
00D5CE  980710     MOV W0, [W14+2]
00D5D0  FC3FFF     DISI #0x3FFF
00D5D2  800211     MOV SR, W1
00D5D4  200E00     MOV #0xE0, W0
00D5D6  708000     IOR W1, W0, W0
00D5D8  880210     MOV W0, SR
00D5DA  90001E     MOV [W14+2], W0
00D5DC  880290     MOV W0, DISICNT
00D5DE  880000     MOV W0, WREG0
70:                   val = counter->value;
00D5E0  90004E     MOV [W14+8], W0
00D5E2  900090     MOV [W0+2], W1
00D5E4  980721     MOV W1, [W14+4]
71:                   CRITICAL_SECTION_END;
00D5E6  800290     MOV DISICNT, W0
00D5E8  980730     MOV W0, [W14+6]
00D5EA  FC3FFF     DISI #0x3FFF
00D5EC  78401E     MOV.B [W14], W0
00D5EE  604067     AND.B W0, #0x7, W0
00D5F0  FB8000     ZE W0, W0
00D5F2  600067     AND W0, #0x7, W0
00D5F4  DD0045     SL W0, #5, W0
00D5F6  800212     MOV SR, W2
00D5F8  2FF1F1     MOV #0xFF1F, W1
00D5FA  610081     AND W2, W1, W1
00D5FC  708000     IOR W1, W0, W0
00D5FE  880210     MOV W0, SR
00D600  90003E     MOV [W14+6], W0
00D602  880290     MOV W0, DISICNT
00D604  880000     MOV W0, WREG0
72:                   return val;
00D606  90002E     MOV [W14+4], W0
73:                   
74:                }
00D608  FA8000     ULNK
00D60A  060000     RETURN
75:                
76:                void cntrIncrement(Counter counter) {
00D60C  FA0008     LNK #0x8
00D60E  980730     MOV W0, [W14+6]
77:                
78:                   CRITICAL_SECTION_START;
00D610  800210     MOV SR, W0
00D612  DE0045     LSR W0, #5, W0
00D614  604067     AND.B W0, #0x7, W0
00D616  784F00     MOV.B W0, [W14]
00D618  800290     MOV DISICNT, W0
00D61A  980710     MOV W0, [W14+2]
00D61C  FC3FFF     DISI #0x3FFF
00D61E  800211     MOV SR, W1
00D620  200E00     MOV #0xE0, W0
00D622  708000     IOR W1, W0, W0
00D624  880210     MOV W0, SR
00D626  90001E     MOV [W14+2], W0
00D628  880290     MOV W0, DISICNT
00D62A  880000     MOV W0, WREG0
79:                   counter->value++;
00D62C  90003E     MOV [W14+6], W0
00D62E  900010     MOV [W0+2], W0
00D630  E80080     INC W0, W1
00D632  90003E     MOV [W14+6], W0
00D634  980011     MOV W1, [W0+2]
80:                   CRITICAL_SECTION_END;
00D636  800290     MOV DISICNT, W0
00D638  980720     MOV W0, [W14+4]
00D63A  FC3FFF     DISI #0x3FFF
00D63C  78401E     MOV.B [W14], W0
00D63E  604067     AND.B W0, #0x7, W0
00D640  FB8000     ZE W0, W0
00D642  600067     AND W0, #0x7, W0
00D644  DD0045     SL W0, #5, W0
00D646  800212     MOV SR, W2
00D648  2FF1F1     MOV #0xFF1F, W1
00D64A  610081     AND W2, W1, W1
00D64C  708000     IOR W1, W0, W0
00D64E  880210     MOV W0, SR
00D650  90002E     MOV [W14+4], W0
00D652  880290     MOV W0, DISICNT
00D654  880000     MOV W0, WREG0
81:                
82:                }
00D656  FA8000     ULNK
00D658  060000     RETURN
83:                
84:                void cntrAdd(Counter counter, unsigned int val) {
00D65A  FA000A     LNK #0xA
00D65C  980730     MOV W0, [W14+6]
00D65E  980741     MOV W1, [W14+8]
85:                
86:                   CRITICAL_SECTION_START;
00D660  800210     MOV SR, W0
00D662  DE0045     LSR W0, #5, W0
00D664  604067     AND.B W0, #0x7, W0
00D666  784F00     MOV.B W0, [W14]
00D668  800290     MOV DISICNT, W0
00D66A  980710     MOV W0, [W14+2]
00D66C  FC3FFF     DISI #0x3FFF
00D66E  800211     MOV SR, W1
00D670  200E00     MOV #0xE0, W0
00D672  708000     IOR W1, W0, W0
00D674  880210     MOV W0, SR
00D676  90001E     MOV [W14+2], W0
00D678  880290     MOV W0, DISICNT
00D67A  880000     MOV W0, WREG0
87:                   counter->value += val;
00D67C  90003E     MOV [W14+6], W0
00D67E  900090     MOV [W0+2], W1
00D680  90004E     MOV [W14+8], W0
00D682  408080     ADD W1, W0, W1
00D684  90003E     MOV [W14+6], W0
00D686  980011     MOV W1, [W0+2]
88:                   CRITICAL_SECTION_END;
00D688  800290     MOV DISICNT, W0
00D68A  980720     MOV W0, [W14+4]
00D68C  FC3FFF     DISI #0x3FFF
00D68E  78401E     MOV.B [W14], W0
00D690  604067     AND.B W0, #0x7, W0
00D692  FB8000     ZE W0, W0
00D694  600067     AND W0, #0x7, W0
00D696  DD0045     SL W0, #5, W0
00D698  800212     MOV SR, W2
00D69A  2FF1F1     MOV #0xFF1F, W1
00D69C  610081     AND W2, W1, W1
00D69E  708000     IOR W1, W0, W0
00D6A0  880210     MOV W0, SR
00D6A2  90002E     MOV [W14+4], W0
00D6A4  880290     MOV W0, DISICNT
00D6A6  880000     MOV W0, WREG0
89:                
90:                }
00D6A8  FA8000     ULNK
00D6AA  060000     RETURN
91:                
92:                void cntrSet(Counter counter, unsigned int value) {
00D6AC  FA000A     LNK #0xA
00D6AE  980730     MOV W0, [W14+6]
00D6B0  980741     MOV W1, [W14+8]
93:                
94:                   CRITICAL_SECTION_START;
00D6B2  800210     MOV SR, W0
00D6B4  DE0045     LSR W0, #5, W0
00D6B6  604067     AND.B W0, #0x7, W0
00D6B8  784F00     MOV.B W0, [W14]
00D6BA  800290     MOV DISICNT, W0
00D6BC  980710     MOV W0, [W14+2]
00D6BE  FC3FFF     DISI #0x3FFF
00D6C0  800211     MOV SR, W1
00D6C2  200E00     MOV #0xE0, W0
00D6C4  708000     IOR W1, W0, W0
00D6C6  880210     MOV W0, SR
00D6C8  90001E     MOV [W14+2], W0
00D6CA  880290     MOV W0, DISICNT
00D6CC  880000     MOV W0, WREG0
95:                   counter->value = value;
00D6CE  90003E     MOV [W14+6], W0
00D6D0  9000CE     MOV [W14+8], W1
00D6D2  980011     MOV W1, [W0+2]
96:                   CRITICAL_SECTION_END;
00D6D4  800290     MOV DISICNT, W0
00D6D6  980720     MOV W0, [W14+4]
00D6D8  FC3FFF     DISI #0x3FFF
00D6DA  78401E     MOV.B [W14], W0
00D6DC  604067     AND.B W0, #0x7, W0
00D6DE  FB8000     ZE W0, W0
00D6E0  600067     AND W0, #0x7, W0
00D6E2  DD0045     SL W0, #5, W0
00D6E4  800212     MOV SR, W2
00D6E6  2FF1F1     MOV #0xFF1F, W1
00D6E8  610081     AND W2, W1, W1
00D6EA  708000     IOR W1, W0, W0
00D6EC  880210     MOV W0, SR
00D6EE  90002E     MOV [W14+4], W0
00D6F0  880290     MOV W0, DISICNT
00D6F2  880000     MOV W0, WREG0
97:                
98:                }
00D6F4  FA8000     ULNK
00D6F6  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/controller.c  -----------------------------------------
1:                 /*
2:                  * Copyright (c) 2009 - 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Control block module
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek      2009-10-30    Initial release 
38:                 */
39:                
40:                #include "controller.h"
41:                #include "dfilter.h"
42:                #include <stdlib.h>
43:                
44:                
45:                /*-----------------------------------------------------------------------------
46:                 *          Public functions
47:                -----------------------------------------------------------------------------*/
48:                
49:                float ctrlGetRef(CtrlPidParam pid) {
00AEC0  FA0002     LNK #0x2
00AEC2  780F00     MOV W0, [W14]
50:                    return pid->ref;
00AEC4  78001E     MOV [W14], W0
00AEC6  9000A0     MOV [W0+4], W1
00AEC8  900010     MOV [W0+2], W0
51:                }
00AECA  FA8000     ULNK
00AECC  060000     RETURN
52:                
53:                void ctrlSetRef(CtrlPidParam pid, float ref) {
00AECE  FA0006     LNK #0x6
00AED0  780F00     MOV W0, [W14]
00AED2  980712     MOV W2, [W14+2]
00AED4  980723     MOV W3, [W14+4]
54:                    pid->ref = ref;
00AED6  78001E     MOV [W14], W0
00AED8  90011E     MOV [W14+2], W2
00AEDA  9001AE     MOV [W14+4], W3
00AEDC  980012     MOV W2, [W0+2]
00AEDE  980023     MOV W3, [W0+4]
55:                }
00AEE0  FA8000     ULNK
00AEE2  060000     RETURN
56:                
57:                
58:                
59:                float ctrlRunPid(CtrlPidParam pid, float y, DigitalFilter lpf) {
00AEE4  FA0020     LNK #0x20
00AEE6  BE9F88     MOV.D W8, [W15++]
00AEE8  980F40     MOV W0, [W14+24]
00AEEA  980F52     MOV W2, [W14+26]
00AEEC  980F63     MOV W3, [W14+28]
00AEEE  980F71     MOV W1, [W14+30]
60:                    float p_term, d_term, i_term, u, p_error, d_error;
61:                
62:                    if (!pid->running){ return 0.0; }
00AEF0  90084E     MOV [W14+24], W0
00AEF2  784090     MOV.B [W0], W1
00AEF4  EB4000     CLR.B W0
00AEF6  50CF80     SUB.B W1, W0, [W15]
00AEF8  3A0002     BRA NZ, 0xAEFE
00AEFA  B80060     MUL.UU W0, #0, W0
00AEFC  3700CC     BRA 0xB096
63:                
64:                    p_term = 0.0;
00AEFE  B80060     MUL.UU W0, #0, W0
00AF00  BE8F00     MOV.D W0, [W14]
65:                    d_term = 0.0;
00AF02  B80060     MUL.UU W0, #0, W0
00AF04  980720     MOV W0, [W14+4]
00AF06  980731     MOV W1, [W14+6]
66:                    i_term = 0.0;
00AF08  B80060     MUL.UU W0, #0, W0
00AF0A  980740     MOV W0, [W14+8]
00AF0C  980751     MOV W1, [W14+10]
67:                    
68:                    d_error = pid->gamma*pid->ref - y;  // error for derivative control
00AF0E  90084E     MOV [W14+24], W0
00AF10  900A70     MOV [W0+30], W4
00AF12  901280     MOV [W0+32], W5
00AF14  90084E     MOV [W14+24], W0
00AF16  9000A0     MOV [W0+4], W1
00AF18  900010     MOV [W0+2], W0
00AF1A  BE0100     MOV.D W0, W2
00AF1C  BE0004     MOV.D W4, W0
00AF1E  022C36     CALL ___mulsf3
00AF20  000000     NOP
00AF22  90095E     MOV [W14+26], W2
00AF24  9009EE     MOV [W14+28], W3
00AF26  022A5A     CALL ___subsf3
00AF28  000000     NOP
00AF2A  980F00     MOV W0, [W14+16]
00AF2C  980F11     MOV W1, [W14+18]
69:                    p_error = pid->beta*pid->ref - y;    // proportional control gain
00AF2E  90084E     MOV [W14+24], W0
00AF30  900A50     MOV [W0+26], W4
00AF32  900AE0     MOV [W0+28], W5
00AF34  90084E     MOV [W14+24], W0
00AF36  9000A0     MOV [W0+4], W1
00AF38  900010     MOV [W0+2], W0
00AF3A  BE0100     MOV.D W0, W2
00AF3C  BE0004     MOV.D W4, W0
00AF3E  022C36     CALL ___mulsf3
00AF40  000000     NOP
00AF42  90095E     MOV [W14+26], W2
00AF44  9009EE     MOV [W14+28], W3
00AF46  022A5A     CALL ___subsf3
00AF48  000000     NOP
00AF4A  980F20     MOV W0, [W14+20]
00AF4C  980F31     MOV W1, [W14+22]
70:                
71:                    if(pid->kp != 0.0) {
00AF4E  90084E     MOV [W14+24], W0
00AF50  900880     MOV [W0+16], W1
00AF52  900070     MOV [W0+14], W0
00AF54  B81160     MUL.UU W2, #0, W2
00AF56  022722     CALL ___nesf2
00AF58  000000     NOP
00AF5A  EB0080     CLR W1
00AF5C  500F81     SUB W0, W1, [W15]
00AF5E  320008     BRA Z, 0xAF70
72:                        p_term = pid->kp*p_error;    // proportional control gain
00AF60  90084E     MOV [W14+24], W0
00AF62  900880     MOV [W0+16], W1
00AF64  900070     MOV [W0+14], W0
00AF66  90092E     MOV [W14+20], W2
00AF68  9009BE     MOV [W14+22], W3
00AF6A  022C36     CALL ___mulsf3
00AF6C  000000     NOP
00AF6E  BE8F00     MOV.D W0, [W14]
73:                    }
74:                
75:                    if(pid->ki != 0.0) {
00AF70  90084E     MOV [W14+24], W0
00AF72  9008A0     MOV [W0+20], W1
00AF74  900810     MOV [W0+18], W0
00AF76  B81160     MUL.UU W2, #0, W2
00AF78  022722     CALL ___nesf2
00AF7A  000000     NOP
00AF7C  EB0080     CLR W1
00AF7E  500F81     SUB W0, W1, [W15]
00AF80  320016     BRA Z, 0xAFAE
76:                        pid->iold += p_error;
00AF82  90084E     MOV [W14+24], W0
00AF84  9010E0     MOV [W0+44], W1
00AF86  901050     MOV [W0+42], W0
00AF88  90092E     MOV [W14+20], W2
00AF8A  9009BE     MOV [W14+22], W3
00AF8C  022A6C     CALL ___addsf3
00AF8E  000000     NOP
00AF90  90094E     MOV [W14+24], W2
00AF92  981150     MOV W0, [W2+42]
00AF94  981161     MOV W1, [W2+44]
77:                        i_term = pid->ki*pid->iold;        
00AF96  90084E     MOV [W14+24], W0
00AF98  900A10     MOV [W0+18], W4
00AF9A  900AA0     MOV [W0+20], W5
00AF9C  90084E     MOV [W14+24], W0
00AF9E  9010E0     MOV [W0+44], W1
00AFA0  901050     MOV [W0+42], W0
00AFA2  BE0100     MOV.D W0, W2
00AFA4  BE0004     MOV.D W4, W0
00AFA6  022C36     CALL ___mulsf3
00AFA8  000000     NOP
00AFAA  980740     MOV W0, [W14+8]
00AFAC  980751     MOV W1, [W14+10]
78:                    }
79:                
80:                    if(pid->kd != 0.0) {
00AFAE  90084E     MOV [W14+24], W0
00AFB0  9008C0     MOV [W0+24], W1
00AFB2  900830     MOV [W0+22], W0
00AFB4  B81160     MUL.UU W2, #0, W2
00AFB6  022722     CALL ___nesf2
00AFB8  000000     NOP
00AFBA  EB0080     CLR W1
00AFBC  500F81     SUB W0, W1, [W15]
00AFBE  320030     BRA Z, 0xB020
81:                        if(lpf == NULL) {
00AFC0  9008FE     MOV [W14+30], W1
00AFC2  EB0000     CLR W0
00AFC4  508F80     SUB W1, W0, [W15]
00AFC6  3A0012     BRA NZ, 0xAFEC
82:                            d_term = pid->kd*(d_error - pid->derrold);
00AFC8  90084E     MOV [W14+24], W0
00AFCA  900C30     MOV [W0+22], W8
00AFCC  900CC0     MOV [W0+24], W9
00AFCE  90084E     MOV [W14+24], W0
00AFD0  901880     MOV [W0+48], W1
00AFD2  901070     MOV [W0+46], W0
00AFD4  BE0100     MOV.D W0, W2
00AFD6  90080E     MOV [W14+16], W0
00AFD8  90089E     MOV [W14+18], W1
00AFDA  022A5A     CALL ___subsf3
00AFDC  000000     NOP
00AFDE  BE0100     MOV.D W0, W2
00AFE0  BE0008     MOV.D W8, W0
00AFE2  022C36     CALL ___mulsf3
00AFE4  000000     NOP
00AFE6  980720     MOV W0, [W14+4]
00AFE8  980731     MOV W1, [W14+6]
00AFEA  370015     BRA 0xB016
83:                        } else {
84:                            d_term = pid->kd*dfilterApply(lpf, d_error - pid->derrold);
00AFEC  90084E     MOV [W14+24], W0
00AFEE  900C30     MOV [W0+22], W8
00AFF0  900CC0     MOV [W0+24], W9
00AFF2  90084E     MOV [W14+24], W0
00AFF4  901880     MOV [W0+48], W1
00AFF6  901070     MOV [W0+46], W0
00AFF8  BE0100     MOV.D W0, W2
00AFFA  90080E     MOV [W14+16], W0
00AFFC  90089E     MOV [W14+18], W1
00AFFE  022A5A     CALL ___subsf3
00B000  000000     NOP
00B002  BE0100     MOV.D W0, W2
00B004  90087E     MOV [W14+30], W0
00B006  02D3F6     CALL dfilterApply
00B008  000000     NOP
00B00A  BE0100     MOV.D W0, W2
00B00C  BE0008     MOV.D W8, W0
00B00E  022C36     CALL ___mulsf3
00B010  000000     NOP
00B012  980720     MOV W0, [W14+4]
00B014  980731     MOV W1, [W14+6]
85:                        }
86:                        pid->derrold = d_error;
00B016  90084E     MOV [W14+24], W0
00B018  90090E     MOV [W14+16], W2
00B01A  90099E     MOV [W14+18], W3
00B01C  981072     MOV W2, [W0+46]
00B01E  981803     MOV W3, [W0+48]
87:                    }
88:                
89:                    u = pid->offset + p_term + i_term + d_term;
00B020  90084E     MOV [W14+24], W0
00B022  9000C0     MOV [W0+8], W1
00B024  900030     MOV [W0+6], W0
00B026  BE011E     MOV.D [W14], W2
00B028  022A6C     CALL ___addsf3
00B02A  000000     NOP
00B02C  90014E     MOV [W14+8], W2
00B02E  9001DE     MOV [W14+10], W3
00B030  022A6C     CALL ___addsf3
00B032  000000     NOP
00B034  90012E     MOV [W14+4], W2
00B036  9001BE     MOV [W14+6], W3
00B038  022A6C     CALL ___addsf3
00B03A  000000     NOP
00B03C  980760     MOV W0, [W14+12]
00B03E  980771     MOV W1, [W14+14]
90:                
91:                    if (u > pid->umax) {
00B040  90084E     MOV [W14+24], W0
00B042  9010A0     MOV [W0+36], W1
00B044  901010     MOV [W0+34], W0
00B046  B3C018     MOV #0x1, W8
00B048  90016E     MOV [W14+12], W2
00B04A  9001FE     MOV [W14+14], W3
00B04C  0225A4     CALL ___lesf2
00B04E  000000     NOP
00B050  EB0080     CLR W1
00B052  500F81     SUB W0, W1, [W15]
00B054  350001     BRA LT, 0xB058
00B056  EB4400     CLR.B W8
00B058  EB4000     CLR.B W0
00B05A  544F80     SUB.B W8, W0, [W15]
00B05C  320006     BRA Z, 0xB06A
92:                        u = pid->umax;
00B05E  90084E     MOV [W14+24], W0
00B060  901110     MOV [W0+34], W2
00B062  9011A0     MOV [W0+36], W3
00B064  980762     MOV W2, [W14+12]
00B066  980773     MOV W3, [W14+14]
00B068  370014     BRA 0xB092
93:                    } else if (u < pid->umin) {
00B06A  90084E     MOV [W14+24], W0
00B06C  9010C0     MOV [W0+40], W1
00B06E  901030     MOV [W0+38], W0
00B070  B3C018     MOV #0x1, W8
00B072  90016E     MOV [W14+12], W2
00B074  9001FE     MOV [W14+14], W3
00B076  0225A8     CALL ___gtsf2
00B078  000000     NOP
00B07A  EB0080     CLR W1
00B07C  500F81     SUB W0, W1, [W15]
00B07E  3C0001     BRA GT, 0xB082
00B080  EB4400     CLR.B W8
00B082  EB4000     CLR.B W0
00B084  544F80     SUB.B W8, W0, [W15]
00B086  320005     BRA Z, 0xB092
94:                        u = pid->umin;
00B088  90084E     MOV [W14+24], W0
00B08A  901130     MOV [W0+38], W2
00B08C  9011C0     MOV [W0+40], W3
00B08E  980762     MOV W2, [W14+12]
00B090  980773     MOV W3, [W14+14]
95:                    }
96:                    
97:                    return u;
00B092  90006E     MOV [W14+12], W0
00B094  9000FE     MOV [W14+14], W1
98:                
99:                }
00B096  BE044F     MOV.D [--W15], W8
00B098  FA8000     ULNK
00B09A  060000     RETURN
100:               
101:               CtrlPidParam ctrlCreatePidParams(float ts) {
00B09C  FA0006     LNK #0x6
00B09E  980710     MOV W0, [W14+2]
00B0A0  980721     MOV W1, [W14+4]
102:               
103:                   CtrlPidParam pid = (CtrlPidParam)malloc(sizeof(CtrlPidParamStruct));
00B0A2  200320     MOV #0x32, W0
00B0A4  0233BA     CALL _malloc
00B0A6  000000     NOP
00B0A8  780F00     MOV W0, [W14]
104:                   pid->ref = 0;
00B0AA  78011E     MOV [W14], W2
00B0AC  B80060     MUL.UU W0, #0, W0
00B0AE  980110     MOV W0, [W2+2]
00B0B0  980121     MOV W1, [W2+4]
105:                   pid->running = 0;
00B0B2  78009E     MOV [W14], W1
00B0B4  EB4000     CLR.B W0
00B0B6  784880     MOV.B W0, [W1]
106:                   pid->ts = ts;
00B0B8  78001E     MOV [W14], W0
00B0BA  90011E     MOV [W14+2], W2
00B0BC  9001AE     MOV [W14+4], W3
00B0BE  980052     MOV W2, [W0+10]
00B0C0  980063     MOV W3, [W0+12]
107:                   pid->iold = 0;
00B0C2  78011E     MOV [W14], W2
00B0C4  B80060     MUL.UU W0, #0, W0
00B0C6  981150     MOV W0, [W2+42]
00B0C8  981161     MOV W1, [W2+44]
108:                   pid->derrold = 0;  
00B0CA  78011E     MOV [W14], W2
00B0CC  B80060     MUL.UU W0, #0, W0
00B0CE  981170     MOV W0, [W2+46]
00B0D0  981901     MOV W1, [W2+48]
109:                   pid->offset = 0;
00B0D2  78011E     MOV [W14], W2
00B0D4  B80060     MUL.UU W0, #0, W0
00B0D6  980130     MOV W0, [W2+6]
00B0D8  980141     MOV W1, [W2+8]
110:                   
111:                   return pid;
00B0DA  78001E     MOV [W14], W0
112:               }
00B0DC  FA8000     ULNK
00B0DE  060000     RETURN
113:               
114:               void ctrlInitPidParams(CtrlPidParam pid, float ts) {
00B0E0  FA0006     LNK #0x6
00B0E2  780F00     MOV W0, [W14]
00B0E4  980712     MOV W2, [W14+2]
00B0E6  980723     MOV W3, [W14+4]
115:               
116:                   pid->ref = 0;
00B0E8  78011E     MOV [W14], W2
00B0EA  B80060     MUL.UU W0, #0, W0
00B0EC  980110     MOV W0, [W2+2]
00B0EE  980121     MOV W1, [W2+4]
117:                   pid->running = 0;
00B0F0  78009E     MOV [W14], W1
00B0F2  EB4000     CLR.B W0
00B0F4  784880     MOV.B W0, [W1]
118:                   pid->ts = ts;
00B0F6  78001E     MOV [W14], W0
00B0F8  90011E     MOV [W14+2], W2
00B0FA  9001AE     MOV [W14+4], W3
00B0FC  980052     MOV W2, [W0+10]
00B0FE  980063     MOV W3, [W0+12]
119:                   pid->iold = 0;
00B100  78011E     MOV [W14], W2
00B102  B80060     MUL.UU W0, #0, W0
00B104  981150     MOV W0, [W2+42]
00B106  981161     MOV W1, [W2+44]
120:                   pid->derrold = 0;
00B108  78011E     MOV [W14], W2
00B10A  B80060     MUL.UU W0, #0, W0
00B10C  981170     MOV W0, [W2+46]
00B10E  981901     MOV W1, [W2+48]
121:                   pid->offset = 0;
00B110  78011E     MOV [W14], W2
00B112  B80060     MUL.UU W0, #0, W0
00B114  980130     MOV W0, [W2+6]
00B116  980141     MOV W1, [W2+8]
122:               
123:               }
00B118  FA8000     ULNK
00B11A  060000     RETURN
124:               
125:               void ctrlSetPidParams(CtrlPidParam pid, float ref, float kp, float ki, float kd) {
00B11C  FA000E     LNK #0xE
00B11E  780F00     MOV W0, [W14]
00B120  980712     MOV W2, [W14+2]
00B122  980723     MOV W3, [W14+4]
00B124  980734     MOV W4, [W14+6]
00B126  980745     MOV W5, [W14+8]
00B128  980756     MOV W6, [W14+10]
00B12A  980767     MOV W7, [W14+12]
126:               
127:                   pid->ref = ref;
00B12C  78001E     MOV [W14], W0
00B12E  90011E     MOV [W14+2], W2
00B130  9001AE     MOV [W14+4], W3
00B132  980012     MOV W2, [W0+2]
00B134  980023     MOV W3, [W0+4]
128:                   pid->kp = kp;
00B136  78001E     MOV [W14], W0
00B138  90013E     MOV [W14+6], W2
00B13A  9001CE     MOV [W14+8], W3
00B13C  980072     MOV W2, [W0+14]
00B13E  980803     MOV W3, [W0+16]
129:                   pid->kd = kd/pid->ts;
00B140  78001E     MOV [W14], W0
00B142  9000E0     MOV [W0+12], W1
00B144  900050     MOV [W0+10], W0
00B146  BE0100     MOV.D W0, W2
00B148  97B83E     MOV [W14-10], W0
00B14A  97B8CE     MOV [W14-8], W1
00B14C  022E80     CALL ___divsf3x
00B14E  000000     NOP
00B150  78011E     MOV [W14], W2
00B152  980930     MOV W0, [W2+22]
00B154  980941     MOV W1, [W2+24]
130:                   pid->ki = ki*pid->ts;
00B156  78001E     MOV [W14], W0
00B158  9000E0     MOV [W0+12], W1
00B15A  900050     MOV [W0+10], W0
00B15C  90015E     MOV [W14+10], W2
00B15E  9001EE     MOV [W14+12], W3
00B160  022C36     CALL ___mulsf3
00B162  000000     NOP
00B164  78011E     MOV [W14], W2
00B166  980910     MOV W0, [W2+18]
00B168  980921     MOV W1, [W2+20]
131:               }
00B16A  FA8000     ULNK
00B16C  060000     RETURN
132:               
133:               
134:               void ctrlSetPidOffset(CtrlPidParam pid, float offset) {
00B16E  FA0006     LNK #0x6
00B170  780F00     MOV W0, [W14]
00B172  980712     MOV W2, [W14+2]
00B174  980723     MOV W3, [W14+4]
135:                   pid->offset = offset;
00B176  78001E     MOV [W14], W0
00B178  90011E     MOV [W14+2], W2
00B17A  9001AE     MOV [W14+4], W3
00B17C  980032     MOV W2, [W0+6]
00B17E  980043     MOV W3, [W0+8]
136:               }
00B180  FA8000     ULNK
00B182  060000     RETURN
137:               
138:               float ctrlGetPidOffset(CtrlPidParam pid) {
00B184  FA0002     LNK #0x2
00B186  780F00     MOV W0, [W14]
139:                   return pid->offset;
00B188  78001E     MOV [W14], W0
00B18A  9000C0     MOV [W0+8], W1
00B18C  900030     MOV [W0+6], W0
140:               }
00B18E  FA8000     ULNK
00B190  060000     RETURN
141:               
142:               
143:               void ctrlSetRefWeigts(CtrlPidParam pid, float beta, float gamma) {
00B192  FA000A     LNK #0xA
00B194  780F00     MOV W0, [W14]
00B196  980712     MOV W2, [W14+2]
00B198  980723     MOV W3, [W14+4]
00B19A  980734     MOV W4, [W14+6]
00B19C  980745     MOV W5, [W14+8]
144:                   pid->beta = beta;
00B19E  78001E     MOV [W14], W0
00B1A0  90011E     MOV [W14+2], W2
00B1A2  9001AE     MOV [W14+4], W3
00B1A4  980852     MOV W2, [W0+26]
00B1A6  980863     MOV W3, [W0+28]
145:                   pid->gamma = gamma;
00B1A8  78001E     MOV [W14], W0
00B1AA  90013E     MOV [W14+6], W2
00B1AC  9001CE     MOV [W14+8], W3
00B1AE  980872     MOV W2, [W0+30]
00B1B0  981003     MOV W3, [W0+32]
146:               }
00B1B2  FA8000     ULNK
00B1B4  060000     RETURN
147:               
148:               void ctrlSetSaturation(CtrlPidParam pid, float max, float min) {
00B1B6  FA000A     LNK #0xA
00B1B8  780F00     MOV W0, [W14]
00B1BA  980712     MOV W2, [W14+2]
00B1BC  980723     MOV W3, [W14+4]
00B1BE  980734     MOV W4, [W14+6]
00B1C0  980745     MOV W5, [W14+8]
149:                   pid->umax = max;
00B1C2  78001E     MOV [W14], W0
00B1C4  90011E     MOV [W14+2], W2
00B1C6  9001AE     MOV [W14+4], W3
00B1C8  981012     MOV W2, [W0+34]
00B1CA  981023     MOV W3, [W0+36]
150:                   pid->umin = min;
00B1CC  78001E     MOV [W14], W0
00B1CE  90013E     MOV [W14+6], W2
00B1D0  9001CE     MOV [W14+8], W3
00B1D2  981032     MOV W2, [W0+38]
00B1D4  981043     MOV W3, [W0+40]
151:               }
00B1D6  FA8000     ULNK
00B1D8  060000     RETURN
152:               
153:               unsigned char ctrlIsRunning(CtrlPidParam pid) {
00B1DA  FA0002     LNK #0x2
00B1DC  780F00     MOV W0, [W14]
154:                   return pid->running;
00B1DE  78001E     MOV [W14], W0
00B1E0  784010     MOV.B [W0], W0
155:               }
00B1E2  FA8000     ULNK
00B1E4  060000     RETURN
156:               
157:               void ctrlStart(CtrlPidParam pid) {
00B1E6  FA0002     LNK #0x2
00B1E8  780F00     MOV W0, [W14]
158:                   pid->running = 1;
00B1EA  78009E     MOV [W14], W1
00B1EC  B3C010     MOV #0x1, W0
00B1EE  784880     MOV.B W0, [W1]
159:               }
00B1F0  FA8000     ULNK
00B1F2  060000     RETURN
160:               
161:               void ctrlStop(CtrlPidParam pid) {
00B1F4  FA0002     LNK #0x2
00B1F6  780F00     MOV W0, [W14]
162:                   pid->running = 0;
00B1F8  78009E     MOV [W14], W1
00B1FA  EB4000     CLR.B W0
00B1FC  784880     MOV.B W0, [W1]
163:               }
00B1FE  FA8000     ULNK
00B200  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/carray.c  ---------------------------------------------
1:                 /**
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Circular Array Data Structure
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v.0.1
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu         2012-02-04    Initial implementation
38:                 *
39:                 * Notes:
40:                 *  - Index convention:
41:                 *      items[head] is the first item in the queue
42:                 *      items[tail] is the last item in the queue
43:                 *  - Empty convention:
44:                 *      items[head] == items[tail] == NULL when the queue is empty
45:                 */
46:                
47:                #include "carray.h"
48:                #include <stdlib.h>
49:                #include "utils.h"
50:                
51:                // ================ Function Stubs ============================================
52:                static inline unsigned int carrayNextIndex(CircArray carray, unsigned int i);
53:                static inline unsigned int carrayPrevIndex(CircArray carray, unsigned int i);
54:                
55:                // ================ Public Functions ==========================================
56:                CircArray carrayCreate(unsigned int max_size) {
008F1C  FA0004     LNK #0x4
008F1E  980710     MOV W0, [W14+2]
57:                
58:                    CircArray carray = (CircArray) malloc(sizeof(CircArrayStruct));
008F20  2000A0     MOV #0xA, W0
008F22  0233BA     CALL _malloc
008F24  000000     NOP
008F26  780F00     MOV W0, [W14]
59:                
60:                    if(carray == NULL) { return carray; }   // Check for allocation failure
008F28  78009E     MOV [W14], W1
008F2A  EB0000     CLR W0
008F2C  508F80     SUB W1, W0, [W15]
008F2E  3A0002     BRA NZ, 0x8F34
008F30  78001E     MOV [W14], W0
008F32  37001D     BRA 0x8F6E
61:                
62:                    carray->items = (CircArrayItem*) calloc(max_size, sizeof(CircArrayItem)); // Init to zeros
008F34  200021     MOV #0x2, W1
008F36  90001E     MOV [W14+2], W0
008F38  023556     CALL _calloc
008F3A  000000     NOP
008F3C  780080     MOV W0, W1
008F3E  78001E     MOV [W14], W0
008F40  780801     MOV W1, [W0]
63:                
64:                    if(carray->items == NULL) {
008F42  78001E     MOV [W14], W0
008F44  780090     MOV [W0], W1
008F46  EB0000     CLR W0
008F48  508F80     SUB W1, W0, [W15]
008F4A  3A0004     BRA NZ, 0x8F54
65:                        carrayDelete(carray);
008F4C  78001E     MOV [W14], W0
008F4E  070011     RCALL carrayDelete
66:                        return NULL;
008F50  EB0000     CLR W0
008F52  37000D     BRA 0x8F6E
67:                    }
68:                
69:                    carray->max_size = max_size;
008F54  78001E     MOV [W14], W0
008F56  90009E     MOV [W14+2], W1
008F58  980041     MOV W1, [W0+8]
70:                    carray->size = 0;
008F5A  78001E     MOV [W14], W0
008F5C  EB0080     CLR W1
008F5E  980031     MOV W1, [W0+6]
71:                    carray->head = 0;
008F60  78001E     MOV [W14], W0
008F62  EB0080     CLR W1
008F64  980011     MOV W1, [W0+2]
72:                    carray->tail = 0;
008F66  78001E     MOV [W14], W0
008F68  EB0080     CLR W1
008F6A  980021     MOV W1, [W0+4]
73:                    return carray;
008F6C  78001E     MOV [W14], W0
74:                
75:                }
008F6E  FA8000     ULNK
008F70  060000     RETURN
76:                
77:                void carrayDelete(CircArray carray) {
008F72  FA0002     LNK #0x2
008F74  780F00     MOV W0, [W14]
78:                
79:                    if(carray != NULL) {
008F76  78009E     MOV [W14], W1
008F78  EB0000     CLR W0
008F7A  508F80     SUB W1, W0, [W15]
008F7C  32000C     BRA Z, 0x8F96
80:                
81:                        if(carray->items != NULL) {
008F7E  78001E     MOV [W14], W0
008F80  780090     MOV [W0], W1
008F82  EB0000     CLR W0
008F84  508F80     SUB W1, W0, [W15]
008F86  320004     BRA Z, 0x8F90
82:                            free(carray->items);
008F88  78001E     MOV [W14], W0
008F8A  780010     MOV [W0], W0
008F8C  0234EC     CALL _free
008F8E  000000     NOP
83:                        }
84:                        free(carray);
008F90  78001E     MOV [W14], W0
008F92  0234EC     CALL _free
008F94  000000     NOP
85:                
86:                    }
87:                
88:                }
008F96  FA8000     ULNK
008F98  060000     RETURN
89:                
90:                unsigned int carrayAddTail(CircArray carray, CircArrayItem item) {
008F9A  FA000C     LNK #0xC
008F9C  980740     MOV W0, [W14+8]
008F9E  980751     MOV W1, [W14+10]
91:                
92:                    // Can't add NULL items since NULL return is reserved
93:                    if(item == NULL) {
008FA0  9000DE     MOV [W14+10], W1
008FA2  EB0000     CLR W0
008FA4  508F80     SUB W1, W0, [W15]
008FA6  3A0002     BRA NZ, 0x8FAC
94:                        return 0;
008FA8  EB0000     CLR W0
008FAA  37004F     BRA 0x904A
95:                    }
96:                
97:                    CRITICAL_SECTION_START
008FAC  800210     MOV SR, W0
008FAE  DE0045     LSR W0, #5, W0
008FB0  604067     AND.B W0, #0x7, W0
008FB2  784F00     MOV.B W0, [W14]
008FB4  800290     MOV DISICNT, W0
008FB6  980710     MOV W0, [W14+2]
008FB8  FC3FFF     DISI #0x3FFF
008FBA  800211     MOV SR, W1
008FBC  200E00     MOV #0xE0, W0
008FBE  708000     IOR W1, W0, W0
008FC0  880210     MOV W0, SR
008FC2  90001E     MOV [W14+2], W0
008FC4  880290     MOV W0, DISICNT
008FC6  880000     MOV W0, WREG0
98:                    // Can't add if the queue is full
99:                    if(carrayIsFull(carray)) {
008FC8  90004E     MOV [W14+8], W0
008FCA  0701E2     RCALL carrayIsFull
008FCC  EB0080     CLR W1
008FCE  500F81     SUB W0, W1, [W15]
008FD0  320012     BRA Z, 0x8FF6
100:                       CRITICAL_SECTION_END
008FD2  800290     MOV DISICNT, W0
008FD4  980720     MOV W0, [W14+4]
008FD6  FC3FFF     DISI #0x3FFF
008FD8  78401E     MOV.B [W14], W0
008FDA  604067     AND.B W0, #0x7, W0
008FDC  FB8000     ZE W0, W0
008FDE  600067     AND W0, #0x7, W0
008FE0  DD0045     SL W0, #5, W0
008FE2  800212     MOV SR, W2
008FE4  2FF1F1     MOV #0xFF1F, W1
008FE6  610081     AND W2, W1, W1
008FE8  708000     IOR W1, W0, W0
008FEA  880210     MOV W0, SR
008FEC  90002E     MOV [W14+4], W0
008FEE  880290     MOV W0, DISICNT
008FF0  880000     MOV W0, WREG0
101:                       return 0;
008FF2  EB0000     CLR W0
008FF4  37002A     BRA 0x904A
102:                   }
103:               
104:                   if(!carrayIsEmpty(carray)) {
008FF6  90004E     MOV [W14+8], W0
008FF8  0701C0     RCALL carrayIsEmpty
008FFA  EB0080     CLR W1
008FFC  500F81     SUB W0, W1, [W15]
008FFE  3A0007     BRA NZ, 0x900E
105:                       carray->tail = carrayNextIndex(carray, carray->tail);  // Find the new tail
009000  90004E     MOV [W14+8], W0
009002  900020     MOV [W0+4], W0
009004  780080     MOV W0, W1
009006  90004E     MOV [W14+8], W0
009008  0701D5     RCALL carrayNextIndex
00900A  9000CE     MOV [W14+8], W1
00900C  9800A0     MOV W0, [W1+4]
106:                   }
107:                   carray->items[carray->tail] = item;   // Assign the item
00900E  90004E     MOV [W14+8], W0
009010  780090     MOV [W0], W1
009012  90004E     MOV [W14+8], W0
009014  900020     MOV [W0+4], W0
009016  400000     ADD W0, W0, W0
009018  408000     ADD W1, W0, W0
00901A  9000DE     MOV [W14+10], W1
00901C  780801     MOV W1, [W0]
108:                   carray->size++;         // Update the size
00901E  90004E     MOV [W14+8], W0
009020  900030     MOV [W0+6], W0
009022  E80080     INC W0, W1
009024  90004E     MOV [W14+8], W0
009026  980031     MOV W1, [W0+6]
109:                   CRITICAL_SECTION_END
009028  800290     MOV DISICNT, W0
00902A  980730     MOV W0, [W14+6]
00902C  FC3FFF     DISI #0x3FFF
00902E  78401E     MOV.B [W14], W0
009030  604067     AND.B W0, #0x7, W0
009032  FB8000     ZE W0, W0
009034  600067     AND W0, #0x7, W0
009036  DD0045     SL W0, #5, W0
009038  800212     MOV SR, W2
00903A  2FF1F1     MOV #0xFF1F, W1
00903C  610081     AND W2, W1, W1
00903E  708000     IOR W1, W0, W0
009040  880210     MOV W0, SR
009042  90003E     MOV [W14+6], W0
009044  880290     MOV W0, DISICNT
009046  880000     MOV W0, WREG0
110:                   return 1;
009048  200010     MOV #0x1, W0
111:               
112:               }
00904A  FA8000     ULNK
00904C  060000     RETURN
113:               
114:               unsigned int carrayAddHead(CircArray carray, CircArrayItem item) {
00904E  FA000C     LNK #0xC
009050  980740     MOV W0, [W14+8]
009052  980751     MOV W1, [W14+10]
115:               
116:                   // Can't add NULL items since NULL return is reserved
117:                   if(item == NULL) {
009054  9000DE     MOV [W14+10], W1
009056  EB0000     CLR W0
009058  508F80     SUB W1, W0, [W15]
00905A  3A0002     BRA NZ, 0x9060
118:                       return 0;
00905C  EB0000     CLR W0
00905E  37004F     BRA 0x90FE
119:                   }
120:               
121:                   CRITICAL_SECTION_START
009060  800210     MOV SR, W0
009062  DE0045     LSR W0, #5, W0
009064  604067     AND.B W0, #0x7, W0
009066  784F00     MOV.B W0, [W14]
009068  800290     MOV DISICNT, W0
00906A  980710     MOV W0, [W14+2]
00906C  FC3FFF     DISI #0x3FFF
00906E  800211     MOV SR, W1
009070  200E00     MOV #0xE0, W0
009072  708000     IOR W1, W0, W0
009074  880210     MOV W0, SR
009076  90001E     MOV [W14+2], W0
009078  880290     MOV W0, DISICNT
00907A  880000     MOV W0, WREG0
122:                   // Can't add if the queue is full
123:                   if(carrayIsFull(carray)) {
00907C  90004E     MOV [W14+8], W0
00907E  070188     RCALL carrayIsFull
009080  EB0080     CLR W1
009082  500F81     SUB W0, W1, [W15]
009084  320012     BRA Z, 0x90AA
124:                       CRITICAL_SECTION_END
009086  800290     MOV DISICNT, W0
009088  980720     MOV W0, [W14+4]
00908A  FC3FFF     DISI #0x3FFF
00908C  78401E     MOV.B [W14], W0
00908E  604067     AND.B W0, #0x7, W0
009090  FB8000     ZE W0, W0
009092  600067     AND W0, #0x7, W0
009094  DD0045     SL W0, #5, W0
009096  800212     MOV SR, W2
009098  2FF1F1     MOV #0xFF1F, W1
00909A  610081     AND W2, W1, W1
00909C  708000     IOR W1, W0, W0
00909E  880210     MOV W0, SR
0090A0  90002E     MOV [W14+4], W0
0090A2  880290     MOV W0, DISICNT
0090A4  880000     MOV W0, WREG0
125:                       return 0;
0090A6  EB0000     CLR W0
0090A8  37002A     BRA 0x90FE
126:                   }
127:               
128:                   if(!carrayIsEmpty(carray)) {
0090AA  90004E     MOV [W14+8], W0
0090AC  070166     RCALL carrayIsEmpty
0090AE  EB0080     CLR W1
0090B0  500F81     SUB W0, W1, [W15]
0090B2  3A0007     BRA NZ, 0x90C2
129:                       carray->head = carrayPrevIndex(carray, carray->head);  // Find the new head
0090B4  90004E     MOV [W14+8], W0
0090B6  900010     MOV [W0+2], W0
0090B8  780080     MOV W0, W1
0090BA  90004E     MOV [W14+8], W0
0090BC  07018A     RCALL carrayPrevIndex
0090BE  9000CE     MOV [W14+8], W1
0090C0  980090     MOV W0, [W1+2]
130:                   }
131:                   carray->items[carray->head] = item;   // Assign the item
0090C2  90004E     MOV [W14+8], W0
0090C4  780090     MOV [W0], W1
0090C6  90004E     MOV [W14+8], W0
0090C8  900010     MOV [W0+2], W0
0090CA  400000     ADD W0, W0, W0
0090CC  408000     ADD W1, W0, W0
0090CE  9000DE     MOV [W14+10], W1
0090D0  780801     MOV W1, [W0]
132:                   carray->size++;         // Update the size
0090D2  90004E     MOV [W14+8], W0
0090D4  900030     MOV [W0+6], W0
0090D6  E80080     INC W0, W1
0090D8  90004E     MOV [W14+8], W0
0090DA  980031     MOV W1, [W0+6]
133:                   CRITICAL_SECTION_END
0090DC  800290     MOV DISICNT, W0
0090DE  980730     MOV W0, [W14+6]
0090E0  FC3FFF     DISI #0x3FFF
0090E2  78401E     MOV.B [W14], W0
0090E4  604067     AND.B W0, #0x7, W0
0090E6  FB8000     ZE W0, W0
0090E8  600067     AND W0, #0x7, W0
0090EA  DD0045     SL W0, #5, W0
0090EC  800212     MOV SR, W2
0090EE  2FF1F1     MOV #0xFF1F, W1
0090F0  610081     AND W2, W1, W1
0090F2  708000     IOR W1, W0, W0
0090F4  880210     MOV W0, SR
0090F6  90003E     MOV [W14+6], W0
0090F8  880290     MOV W0, DISICNT
0090FA  880000     MOV W0, WREG0
134:                   return -1;
0090FC  EB8000     SETM W0
135:               
136:               }
0090FE  FA8000     ULNK
009100  060000     RETURN
137:               
138:               CircArrayItem carrayPopTail(CircArray carray) {
009102  FA000C     LNK #0xC
009104  980750     MOV W0, [W14+10]
139:               
140:                   CircArrayItem item;
141:               
142:                   CRITICAL_SECTION_START
009106  800210     MOV SR, W0
009108  DE0045     LSR W0, #5, W0
00910A  604067     AND.B W0, #0x7, W0
00910C  784F00     MOV.B W0, [W14]
00910E  800290     MOV DISICNT, W0
009110  980710     MOV W0, [W14+2]
009112  FC3FFF     DISI #0x3FFF
009114  800211     MOV SR, W1
009116  200E00     MOV #0xE0, W0
009118  708000     IOR W1, W0, W0
00911A  880210     MOV W0, SR
00911C  90001E     MOV [W14+2], W0
00911E  880290     MOV W0, DISICNT
009120  880000     MOV W0, WREG0
143:                   if(carrayIsEmpty(carray)) {
009122  90005E     MOV [W14+10], W0
009124  07012A     RCALL carrayIsEmpty
009126  EB0080     CLR W1
009128  500F81     SUB W0, W1, [W15]
00912A  320012     BRA Z, 0x9150
144:                       CRITICAL_SECTION_END
00912C  800290     MOV DISICNT, W0
00912E  980720     MOV W0, [W14+4]
009130  FC3FFF     DISI #0x3FFF
009132  78401E     MOV.B [W14], W0
009134  604067     AND.B W0, #0x7, W0
009136  FB8000     ZE W0, W0
009138  600067     AND W0, #0x7, W0
00913A  DD0045     SL W0, #5, W0
00913C  800212     MOV SR, W2
00913E  2FF1F1     MOV #0xFF1F, W1
009140  610081     AND W2, W1, W1
009142  708000     IOR W1, W0, W0
009144  880210     MOV W0, SR
009146  90002E     MOV [W14+4], W0
009148  880290     MOV W0, DISICNT
00914A  880000     MOV W0, WREG0
145:                       return NULL;
00914C  EB0000     CLR W0
00914E  370033     BRA 0x91B6
146:                   }
147:               
148:                   item = carray->items[carray->tail]; // Retrieve item
009150  90005E     MOV [W14+10], W0
009152  780090     MOV [W0], W1
009154  90005E     MOV [W14+10], W0
009156  900020     MOV [W0+4], W0
009158  400000     ADD W0, W0, W0
00915A  408000     ADD W1, W0, W0
00915C  780090     MOV [W0], W1
00915E  980731     MOV W1, [W14+6]
149:                   carray->items[carray->tail] = NULL; // Clear entry
009160  90005E     MOV [W14+10], W0
009162  780090     MOV [W0], W1
009164  90005E     MOV [W14+10], W0
009166  900020     MOV [W0+4], W0
009168  400000     ADD W0, W0, W0
00916A  408000     ADD W1, W0, W0
00916C  EB0080     CLR W1
00916E  780801     MOV W1, [W0]
150:               
151:                   if(carray->tail != carray->head) {  // Size > 1
009170  90005E     MOV [W14+10], W0
009172  9000A0     MOV [W0+4], W1
009174  90005E     MOV [W14+10], W0
009176  900010     MOV [W0+2], W0
009178  508F80     SUB W1, W0, [W15]
00917A  320007     BRA Z, 0x918A
152:                       carray->tail = carrayPrevIndex(carray, carray->tail); // Update tail
00917C  90005E     MOV [W14+10], W0
00917E  900020     MOV [W0+4], W0
009180  780080     MOV W0, W1
009182  90005E     MOV [W14+10], W0
009184  070126     RCALL carrayPrevIndex
009186  9000DE     MOV [W14+10], W1
009188  9800A0     MOV W0, [W1+4]
153:                   }
154:                   carray->size--;
00918A  90005E     MOV [W14+10], W0
00918C  900030     MOV [W0+6], W0
00918E  E90080     DEC W0, W1
009190  90005E     MOV [W14+10], W0
009192  980031     MOV W1, [W0+6]
155:                   CRITICAL_SECTION_END
009194  800290     MOV DISICNT, W0
009196  980740     MOV W0, [W14+8]
009198  FC3FFF     DISI #0x3FFF
00919A  78401E     MOV.B [W14], W0
00919C  604067     AND.B W0, #0x7, W0
00919E  FB8000     ZE W0, W0
0091A0  600067     AND W0, #0x7, W0
0091A2  DD0045     SL W0, #5, W0
0091A4  800212     MOV SR, W2
0091A6  2FF1F1     MOV #0xFF1F, W1
0091A8  610081     AND W2, W1, W1
0091AA  708000     IOR W1, W0, W0
0091AC  880210     MOV W0, SR
0091AE  90004E     MOV [W14+8], W0
0091B0  880290     MOV W0, DISICNT
0091B2  880000     MOV W0, WREG0
156:                   return item;
0091B4  90003E     MOV [W14+6], W0
157:               
158:               }
0091B6  FA8000     ULNK
0091B8  060000     RETURN
159:               
160:               CircArrayItem carrayPopHead(CircArray carray) {
0091BA  FA000C     LNK #0xC
0091BC  980750     MOV W0, [W14+10]
161:               
162:                   CircArrayItem item;
163:               
164:                   CRITICAL_SECTION_START
0091BE  800210     MOV SR, W0
0091C0  DE0045     LSR W0, #5, W0
0091C2  604067     AND.B W0, #0x7, W0
0091C4  784F00     MOV.B W0, [W14]
0091C6  800290     MOV DISICNT, W0
0091C8  980710     MOV W0, [W14+2]
0091CA  FC3FFF     DISI #0x3FFF
0091CC  800211     MOV SR, W1
0091CE  200E00     MOV #0xE0, W0
0091D0  708000     IOR W1, W0, W0
0091D2  880210     MOV W0, SR
0091D4  90001E     MOV [W14+2], W0
0091D6  880290     MOV W0, DISICNT
0091D8  880000     MOV W0, WREG0
165:                   if(carrayIsEmpty(carray)) {
0091DA  90005E     MOV [W14+10], W0
0091DC  0700CE     RCALL carrayIsEmpty
0091DE  EB0080     CLR W1
0091E0  500F81     SUB W0, W1, [W15]
0091E2  320012     BRA Z, 0x9208
166:                       CRITICAL_SECTION_END
0091E4  800290     MOV DISICNT, W0
0091E6  980720     MOV W0, [W14+4]
0091E8  FC3FFF     DISI #0x3FFF
0091EA  78401E     MOV.B [W14], W0
0091EC  604067     AND.B W0, #0x7, W0
0091EE  FB8000     ZE W0, W0
0091F0  600067     AND W0, #0x7, W0
0091F2  DD0045     SL W0, #5, W0
0091F4  800212     MOV SR, W2
0091F6  2FF1F1     MOV #0xFF1F, W1
0091F8  610081     AND W2, W1, W1
0091FA  708000     IOR W1, W0, W0
0091FC  880210     MOV W0, SR
0091FE  90002E     MOV [W14+4], W0
009200  880290     MOV W0, DISICNT
009202  880000     MOV W0, WREG0
167:                       return NULL;
009204  EB0000     CLR W0
009206  370033     BRA 0x926E
168:                   }
169:               
170:                   item = carray->items[carray->head]; // Retrieve item
009208  90005E     MOV [W14+10], W0
00920A  780090     MOV [W0], W1
00920C  90005E     MOV [W14+10], W0
00920E  900010     MOV [W0+2], W0
009210  400000     ADD W0, W0, W0
009212  408000     ADD W1, W0, W0
009214  780090     MOV [W0], W1
009216  980731     MOV W1, [W14+6]
171:                   carray->items[carray->head] = NULL; // Clear entry
009218  90005E     MOV [W14+10], W0
00921A  780090     MOV [W0], W1
00921C  90005E     MOV [W14+10], W0
00921E  900010     MOV [W0+2], W0
009220  400000     ADD W0, W0, W0
009222  408000     ADD W1, W0, W0
009224  EB0080     CLR W1
009226  780801     MOV W1, [W0]
172:               
173:                   if(carray->head != carray->tail) {  // Size > 1
009228  90005E     MOV [W14+10], W0
00922A  900090     MOV [W0+2], W1
00922C  90005E     MOV [W14+10], W0
00922E  900020     MOV [W0+4], W0
009230  508F80     SUB W1, W0, [W15]
009232  320007     BRA Z, 0x9242
174:                       carray->head = carrayNextIndex(carray, carray->head); // Update head
009234  90005E     MOV [W14+10], W0
009236  900010     MOV [W0+2], W0
009238  780080     MOV W0, W1
00923A  90005E     MOV [W14+10], W0
00923C  0700BB     RCALL carrayNextIndex
00923E  9000DE     MOV [W14+10], W1
009240  980090     MOV W0, [W1+2]
175:                   }
176:                   carray->size--;
009242  90005E     MOV [W14+10], W0
009244  900030     MOV [W0+6], W0
009246  E90080     DEC W0, W1
009248  90005E     MOV [W14+10], W0
00924A  980031     MOV W1, [W0+6]
177:                   CRITICAL_SECTION_END
00924C  800290     MOV DISICNT, W0
00924E  980740     MOV W0, [W14+8]
009250  FC3FFF     DISI #0x3FFF
009252  78401E     MOV.B [W14], W0
009254  604067     AND.B W0, #0x7, W0
009256  FB8000     ZE W0, W0
009258  600067     AND W0, #0x7, W0
00925A  DD0045     SL W0, #5, W0
00925C  800212     MOV SR, W2
00925E  2FF1F1     MOV #0xFF1F, W1
009260  610081     AND W2, W1, W1
009262  708000     IOR W1, W0, W0
009264  880210     MOV W0, SR
009266  90004E     MOV [W14+8], W0
009268  880290     MOV W0, DISICNT
00926A  880000     MOV W0, WREG0
178:                   return item;
00926C  90003E     MOV [W14+6], W0
179:               
180:               }
00926E  FA8000     ULNK
009270  060000     RETURN
181:               
182:               CircArrayItem carrayPeekTail(CircArray carray) {
009272  FA000C     LNK #0xC
009274  980750     MOV W0, [W14+10]
183:               
184:                   CircArrayItem item;
185:               
186:                   CRITICAL_SECTION_START
009276  800210     MOV SR, W0
009278  DE0045     LSR W0, #5, W0
00927A  604067     AND.B W0, #0x7, W0
00927C  784F00     MOV.B W0, [W14]
00927E  800290     MOV DISICNT, W0
009280  980710     MOV W0, [W14+2]
009282  FC3FFF     DISI #0x3FFF
009284  800211     MOV SR, W1
009286  200E00     MOV #0xE0, W0
009288  708000     IOR W1, W0, W0
00928A  880210     MOV W0, SR
00928C  90001E     MOV [W14+2], W0
00928E  880290     MOV W0, DISICNT
009290  880000     MOV W0, WREG0
187:               
188:                   if(carrayIsEmpty(carray)) {
009292  90005E     MOV [W14+10], W0
009294  070072     RCALL carrayIsEmpty
009296  EB0080     CLR W1
009298  500F81     SUB W0, W1, [W15]
00929A  320012     BRA Z, 0x92C0
189:                       CRITICAL_SECTION_END
00929C  800290     MOV DISICNT, W0
00929E  980720     MOV W0, [W14+4]
0092A0  FC3FFF     DISI #0x3FFF
0092A2  78401E     MOV.B [W14], W0
0092A4  604067     AND.B W0, #0x7, W0
0092A6  FB8000     ZE W0, W0
0092A8  600067     AND W0, #0x7, W0
0092AA  DD0045     SL W0, #5, W0
0092AC  800212     MOV SR, W2
0092AE  2FF1F1     MOV #0xFF1F, W1
0092B0  610081     AND W2, W1, W1
0092B2  708000     IOR W1, W0, W0
0092B4  880210     MOV W0, SR
0092B6  90002E     MOV [W14+4], W0
0092B8  880290     MOV W0, DISICNT
0092BA  880000     MOV W0, WREG0
190:                       return NULL;
0092BC  EB0000     CLR W0
0092BE  370019     BRA 0x92F2
191:                   }
192:               
193:                   item = carray->items[carray->tail];
0092C0  90005E     MOV [W14+10], W0
0092C2  780090     MOV [W0], W1
0092C4  90005E     MOV [W14+10], W0
0092C6  900020     MOV [W0+4], W0
0092C8  400000     ADD W0, W0, W0
0092CA  408000     ADD W1, W0, W0
0092CC  780090     MOV [W0], W1
0092CE  980731     MOV W1, [W14+6]
194:               
195:                   CRITICAL_SECTION_END
0092D0  800290     MOV DISICNT, W0
0092D2  980740     MOV W0, [W14+8]
0092D4  FC3FFF     DISI #0x3FFF
0092D6  78401E     MOV.B [W14], W0
0092D8  604067     AND.B W0, #0x7, W0
0092DA  FB8000     ZE W0, W0
0092DC  600067     AND W0, #0x7, W0
0092DE  DD0045     SL W0, #5, W0
0092E0  800212     MOV SR, W2
0092E2  2FF1F1     MOV #0xFF1F, W1
0092E4  610081     AND W2, W1, W1
0092E6  708000     IOR W1, W0, W0
0092E8  880210     MOV W0, SR
0092EA  90004E     MOV [W14+8], W0
0092EC  880290     MOV W0, DISICNT
0092EE  880000     MOV W0, WREG0
196:               
197:                   return item;
0092F0  90003E     MOV [W14+6], W0
198:               
199:               }
0092F2  FA8000     ULNK
0092F4  060000     RETURN
200:               
201:               CircArrayItem carrayPeekHead(CircArray carray) {
0092F6  FA000C     LNK #0xC
0092F8  980750     MOV W0, [W14+10]
202:               
203:                   CircArrayItem item;
204:               
205:                   CRITICAL_SECTION_START
0092FA  800210     MOV SR, W0
0092FC  DE0045     LSR W0, #5, W0
0092FE  604067     AND.B W0, #0x7, W0
009300  784F00     MOV.B W0, [W14]
009302  800290     MOV DISICNT, W0
009304  980710     MOV W0, [W14+2]
009306  FC3FFF     DISI #0x3FFF
009308  800211     MOV SR, W1
00930A  200E00     MOV #0xE0, W0
00930C  708000     IOR W1, W0, W0
00930E  880210     MOV W0, SR
009310  90001E     MOV [W14+2], W0
009312  880290     MOV W0, DISICNT
009314  880000     MOV W0, WREG0
206:               
207:                   if(carrayIsEmpty(carray)) {
009316  90005E     MOV [W14+10], W0
009318  070030     RCALL carrayIsEmpty
00931A  EB0080     CLR W1
00931C  500F81     SUB W0, W1, [W15]
00931E  320012     BRA Z, 0x9344
208:                       CRITICAL_SECTION_END
009320  800290     MOV DISICNT, W0
009322  980720     MOV W0, [W14+4]
009324  FC3FFF     DISI #0x3FFF
009326  78401E     MOV.B [W14], W0
009328  604067     AND.B W0, #0x7, W0
00932A  FB8000     ZE W0, W0
00932C  600067     AND W0, #0x7, W0
00932E  DD0045     SL W0, #5, W0
009330  800212     MOV SR, W2
009332  2FF1F1     MOV #0xFF1F, W1
009334  610081     AND W2, W1, W1
009336  708000     IOR W1, W0, W0
009338  880210     MOV W0, SR
00933A  90002E     MOV [W14+4], W0
00933C  880290     MOV W0, DISICNT
00933E  880000     MOV W0, WREG0
209:                       return NULL;
009340  EB0000     CLR W0
009342  370019     BRA 0x9376
210:                   }
211:               
212:                   item = carray->items[carray->head];
009344  90005E     MOV [W14+10], W0
009346  780090     MOV [W0], W1
009348  90005E     MOV [W14+10], W0
00934A  900010     MOV [W0+2], W0
00934C  400000     ADD W0, W0, W0
00934E  408000     ADD W1, W0, W0
009350  780090     MOV [W0], W1
009352  980731     MOV W1, [W14+6]
213:               
214:                   CRITICAL_SECTION_END
009354  800290     MOV DISICNT, W0
009356  980740     MOV W0, [W14+8]
009358  FC3FFF     DISI #0x3FFF
00935A  78401E     MOV.B [W14], W0
00935C  604067     AND.B W0, #0x7, W0
00935E  FB8000     ZE W0, W0
009360  600067     AND W0, #0x7, W0
009362  DD0045     SL W0, #5, W0
009364  800212     MOV SR, W2
009366  2FF1F1     MOV #0xFF1F, W1
009368  610081     AND W2, W1, W1
00936A  708000     IOR W1, W0, W0
00936C  880210     MOV W0, SR
00936E  90004E     MOV [W14+8], W0
009370  880290     MOV W0, DISICNT
009372  880000     MOV W0, WREG0
215:               
216:                   return item;
009374  90003E     MOV [W14+6], W0
217:               
218:               }
009376  FA8000     ULNK
009378  060000     RETURN
219:               
220:               unsigned int carrayIsEmpty(CircArray carray) {
00937A  FA0002     LNK #0x2
00937C  780F00     MOV W0, [W14]
221:               
222:                   return carray->size == 0;
00937E  78001E     MOV [W14], W0
009380  900130     MOV [W0+6], W2
009382  200010     MOV #0x1, W0
009384  EB0080     CLR W1
009386  510F81     SUB W2, W1, [W15]
009388  320001     BRA Z, 0x938C
00938A  EB0000     CLR W0
223:               
224:               }
00938C  FA8000     ULNK
00938E  060000     RETURN
225:               
226:               unsigned int carrayIsFull(CircArray carray) {
009390  FA0002     LNK #0x2
009392  780F00     MOV W0, [W14]
227:               
228:                   return carray->size == carray->max_size;
009394  78001E     MOV [W14], W0
009396  900130     MOV [W0+6], W2
009398  78001E     MOV [W14], W0
00939A  9000C0     MOV [W0+8], W1
00939C  200010     MOV #0x1, W0
00939E  510F81     SUB W2, W1, [W15]
0093A0  320001     BRA Z, 0x93A4
0093A2  EB0000     CLR W0
229:               
230:               }
0093A4  FA8000     ULNK
0093A6  060000     RETURN
231:               
232:               unsigned int carrayGetSize(CircArray carray) {
0093A8  FA0002     LNK #0x2
0093AA  780F00     MOV W0, [W14]
233:               
234:                   return carray->size;
0093AC  78001E     MOV [W14], W0
0093AE  900030     MOV [W0+6], W0
235:               
236:               }
0093B0  FA8000     ULNK
0093B2  060000     RETURN
237:               
238:               // ================== PRIVATE FUNCTIONS ==========================
239:               /**
240:                * Returns the next valid index with wraparound in a queue from a position
241:                *
242:                * @param carray FastQueue to search in
243:                * @param i Position to start from
244:                * @return next valid index
245:                */
246:               static inline unsigned int carrayNextIndex(CircArray carray, unsigned int i) {
0093B4  FA0004     LNK #0x4
0093B6  780F00     MOV W0, [W14]
0093B8  980711     MOV W1, [W14+2]
247:               
248:                   if(i == (carray->max_size - 1)) {
0093BA  78001E     MOV [W14], W0
0093BC  900040     MOV [W0+8], W0
0093BE  E90080     DEC W0, W1
0093C0  90001E     MOV [W14+2], W0
0093C2  508F80     SUB W1, W0, [W15]
0093C4  3A0002     BRA NZ, 0x93CA
249:                       return 0;
0093C6  EB0000     CLR W0
0093C8  370002     BRA 0x93CE
250:                   }
251:                   return i + 1;
0093CA  90001E     MOV [W14+2], W0
0093CC  E80000     INC W0, W0
252:               
253:               }
0093CE  FA8000     ULNK
0093D0  060000     RETURN
254:               
255:               /**
256:                * Returns the previous valid index with wraparound in a queue from a position
257:                *
258:                * @param carray FastQueue to search in
259:                * @param i Position to start from
260:                * @return previous valid index
261:                */
262:               static inline unsigned int carrayPrevIndex(CircArray carray, unsigned int i) {
0093D2  FA0004     LNK #0x4
0093D4  780F00     MOV W0, [W14]
0093D6  980711     MOV W1, [W14+2]
263:               
264:                   if(i == 0) {
0093D8  90009E     MOV [W14+2], W1
0093DA  EB0000     CLR W0
0093DC  508F80     SUB W1, W0, [W15]
0093DE  3A0004     BRA NZ, 0x93E8
265:                       return carray->max_size - 1;
0093E0  78001E     MOV [W14], W0
0093E2  900040     MOV [W0+8], W0
0093E4  E90000     DEC W0, W0
0093E6  370002     BRA 0x93EC
266:                   }
267:                   return i - 1;
0093E8  90001E     MOV [W14+2], W0
0093EA  E90000     DEC W0, W0
268:               
269:               }
0093EC  FA8000     ULNK
0093EE  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/cam.c  ------------------------------------------------
1:                 /*
2:                  * Copyright (c) 2011-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Image capture device interface
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v2.0
35:                 *
36:                 * Revisions:
37:                 *   Humphrey Hu    2011-10-26  Initial implementation
38:                 *                  2012-01-31  Release
39:                 *                  2012-02-16  Slight restructuring
40:                 *                  2012-02-21  Changed to use pooled frames
41:                 *                  2012-06-02  Changed to static frames
42:                 */
43:                
44:                #include "timer.h"
45:                #include "counter.h"
46:                #include "ovcam.h"
47:                #include "utils.h"
48:                #include "carray.h"
49:                #include <stdlib.h>
50:                #include <string.h>
51:                #include "cam.h"
52:                #include "sys_clock.h"
53:                #include "ov7660.h"
54:                
55:                // Default camera capture timings for QQVGA no subsampling, 25 fps
56:                #define ROW_ROW_TIME                    (32)
57:                #define VSYNC_ROW_TIME                  (12800)
58:                #define ROW_VSYNC_TIME                  (2800)
59:                #define VSYNC_VSYNC_TIME                (25000)
60:                
61:                // Amount of time before an event to trigger timer
62:                #define ROW_ROW_OFFSET                  (6) // 384 cycles
63:                #define VSYNC_ROW_OFFSET                (6) // 384 cycles
64:                #define ROW_VSYNC_OFFSET                (10) // 640 cycles
65:                #define VSYNC_VSYNC_OFFSET              (8) // 512 cycles
66:                
67:                // The timer states describe what the timer is waiting for
68:                // i.e. VSYNC state means timer is waiting for VSYNC event
69:                // The NOT_SYNC state means that the timer has not been synchronized
70:                // yet and is not ready for operation.
71:                typedef enum {
72:                    CT_NOT_SYNC,
73:                    CT_WAIT_VSYNC,
74:                    CT_WAIT_ROW,
75:                    CT_SKIP_FRAME,
76:                }CTimerState;
77:                
78:                // ==== Function Stubs ========================================================
79:                static void setupTimer7(void);
80:                void _T7Interrupt(void);
81:                
82:                void camCaptureRow(void);
83:                static void processRow(void);
84:                
85:                static CamFrame getEmptyFrame(void);
86:                static void enqueueEmptyFrame(CamFrame frame);
87:                static CamFrame getOldestFullFrame(void);
88:                static void enqueueFullFrame(CamFrame frame);
89:                
90:                // ==== Static Variables ======================================================
91:                // Driver validity
92:                static unsigned char is_ready;
93:                
94:                // Asynchronous capture state
95:                static CTimerState ct_state = CT_NOT_SYNC;
96:                static unsigned long frame_start, frame_period;
97:                
98:                // Asynchronous capture timing parameters
99:                static unsigned int row_row_time = ROW_ROW_TIME;
100:               static unsigned int vsync_row_time = VSYNC_ROW_TIME;
101:               static unsigned int row_vsync_time = ROW_VSYNC_TIME;
102:               static unsigned int vsync_vsync_time = VSYNC_VSYNC_TIME;
103:               
104:               // Protected counters
105:               static Counter frame_counter;
106:               static Counter row_counter;
107:               
108:               // Row capture buffer
109:               static unsigned char row_buff[NATIVE_IMAGE_COLS];
110:               
111:               // Frame buffering variables
112:               static CamFrame current_frame;
113:               static unsigned int next_row_index;
114:               static unsigned char has_new_frame, frame_started;
115:               static CircArray empty_frame_pool, full_frame_pool;
116:               
117:               // Driver config'd function pointers
118:               static CamIrqHandler irq_handler;
119:               static CamRowGetter row_getter;
120:               static CamFrameWaiter frame_waiter;
121:               
122:               // ==== Public functions ======================================================
123:               
124:               void camSetup(CamFrame frames, unsigned int num_frames) {
0098C8  FA0006     LNK #0x6
0098CA  980710     MOV W0, [W14+2]
0098CC  980721     MOV W1, [W14+4]
125:               
126:                   unsigned int i;
127:               
128:                   setupTimer7();  // Set up timer peripheral
0098CE  07021D     RCALL setupTimer7
129:               
130:                   next_row_index = 0;
0098D0  EB0000     CLR W0
0098D2  88FB10     MOV W0, next_row_index
131:                   has_new_frame = 0;
0098D4  21F641     MOV #0x1F64, W1
0098D6  EB4000     CLR.B W0
0098D8  784880     MOV.B W0, [W1]
132:                   current_frame = NULL;
0098DA  EB0000     CLR W0
0098DC  88FB00     MOV W0, current_frame
133:               
134:                   frame_counter = cntrCreate(); // Frame counter allocation
0098DE  02D58E     CALL cntrCreate
0098E0  000000     NOP
0098E2  88F5E0     MOV W0, frame_counter
135:                   if(frame_counter == NULL) { return; }
0098E4  80F5E1     MOV frame_counter, W1
0098E6  EB0000     CLR W0
0098E8  508F80     SUB W1, W0, [W15]
0098EA  320036     BRA Z, 0x9958
009958  000000     NOP
00995A  370005     BRA 0x9966
136:                   row_counter = cntrCreate(); // Row counter allocation
0098EC  02D58E     CALL cntrCreate
0098EE  000000     NOP
0098F0  88F5F0     MOV W0, row_counter
137:                   if(row_counter == NULL) { return; }
0098F2  80F5F1     MOV row_counter, W1
0098F4  EB0000     CLR W0
0098F6  508F80     SUB W1, W0, [W15]
0098F8  320031     BRA Z, 0x995C
00995C  000000     NOP
00995E  370003     BRA 0x9966
138:               
139:                   empty_frame_pool = carrayCreate(num_frames); // Initialize frame pool
0098FA  90002E     MOV [W14+4], W0
0098FC  028F1C     CALL carrayCreate
0098FE  000000     NOP
009900  88FB30     MOV W0, empty_frame_pool
140:                   if(empty_frame_pool == NULL) { return; }
009902  80FB31     MOV empty_frame_pool, W1
009904  EB0000     CLR W0
009906  508F80     SUB W1, W0, [W15]
009908  32002B     BRA Z, 0x9960
009960  000000     NOP
009962  370001     BRA 0x9966
141:                   full_frame_pool = carrayCreate(num_frames); // Initialize frame pool
00990A  90002E     MOV [W14+4], W0
00990C  028F1C     CALL carrayCreate
00990E  000000     NOP
009910  88FB40     MOV W0, full_frame_pool
142:                   if(full_frame_pool == NULL) { return; }
009912  80FB41     MOV full_frame_pool, W1
009914  EB0000     CLR W0
009916  508F80     SUB W1, W0, [W15]
009918  320025     BRA Z, 0x9964
009964  000000     NOP
143:               
144:                   for(i = 0; i < num_frames; i++) {
00991A  EB0000     CLR W0
00991C  780F00     MOV W0, [W14]
00991E  370008     BRA 0x9930
00992E  E80F1E     INC [W14], [W14]
009930  90002E     MOV [W14+4], W0
009932  78009E     MOV [W14], W1
009934  508F80     SUB W1, W0, [W15]
009936  39FFF4     BRA NC, 0x9920
145:                       camReturnFrame(&frames[i]);
009920  78009E     MOV [W14], W1
009922  2119A0     MOV #0x119A, W0
009924  B98800     MUL.SS W1, W0, W0
009926  780000     MOV W0, W0
009928  90009E     MOV [W14+2], W1
00992A  408000     ADD W1, W0, W0
00992C  0700D4     RCALL camReturnFrame
146:                   }
147:               
148:                   ovcamSetup();   // Set up camera device
009938  029D2C     CALL ovcamSetup
00993A  000000     NOP
149:                   irq_handler = NULL;   // Set up function pointers
00993C  EB0000     CLR W0
00993E  88FB50     MOV W0, irq_handler
150:                   row_getter = &ovcamGetPixels;
009940  2E20E0     MOV #0xE20E, W0
009942  88FB60     MOV W0, row_getter
151:                   frame_waiter = &ovcamWaitForNewFrame;
009944  298A60     MOV #0x98A6, W0
009946  88FB70     MOV W0, frame_waiter
152:                   frame_started = 0;
009948  21F651     MOV #0x1F65, W1
00994A  EB4000     CLR.B W0
00994C  784880     MOV.B W0, [W1]
153:               
154:                   is_ready = 1;
00994E  21EB01     MOV #0x1EB0, W1
009950  B3C010     MOV #0x1, W0
009952  784880     MOV.B W0, [W1]
155:               
156:                   camRunCalib();  // Measure timing parameters
009954  07004A     RCALL camRunCalib
009956  370007     BRA 0x9966
157:               
158:               }
009966  FA8000     ULNK
009968  060000     RETURN
159:               
160:               void camGetParams(CamParam params) {
00996A  FA0002     LNK #0x2
00996C  780F00     MOV W0, [W14]
161:               
162:                   if(params == NULL) { return; }
00996E  78009E     MOV [W14], W1
009970  EB0000     CLR W0
009972  508F80     SUB W1, W0, [W15]
009974  320012     BRA Z, 0x999A
00999A  000000     NOP
163:               
164:                   params->type = 0; // Not implemented yet!
009976  78009E     MOV [W14], W1
009978  EB4000     CLR.B W0
00997A  784880     MOV.B W0, [W1]
165:                   params->active = is_ready;
00997C  21EB00     MOV #0x1EB0, W0
00997E  784010     MOV.B [W0], W0
009980  78009E     MOV [W14], W1
009982  984090     MOV.B W0, [W1+1]
166:                   params->frame_start = frame_start;
009984  80F5A0     MOV frame_start, W0
009986  80F5B1     MOV 0x1EB6, W1
009988  78011E     MOV [W14], W2
00998A  980120     MOV W0, [W2+4]
00998C  980131     MOV W1, [W2+6]
167:                   params->frame_period = frame_period;
00998E  80F5C0     MOV frame_period, W0
009990  80F5D1     MOV 0x1EBA, W1
009992  78011E     MOV [W14], W2
009994  980140     MOV W0, [W2+8]
009996  980151     MOV W1, [W2+10]
009998  370001     BRA 0x999C
168:               
169:               }
00999C  FA8000     ULNK
00999E  060000     RETURN
170:               
171:               // Syncs the timer with the frame start event and begins the
172:               //  capture process.
173:               void camStart(void) {
0099A0  FA0000     LNK #0x0
174:               
175:                   if(!is_ready) { return; }
0099A2  21EB00     MOV #0x1EB0, W0
0099A4  784090     MOV.B [W0], W1
0099A6  EB4000     CLR.B W0
0099A8  50CF80     SUB.B W1, W0, [W15]
0099AA  320018     BRA Z, 0x99DC
0099DC  000000     NOP
176:               
177:                   DisableIntT7;               // Disable interrupt while syncing
0099AC  A9009A     BCLR IEC3, #0
178:                   frame_waiter();             // Avoid clock drift
0099AE  80FB70     MOV frame_waiter, W0
0099B0  010000     CALL W0
179:                   PR7 = VSYNC_ROW_TIME;       // Set wait time
0099B2  232000     MOV #0x3200, W0
0099B4  880950     MOV W0, PR7
180:                   WriteTimer7(0);             // Reset timer
0099B6  EB0000     CLR W0
0099B8  022576     CALL _WriteTimer7
0099BA  000000     NOP
181:                   frame_start = sclockGetGlobalTicks();
0099BC  02DE28     CALL sclockGetGlobalTicks
0099BE  000000     NOP
0099C0  88F5A0     MOV W0, frame_start
0099C2  88F5B1     MOV W1, 0x1EB6
182:                   cntrSet(row_counter, 0);    // Reset row counter
0099C4  80F5F0     MOV row_counter, W0
0099C6  EB0080     CLR W1
0099C8  02D6AC     CALL cntrSet
0099CA  000000     NOP
183:                   cntrSet(frame_counter, 0);  // Reset frame counter
0099CC  80F5E0     MOV frame_counter, W0
0099CE  EB0080     CLR W1
0099D0  02D6AC     CALL cntrSet
0099D2  000000     NOP
184:                   ct_state = CT_WAIT_ROW;     // Wait for first row
0099D4  200020     MOV #0x2, W0
0099D6  88F590     MOV W0, ct_state
185:                   EnableIntT7;                // Re-enable interrupt
0099D8  A8009A     BSET IEC3, #0
0099DA  370001     BRA 0x99DE
186:               
187:               }
0099DE  FA8000     ULNK
0099E0  060000     RETURN
188:               
189:               void camStop(void) {
0099E2  FA0000     LNK #0x0
190:               
191:                   DisableIntT7;
0099E4  A9009A     BCLR IEC3, #0
192:               
193:               }
0099E6  FA8000     ULNK
0099E8  060000     RETURN
194:               
195:               // Measures camera timing parameters
196:               void camRunCalib(void) {
0099EA  FA000E     LNK #0xE
197:               
198:                   unsigned int tic, capture_time, i;
199:                   unsigned long t1, t2;
200:               
201:                   if(!is_ready) { return; }
0099EC  21EB00     MOV #0x1EB0, W0
0099EE  784090     MOV.B [W0], W1
0099F0  EB4000     CLR.B W0
0099F2  50CF80     SUB.B W1, W0, [W15]
0099F4  32005E     BRA Z, 0x9AB2
009AB2  000000     NOP
202:               
203:                   // Approximately 8*pixels cycles per row
204:                   // Using 64:1 prescale
205:                   capture_time = (NATIVE_IMAGE_COLS)/(8);
0099F6  200140     MOV #0x14, W0
0099F8  980710     MOV W0, [W14+2]
206:               
207:                   DisableIntT7;
0099FA  A9009A     BCLR IEC3, #0
208:               
209:                   // VSYNC to VSYNC timing
210:                   frame_waiter();
0099FC  80FB70     MOV frame_waiter, W0
0099FE  010000     CALL W0
211:                   WriteTimer7(0);
009A00  EB0000     CLR W0
009A02  022576     CALL _WriteTimer7
009A04  000000     NOP
212:                   t1 = sclockGetGlobalTicks();
009A06  02DE28     CALL sclockGetGlobalTicks
009A08  000000     NOP
009A0A  980720     MOV W0, [W14+4]
009A0C  980731     MOV W1, [W14+6]
213:                   frame_waiter();
009A0E  80FB70     MOV frame_waiter, W0
009A10  010000     CALL W0
214:                   tic = ReadTimer7();
009A12  02256E     CALL _ReadTimer7
009A14  000000     NOP
009A16  980740     MOV W0, [W14+8]
215:                   t2 = sclockGetGlobalTicks();
009A18  02DE28     CALL sclockGetGlobalTicks
009A1A  000000     NOP
009A1C  980750     MOV W0, [W14+10]
009A1E  980761     MOV W1, [W14+12]
216:                   vsync_vsync_time = tic - VSYNC_VSYNC_OFFSET;
009A20  90004E     MOV [W14+8], W0
009A22  500068     SUB W0, #0x8, W0
009A24  891070     MOV W0, 0x220E
217:                   frame_period = t2 - t1;
009A26  90015E     MOV [W14+10], W2
009A28  9001EE     MOV [W14+12], W3
009A2A  90002E     MOV [W14+4], W0
009A2C  9000BE     MOV [W14+6], W1
009A2E  510000     SUB W2, W0, W0
009A30  598081     SUBB W3, W1, W1
009A32  88F5C0     MOV W0, frame_period
009A34  88F5D1     MOV W1, 0x1EBA
218:               
219:                   // VSYNC to row timing
220:                   frame_waiter();
009A36  80FB70     MOV frame_waiter, W0
009A38  010000     CALL W0
221:                   WriteTimer7(0);
009A3A  EB0000     CLR W0
009A3C  022576     CALL _WriteTimer7
009A3E  000000     NOP
222:                   for(i = 0; i < WINDOW_START_ROW; i++) {
009A40  EB0000     CLR W0
009A42  780F00     MOV W0, [W14]
223:                       camCaptureRow();
224:                   }
225:                   camCaptureRow();
009A44  0700AC     RCALL camCaptureRow
226:                   tic = ReadTimer7();
009A46  02256E     CALL _ReadTimer7
009A48  000000     NOP
009A4A  980740     MOV W0, [W14+8]
227:                   vsync_row_time = tic - capture_time - VSYNC_ROW_OFFSET;
009A4C  9000CE     MOV [W14+8], W1
009A4E  90001E     MOV [W14+2], W0
009A50  508000     SUB W1, W0, W0
009A52  500066     SUB W0, #0x6, W0
009A54  891050     MOV W0, 0x220A
228:               
229:                   // row to row timing
230:                   frame_waiter();
009A56  80FB70     MOV frame_waiter, W0
009A58  010000     CALL W0
231:                   camCaptureRow();
009A5A  0700A1     RCALL camCaptureRow
232:                   WriteTimer7(0);
009A5C  EB0000     CLR W0
009A5E  022576     CALL _WriteTimer7
009A60  000000     NOP
233:                   for(i = 0; i < DS_ROW; i++) {
009A62  EB0000     CLR W0
009A64  780F00     MOV W0, [W14]
009A66  370002     BRA 0x9A6C
009A6A  E80F1E     INC [W14], [W14]
009A6C  78009E     MOV [W14], W1
009A6E  200010     MOV #0x1, W0
009A70  508F80     SUB W1, W0, [W15]
009A72  36FFFA     BRA LEU, 0x9A68
234:                       camCaptureRow();
009A68  07009A     RCALL camCaptureRow
235:                   }
236:                   tic = ReadTimer7();
009A74  02256E     CALL _ReadTimer7
009A76  000000     NOP
009A78  980740     MOV W0, [W14+8]
237:                   row_row_time = tic - capture_time - ROW_ROW_OFFSET;
009A7A  9000CE     MOV [W14+8], W1
009A7C  90001E     MOV [W14+2], W0
009A7E  508000     SUB W1, W0, W0
009A80  500066     SUB W0, #0x6, W0
009A82  891040     MOV W0, 0x2208
238:               
239:                   // row to VSYNC timing
240:                   frame_waiter();
009A84  80FB70     MOV frame_waiter, W0
009A86  010000     CALL W0
241:                   for(i = 0; i < WINDOW_END_ROW; i++) {
009A88  EB0000     CLR W0
009A8A  780F00     MOV W0, [W14]
009A8C  370002     BRA 0x9A92
009A90  E80F1E     INC [W14], [W14]
009A92  200770     MOV #0x77, W0
009A94  78009E     MOV [W14], W1
009A96  508F80     SUB W1, W0, [W15]
009A98  36FFFA     BRA LEU, 0x9A8E
242:                       camCaptureRow();
009A8E  070087     RCALL camCaptureRow
243:                   }
244:                   WriteTimer7(0);
009A9A  EB0000     CLR W0
009A9C  022576     CALL _WriteTimer7
009A9E  000000     NOP
245:                   frame_waiter();
009AA0  80FB70     MOV frame_waiter, W0
009AA2  010000     CALL W0
246:                   tic = ReadTimer7();
009AA4  02256E     CALL _ReadTimer7
009AA6  000000     NOP
009AA8  980740     MOV W0, [W14+8]
247:                   row_vsync_time = tic - ROW_VSYNC_OFFSET;
009AAA  90004E     MOV [W14+8], W0
009AAC  50006A     SUB W0, #0xA, W0
009AAE  891060     MOV W0, 0x220C
009AB0  370001     BRA 0x9AB4
248:               
249:               }
009AB4  FA8000     ULNK
009AB6  060000     RETURN
250:               
251:               void camSetIrqHandler(CamIrqHandler irq) {
009AB8  FA0002     LNK #0x2
009ABA  780F00     MOV W0, [W14]
252:                   irq_handler = irq;
009ABC  78001E     MOV [W14], W0
009ABE  88FB50     MOV W0, irq_handler
253:               }
009AC0  FA8000     ULNK
009AC2  060000     RETURN
254:               
255:               unsigned char camHasNewFrame(void) {
009AC4  FA0000     LNK #0x0
256:               
257:                   return has_new_frame;
009AC6  21F640     MOV #0x1F64, W0
009AC8  784010     MOV.B [W0], W0
258:               
259:               }
009ACA  FA8000     ULNK
009ACC  060000     RETURN
260:               
261:               CamFrame camGetFrame(void) {
009ACE  FA0000     LNK #0x0
262:               
263:                   return getOldestFullFrame();
009AD0  070100     RCALL getOldestFullFrame
264:               
265:               }
009AD2  FA8000     ULNK
009AD4  060000     RETURN
266:               
267:               void camReturnFrame(CamFrame frame) {
009AD6  FA0002     LNK #0x2
009AD8  780F00     MOV W0, [W14]
268:               
269:                   if(frame == NULL) { return; }
009ADA  78009E     MOV [W14], W1
009ADC  EB0000     CLR W0
009ADE  508F80     SUB W1, W0, [W15]
009AE0  320003     BRA Z, 0x9AE8
009AE8  000000     NOP
270:                   enqueueEmptyFrame(frame);
009AE2  78001E     MOV [W14], W0
009AE4  0700EE     RCALL enqueueEmptyFrame
009AE6  370001     BRA 0x9AEA
271:               
272:               }
009AEA  FA8000     ULNK
009AEC  060000     RETURN
273:               
274:               unsigned int camGetFrameNum(void) {
009AEE  FA0000     LNK #0x0
275:                   return cntrRead(frame_counter);
009AF0  80F5E0     MOV frame_counter, W0
009AF2  02D5C0     CALL cntrRead
009AF4  000000     NOP
276:               }
009AF6  FA8000     ULNK
009AF8  060000     RETURN
277:               
278:               // =========== Private Functions ==============================================
279:               
280:               // Interrupt handler for Timer 7
281:               // Syncs frame timings and captures camera rows.
282:               void __attribute__((interrupt, no_auto_psv)) _T7Interrupt(void) {
009AFA  F80036     PUSH RCOUNT
009AFC  BE9F80     MOV.D W0, [W15++]
009AFE  BE9F82     MOV.D W2, [W15++]
009B00  BE9F84     MOV.D W4, [W15++]
009B02  BE9F86     MOV.D W6, [W15++]
009B04  FA0000     LNK #0x0
283:               
284:                   if(ct_state == CT_WAIT_VSYNC) {
009B06  80F591     MOV ct_state, W1
009B08  200010     MOV #0x1, W0
009B0A  508F80     SUB W1, W0, [W15]
009B0C  3A0018     BRA NZ, 0x9B3E
285:                       frame_waiter();             // Avoid clock drift
009B0E  80FB70     MOV frame_waiter, W0
009B10  010000     CALL W0
286:                       WriteTimer7(0);             // Reset timer
009B12  EB0000     CLR W0
009B14  022576     CALL _WriteTimer7
009B16  000000     NOP
287:               
288:                       cntrIncrement(frame_counter);
009B18  80F5E0     MOV frame_counter, W0
009B1A  02D60C     CALL cntrIncrement
009B1C  000000     NOP
289:                       cntrSet(row_counter, 0);    // Reset row counter
009B1E  80F5F0     MOV row_counter, W0
009B20  EB0080     CLR W1
009B22  02D6AC     CALL cntrSet
009B24  000000     NOP
290:               
291:                       if(cntrRead(frame_counter) % DS_FRAME == 0) {
009B26  80F5E0     MOV frame_counter, W0
009B28  02D5C0     CALL cntrRead
009B2A  000000     NOP
292:                           ct_state = CT_WAIT_ROW;         // Wait for first row
009B2C  200020     MOV #0x2, W0
009B2E  88F590     MOV W0, ct_state
293:                           PR7 = vsync_row_time;           // Set wait time
009B30  811050     MOV 0x220A, W0
009B32  880950     MOV W0, PR7
294:                       } else {
295:                           // ct_state == CT_WAIT_VSYNC (unchanged)
296:                           PR7 = vsync_vsync_time;         // Wait for next frame
297:                       }
298:                       frame_start = sclockGetGlobalTicks();
009B34  02DE28     CALL sclockGetGlobalTicks
009B36  000000     NOP
009B38  88F5A0     MOV W0, frame_start
009B3A  88F5B1     MOV W1, 0x1EB6
009B3C  370028     BRA 0x9B8E
299:               
300:                   } else if(ct_state == CT_WAIT_ROW) {
009B3E  80F591     MOV ct_state, W1
009B40  200020     MOV #0x2, W0
009B42  508F80     SUB W1, W0, [W15]
009B44  3A0024     BRA NZ, 0x9B8E
301:               
302:                       camCaptureRow();            // Capture row
009B46  07002B     RCALL camCaptureRow
303:                       WriteTimer7(0);             // Reset timer
009B48  EB0000     CLR W0
009B4A  022576     CALL _WriteTimer7
009B4C  000000     NOP
304:                       processRow();               // Process row
009B4E  07004C     RCALL processRow
305:                       cntrAdd(row_counter, DS_ROW);    // Increment row count
009B50  80F5F0     MOV row_counter, W0
009B52  200021     MOV #0x2, W1
009B54  02D65A     CALL cntrAdd
009B56  000000     NOP
306:               
307:                       // Transition if captured last row
308:                       if(cntrRead(row_counter) >= NATIVE_IMAGE_ROWS) {
009B58  80F5F0     MOV row_counter, W0
009B5A  02D5C0     CALL cntrRead
009B5C  000000     NOP
009B5E  200771     MOV #0x77, W1
009B60  500F81     SUB W0, W1, [W15]
009B62  36000C     BRA LEU, 0x9B7C
309:                           ct_state = CT_WAIT_VSYNC;
009B64  200010     MOV #0x1, W0
009B66  88F590     MOV W0, ct_state
310:                           PR7 = row_vsync_time;
009B68  811060     MOV 0x220C, W0
009B6A  880950     MOV W0, PR7
311:                           if(irq_handler != NULL) {
009B6C  80FB51     MOV irq_handler, W1
009B6E  EB0000     CLR W0
009B70  508F80     SUB W1, W0, [W15]
009B72  32000D     BRA Z, 0x9B8E
312:                               irq_handler(CAM_IRQ_FRAME_DONE);
009B74  80FB51     MOV irq_handler, W1
009B76  200010     MOV #0x1, W0
009B78  010001     CALL W1
009B7A  370009     BRA 0x9B8E
313:                           }
314:                       } else { // Else wait for next row
315:                           PR7 = row_row_time;
009B7C  811040     MOV 0x2208, W0
009B7E  880950     MOV W0, PR7
316:                           if(irq_handler != NULL) {
009B80  80FB51     MOV irq_handler, W1
009B82  EB0000     CLR W0
009B84  508F80     SUB W1, W0, [W15]
009B86  320003     BRA Z, 0x9B8E
317:                               irq_handler(CAM_IRQ_ROW_DONE);
009B88  80FB51     MOV irq_handler, W1
009B8A  EB0000     CLR W0
009B8C  010001     CALL W1
318:                           }
319:                       }
320:                   }
321:               
322:                   _T7IF = 0;
009B8E  A9008A     BCLR IFS3, #0
323:               
324:               }
009B90  FA8000     ULNK
009B92  BE034F     MOV.D [--W15], W6
009B94  BE024F     MOV.D [--W15], W4
009B96  BE014F     MOV.D [--W15], W2
009B98  BE004F     MOV.D [--W15], W0
009B9A  F90036     POP RCOUNT
009B9C  064000     RETFIE
325:               
326:               void camCaptureRow(void) {
009B9E  FA0006     LNK #0x6
327:               
328:                   CRITICAL_SECTION_START;
009BA0  800210     MOV SR, W0
009BA2  DE0045     LSR W0, #5, W0
009BA4  604067     AND.B W0, #0x7, W0
009BA6  784F00     MOV.B W0, [W14]
009BA8  800290     MOV DISICNT, W0
009BAA  980710     MOV W0, [W14+2]
009BAC  FC3FFF     DISI #0x3FFF
009BAE  800211     MOV SR, W1
009BB0  200E00     MOV #0xE0, W0
009BB2  708000     IOR W1, W0, W0
009BB4  880210     MOV W0, SR
009BB6  90001E     MOV [W14+2], W0
009BB8  880290     MOV W0, DISICNT
009BBA  880000     MOV W0, WREG0
329:                   row_getter(row_buff, NATIVE_IMAGE_COLS);
009BBC  80FB62     MOV row_getter, W2
009BBE  200A01     MOV #0xA0, W1
009BC0  21EC00     MOV #0x1EC0, W0
009BC2  010002     CALL W2
330:                   CRITICAL_SECTION_END;
009BC4  800290     MOV DISICNT, W0
009BC6  980720     MOV W0, [W14+4]
009BC8  FC3FFF     DISI #0x3FFF
009BCA  78401E     MOV.B [W14], W0
009BCC  604067     AND.B W0, #0x7, W0
009BCE  FB8000     ZE W0, W0
009BD0  600067     AND W0, #0x7, W0
009BD2  DD0045     SL W0, #5, W0
009BD4  800212     MOV SR, W2
009BD6  2FF1F1     MOV #0xFF1F, W1
009BD8  610081     AND W2, W1, W1
009BDA  708000     IOR W1, W0, W0
009BDC  880210     MOV W0, SR
009BDE  90002E     MOV [W14+4], W0
009BE0  880290     MOV W0, DISICNT
009BE2  880000     MOV W0, WREG0
331:               
332:               }
009BE4  FA8000     ULNK
009BE6  060000     RETURN
333:               
334:               void processRow(void) {
009BE8  FA000C     LNK #0xC
009BEA  781F88     MOV W8, [W15++]
335:               
336:                   unsigned int i, j, k, acc;
337:                   unsigned char *src_data, *dst_data;
338:               
339:                   if(cntrRead(row_counter) == 0) {
009BEC  80F5F0     MOV row_counter, W0
009BEE  02D5C0     CALL cntrRead
009BF0  000000     NOP
009BF2  EB0080     CLR W1
009BF4  500F81     SUB W0, W1, [W15]
009BF6  3A0006     BRA NZ, 0x9C04
340:                       if(current_frame == NULL) {
009BF8  80FB01     MOV current_frame, W1
009BFA  EB0000     CLR W0
009BFC  508F80     SUB W1, W0, [W15]
009BFE  3A0002     BRA NZ, 0x9C04
341:                           current_frame = getEmptyFrame(); // Load new frame
009C00  070052     RCALL getEmptyFrame
009C02  88FB00     MOV W0, current_frame
342:                       }
343:                   }
344:               
345:                   if(current_frame == NULL) { return; }
009C04  80FB01     MOV current_frame, W1
009C06  EB0000     CLR W0
009C08  508F80     SUB W1, W0, [W15]
009C0A  320049     BRA Z, 0x9C9E
009C9E  000000     NOP
346:               
347:                   dst_data = current_frame->pixels[next_row_index]; // Write into current frame
009C0C  80FB00     MOV current_frame, W0
009C0E  400066     ADD W0, #0x6, W0
009C10  780100     MOV W0, W2
009C12  80FB11     MOV next_row_index, W1
009C14  2004B0     MOV #0x4B, W0
009C16  B98800     MUL.SS W1, W0, W0
009C18  780000     MOV W0, W0
009C1A  410000     ADD W2, W0, W0
009C1C  980740     MOV W0, [W14+8]
348:                   src_data = row_buff;
009C1E  21EC00     MOV #0x1EC0, W0
009C20  980750     MOV W0, [W14+10]
349:               
350:                   k = WINDOW_START_COL;
009C22  200050     MOV #0x5, W0
009C24  980720     MOV W0, [W14+4]
351:                   for(i = 0; i < DS_IMAGE_COLS; i++) {
009C26  EB0000     CLR W0
009C28  780F00     MOV W0, [W14]
009C2A  37001E     BRA 0x9C68
009C66  E80F1E     INC [W14], [W14]
009C68  2004A0     MOV #0x4A, W0
009C6A  78009E     MOV [W14], W1
009C6C  508F80     SUB W1, W0, [W15]
009C6E  36FFDE     BRA LEU, 0x9C2C
352:                       acc = 0;
009C2C  EB0000     CLR W0
009C2E  980730     MOV W0, [W14+6]
353:                       for(j = 0; j < DS_COL; j++) {
009C30  EB0000     CLR W0
009C32  980710     MOV W0, [W14+2]
009C34  37000E     BRA 0x9C52
009C4C  90001E     MOV [W14+2], W0
009C4E  E80000     INC W0, W0
009C50  980710     MOV W0, [W14+2]
009C52  90009E     MOV [W14+2], W1
009C54  200010     MOV #0x1, W0
009C56  508F80     SUB W1, W0, [W15]
009C58  36FFEE     BRA LEU, 0x9C36
354:                           acc += row_buff[k++];
009C36  21EC01     MOV #0x1EC0, W1
009C38  90002E     MOV [W14+4], W0
009C3A  408000     ADD W1, W0, W0
009C3C  784010     MOV.B [W0], W0
009C3E  FB8000     ZE W0, W0
009C40  9000BE     MOV [W14+6], W1
009C42  408000     ADD W1, W0, W0
009C44  980730     MOV W0, [W14+6]
009C46  90002E     MOV [W14+4], W0
009C48  E80000     INC W0, W0
009C4A  980720     MOV W0, [W14+4]
355:                       }
356:                       dst_data[i] = acc/DS_COL;
009C5A  90004E     MOV [W14+8], W0
009C5C  40009E     ADD W0, [W14], W1
009C5E  90003E     MOV [W14+6], W0
009C60  D10000     LSR W0, W0
009C62  784000     MOV.B W0, W0
009C64  784880     MOV.B W0, [W1]
357:                   }
358:               
359:                   next_row_index++;
009C70  80FB10     MOV next_row_index, W0
009C72  E80000     INC W0, W0
009C74  88FB10     MOV W0, next_row_index
360:               
361:                   // If all rows are filled, add the frame to the full frame buffer
362:                   if(next_row_index >= DS_IMAGE_ROWS) {
009C76  80FB11     MOV next_row_index, W1
009C78  2003B0     MOV #0x3B, W0
009C7A  508F80     SUB W1, W0, [W15]
009C7C  360011     BRA LEU, 0x9CA0
363:                       current_frame->frame_num = cntrRead(frame_counter); // write frame number
009C7E  80FB08     MOV current_frame, W8
009C80  80F5E0     MOV frame_counter, W0
009C82  02D5C0     CALL cntrRead
009C84  000000     NOP
009C86  980420     MOV W0, [W8+4]
364:                       current_frame->timestamp = sclockGetLocalTicks();
009C88  80FB08     MOV current_frame, W8
009C8A  02DE50     CALL sclockGetLocalTicks
009C8C  000000     NOP
009C8E  BE8C00     MOV.D W0, [W8]
365:                       enqueueFullFrame(current_frame); // Add to output queue
009C90  80FB00     MOV current_frame, W0
009C92  070030     RCALL enqueueFullFrame
366:                       current_frame = NULL;
009C94  EB0000     CLR W0
009C96  88FB00     MOV W0, current_frame
367:                       next_row_index = 0;
009C98  EB0000     CLR W0
009C9A  88FB10     MOV W0, next_row_index
009C9C  370001     BRA 0x9CA0
368:                   }
369:               
370:               }
009CA0  78044F     MOV [--W15], W8
009CA2  FA8000     ULNK
009CA4  060000     RETURN
371:               
372:               /**
373:                * Get the next available empty frame. If no frames are available, automatically
374:                * dequeues and returns the oldest full frame.
375:                *
376:                * @return Next available frame for writing
377:                */
378:               static CamFrame getEmptyFrame(void) {
009CA6  FA0002     LNK #0x2
379:               
380:                   CamFrame frame;
381:               
382:                   frame = carrayPopHead(empty_frame_pool);
009CA8  80FB30     MOV empty_frame_pool, W0
009CAA  0291BA     CALL carrayPopHead
009CAC  000000     NOP
009CAE  780F00     MOV W0, [W14]
383:                   if(frame == NULL) {
009CB0  78009E     MOV [W14], W1
009CB2  EB0000     CLR W0
009CB4  508F80     SUB W1, W0, [W15]
009CB6  3A0002     BRA NZ, 0x9CBC
384:                       frame = getOldestFullFrame(); // If no more empty frames, get oldest full
009CB8  07000C     RCALL getOldestFullFrame
009CBA  780F00     MOV W0, [W14]
385:                   }
386:                   return frame;
009CBC  78001E     MOV [W14], W0
387:               
388:               }
009CBE  FA8000     ULNK
009CC0  060000     RETURN
389:               
390:               /**
391:                * Enqueues a frame for writing into.
392:                *
393:                * @param frame CamFrame object to enqueue
394:                */
395:               static void enqueueEmptyFrame(CamFrame frame) {
009CC2  FA0002     LNK #0x2
009CC4  780F00     MOV W0, [W14]
396:               
397:                   carrayAddTail(empty_frame_pool, frame);
009CC6  80FB30     MOV empty_frame_pool, W0
009CC8  78009E     MOV [W14], W1
009CCA  028F9A     CALL carrayAddTail
009CCC  000000     NOP
398:               
399:               }
009CCE  FA8000     ULNK
009CD0  060000     RETURN
400:               
401:               /**
402:                * Returns the oldest full frame in the outgoing buffer.
403:                *
404:                * @return Oldest full frame object
405:                */
406:               static CamFrame getOldestFullFrame(void) {
009CD2  FA0002     LNK #0x2
407:               
408:                   CamFrame frame;
409:               
410:                   frame = carrayPopHead(full_frame_pool);
009CD4  80FB40     MOV full_frame_pool, W0
009CD6  0291BA     CALL carrayPopHead
009CD8  000000     NOP
009CDA  780F00     MOV W0, [W14]
411:                   if(carrayIsEmpty(full_frame_pool)) {
009CDC  80FB40     MOV full_frame_pool, W0
009CDE  02937A     CALL carrayIsEmpty
009CE0  000000     NOP
009CE2  EB0080     CLR W1
009CE4  500F81     SUB W0, W1, [W15]
009CE6  320003     BRA Z, 0x9CEE
412:                       has_new_frame = 0;
009CE8  21F641     MOV #0x1F64, W1
009CEA  EB4000     CLR.B W0
009CEC  784880     MOV.B W0, [W1]
413:                   }
414:               
415:                   return frame;
009CEE  78001E     MOV [W14], W0
416:               
417:               }
009CF0  FA8000     ULNK
009CF2  060000     RETURN
418:               
419:               /**
420:                * Enqueues a full frame object in the outgoing buffer.
421:                *
422:                * @param frame CamFrame object to enqueue
423:                */
424:               static void enqueueFullFrame(CamFrame frame) {
009CF4  FA0002     LNK #0x2
009CF6  780F00     MOV W0, [W14]
425:               
426:                   carrayAddTail(full_frame_pool, frame);
009CF8  80FB40     MOV full_frame_pool, W0
009CFA  78009E     MOV [W14], W1
009CFC  028F9A     CALL carrayAddTail
009CFE  000000     NOP
427:                   has_new_frame = 1;
009D00  21F641     MOV #0x1F64, W1
009D02  B3C010     MOV #0x1, W0
009D04  784880     MOV.B W0, [W1]
428:               
429:               }
009D06  FA8000     ULNK
009D08  060000     RETURN
430:               
431:               // Camera acquisition timer setup
432:               static void setupTimer7(void) {
009D0A  FA0002     LNK #0x2
433:               
434:                   unsigned int con_reg;
435:               
436:                   con_reg =   T7_ON &             // Enable module
009D0C  2DFAD0     MOV #0xDFAD, W0
009D0E  780F00     MOV W0, [W14]
437:                   T7_IDLE_CON &       // Continue running when idle
438:                   T7_GATE_OFF &       // Time accumulation disable
439:                   T7_PS_1_64 &        // Prescale 1:64
440:                   T7_SOURCE_INT;      // Internal clock
441:               
442:                   _T7IF = 0;
009D10  A9008A     BCLR IFS3, #0
443:                   OpenTimer7(con_reg, 0);         // Configure timer
009D12  EB0080     CLR W1
009D14  78001E     MOV [W14], W0
009D16  02255E     CALL _OpenTimer7
009D18  000000     NOP
444:                   ConfigIntTimer7(T7_INT_PRIOR_6 & T7_INT_OFF);
009D1A  2FFF60     MOV #0xFFF6, W0
009D1C  02250C     CALL _ConfigIntTimer7
009D1E  000000     NOP
445:               
446:               }
009D20  FA8000     ULNK
009D22  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/battery.c  --------------------------------------------
1:                 /*
2:                  * Copyright (c) 2007-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Battery supervisor module
31:                 *
32:                 * by Fernando L. Garcia Bermudez and Stanley S. Baek
33:                 *
34:                 * v.0.2
35:                 *
36:                 * Revisions:
37:                 *  Fernando L. Garcia Bermudez     2007-8-8    Initial release
38:                 *  Aaron M. Hoover                 2009-4-2    Moved code to interrupts.c/h
39:                 *  Stanley S. Baek                 2010-7-5    Created this module
40:                 *  Humphrey Hu                     2012-07-12  Added event callback
41:                 *
42:                 * Notes:
43:                 *  - Uses an external interrupt (INT0 for ImageProc1, INT2 for ImageProc2).
44:                 */
45:                
46:                #include "battery.h"
47:                #include "ports.h"
48:                #include "pwm.h"
49:                #include "utils.h"
50:                #include <stdlib.h>
51:                
52:                // =========== Static Variables ================================================
53:                BatteryEventISR event_callback;
54:                
55:                // =========== Function Stubs ==================================================
56:                static void batHandleISR(void);
57:                static void batDefaultCallback(void);
58:                
59:                // =========== Public Methods ==================================================
60:                void batSetup(void) {
00DB68  FA0000     LNK #0x0
61:                
62:                #if defined(__IMAGEPROC1)
63:                    ConfigINT0(RISING_EDGE_INT & EXT_INT_ENABLE & EXT_INT_PRI_7);
64:                #elif defined(__IMAGEPROC2)
65:                    ConfigINT2(RISING_EDGE_INT & EXT_INT_ENABLE & EXT_INT_PRI_7);
00DB6A  2FFEF0     MOV #0xFFEF, W0
00DB6C  022344     CALL _ConfigINT2
00DB6E  000000     NOP
66:                #endif
67:                
68:                }
00DB70  FA8000     ULNK
00DB72  060000     RETURN
69:                
70:                void batSetCallback(BatteryEventISR isr) {
00DB74  FA0002     LNK #0x2
00DB76  780F00     MOV W0, [W14]
71:                
72:                    event_callback = isr;
00DB78  78001E     MOV [W14], W0
00DB7A  891160     MOV W0, event_callback
73:                
74:                }
00DB7C  FA8000     ULNK
00DB7E  060000     RETURN
75:                
76:                // =========== Private Methods =================================================
77:                static void batHandleISR(void) {
00DB80  FA0000     LNK #0x0
78:                
79:                    if(event_callback == NULL) {
00DB82  811161     MOV event_callback, W1
00DB84  EB0000     CLR W0
00DB86  508F80     SUB W1, W0, [W15]
00DB88  3A0002     BRA NZ, 0xDB8E
80:                        batDefaultCallback();
00DB8A  070005     RCALL batDefaultCallback
00DB8C  370002     BRA 0xDB92
81:                    } else {
82:                        event_callback();
00DB8E  811160     MOV event_callback, W0
00DB90  010000     CALL W0
83:                    }
84:                
85:                }
00DB92  FA8000     ULNK
00DB94  060000     RETURN
86:                
87:                static void batDefaultCallback(void) {
00DB96  FA0006     LNK #0x6
88:                
89:                    unsigned char i;
90:                
91:                    // Disable all interrupts
92:                    CRITICAL_SECTION_START;
00DB98  800210     MOV SR, W0
00DB9A  DE0045     LSR W0, #5, W0
00DB9C  604067     AND.B W0, #0x7, W0
00DB9E  984710     MOV.B W0, [W14+1]
00DBA0  800290     MOV DISICNT, W0
00DBA2  980710     MOV W0, [W14+2]
00DBA4  FC3FFF     DISI #0x3FFF
00DBA6  800211     MOV SR, W1
00DBA8  200E00     MOV #0xE0, W0
00DBAA  708000     IOR W1, W0, W0
00DBAC  880210     MOV W0, SR
00DBAE  90001E     MOV [W14+2], W0
00DBB0  880290     MOV W0, DISICNT
00DBB2  880000     MOV W0, WREG0
93:                
94:                    LED_1 = 1;
00DBB4  A882CB     BSET 0x2CB, #4
95:                    LED_2 = 1;
00DBB6  A8A2CB     BSET 0x2CB, #5
96:                    #if defined(__IMAGEPROC2)
97:                        LED_3 = 1;
00DBB8  A8C2CB     BSET 0x2CB, #6
98:                    #endif
99:                
100:                   #if defined(__LOWBATT_STOPS_MOTORS)
101:                       // Stop any running motors
102:                       for (i=1; i<=4; i++) { SetDCMCPWM(i, 0, 0); }
103:                       CloseMCPWM();
104:                   #endif
105:               
106:                   // Slowly blink all LEDs 5 times (1 second interval)
107:                   for (i=0; i<5; ++i) {
00DBBA  EB4000     CLR.B W0
00DBBC  784F00     MOV.B W0, [W14]
00DBBE  37002B     BRA 0xDC16
00DC14  E84F1E     INC.B [W14], [W14]
00DC16  78409E     MOV.B [W14], W1
00DC18  B3C040     MOV #0x4, W0
00DC1A  50CF80     SUB.B W1, W0, [W15]
00DC1C  36FFD1     BRA LEU, 0xDBC0
108:                       LED_1 = ~LED_1;
00DBC0  801650     MOV LATB, W0
00DBC2  DE004C     LSR W0, #12, W0
00DBC4  604061     AND.B W0, #0x1, W0
00DBC6  EAC000     COM.B W0, W0
00DBC8  604061     AND.B W0, #0x1, W0
00DBCA  FB8000     ZE W0, W0
00DBCC  600061     AND W0, #0x1, W0
00DBCE  DD004C     SL W0, #12, W0
00DBD0  801652     MOV LATB, W2
00DBD2  2EFFF1     MOV #0xEFFF, W1
00DBD4  610081     AND W2, W1, W1
00DBD6  708000     IOR W1, W0, W0
00DBD8  881650     MOV W0, LATB
109:                       LED_2 = ~LED_2;
00DBDA  801650     MOV LATB, W0
00DBDC  DE004D     LSR W0, #13, W0
00DBDE  604061     AND.B W0, #0x1, W0
00DBE0  EAC000     COM.B W0, W0
00DBE2  604061     AND.B W0, #0x1, W0
00DBE4  FB8000     ZE W0, W0
00DBE6  600061     AND W0, #0x1, W0
00DBE8  DD004D     SL W0, #13, W0
00DBEA  801652     MOV LATB, W2
00DBEC  2DFFF1     MOV #0xDFFF, W1
00DBEE  610081     AND W2, W1, W1
00DBF0  708000     IOR W1, W0, W0
00DBF2  881650     MOV W0, LATB
110:                       #if defined(__IMAGEPROC2)
111:                           LED_3 = ~LED_3;
00DBF4  801650     MOV LATB, W0
00DBF6  DE004E     LSR W0, #14, W0
00DBF8  604061     AND.B W0, #0x1, W0
00DBFA  EAC000     COM.B W0, W0
00DBFC  604061     AND.B W0, #0x1, W0
00DBFE  FB8000     ZE W0, W0
00DC00  600061     AND W0, #0x1, W0
00DC02  DD004E     SL W0, #14, W0
00DC04  801652     MOV LATB, W2
00DC06  2BFFF1     MOV #0xBFFF, W1
00DC08  610081     AND W2, W1, W1
00DC0A  708000     IOR W1, W0, W0
00DC0C  881650     MOV W0, LATB
112:                       #endif
113:                       delay_ms(1000);
00DC0E  203E80     MOV #0x3E8, W0
00DC10  02E270     CALL msELAPSED
00DC12  000000     NOP
114:                   }
115:               
116:                   CRITICAL_SECTION_END;
00DC1E  800290     MOV DISICNT, W0
00DC20  980720     MOV W0, [W14+4]
00DC22  FC3FFF     DISI #0x3FFF
00DC24  90401E     MOV.B [W14+1], W0
00DC26  604067     AND.B W0, #0x7, W0
00DC28  FB8000     ZE W0, W0
00DC2A  600067     AND W0, #0x7, W0
00DC2C  DD0045     SL W0, #5, W0
00DC2E  800212     MOV SR, W2
00DC30  2FF1F1     MOV #0xFF1F, W1
00DC32  610081     AND W2, W1, W1
00DC34  708000     IOR W1, W0, W0
00DC36  880210     MOV W0, SR
00DC38  90002E     MOV [W14+4], W0
00DC3A  880290     MOV W0, DISICNT
00DC3C  880000     MOV W0, WREG0
117:               
118:               }
00DC3E  FA8000     ULNK
00DC40  060000     RETURN
119:               
120:               /*****************************************************************************
121:               * Function Name : _INT0Interrupt/_INT2Interrupt
122:               * Description   : Interrupt handler for Battery Supervisor
123:               * Parameters    : None
124:               * Return Value  : None
125:               *****************************************************************************/
126:               
127:               #if defined(__IMAGEPROC1)
128:               void __attribute__((interrupt, no_auto_psv)) _INT0Interrupt(void) {
129:               
130:                   batHandleISR();
131:                   _INT0IF = 0;    // Clear the interrupt flag
132:               
133:               }
134:               #elif defined(__IMAGEPROC2)
135:               void __attribute__((interrupt, no_auto_psv)) _INT2Interrupt(void) {
00DC42  F80036     PUSH RCOUNT
00DC44  BE9F80     MOV.D W0, [W15++]
00DC46  BE9F82     MOV.D W2, [W15++]
00DC48  BE9F84     MOV.D W4, [W15++]
00DC4A  BE9F86     MOV.D W6, [W15++]
00DC4C  FA0000     LNK #0x0
136:               
137:                   batHandleISR();
00DC4E  07FF98     RCALL batHandleISR
138:                   _INT2IF = 0;    // Clear the interrupt flag
00DC50  A9A087     BCLR 0x87, #5
139:               
140:               }
00DC52  FA8000     ULNK
00DC54  BE034F     MOV.D [--W15], W6
00DC56  BE024F     MOV.D [--W15], W4
00DC58  BE014F     MOV.D [--W15], W2
00DC5A  BE004F     MOV.D [--W15], W0
00DC5C  F90036     POP RCOUNT
00DC5E  064000     RETFIE
141:               #endif
---  C:/Users/Cameron/Documents/Git/imageproc-lib/bams.c  -----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2009 - 2010, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Binary Angle Measurement System (BAMS) Implementation
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v.alpha
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu			 2011-10-23	   Initial implementation
38:                 * 
39:                 */
40:                
41:                #include "bams.h"
42:                #include "math.h"
43:                
44:                // Conversion constants
45:                #define BAMS16_TO_RAD		(9.58737992e-5)
46:                #define BAMS16_TO_DEG		(5.49316406e-3)
47:                #define BAMS32_TO_RAD		(1.46291808e-9)
48:                #define BAMS32_TO_DEG		(8.38190317e-8)
49:                
50:                #define RAD_TO_BAMS16		(10430.3784)
51:                #define DEG_TO_BAMS16		(182.044444)
52:                #define DEG_TO_BAMS32		(11930464.7)
53:                #define RAD_TO_BAMS32		(683565276.0)
54:                
55:                #define BAMS16_LSB2RAD		(9.58737992e-5) 		
56:                #define BAMS32_LSB2RAD		(1.46291808e-9)
57:                
58:                // Other constants
59:                #define _2PI				(6.28318531)
60:                #define PI					(3.14159265)
61:                #define PI_4				(0.785398163
62:                
63:                float bams16ToFloatRad(bams16_t b) {
006B50  FA0002     LNK #0x2
006B52  780F00     MOV W0, [W14]
64:                    return b*BAMS16_TO_RAD;
006B54  78001E     MOV [W14], W0
006B56  DE80CF     ASR W0, #15, W1
006B58  022624     CALL ___floatsisf
006B5A  000000     NOP
006B5C  20FDB2     MOV #0xFDB, W2
006B5E  238C93     MOV #0x38C9, W3
006B60  022C36     CALL ___mulsf3
006B62  000000     NOP
65:                }
006B64  FA8000     ULNK
006B66  060000     RETURN
66:                float bams16ToFloatDeg(bams16_t b) {
006B68  FA0002     LNK #0x2
006B6A  780F00     MOV W0, [W14]
67:                    return b*BAMS16_TO_DEG;
006B6C  78001E     MOV [W14], W0
006B6E  DE80CF     ASR W0, #15, W1
006B70  022624     CALL ___floatsisf
006B72  000000     NOP
006B74  200002     MOV #0x0, W2
006B76  23BB43     MOV #0x3BB4, W3
006B78  022C36     CALL ___mulsf3
006B7A  000000     NOP
68:                }
006B7C  FA8000     ULNK
006B7E  060000     RETURN
69:                bams16_t floatToBams16Rad(float f) {
006B80  FA0004     LNK #0x4
006B82  781F88     MOV W8, [W15++]
006B84  BE8F00     MOV.D W0, [W14]
70:                    return (bams16_t) (((f > PI) ? (f - _2PI) : f)*RAD_TO_BAMS16);
006B86  B3C018     MOV #0x1, W8
006B88  20FDB2     MOV #0xFDB, W2
006B8A  240493     MOV #0x4049, W3
006B8C  BE001E     MOV.D [W14], W0
006B8E  0225A8     CALL ___gtsf2
006B90  000000     NOP
006B92  EB0080     CLR W1
006B94  500F81     SUB W0, W1, [W15]
006B96  3C0001     BRA GT, 0x6B9A
006B98  EB4400     CLR.B W8
006B9A  EB4000     CLR.B W0
006B9C  544F80     SUB.B W8, W0, [W15]
006B9E  32000D     BRA Z, 0x6BBA
006BA0  20FDB2     MOV #0xFDB, W2
006BA2  240C93     MOV #0x40C9, W3
006BA4  BE001E     MOV.D [W14], W0
006BA6  022A5A     CALL ___subsf3
006BA8  000000     NOP
006BAA  2F9832     MOV #0xF983, W2
006BAC  246223     MOV #0x4622, W3
006BAE  022C36     CALL ___mulsf3
006BB0  000000     NOP
006BB2  0225AC     CALL ___fixsfsi
006BB4  000000     NOP
006BB6  780000     MOV W0, W0
006BB8  370008     BRA 0x6BCA
006BBA  2F9832     MOV #0xF983, W2
006BBC  246223     MOV #0x4622, W3
006BBE  BE001E     MOV.D [W14], W0
006BC0  022C36     CALL ___mulsf3
006BC2  000000     NOP
006BC4  0225AC     CALL ___fixsfsi
006BC6  000000     NOP
006BC8  780000     MOV W0, W0
71:                }
006BCA  78044F     MOV [--W15], W8
006BCC  FA8000     ULNK
006BCE  060000     RETURN
72:                bams16_t floatToBams16Deg(float f) {
006BD0  FA0004     LNK #0x4
006BD2  781F88     MOV W8, [W15++]
006BD4  BE8F00     MOV.D W0, [W14]
73:                    return (bams16_t) (((f > 180.0) ? (f - 360.0) : f)*DEG_TO_BAMS16);
006BD6  B3C018     MOV #0x1, W8
006BD8  200002     MOV #0x0, W2
006BDA  243343     MOV #0x4334, W3
006BDC  BE001E     MOV.D [W14], W0
006BDE  0225A8     CALL ___gtsf2
006BE0  000000     NOP
006BE2  EB0080     CLR W1
006BE4  500F81     SUB W0, W1, [W15]
006BE6  3C0001     BRA GT, 0x6BEA
006BE8  EB4400     CLR.B W8
006BEA  EB4000     CLR.B W0
006BEC  544F80     SUB.B W8, W0, [W15]
006BEE  32000D     BRA Z, 0x6C0A
006BF0  200002     MOV #0x0, W2
006BF2  243B43     MOV #0x43B4, W3
006BF4  BE001E     MOV.D [W14], W0
006BF6  022A5A     CALL ___subsf3
006BF8  000000     NOP
006BFA  20B612     MOV #0xB61, W2
006BFC  243363     MOV #0x4336, W3
006BFE  022C36     CALL ___mulsf3
006C00  000000     NOP
006C02  0225AC     CALL ___fixsfsi
006C04  000000     NOP
006C06  780000     MOV W0, W0
006C08  370008     BRA 0x6C1A
006C0A  20B612     MOV #0xB61, W2
006C0C  243363     MOV #0x4336, W3
006C0E  BE001E     MOV.D [W14], W0
006C10  022C36     CALL ___mulsf3
006C12  000000     NOP
006C14  0225AC     CALL ___fixsfsi
006C16  000000     NOP
006C18  780000     MOV W0, W0
74:                }
006C1A  78044F     MOV [--W15], W8
006C1C  FA8000     ULNK
006C1E  060000     RETURN
75:                
76:                float bams32ToFloatRad(bams32_t b) {
006C20  FA0004     LNK #0x4
006C22  BE8F00     MOV.D W0, [W14]
77:                    return b*BAMS32_TO_RAD;
006C24  BE001E     MOV.D [W14], W0
006C26  022624     CALL ___floatsisf
006C28  000000     NOP
006C2A  20FDB2     MOV #0xFDB, W2
006C2C  230C93     MOV #0x30C9, W3
006C2E  022C36     CALL ___mulsf3
006C30  000000     NOP
78:                }
006C32  FA8000     ULNK
006C34  060000     RETURN
79:                float bams32ToFloatDeg(bams32_t b) {
006C36  FA0004     LNK #0x4
006C38  BE8F00     MOV.D W0, [W14]
80:                    return b*BAMS32_TO_DEG;
006C3A  BE001E     MOV.D [W14], W0
006C3C  022624     CALL ___floatsisf
006C3E  000000     NOP
006C40  200002     MOV #0x0, W2
006C42  233B43     MOV #0x33B4, W3
006C44  022C36     CALL ___mulsf3
006C46  000000     NOP
81:                }
006C48  FA8000     ULNK
006C4A  060000     RETURN
82:                bams32_t floatToBams32Rad(float f) {
006C4C  FA0004     LNK #0x4
006C4E  781F88     MOV W8, [W15++]
006C50  BE8F00     MOV.D W0, [W14]
83:                    return (bams32_t) (((f > PI) ? (f - _2PI) : f)*RAD_TO_BAMS32);
006C52  B3C018     MOV #0x1, W8
006C54  20FDB2     MOV #0xFDB, W2
006C56  240493     MOV #0x4049, W3
006C58  BE001E     MOV.D [W14], W0
006C5A  0225A8     CALL ___gtsf2
006C5C  000000     NOP
006C5E  EB0080     CLR W1
006C60  500F81     SUB W0, W1, [W15]
006C62  3C0001     BRA GT, 0x6C66
006C64  EB4400     CLR.B W8
006C66  EB4000     CLR.B W0
006C68  544F80     SUB.B W8, W0, [W15]
006C6A  32000C     BRA Z, 0x6C84
006C6C  20FDB2     MOV #0xFDB, W2
006C6E  240C93     MOV #0x40C9, W3
006C70  BE001E     MOV.D [W14], W0
006C72  022A5A     CALL ___subsf3
006C74  000000     NOP
006C76  2F9832     MOV #0xF983, W2
006C78  24E223     MOV #0x4E22, W3
006C7A  022C36     CALL ___mulsf3
006C7C  000000     NOP
006C7E  0225AC     CALL ___fixsfsi
006C80  000000     NOP
006C82  370007     BRA 0x6C92
006C84  2F9832     MOV #0xF983, W2
006C86  24E223     MOV #0x4E22, W3
006C88  BE001E     MOV.D [W14], W0
006C8A  022C36     CALL ___mulsf3
006C8C  000000     NOP
006C8E  0225AC     CALL ___fixsfsi
006C90  000000     NOP
84:                }
006C92  78044F     MOV [--W15], W8
006C94  FA8000     ULNK
006C96  060000     RETURN
85:                bams32_t floatToBams32Deg(float f) {
006C98  FA0004     LNK #0x4
006C9A  781F88     MOV W8, [W15++]
006C9C  BE8F00     MOV.D W0, [W14]
86:                    return (bams32_t) (((f > 180.0) ? (f - 360.0) : f)*DEG_TO_BAMS32);
006C9E  B3C018     MOV #0x1, W8
006CA0  200002     MOV #0x0, W2
006CA2  243343     MOV #0x4334, W3
006CA4  BE001E     MOV.D [W14], W0
006CA6  0225A8     CALL ___gtsf2
006CA8  000000     NOP
006CAA  EB0080     CLR W1
006CAC  500F81     SUB W0, W1, [W15]
006CAE  3C0001     BRA GT, 0x6CB2
006CB0  EB4400     CLR.B W8
006CB2  EB4000     CLR.B W0
006CB4  544F80     SUB.B W8, W0, [W15]
006CB6  32000C     BRA Z, 0x6CD0
006CB8  200002     MOV #0x0, W2
006CBA  243B43     MOV #0x43B4, W3
006CBC  BE001E     MOV.D [W14], W0
006CBE  022A5A     CALL ___subsf3
006CC0  000000     NOP
006CC2  20B612     MOV #0xB61, W2
006CC4  24B363     MOV #0x4B36, W3
006CC6  022C36     CALL ___mulsf3
006CC8  000000     NOP
006CCA  0225AC     CALL ___fixsfsi
006CCC  000000     NOP
006CCE  370007     BRA 0x6CDE
006CD0  20B612     MOV #0xB61, W2
006CD2  24B363     MOV #0x4B36, W3
006CD4  BE001E     MOV.D [W14], W0
006CD6  022C36     CALL ___mulsf3
006CD8  000000     NOP
006CDA  0225AC     CALL ___fixsfsi
006CDC  000000     NOP
87:                }
006CDE  78044F     MOV [--W15], W8
006CE0  FA8000     ULNK
006CE2  060000     RETURN
88:                 
89:                bams16_t bams32ToBams16(bams32_t b) {            
006CE4  FA0004     LNK #0x4
006CE6  BE8F00     MOV.D W0, [W14]
90:                    return (bams16_t) (b & 0x0080) ? (b >> 16) + 1 : b >> 16;
006CE8  78009E     MOV [W14], W1
006CEA  200800     MOV #0x80, W0
006CEC  608080     AND W1, W0, W1
006CEE  EB0000     CLR W0
006CF0  508F80     SUB W1, W0, [W15]
006CF2  320006     BRA Z, 0x6D00
006CF4  BE001E     MOV.D [W14], W0
006CF6  DE8840     ASR W1, #0, W0
006CF8  DE80CF     ASR W0, #15, W1
006CFA  780000     MOV W0, W0
006CFC  E80000     INC W0, W0
006CFE  370004     BRA 0x6D08
006D00  BE001E     MOV.D [W14], W0
006D02  DE8840     ASR W1, #0, W0
006D04  DE80CF     ASR W0, #15, W1
006D06  780000     MOV W0, W0
91:                }
006D08  FA8000     ULNK
006D0A  060000     RETURN
92:                bams32_t bams16ToBams32(bams16_t b) {
006D0C  FA0002     LNK #0x2
006D0E  780F00     MOV W0, [W14]
93:                    return (bams32_t) b << 16;
006D10  78001E     MOV [W14], W0
006D12  DE80CF     ASR W0, #15, W1
006D14  DD00C0     SL W0, #0, W1
006D16  200000     MOV #0x0, W0
94:                }
006D18  FA8000     ULNK
006D1A  060000     RETURN
95:                 
96:                // Need 2^i + 1 values to cover 0 and pi/4, where i is # index bits
97:                // We shift over 6 bits to get 10 significant bits, which we then use symmetry to
98:                // further segment by 4, bringing us to 8 index bits (2^8 + 1 = 257)
99:                #define SIN_TABLE_SIZE              (257)
100:               #define SIN_SIGBITS_SHIFT           (6)         // Right shift amount to get significant bits
101:               #define SIN_SIGBITS16_UPPER_MASK    (0xFFC0)    // Top 10 bits
102:               #define SIN_SIGBITS16_LOWER_MASK    (0x003F)    // Bottom 6 bits
103:               #define SIN_SIGBITS32_UPPER_MASK    (0xFFC00000)// Top 10 bits
104:               #define SIN_SIGBITS32_LOWER_MASK    (0x003FFFFF)// Bottom 22 bits
105:               #define SIN_FINE_STEP16             (0.015625)
106:               #define SIN_FINE_STEP32             (2.38418579E-7)
107:               const float sin_table[] = {
108:                   0.0, 0.00613588464915, 0.0122715382857, 0.0184067299058, 0.0245412285229, 0.0306748031766, 0.0368072229414, 0.0429382569349, 0.0490676743274, 0.0551952443497, 
109:                   0.0613207363022, 0.0674439195637, 0.0735645635997, 0.0796824379714, 0.0857973123444, 0.0919089564971, 0.0980171403296, 0.104121633872, 0.110222207294, 0.116318630912, 
110:                   0.122410675199, 0.128498110794, 0.134580708507, 0.140658239333, 0.146730474455, 0.152797185258, 0.158858143334, 0.16491312049, 0.17096188876, 0.177004220412, 
111:                   0.183039887955, 0.18906866415, 0.195090322016, 0.201104634842, 0.207111376192, 0.213110319916, 0.219101240157, 0.22508391136, 0.231058108281, 0.237023605994, 
112:                   0.242980179903, 0.248927605746, 0.254865659605, 0.260794117915, 0.266712757475, 0.27262135545, 0.278519689385, 0.284407537211, 0.290284677254, 0.296150888244, 
113:                   0.302005949319, 0.307849640042, 0.313681740399, 0.319502030816, 0.325310292162, 0.33110630576, 0.336889853392, 0.342660717312, 0.348418680249, 0.35416352542, 
114:                   0.359895036535, 0.365612997805, 0.371317193952, 0.377007410216, 0.382683432365, 0.388345046699, 0.393992040061, 0.399624199846, 0.405241314005, 0.410843171058, 
115:                   0.416429560098, 0.4220002708, 0.42755509343, 0.433093818853, 0.438616238539, 0.44412214457, 0.449611329655, 0.455083587126, 0.460538710958, 0.465976495768, 
116:                   0.471396736826, 0.476799230063, 0.482183772079, 0.487550160148, 0.49289819223, 0.498227666973, 0.503538383726, 0.508830142543, 0.514102744193, 0.519355990166, 
117:                   0.524589682678, 0.529803624686, 0.534997619887, 0.54017147273, 0.545324988422, 0.550457972937, 0.55557023302, 0.560661576197, 0.565731810784, 0.570780745887, 
118:                   0.575808191418, 0.580813958096, 0.585797857456, 0.590759701859, 0.595699304492, 0.600616479384, 0.605511041404, 0.610382806276, 0.615231590581, 0.620057211763, 
119:                   0.624859488142, 0.629638238915, 0.634393284164, 0.639124444864, 0.64383154289, 0.648514401022, 0.653172842954, 0.657806693297, 0.66241577759, 0.666999922304, 
120:                   0.671558954847, 0.676092703575, 0.680600997795, 0.685083667773, 0.689540544737, 0.69397146089, 0.698376249409, 0.702754744457, 0.707106781187, 0.711432195745, 
121:                   0.715730825284, 0.720002507961, 0.724247082951, 0.728464390448, 0.732654271672, 0.736816568877, 0.740951125355, 0.745057785441, 0.749136394523, 0.753186799044, 
122:                   0.757208846506, 0.761202385484, 0.765167265622, 0.769103337646, 0.773010453363, 0.776888465673, 0.780737228572, 0.784556597156, 0.788346427627, 0.7921065773, 
123:                   0.795836904609, 0.799537269108, 0.803207531481, 0.806847553544, 0.810457198253, 0.814036329706, 0.817584813152, 0.821102514991, 0.824589302785, 0.828045045258, 
124:                   0.831469612303, 0.834862874986, 0.838224705555, 0.841554977437, 0.84485356525, 0.848120344803, 0.851355193105, 0.854557988365, 0.85772861, 0.860866938638, 
125:                   0.863972856122, 0.867046245516, 0.870086991109, 0.873094978418, 0.876070094195, 0.879012226429, 0.881921264348, 0.884797098431, 0.887639620403, 0.890448723245, 
126:                   0.893224301196, 0.895966249756, 0.898674465694, 0.901348847046, 0.903989293123, 0.906595704515, 0.909167983091, 0.911706032005, 0.914209755704, 0.916679059921, 
127:                   0.91911385169, 0.921514039342, 0.923879532511, 0.926210242138, 0.928506080473, 0.930766961079, 0.932992798835, 0.935183509939, 0.937339011913, 0.939459223602, 
128:                   0.941544065183, 0.943593458162, 0.945607325381, 0.947585591018, 0.949528180593, 0.951435020969, 0.953306040354, 0.955141168306, 0.956940335732, 0.958703474896, 
129:                   0.960430519416, 0.962121404269, 0.963776065795, 0.965394441698, 0.966976471045, 0.968522094274, 0.970031253195, 0.971503890986, 0.972939952206, 0.974339382786, 
130:                   0.975702130039, 0.977028142658, 0.97831737072, 0.979569765685, 0.980785280403, 0.98196386911, 0.983105487431, 0.984210092387, 0.985277642389, 0.986308097245, 
131:                   0.987301418158, 0.988257567731, 0.989176509965, 0.990058210262, 0.990902635428, 0.991709753669, 0.992479534599, 0.993211949235, 0.993906970002, 0.994564570734, 
132:                   0.995184726672, 0.995767414468, 0.996312612183, 0.996820299291, 0.997290456679, 0.997723066644, 0.9981181129, 0.998475580573, 0.998795456205, 0.999077727753, 
133:                   0.999322384588, 0.999529417501, 0.999698818696, 0.999830581796, 0.999924701839, 0.999981175283, 1.0, 0.999981175283
134:               };
135:                
136:               // Quick lookup implementation
137:               // Runs full range at ~43 cycles
138:               float bams16Sin(bams16_t b) {
006D1C  FA0002     LNK #0x2
006D1E  780F00     MOV W0, [W14]
139:                   
140:                   if(b < 0) {
006D20  78009E     MOV [W14], W1
006D22  EB0000     CLR W0
006D24  508F80     SUB W1, W0, [W15]
006D26  3D0012     BRA GE, 0x6D4C
141:                       if(b < -BAMS16_PI_2) {
006D28  2C0000     MOV #0xC000, W0
006D2A  78009E     MOV [W14], W1
006D2C  508F80     SUB W1, W0, [W15]
006D2E  3D0005     BRA GE, 0x6D3A
142:                           b = b - BAMS16_PI;
006D30  78009E     MOV [W14], W1
006D32  280000     MOV #0x8000, W0
006D34  408000     ADD W1, W0, W0
006D36  780F00     MOV W0, [W14]
006D38  370001     BRA 0x6D3C
143:                       } else {
144:                           b = -b;
006D3A  EA0F1E     NEG [W14], [W14]
145:                       }
146:                       return -sin_table[(unsigned int) b >> SIN_SIGBITS_SHIFT];
006D3C  78001E     MOV [W14], W0
006D3E  DE0046     LSR W0, #6, W0
006D40  DD00C2     SL W0, #2, W1
006D42  2B6560     MOV #0xB656, W0
006D44  408000     ADD W1, W0, W0
006D46  BE0010     MOV.D [W0], W0
006D48  A2F001     BTG W1, #15
006D4A  37000E     BRA 0x6D68
147:                   } else {
148:                       if(b > BAMS16_PI_2) {
006D4C  240000     MOV #0x4000, W0
006D4E  78009E     MOV [W14], W1
006D50  508F80     SUB W1, W0, [W15]
006D52  340004     BRA LE, 0x6D5C
149:                           b = BAMS16_PI - b;
006D54  78001E     MOV [W14], W0
006D56  280001     MOV #0x8000, W1
006D58  508000     SUB W1, W0, W0
006D5A  780F00     MOV W0, [W14]
150:                       } else {
151:                           // b = b;
152:                       }
153:                       return sin_table[(unsigned int) b >> SIN_SIGBITS_SHIFT];
006D5C  78001E     MOV [W14], W0
006D5E  DE0046     LSR W0, #6, W0
006D60  DD00C2     SL W0, #2, W1
006D62  2B6560     MOV #0xB656, W0
006D64  408000     ADD W1, W0, W0
006D66  BE0010     MOV.D [W0], W0
154:                   }
155:                   
156:               }
006D68  FA8000     ULNK
006D6A  060000     RETURN
157:               
158:               float bams16Cos(bams16_t b) {
006D6C  FA0002     LNK #0x2
006D6E  780F00     MOV W0, [W14]
159:                   // cos(x) = sin(x + pi/2)        
160:                   return bams16Sin(b + BAMS16_PI_2);
006D70  240000     MOV #0x4000, W0
006D72  40001E     ADD W0, [W14], W0
006D74  07FFD3     RCALL bams16Sin
161:                   
162:               }
006D76  FA8000     ULNK
006D78  060000     RETURN
163:               
164:               // High precision implementation
165:               // Runs full range at ~370 cycles
166:               float bams16SinFine(bams16_t b) {
006D7A  FA000E     LNK #0xE
006D7C  980760     MOV W0, [W14+12]
167:               
168:                   float v0, v1, r;
169:                   
170:                   v0 = bams16Sin(b & SIN_SIGBITS16_UPPER_MASK);
006D7E  9000EE     MOV [W14+12], W1
006D80  2FFC00     MOV #0xFFC0, W0
006D82  608000     AND W1, W0, W0
006D84  07FFCB     RCALL bams16Sin
006D86  BE8F00     MOV.D W0, [W14]
171:                   v1 = bams16Sin((b & SIN_SIGBITS16_UPPER_MASK) + SIN_SIGBITS16_LOWER_MASK + 1);
006D88  9000EE     MOV [W14+12], W1
006D8A  2FFC00     MOV #0xFFC0, W0
006D8C  608000     AND W1, W0, W0
006D8E  B00400     ADD #0x40, W0
006D90  07FFC5     RCALL bams16Sin
006D92  980720     MOV W0, [W14+4]
006D94  980731     MOV W1, [W14+6]
172:                   r = (b & SIN_SIGBITS16_LOWER_MASK)*SIN_FINE_STEP16;    
006D96  9000EE     MOV [W14+12], W1
006D98  2003F0     MOV #0x3F, W0
006D9A  608000     AND W1, W0, W0
006D9C  DE80CF     ASR W0, #15, W1
006D9E  022624     CALL ___floatsisf
006DA0  000000     NOP
006DA2  200002     MOV #0x0, W2
006DA4  23C803     MOV #0x3C80, W3
006DA6  022C36     CALL ___mulsf3
006DA8  000000     NOP
006DAA  980740     MOV W0, [W14+8]
006DAC  980751     MOV W1, [W14+10]
173:                   return v0 + (v1 - v0)*r;
006DAE  BE011E     MOV.D [W14], W2
006DB0  90002E     MOV [W14+4], W0
006DB2  9000BE     MOV [W14+6], W1
006DB4  022A5A     CALL ___subsf3
006DB6  000000     NOP
006DB8  90014E     MOV [W14+8], W2
006DBA  9001DE     MOV [W14+10], W3
006DBC  022C36     CALL ___mulsf3
006DBE  000000     NOP
006DC0  BE011E     MOV.D [W14], W2
006DC2  022A6C     CALL ___addsf3
006DC4  000000     NOP
174:                   
175:               }
006DC6  FA8000     ULNK
006DC8  060000     RETURN
176:               
177:               // High precision implementation
178:               // ~370 cycles
179:               float bams16CosFine(bams16_t b) {
006DCA  FA0002     LNK #0x2
006DCC  780F00     MOV W0, [W14]
180:                
181:                  return bams16SinFine(b + BAMS16_PI_2);
006DCE  240000     MOV #0x4000, W0
006DD0  40001E     ADD W0, [W14], W0
006DD2  07FFD3     RCALL bams16SinFine
182:                
183:               }
006DD4  FA8000     ULNK
006DD6  060000     RETURN
184:               
185:               float bams16Tan(bams16_t b) {
006DD8  FA0002     LNK #0x2
006DDA  BE9F88     MOV.D W8, [W15++]
006DDC  780F00     MOV W0, [W14]
186:                   return bams16Sin(b)/bams16Cos(b);
006DDE  78001E     MOV [W14], W0
006DE0  07FF9D     RCALL bams16Sin
006DE2  BE0400     MOV.D W0, W8
006DE4  78001E     MOV [W14], W0
006DE6  07FFC2     RCALL bams16Cos
006DE8  BE0100     MOV.D W0, W2
006DEA  BE0008     MOV.D W8, W0
006DEC  022E80     CALL ___divsf3x
006DEE  000000     NOP
187:               }
006DF0  BE044F     MOV.D [--W15], W8
006DF2  FA8000     ULNK
006DF4  060000     RETURN
188:               
189:               float bams16TanFine(bams16_t b) {
006DF6  FA0002     LNK #0x2
006DF8  BE9F88     MOV.D W8, [W15++]
006DFA  780F00     MOV W0, [W14]
190:                   return bams16SinFine(b)/bams16CosFine(b);
006DFC  78001E     MOV [W14], W0
006DFE  07FFBD     RCALL bams16SinFine
006E00  BE0400     MOV.D W0, W8
006E02  78001E     MOV [W14], W0
006E04  07FFE2     RCALL bams16CosFine
006E06  BE0100     MOV.D W0, W2
006E08  BE0008     MOV.D W8, W0
006E0A  022E80     CALL ___divsf3x
006E0C  000000     NOP
191:               }
006E0E  BE044F     MOV.D [--W15], W8
006E10  FA8000     ULNK
006E12  060000     RETURN
192:               
193:               float bams32Sin(bams32_t b) {
006E14  FA0004     LNK #0x4
006E16  BE8F00     MOV.D W0, [W14]
194:               
195:                   return bams16Sin(bams32ToBams16(b));
006E18  BE001E     MOV.D [W14], W0
006E1A  07FF64     RCALL bams32ToBams16
006E1C  07FF7F     RCALL bams16Sin
196:               
197:               }
006E1E  FA8000     ULNK
006E20  060000     RETURN
198:               
199:               float bams32Cos(bams32_t b) {
006E22  FA0004     LNK #0x4
006E24  BE8F00     MOV.D W0, [W14]
200:               
201:                   return bams16Cos(bams32ToBams16(b));
006E26  BE001E     MOV.D [W14], W0
006E28  07FF5D     RCALL bams32ToBams16
006E2A  07FFA0     RCALL bams16Cos
202:               
203:               }
006E2C  FA8000     ULNK
006E2E  060000     RETURN
204:               
205:               float bams32SinFine(bams32_t b) {
006E30  FA0010     LNK #0x10
006E32  980760     MOV W0, [W14+12]
006E34  980771     MOV W1, [W14+14]
206:               
207:                   float v0, v1, r;
208:                   
209:                   v0 = bams32Sin(b & SIN_SIGBITS32_UPPER_MASK);
006E36  90016E     MOV [W14+12], W2
006E38  9001FE     MOV [W14+14], W3
006E3A  200000     MOV #0x0, W0
006E3C  2FFC01     MOV #0xFFC0, W1
006E3E  780202     MOV W2, W4
006E40  780103     MOV W3, W2
006E42  780180     MOV W0, W3
006E44  780001     MOV W1, W0
006E46  620203     AND W4, W3, W4
006E48  610000     AND W2, W0, W0
006E4A  200001     MOV #0x0, W1
006E4C  DD00C0     SL W0, #0, W1
006E4E  200000     MOV #0x0, W0
006E50  BE0100     MOV.D W0, W2
006E52  B82061     MUL.UU W4, #1, W0
006E54  710100     IOR W2, W0, W2
006E56  718181     IOR W3, W1, W3
006E58  BE0002     MOV.D W2, W0
006E5A  07FFDC     RCALL bams32Sin
006E5C  BE8F00     MOV.D W0, [W14]
210:                   v1 = bams32Sin((b & SIN_SIGBITS32_UPPER_MASK) + SIN_SIGBITS32_LOWER_MASK + 1);
006E5E  90016E     MOV [W14+12], W2
006E60  9001FE     MOV [W14+14], W3
006E62  200000     MOV #0x0, W0
006E64  2FFC01     MOV #0xFFC0, W1
006E66  780202     MOV W2, W4
006E68  780103     MOV W3, W2
006E6A  780180     MOV W0, W3
006E6C  780001     MOV W1, W0
006E6E  620203     AND W4, W3, W4
006E70  610000     AND W2, W0, W0
006E72  200001     MOV #0x0, W1
006E74  DD00C0     SL W0, #0, W1
006E76  200000     MOV #0x0, W0
006E78  BE0100     MOV.D W0, W2
006E7A  B82061     MUL.UU W4, #1, W0
006E7C  710100     IOR W2, W0, W2
006E7E  718181     IOR W3, W1, W3
006E80  200000     MOV #0x0, W0
006E82  200401     MOV #0x40, W1
006E84  400002     ADD W0, W2, W0
006E86  488083     ADDC W1, W3, W1
006E88  07FFC5     RCALL bams32Sin
006E8A  980720     MOV W0, [W14+4]
006E8C  980731     MOV W1, [W14+6]
211:                   r = (b & SIN_SIGBITS32_LOWER_MASK)*SIN_FINE_STEP32;    
006E8E  90016E     MOV [W14+12], W2
006E90  9001FE     MOV [W14+14], W3
006E92  2FFFF0     MOV #0xFFFF, W0
006E94  2003F1     MOV #0x3F, W1
006E96  780202     MOV W2, W4
006E98  780103     MOV W3, W2
006E9A  780180     MOV W0, W3
006E9C  780001     MOV W1, W0
006E9E  620203     AND W4, W3, W4
006EA0  610000     AND W2, W0, W0
006EA2  200001     MOV #0x0, W1
006EA4  DD00C0     SL W0, #0, W1
006EA6  200000     MOV #0x0, W0
006EA8  BE0100     MOV.D W0, W2
006EAA  B82061     MUL.UU W4, #1, W0
006EAC  710100     IOR W2, W0, W2
006EAE  718181     IOR W3, W1, W3
006EB0  BE0002     MOV.D W2, W0
006EB2  022624     CALL ___floatsisf
006EB4  000000     NOP
006EB6  200002     MOV #0x0, W2
006EB8  234803     MOV #0x3480, W3
006EBA  022C36     CALL ___mulsf3
006EBC  000000     NOP
006EBE  980740     MOV W0, [W14+8]
006EC0  980751     MOV W1, [W14+10]
212:                   return v0 + (v1 - v0)*r;    
006EC2  BE011E     MOV.D [W14], W2
006EC4  90002E     MOV [W14+4], W0
006EC6  9000BE     MOV [W14+6], W1
006EC8  022A5A     CALL ___subsf3
006ECA  000000     NOP
006ECC  90014E     MOV [W14+8], W2
006ECE  9001DE     MOV [W14+10], W3
006ED0  022C36     CALL ___mulsf3
006ED2  000000     NOP
006ED4  BE011E     MOV.D [W14], W2
006ED6  022A6C     CALL ___addsf3
006ED8  000000     NOP
213:               
214:               }
006EDA  FA8000     ULNK
006EDC  060000     RETURN
215:               
216:               float bams32CosFine(bams32_t b) {
006EDE  FA0004     LNK #0x4
006EE0  BE8F00     MOV.D W0, [W14]
217:               
218:                   return bams32SinFine(b + BAMS32_PI_2);
006EE2  200000     MOV #0x0, W0
006EE4  240001     MOV #0x4000, W1
006EE6  40013E     ADD W0, [W14++], W2
006EE8  4881AE     ADDC W1, [W14--], W3
006EEA  BE0002     MOV.D W2, W0
006EEC  07FFA1     RCALL bams32SinFine
219:               
220:               }
006EEE  FA8000     ULNK
006EF0  060000     RETURN
221:               
222:               float bams32Tan(bams32_t b) {
006EF2  FA0004     LNK #0x4
006EF4  BE9F88     MOV.D W8, [W15++]
006EF6  BE8F00     MOV.D W0, [W14]
223:               
224:                   return bams32Sin(b)/bams32Cos(b);
006EF8  BE001E     MOV.D [W14], W0
006EFA  07FF8C     RCALL bams32Sin
006EFC  BE0400     MOV.D W0, W8
006EFE  BE001E     MOV.D [W14], W0
006F00  07FF90     RCALL bams32Cos
006F02  BE0100     MOV.D W0, W2
006F04  BE0008     MOV.D W8, W0
006F06  022E80     CALL ___divsf3x
006F08  000000     NOP
225:               
226:               }
006F0A  BE044F     MOV.D [--W15], W8
006F0C  FA8000     ULNK
006F0E  060000     RETURN
227:               
228:               float bams32TanFine(bams32_t b) {
006F10  FA0004     LNK #0x4
006F12  BE9F88     MOV.D W8, [W15++]
006F14  BE8F00     MOV.D W0, [W14]
229:                   
230:                   return bams32SinFine(b)/bams32CosFine(b);
006F16  BE001E     MOV.D [W14], W0
006F18  07FF8B     RCALL bams32SinFine
006F1A  BE0400     MOV.D W0, W8
006F1C  BE001E     MOV.D [W14], W0
006F1E  07FFDF     RCALL bams32CosFine
006F20  BE0100     MOV.D W0, W2
006F22  BE0008     MOV.D W8, W0
006F24  022E80     CALL ___divsf3x
006F26  000000     NOP
231:                   
232:               }
006F28  BE044F     MOV.D [--W15], W8
006F2A  FA8000     ULNK
006F2C  060000     RETURN
233:               
234:               #define ASIN_TABLE_NUM		(256) // +1 extra value for linear interpolation
235:               #define ASIN_STEP			(255.0)
236:               const bams16_t bams_asin_table[] = {
237:                   0x0, 0x28, 0x51, 0x7a, 0xa3, 0xcc, 0xf5, 0x11e, 0x147, 0x170, 
238:                   0x199, 0x1c2, 0x1eb, 0x213, 0x23c, 0x265, 0x28e, 0x2b7, 0x2e0, 0x309, 
239:                   0x332, 0x35b, 0x384, 0x3ae, 0x3d7, 0x400, 0x429, 0x452, 0x47b, 0x4a4, 
240:                   0x4cd, 0x4f7, 0x520, 0x549, 0x572, 0x59c, 0x5c5, 0x5ee, 0x618, 0x641, 
241:                   0x66a, 0x694, 0x6bd, 0x6e7, 0x710, 0x73a, 0x763, 0x78d, 0x7b7, 0x7e0, 
242:                   0x80a, 0x834, 0x85e, 0x887, 0x8b1, 0x8db, 0x905, 0x92f, 0x959, 0x983, 
243:                   0x9ad, 0x9d7, 0xa01, 0xa2b, 0xa56, 0xa80, 0xaaa, 0xad5, 0xaff, 0xb29, 
244:                   0xb54, 0xb7f, 0xba9, 0xbd4, 0xbff, 0xc29, 0xc54, 0xc7f, 0xcaa, 0xcd5, 
245:                   0xd00, 0xd2b, 0xd56, 0xd81, 0xdad, 0xdd8, 0xe04, 0xe2f, 0xe5b, 0xe86, 
246:                   0xeb2, 0xede, 0xf09, 0xf35, 0xf61, 0xf8d, 0xfb9, 0xfe6, 0x1012, 0x103e, 
247:                   0x106b, 0x1097, 0x10c4, 0x10f0, 0x111d, 0x114a, 0x1177, 0x11a4, 0x11d1, 0x11fe, 
248:                   0x122c, 0x1259, 0x1286, 0x12b4, 0x12e2, 0x130f, 0x133d, 0x136b, 0x1399, 0x13c8, 
249:                   0x13f6, 0x1424, 0x1453, 0x1482, 0x14b0, 0x14df, 0x150e, 0x153d, 0x156c, 0x159c, 
250:                   0x15cb, 0x15fb, 0x162b, 0x165b, 0x168b, 0x16bb, 0x16eb, 0x171b, 0x174c, 0x177d, 
251:                   0x17ae, 0x17df, 0x1810, 0x1841, 0x1873, 0x18a4, 0x18d6, 0x1908, 0x193a, 0x196c, 
252:                   0x199f, 0x19d2, 0x1a04, 0x1a37, 0x1a6b, 0x1a9e, 0x1ad2, 0x1b06, 0x1b3a, 0x1b6e, 
253:                   0x1ba2, 0x1bd7, 0x1c0c, 0x1c41, 0x1c76, 0x1cac, 0x1ce1, 0x1d17, 0x1d4e, 0x1d84, 
254:                   0x1dbb, 0x1df2, 0x1e29, 0x1e61, 0x1e98, 0x1ed1, 0x1f09, 0x1f42, 0x1f7b, 0x1fb4, 
255:                   0x1fed, 0x2027, 0x2062, 0x209c, 0x20d7, 0x2112, 0x214e, 0x218a, 0x21c6, 0x2203, 
256:                   0x2240, 0x227e, 0x22bc, 0x22fa, 0x2339, 0x2378, 0x23b8, 0x23f8, 0x2439, 0x247a, 
257:                   0x24bb, 0x24fe, 0x2540, 0x2584, 0x25c8, 0x260c, 0x2651, 0x2697, 0x26dd, 0x2724, 
258:                   0x276c, 0x27b4, 0x27fe, 0x2848, 0x2892, 0x28de, 0x292b, 0x2978, 0x29c6, 0x2a16, 
259:                   0x2a66, 0x2ab8, 0x2b0a, 0x2b5e, 0x2bb3, 0x2c09, 0x2c61, 0x2cba, 0x2d14, 0x2d70, 
260:                   0x2dce, 0x2e2e, 0x2e8f, 0x2ef3, 0x2f59, 0x2fc1, 0x302c, 0x3099, 0x3109, 0x317d, 
261:                   0x31f4, 0x326f, 0x32ef, 0x3373, 0x33fd, 0x348d, 0x3524, 0x35c4, 0x366e, 0x3724, 
262:                   0x37eb, 0x38c6, 0x39be, 0x3ae4, 0x3c63, 0x4000, 0x3c63 // Extra value for linear interp bounds
263:               
264:               };
265:               
266:               // Standard precision implementation
267:               // 330 cycles
268:               bams16_t bams16Asin(float f) {
006F2E  FA0004     LNK #0x4
006F30  781F88     MOV W8, [W15++]
006F32  BE8F00     MOV.D W0, [W14]
269:                   
270:                   if(f >= 0.0) {
006F34  B3C018     MOV #0x1, W8
006F36  B81160     MUL.UU W2, #0, W2
006F38  BE001E     MOV.D [W14], W0
006F3A  0225A8     CALL ___gtsf2
006F3C  000000     NOP
006F3E  EB0080     CLR W1
006F40  500F81     SUB W0, W1, [W15]
006F42  3D0001     BRA GE, 0x6F46
006F44  EB4400     CLR.B W8
006F46  EB4000     CLR.B W0
006F48  544F80     SUB.B W8, W0, [W15]
006F4A  32000D     BRA Z, 0x6F66
271:                       return bams_asin_table[(unsigned int) (f*ASIN_STEP)];
006F4C  200002     MOV #0x0, W2
006F4E  2437F3     MOV #0x437F, W3
006F50  BE001E     MOV.D [W14], W0
006F52  022C36     CALL ___mulsf3
006F54  000000     NOP
006F56  0225EE     CALL ___fixunssfsi
006F58  000000     NOP
006F5A  780000     MOV W0, W0
006F5C  400080     ADD W0, W0, W1
006F5E  2BA5E0     MOV #0xBA5E, W0
006F60  408000     ADD W1, W0, W0
006F62  780010     MOV [W0], W0
006F64  37000E     BRA 0x6F82
272:                   } else {
273:                       return -bams_asin_table[(unsigned int) (-f*ASIN_STEP)];
006F66  BE001E     MOV.D [W14], W0
006F68  A2F001     BTG W1, #15
006F6A  200002     MOV #0x0, W2
006F6C  2437F3     MOV #0x437F, W3
006F6E  022C36     CALL ___mulsf3
006F70  000000     NOP
006F72  0225EE     CALL ___fixunssfsi
006F74  000000     NOP
006F76  780000     MOV W0, W0
006F78  400080     ADD W0, W0, W1
006F7A  2BA5E0     MOV #0xBA5E, W0
006F7C  408000     ADD W1, W0, W0
006F7E  780010     MOV [W0], W0
006F80  EA0000     NEG W0, W0
274:                   }
275:               }
006F82  78044F     MOV [--W15], W8
006F84  FA8000     ULNK
006F86  060000     RETURN
276:               
277:               bams16_t bams16Acos(float f) {
006F88  FA0004     LNK #0x4
006F8A  781F88     MOV W8, [W15++]
006F8C  BE8F00     MOV.D W0, [W14]
278:               
279:                   if(f >= 0.0) {
006F8E  B3C018     MOV #0x1, W8
006F90  B81160     MUL.UU W2, #0, W2
006F92  BE001E     MOV.D [W14], W0
006F94  0225A8     CALL ___gtsf2
006F96  000000     NOP
006F98  EB0080     CLR W1
006F9A  500F81     SUB W0, W1, [W15]
006F9C  3D0001     BRA GE, 0x6FA0
006F9E  EB4400     CLR.B W8
006FA0  EB4000     CLR.B W0
006FA2  544F80     SUB.B W8, W0, [W15]
006FA4  32000F     BRA Z, 0x6FC4
280:                       return -bams_asin_table[(unsigned int) (f*ASIN_STEP)] + BAMS16_PI_2;
006FA6  200002     MOV #0x0, W2
006FA8  2437F3     MOV #0x437F, W3
006FAA  BE001E     MOV.D [W14], W0
006FAC  022C36     CALL ___mulsf3
006FAE  000000     NOP
006FB0  0225EE     CALL ___fixunssfsi
006FB2  000000     NOP
006FB4  780000     MOV W0, W0
006FB6  400080     ADD W0, W0, W1
006FB8  2BA5E0     MOV #0xBA5E, W0
006FBA  408000     ADD W1, W0, W0
006FBC  780010     MOV [W0], W0
006FBE  240001     MOV #0x4000, W1
006FC0  508000     SUB W1, W0, W0
006FC2  37000F     BRA 0x6FE2
281:                   } else {
282:                       return bams_asin_table[(unsigned int) (-f*ASIN_STEP)] + BAMS16_PI_2;
006FC4  BE001E     MOV.D [W14], W0
006FC6  A2F001     BTG W1, #15
006FC8  200002     MOV #0x0, W2
006FCA  2437F3     MOV #0x437F, W3
006FCC  022C36     CALL ___mulsf3
006FCE  000000     NOP
006FD0  0225EE     CALL ___fixunssfsi
006FD2  000000     NOP
006FD4  780000     MOV W0, W0
006FD6  400080     ADD W0, W0, W1
006FD8  2BA5E0     MOV #0xBA5E, W0
006FDA  408000     ADD W1, W0, W0
006FDC  780090     MOV [W0], W1
006FDE  240000     MOV #0x4000, W0
006FE0  408000     ADD W1, W0, W0
283:                   }
284:               
285:               }
006FE2  78044F     MOV [--W15], W8
006FE4  FA8000     ULNK
006FE6  060000     RETURN
286:               
287:               // High precision implementation
288:               // 1100 cycles
289:               bams16_t bams16AsinFine(float f) {
006FE8  FA0014     LNK #0x14
006FEA  781F88     MOV W8, [W15++]
006FEC  980F00     MOV W0, [W14+16]
006FEE  980F11     MOV W1, [W14+18]
290:               
291:                   float fract, pint;
292:                   unsigned int index;
293:                   bams16_t b1, b2, db;
294:                   
295:                   if(f >= 0.0) {
006FF0  B3C018     MOV #0x1, W8
006FF2  B81160     MUL.UU W2, #0, W2
006FF4  90080E     MOV [W14+16], W0
006FF6  90089E     MOV [W14+18], W1
006FF8  0225A8     CALL ___gtsf2
006FFA  000000     NOP
006FFC  EB0080     CLR W1
006FFE  500F81     SUB W0, W1, [W15]
007000  3D0001     BRA GE, 0x7004
007002  EB4400     CLR.B W8
007004  EB4000     CLR.B W0
007006  544F80     SUB.B W8, W0, [W15]
007008  32002D     BRA Z, 0x7064
296:                       fract = modff(f*ASIN_STEP, &pint);
00700A  200002     MOV #0x0, W2
00700C  2437F3     MOV #0x437F, W3
00700E  90080E     MOV [W14+16], W0
007010  90089E     MOV [W14+18], W1
007012  022C36     CALL ___mulsf3
007014  000000     NOP
007016  47016C     ADD W14, #0xC, W2
007018  0227CC     CALL _modff
00701A  000000     NOP
00701C  BE8F00     MOV.D W0, [W14]
297:                       index = (unsigned int) pint;
00701E  90006E     MOV [W14+12], W0
007020  9000FE     MOV [W14+14], W1
007022  0225EE     CALL ___fixunssfsi
007024  000000     NOP
007026  980720     MOV W0, [W14+4]
298:                       b1 = bams_asin_table[index];
007028  90002E     MOV [W14+4], W0
00702A  400080     ADD W0, W0, W1
00702C  2BA5E0     MOV #0xBA5E, W0
00702E  408000     ADD W1, W0, W0
007030  780090     MOV [W0], W1
007032  980731     MOV W1, [W14+6]
299:                       b2 = bams_asin_table[index + 1];
007034  90002E     MOV [W14+4], W0
007036  E80000     INC W0, W0
007038  400080     ADD W0, W0, W1
00703A  2BA5E0     MOV #0xBA5E, W0
00703C  408000     ADD W1, W0, W0
00703E  780090     MOV [W0], W1
007040  980741     MOV W1, [W14+8]
300:                       db = (unsigned int) (fract*(b2 - b1));
007042  9000CE     MOV [W14+8], W1
007044  90003E     MOV [W14+6], W0
007046  508000     SUB W1, W0, W0
007048  DE80CF     ASR W0, #15, W1
00704A  022624     CALL ___floatsisf
00704C  000000     NOP
00704E  BE011E     MOV.D [W14], W2
007050  022C36     CALL ___mulsf3
007052  000000     NOP
007054  0225EE     CALL ___fixunssfsi
007056  000000     NOP
007058  780000     MOV W0, W0
00705A  980750     MOV W0, [W14+10]
301:                       return b1 + db;
00705C  9000BE     MOV [W14+6], W1
00705E  90005E     MOV [W14+10], W0
007060  408000     ADD W1, W0, W0
007062  37002E     BRA 0x70C0
302:                   } else {
303:                       fract = modff(-f*ASIN_STEP, &pint);
007064  90080E     MOV [W14+16], W0
007066  90089E     MOV [W14+18], W1
007068  A2F001     BTG W1, #15
00706A  200002     MOV #0x0, W2
00706C  2437F3     MOV #0x437F, W3
00706E  022C36     CALL ___mulsf3
007070  000000     NOP
007072  47016C     ADD W14, #0xC, W2
007074  0227CC     CALL _modff
007076  000000     NOP
007078  BE8F00     MOV.D W0, [W14]
304:                       index = (unsigned int) pint;
00707A  90006E     MOV [W14+12], W0
00707C  9000FE     MOV [W14+14], W1
00707E  0225EE     CALL ___fixunssfsi
007080  000000     NOP
007082  980720     MOV W0, [W14+4]
305:                       b1 = bams_asin_table[index];
007084  90002E     MOV [W14+4], W0
007086  400080     ADD W0, W0, W1
007088  2BA5E0     MOV #0xBA5E, W0
00708A  408000     ADD W1, W0, W0
00708C  780090     MOV [W0], W1
00708E  980731     MOV W1, [W14+6]
306:                       b2 = bams_asin_table[index + 1];
007090  90002E     MOV [W14+4], W0
007092  E80000     INC W0, W0
007094  400080     ADD W0, W0, W1
007096  2BA5E0     MOV #0xBA5E, W0
007098  408000     ADD W1, W0, W0
00709A  780090     MOV [W0], W1
00709C  980741     MOV W1, [W14+8]
307:                       db = (unsigned int) (fract*(b2 - b1));
00709E  9000CE     MOV [W14+8], W1
0070A0  90003E     MOV [W14+6], W0
0070A2  508000     SUB W1, W0, W0
0070A4  DE80CF     ASR W0, #15, W1
0070A6  022624     CALL ___floatsisf
0070A8  000000     NOP
0070AA  BE011E     MOV.D [W14], W2
0070AC  022C36     CALL ___mulsf3
0070AE  000000     NOP
0070B0  0225EE     CALL ___fixunssfsi
0070B2  000000     NOP
0070B4  780000     MOV W0, W0
0070B6  980750     MOV W0, [W14+10]
308:                       return -(b1 + db);
0070B8  9000BE     MOV [W14+6], W1
0070BA  90005E     MOV [W14+10], W0
0070BC  408000     ADD W1, W0, W0
0070BE  EA0000     NEG W0, W0
309:                   }
310:                   
311:               }
0070C0  78044F     MOV [--W15], W8
0070C2  FA8000     ULNK
0070C4  060000     RETURN
312:               
313:               bams16_t bams16AcosFine(float f) {
0070C6  FA0014     LNK #0x14
0070C8  781F88     MOV W8, [W15++]
0070CA  980F00     MOV W0, [W14+16]
0070CC  980F11     MOV W1, [W14+18]
314:               
315:                   float fract, pint;
316:                   unsigned int index;
317:                   bams16_t b1, b2, db;
318:                   
319:                   if(f >= 0.0) {
0070CE  B3C018     MOV #0x1, W8
0070D0  B81160     MUL.UU W2, #0, W2
0070D2  90080E     MOV [W14+16], W0
0070D4  90089E     MOV [W14+18], W1
0070D6  0225A8     CALL ___gtsf2
0070D8  000000     NOP
0070DA  EB0080     CLR W1
0070DC  500F81     SUB W0, W1, [W15]
0070DE  3D0001     BRA GE, 0x70E2
0070E0  EB4400     CLR.B W8
0070E2  EB4000     CLR.B W0
0070E4  544F80     SUB.B W8, W0, [W15]
0070E6  32002F     BRA Z, 0x7146
320:                       fract = modff(f*ASIN_STEP, &pint);
0070E8  200002     MOV #0x0, W2
0070EA  2437F3     MOV #0x437F, W3
0070EC  90080E     MOV [W14+16], W0
0070EE  90089E     MOV [W14+18], W1
0070F0  022C36     CALL ___mulsf3
0070F2  000000     NOP
0070F4  47016C     ADD W14, #0xC, W2
0070F6  0227CC     CALL _modff
0070F8  000000     NOP
0070FA  BE8F00     MOV.D W0, [W14]
321:                       index = (unsigned int) pint;
0070FC  90006E     MOV [W14+12], W0
0070FE  9000FE     MOV [W14+14], W1
007100  0225EE     CALL ___fixunssfsi
007102  000000     NOP
007104  980720     MOV W0, [W14+4]
322:                       b1 = bams_asin_table[index];
007106  90002E     MOV [W14+4], W0
007108  400080     ADD W0, W0, W1
00710A  2BA5E0     MOV #0xBA5E, W0
00710C  408000     ADD W1, W0, W0
00710E  780090     MOV [W0], W1
007110  980731     MOV W1, [W14+6]
323:                       b2 = bams_asin_table[index + 1];
007112  90002E     MOV [W14+4], W0
007114  E80000     INC W0, W0
007116  400080     ADD W0, W0, W1
007118  2BA5E0     MOV #0xBA5E, W0
00711A  408000     ADD W1, W0, W0
00711C  780090     MOV [W0], W1
00711E  980741     MOV W1, [W14+8]
324:                       db = (unsigned int) (fract*(b2 - b1));
007120  9000CE     MOV [W14+8], W1
007122  90003E     MOV [W14+6], W0
007124  508000     SUB W1, W0, W0
007126  DE80CF     ASR W0, #15, W1
007128  022624     CALL ___floatsisf
00712A  000000     NOP
00712C  BE011E     MOV.D [W14], W2
00712E  022C36     CALL ___mulsf3
007130  000000     NOP
007132  0225EE     CALL ___fixunssfsi
007134  000000     NOP
007136  780000     MOV W0, W0
007138  980750     MOV W0, [W14+10]
325:                       return -(b1 + db - BAMS16_PI_2);
00713A  9000BE     MOV [W14+6], W1
00713C  90005E     MOV [W14+10], W0
00713E  408000     ADD W1, W0, W0
007140  240001     MOV #0x4000, W1
007142  508000     SUB W1, W0, W0
007144  37002F     BRA 0x71A4
326:                   } else {
327:                       fract = modff(-f*ASIN_STEP, &pint);
007146  90080E     MOV [W14+16], W0
007148  90089E     MOV [W14+18], W1
00714A  A2F001     BTG W1, #15
00714C  200002     MOV #0x0, W2
00714E  2437F3     MOV #0x437F, W3
007150  022C36     CALL ___mulsf3
007152  000000     NOP
007154  47016C     ADD W14, #0xC, W2
007156  0227CC     CALL _modff
007158  000000     NOP
00715A  BE8F00     MOV.D W0, [W14]
328:                       index = (unsigned int) pint;
00715C  90006E     MOV [W14+12], W0
00715E  9000FE     MOV [W14+14], W1
007160  0225EE     CALL ___fixunssfsi
007162  000000     NOP
007164  980720     MOV W0, [W14+4]
329:                       b1 = bams_asin_table[index];
007166  90002E     MOV [W14+4], W0
007168  400080     ADD W0, W0, W1
00716A  2BA5E0     MOV #0xBA5E, W0
00716C  408000     ADD W1, W0, W0
00716E  780090     MOV [W0], W1
007170  980731     MOV W1, [W14+6]
330:                       b2 = bams_asin_table[index + 1];
007172  90002E     MOV [W14+4], W0
007174  E80000     INC W0, W0
007176  400080     ADD W0, W0, W1
007178  2BA5E0     MOV #0xBA5E, W0
00717A  408000     ADD W1, W0, W0
00717C  780090     MOV [W0], W1
00717E  980741     MOV W1, [W14+8]
331:                       db = (unsigned int) (fract*(b2 - b1));
007180  9000CE     MOV [W14+8], W1
007182  90003E     MOV [W14+6], W0
007184  508000     SUB W1, W0, W0
007186  DE80CF     ASR W0, #15, W1
007188  022624     CALL ___floatsisf
00718A  000000     NOP
00718C  BE011E     MOV.D [W14], W2
00718E  022C36     CALL ___mulsf3
007190  000000     NOP
007192  0225EE     CALL ___fixunssfsi
007194  000000     NOP
007196  780000     MOV W0, W0
007198  980750     MOV W0, [W14+10]
332:                       return b1 + db + BAMS16_PI_2;
00719A  9000BE     MOV [W14+6], W1
00719C  90005E     MOV [W14+10], W0
00719E  408080     ADD W1, W0, W1
0071A0  240000     MOV #0x4000, W0
0071A2  408000     ADD W1, W0, W0
333:                   }
334:                   
335:               }
0071A4  78044F     MOV [--W15], W8
0071A6  FA8000     ULNK
0071A8  060000     RETURN
336:               
337:               #define ATAN_TABLE_NUM 	(256)
338:               #define ATAN_STEP		(255.0)
339:               
340:               const bams16_t bams_atan_table[] = {
341:                   0x0, 0x28, 0x51, 0x7a, 0xa3, 0xcc, 0xf5, 0x11e, 0x147, 0x16f, 
342:                   0x198, 0x1c1, 0x1ea, 0x213, 0x23c, 0x264, 0x28d, 0x2b6, 0x2df, 0x307, 
343:                   0x330, 0x359, 0x381, 0x3aa, 0x3d2, 0x3fb, 0x423, 0x44c, 0x474, 0x49d, 
344:                   0x4c5, 0x4ed, 0x516, 0x53e, 0x566, 0x58e, 0x5b6, 0x5de, 0x606, 0x62e, 
345:                   0x656, 0x67e, 0x6a6, 0x6ce, 0x6f6, 0x71d, 0x745, 0x76d, 0x794, 0x7bc, 
346:                   0x7e3, 0x80a, 0x832, 0x859, 0x880, 0x8a7, 0x8ce, 0x8f5, 0x91c, 0x943, 
347:                   0x96a, 0x991, 0x9b7, 0x9de, 0xa04, 0xa2b, 0xa51, 0xa77, 0xa9e, 0xac4, 
348:                   0xaea, 0xb10, 0xb36, 0xb5c, 0xb81, 0xba7, 0xbcd, 0xbf2, 0xc18, 0xc3d, 
349:                   0xc62, 0xc88, 0xcad, 0xcd2, 0xcf7, 0xd1b, 0xd40, 0xd65, 0xd8a, 0xdae, 
350:                   0xdd2, 0xdf7, 0xe1b, 0xe3f, 0xe63, 0xe87, 0xeab, 0xecf, 0xef3, 0xf16, 
351:                   0xf3a, 0xf5d, 0xf80, 0xfa4, 0xfc7, 0xfea, 0x100d, 0x102f, 0x1052, 0x1075, 
352:                   0x1097, 0x10ba, 0x10dc, 0x10fe, 0x1120, 0x1143, 0x1164, 0x1186, 0x11a8, 0x11ca, 
353:                   0x11eb, 0x120d, 0x122e, 0x124f, 0x1270, 0x1291, 0x12b2, 0x12d3, 0x12f4, 0x1314, 
354:                   0x1335, 0x1355, 0x1376, 0x1396, 0x13b6, 0x13d6, 0x13f6, 0x1416, 0x1435, 0x1455, 
355:                   0x1474, 0x1494, 0x14b3, 0x14d2, 0x14f1, 0x1510, 0x152f, 0x154e, 0x156d, 0x158b, 
356:                   0x15aa, 0x15c8, 0x15e6, 0x1604, 0x1622, 0x1640, 0x165e, 0x167c, 0x1699, 0x16b7, 
357:                   0x16d4, 0x16f2, 0x170f, 0x172c, 0x1749, 0x1766, 0x1782, 0x179f, 0x17bc, 0x17d8, 
358:                   0x17f5, 0x1811, 0x182d, 0x1849, 0x1865, 0x1881, 0x189d, 0x18b8, 0x18d4, 0x18ef, 
359:                   0x190b, 0x1926, 0x1941, 0x195c, 0x1977, 0x1992, 0x19ad, 0x19c7, 0x19e2, 0x19fc, 
360:                   0x1a17, 0x1a31, 0x1a4b, 0x1a65, 0x1a7f, 0x1a99, 0x1ab3, 0x1acc, 0x1ae6, 0x1aff, 
361:                   0x1b19, 0x1b32, 0x1b4b, 0x1b64, 0x1b7d, 0x1b96, 0x1baf, 0x1bc8, 0x1be0, 0x1bf9, 
362:                   0x1c11, 0x1c2a, 0x1c42, 0x1c5a, 0x1c72, 0x1c8a, 0x1ca2, 0x1cba, 0x1cd1, 0x1ce9, 
363:                   0x1d00, 0x1d18, 0x1d2f, 0x1d46, 0x1d5d, 0x1d74, 0x1d8b, 0x1da2, 0x1db9, 0x1dd0, 
364:                   0x1de6, 0x1dfd, 0x1e13, 0x1e2a, 0x1e40, 0x1e56, 0x1e6c, 0x1e82, 0x1e98, 0x1eae, 
365:                   0x1ec4, 0x1ed9, 0x1eef, 0x1f04, 0x1f1a, 0x1f2f, 0x1f44, 0x1f59, 0x1f6e, 0x1f83, 
366:                   0x1f98, 0x1fad, 0x1fc2, 0x1fd6, 0x1feb, 0x2000
367:               };
368:               
369:               // Standard implementation
370:               // 1000 cycles
371:               bams16_t bams16Atan2(float y, float x) {
0071AA  FA0012     LNK #0x12
0071AC  781F88     MOV W8, [W15++]
0071AE  980750     MOV W0, [W14+10]
0071B0  980761     MOV W1, [W14+12]
0071B2  980772     MOV W2, [W14+14]
0071B4  980F03     MOV W3, [W14+16]
372:                   
373:                   float div;
374:                   unsigned char yneg, xneg, invert, temp;
375:                   bams16_t b;
376:                   
377:                   yneg = y < 0.0;
0071B6  B3C018     MOV #0x1, W8
0071B8  B81160     MUL.UU W2, #0, W2
0071BA  90005E     MOV [W14+10], W0
0071BC  9000EE     MOV [W14+12], W1
0071BE  0225A4     CALL ___lesf2
0071C0  000000     NOP
0071C2  EB0080     CLR W1
0071C4  500F81     SUB W0, W1, [W15]
0071C6  350001     BRA LT, 0x71CA
0071C8  EB4400     CLR.B W8
0071CA  984748     MOV.B W8, [W14+4]
378:                   xneg = x < 0.0;
0071CC  B3C018     MOV #0x1, W8
0071CE  B81160     MUL.UU W2, #0, W2
0071D0  90007E     MOV [W14+14], W0
0071D2  90088E     MOV [W14+16], W1
0071D4  0225A4     CALL ___lesf2
0071D6  000000     NOP
0071D8  EB0080     CLR W1
0071DA  500F81     SUB W0, W1, [W15]
0071DC  350001     BRA LT, 0x71E0
0071DE  EB4400     CLR.B W8
0071E0  984758     MOV.B W8, [W14+5]
379:                   
380:                   y = (yneg) ? -y : y;
0071E2  9040CE     MOV.B [W14+4], W1
0071E4  EB4000     CLR.B W0
0071E6  50CF80     SUB.B W1, W0, [W15]
0071E8  320004     BRA Z, 0x71F2
0071EA  90005E     MOV [W14+10], W0
0071EC  9000EE     MOV [W14+12], W1
0071EE  A2F001     BTG W1, #15
0071F0  370002     BRA 0x71F6
0071F2  90005E     MOV [W14+10], W0
0071F4  9000EE     MOV [W14+12], W1
0071F6  980750     MOV W0, [W14+10]
0071F8  980761     MOV W1, [W14+12]
381:                   x = (xneg) ? -x : x;
0071FA  9040DE     MOV.B [W14+5], W1
0071FC  EB4000     CLR.B W0
0071FE  50CF80     SUB.B W1, W0, [W15]
007200  320004     BRA Z, 0x720A
007202  90007E     MOV [W14+14], W0
007204  90088E     MOV [W14+16], W1
007206  A2F001     BTG W1, #15
007208  370002     BRA 0x720E
00720A  90007E     MOV [W14+14], W0
00720C  90088E     MOV [W14+16], W1
00720E  980770     MOV W0, [W14+14]
007210  980F01     MOV W1, [W14+16]
382:                   
383:                   // Add pi/2 to tan argument and flip the tan
384:                   // This lets us use a quarter table
385:                   if(y > x) {
007212  B3C018     MOV #0x1, W8
007214  90017E     MOV [W14+14], W2
007216  90098E     MOV [W14+16], W3
007218  90005E     MOV [W14+10], W0
00721A  9000EE     MOV [W14+12], W1
00721C  0225A8     CALL ___gtsf2
00721E  000000     NOP
007220  EB0080     CLR W1
007222  500F81     SUB W0, W1, [W15]
007224  3C0001     BRA GT, 0x7228
007226  EB4400     CLR.B W8
007228  EB4000     CLR.B W0
00722A  544F80     SUB.B W8, W0, [W15]
00722C  320010     BRA Z, 0x724E
386:                       div = x/y;
00722E  90015E     MOV [W14+10], W2
007230  9001EE     MOV [W14+12], W3
007232  90007E     MOV [W14+14], W0
007234  90088E     MOV [W14+16], W1
007236  022E80     CALL ___divsf3x
007238  000000     NOP
00723A  BE8F00     MOV.D W0, [W14]
387:                       temp = yneg;
00723C  90404E     MOV.B [W14+4], W0
00723E  984770     MOV.B W0, [W14+7]
388:                       yneg = xneg;
007240  9040DE     MOV.B [W14+5], W1
007242  984741     MOV.B W1, [W14+4]
389:                       xneg = temp;
007244  90407E     MOV.B [W14+7], W0
007246  984750     MOV.B W0, [W14+5]
390:                       invert = 1;
007248  B3C010     MOV #0x1, W0
00724A  984760     MOV.B W0, [W14+6]
00724C  370009     BRA 0x7260
391:                   } else {
392:                       div = y/x;
00724E  90017E     MOV [W14+14], W2
007250  90098E     MOV [W14+16], W3
007252  90005E     MOV [W14+10], W0
007254  9000EE     MOV [W14+12], W1
007256  022E80     CALL ___divsf3x
007258  000000     NOP
00725A  BE8F00     MOV.D W0, [W14]
393:                       invert = 0;
00725C  EB4000     CLR.B W0
00725E  984760     MOV.B W0, [W14+6]
394:                   }
395:                   
396:                   b = bams_atan_table[(unsigned int) (div*ATAN_STEP)];
007260  200002     MOV #0x0, W2
007262  2437F3     MOV #0x437F, W3
007264  BE001E     MOV.D [W14], W0
007266  022C36     CALL ___mulsf3
007268  000000     NOP
00726A  0225EE     CALL ___fixunssfsi
00726C  000000     NOP
00726E  780000     MOV W0, W0
007270  400080     ADD W0, W0, W1
007272  2BC600     MOV #0xBC60, W0
007274  408000     ADD W1, W0, W0
007276  780090     MOV [W0], W1
007278  980741     MOV W1, [W14+8]
397:                   b = (xneg) ? BAMS16_PI - b : b;
00727A  9040DE     MOV.B [W14+5], W1
00727C  EB4000     CLR.B W0
00727E  50CF80     SUB.B W1, W0, [W15]
007280  320004     BRA Z, 0x728A
007282  90004E     MOV [W14+8], W0
007284  280001     MOV #0x8000, W1
007286  508000     SUB W1, W0, W0
007288  370001     BRA 0x728C
00728A  90004E     MOV [W14+8], W0
00728C  980740     MOV W0, [W14+8]
398:                   b = (yneg) ? -b : b;
00728E  9040CE     MOV.B [W14+4], W1
007290  EB4000     CLR.B W0
007292  50CF80     SUB.B W1, W0, [W15]
007294  320003     BRA Z, 0x729C
007296  90004E     MOV [W14+8], W0
007298  EA0000     NEG W0, W0
00729A  370001     BRA 0x729E
00729C  90004E     MOV [W14+8], W0
00729E  980740     MOV W0, [W14+8]
399:                   return (invert) ? -b + BAMS16_PI_2 : b;
0072A0  9040EE     MOV.B [W14+6], W1
0072A2  EB4000     CLR.B W0
0072A4  50CF80     SUB.B W1, W0, [W15]
0072A6  320004     BRA Z, 0x72B0
0072A8  240001     MOV #0x4000, W1
0072AA  90004E     MOV [W14+8], W0
0072AC  508000     SUB W1, W0, W0
0072AE  370001     BRA 0x72B2
0072B0  90004E     MOV [W14+8], W0
400:                   
401:               }
0072B2  78044F     MOV [--W15], W8
0072B4  FA8000     ULNK
0072B6  060000     RETURN
---  C:/Users/Cameron/Documents/Git/imageproc-lib/attitude.c  -------------------------------------------
1:                 /**
2:                  * Copyright (c) 2010-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Orientation Estimation Module (Quaternion and Binary Angle Representation)
31:                 *
32:                 *  by Humphrey Hu
33:                 *  v.0.4
34:                 *
35:                 *
36:                 * Revision History:
37:                 *  Humphrey Hu         2011-10-08      Initial release
38:                 *  Humphrey Hu         2011-12-06      Code refactor
39:                 *  Humphrey Hu         2012-02-16      Updated interface to use objects
40:                 */
41:                
42:                #include "stopwatch.h"
43:                #include "attitude.h"
44:                #include "quat.h"
45:                #include "xl.h"
46:                #include "gyro.h"
47:                #include <math.h>
48:                #include "bams.h"
49:                #include <stdlib.h>
50:                #include <string.h>
51:                #include "utils.h"
52:                
53:                #define QUAT_POLE_LIMIT         (0.499)
54:                #define PI                  (3.14159265)
55:                #define PI_2                (1.57079633)
56:                #define GRAVITY             (9.80665)   // Gravitational acceleration
57:                #define GRAVITY_SQUARED         (96.1703842)
58:                
59:                #define SCALE_CALIB_SAMPLES     (100)
60:                
61:                // =========== Static Variables ===============================================
62:                
63:                // State variables
64:                // Orientation is represented internally as a quaternion
65:                static Quaternion pose_quat;
66:                static unsigned char is_ready, is_running;
67:                
68:                // Attitude estimate terms
69:                static bams16_t phi;
70:                static bams16_t theta;
71:                static bams16_t psi;
72:                static unsigned long timestamp;
73:                
74:                //static float xl_scale;
75:                
76:                // Calculation parameters
77:                static float sample_period = 0;
78:                
79:                // =========== Function Prototypes ============================================
80:                
81:                static void calculateEulerAngles(void);
82:                //static void compensateDrift(void);
83:                //static void measureXLScale(unsigned int num_samples);
84:                
85:                // =========== Public Functions ===============================================
86:                
87:                void attSetup(float ts) {    
008A42  FA0004     LNK #0x4
008A44  BE8F00     MOV.D W0, [W14]
88:                
89:                    sample_period = ts;        
008A46  BE001E     MOV.D [W14], W0
008A48  890710     MOV W0, sample_period
008A4A  890721     MOV W1, 0x20E4
90:                    xlReadXYZ();
008A4C  02B464     CALL xlReadXYZ
008A4E  000000     NOP
91:                    attZero();
008A50  070078     RCALL attZero
92:                    is_ready = 1;
008A52  220D61     MOV #0x20D6, W1
008A54  B3C010     MOV #0x1, W0
008A56  784880     MOV.B W0, [W1]
93:                    attReset();
008A58  070008     RCALL attReset
94:                    
95:                    is_running = 0;
008A5A  220D71     MOV #0x20D7, W1
008A5C  EB4000     CLR.B W0
008A5E  784880     MOV.B W0, [W1]
96:                    is_ready = 1;
008A60  220D61     MOV #0x20D6, W1
008A62  B3C010     MOV #0x1, W0
008A64  784880     MOV.B W0, [W1]
97:                }
008A66  FA8000     ULNK
008A68  060000     RETURN
98:                
99:                void attReset(void) {
008A6A  FA0000     LNK #0x0
100:               
101:                   if(!is_ready) { return; }
008A6C  220D60     MOV #0x20D6, W0
008A6E  784090     MOV.B [W0], W1
008A70  EB4000     CLR.B W0
008A72  50CF80     SUB.B W1, W0, [W15]
008A74  320014     BRA Z, 0x8A9E
008A9E  000000     NOP
102:               
103:                   pose_quat.w = 1.0;
008A76  200000     MOV #0x0, W0
008A78  23F801     MOV #0x3F80, W1
008A7A  890630     MOV W0, pose_quat
008A7C  890641     MOV W1, 0x20C8
104:                   pose_quat.x = 0.0;
008A7E  B80060     MUL.UU W0, #0, W0
008A80  890650     MOV W0, 0x20CA
008A82  890661     MOV W1, 0x20CC
105:                   pose_quat.y = 0.0;
008A84  B80060     MUL.UU W0, #0, W0
008A86  890670     MOV W0, 0x20CE
008A88  890681     MOV W1, 0x20D0
106:                   pose_quat.z = 0.0;
008A8A  B80060     MUL.UU W0, #0, W0
008A8C  890690     MOV W0, 0x20D2
008A8E  8906A1     MOV W1, 0x20D4
107:               
108:                   phi = 0.0;
008A90  EB0000     CLR W0
008A92  8906C0     MOV W0, phi
109:                   theta = 0.0;
008A94  EB0000     CLR W0
008A96  8906D0     MOV W0, theta
110:                   psi = 0.0;
008A98  EB0000     CLR W0
008A9A  8906E0     MOV W0, psi
008A9C  370001     BRA 0x8AA0
111:               
112:               }
008AA0  FA8000     ULNK
008AA2  060000     RETURN
113:               
114:               bams16_t attGetPitchBAMS(void) {
008AA4  FA0000     LNK #0x0
115:                   return theta;
008AA6  8106D0     MOV theta, W0
116:               }
008AA8  FA8000     ULNK
008AAA  060000     RETURN
117:               
118:               bams16_t attGetRollBAMS(void) {
008AAC  FA0000     LNK #0x0
119:                   return phi;
008AAE  8106C0     MOV phi, W0
120:               }
008AB0  FA8000     ULNK
008AB2  060000     RETURN
121:               
122:               bams16_t attGetYawBAMS(void) {
008AB4  FA0000     LNK #0x0
123:                   return psi;
008AB6  8106E0     MOV psi, W0
124:               }
008AB8  FA8000     ULNK
008ABA  060000     RETURN
125:               
126:               void attGetQuat(Quaternion *quat) {
008ABC  FA0002     LNK #0x2
008ABE  780F00     MOV W0, [W14]
127:               
128:                   memcpy(quat, &pose_quat, sizeof(Quaternion));    
008AC0  200102     MOV #0x10, W2
008AC2  220C61     MOV #0x20C6, W1
008AC4  78001E     MOV [W14], W0
008AC6  023582     CALL _memcpy
008AC8  000000     NOP
129:               
130:               }
008ACA  FA8000     ULNK
008ACC  060000     RETURN
131:               
132:               void attGetPose(PoseEstimate pose) {
008ACE  FA0002     LNK #0x2
008AD0  780F00     MOV W0, [W14]
133:                   pose->yaw = bams16ToFloatRad(psi);
008AD2  8106E0     MOV psi, W0
008AD4  026B50     CALL bams16ToFloatRad
008AD6  000000     NOP
008AD8  78011E     MOV [W14], W2
008ADA  BE8900     MOV.D W0, [W2]
134:                   pose->pitch = bams16ToFloatRad(theta);
008ADC  8106D0     MOV theta, W0
008ADE  026B50     CALL bams16ToFloatRad
008AE0  000000     NOP
008AE2  78011E     MOV [W14], W2
008AE4  980120     MOV W0, [W2+4]
008AE6  980131     MOV W1, [W2+6]
135:                   pose->roll = bams16ToFloatRad(phi);
008AE8  8106C0     MOV phi, W0
008AEA  026B50     CALL bams16ToFloatRad
008AEC  000000     NOP
008AEE  78011E     MOV [W14], W2
008AF0  980140     MOV W0, [W2+8]
008AF2  980151     MOV W1, [W2+10]
136:                   pose->timestamp = timestamp;
008AF4  8106F0     MOV timestamp, W0
008AF6  810701     MOV 0x20E0, W1
008AF8  78011E     MOV [W14], W2
008AFA  980160     MOV W0, [W2+12]
008AFC  980171     MOV W1, [W2+14]
137:               }
008AFE  FA8000     ULNK
008B00  060000     RETURN
138:               
139:               unsigned char attIsRunning(void) {
008B02  FA0000     LNK #0x0
140:                   return is_running;
008B04  220D70     MOV #0x20D7, W0
008B06  784010     MOV.B [W0], W0
141:               }
008B08  FA8000     ULNK
008B0A  060000     RETURN
142:               
143:               void attSetRunning(unsigned char flag) {
008B0C  FA0002     LNK #0x2
008B0E  784F00     MOV.B W0, [W14]
144:                   if(flag == 0) { attStop(); }
008B10  78409E     MOV.B [W14], W1
008B12  EB4000     CLR.B W0
008B14  50CF80     SUB.B W1, W0, [W15]
008B16  3A0002     BRA NZ, 0x8B1C
008B18  07000E     RCALL attStop
008B1A  370005     BRA 0x8B26
145:                   else if(flag == 1) { attStart(); }
008B1C  78409E     MOV.B [W14], W1
008B1E  B3C010     MOV #0x1, W0
008B20  50CF80     SUB.B W1, W0, [W15]
008B22  3A0001     BRA NZ, 0x8B26
008B24  070002     RCALL attStart
146:               }
008B26  FA8000     ULNK
008B28  060000     RETURN
147:               
148:               void attStart(void) {
008B2A  FA0000     LNK #0x0
149:                   is_running = 1;
008B2C  220D71     MOV #0x20D7, W1
008B2E  B3C010     MOV #0x1, W0
008B30  784880     MOV.B W0, [W1]
150:               }
008B32  FA8000     ULNK
008B34  060000     RETURN
151:               
152:               void attStop(void) {
008B36  FA0000     LNK #0x0
153:                   is_running = 0;
008B38  220D71     MOV #0x20D7, W1
008B3A  EB4000     CLR.B W0
008B3C  784880     MOV.B W0, [W1]
154:               }
008B3E  FA8000     ULNK
008B40  060000     RETURN
155:               
156:               
157:               // TODO: Fix!
158:               void attZero(void) {
008B42  FA001A     LNK #0x1A
008B44  BE9F88     MOV.D W8, [W15++]
159:               
160:                   float gxy, sina_2, xl[3], temp;
161:                   bams16_t a_2;
162:               
163:                   xlGetFloatXYZ(xl);
008B46  47006E     ADD W14, #0xE, W0
008B48  02B3A6     CALL xlGetFloatXYZ
008B4A  000000     NOP
164:               
165:                   // Convert frames so that z axis is oriented upwards, x is forward, y is side
166:                   xl[2] = -xl[2];
008B4C  47006E     ADD W14, #0xE, W0
008B4E  9000D0     MOV [W0+10], W1
008B50  900040     MOV [W0+8], W0
008B52  A2F001     BTG W1, #15
008B54  47016E     ADD W14, #0xE, W2
008B56  980140     MOV W0, [W2+8]
008B58  980151     MOV W1, [W2+10]
167:                   temp = xl[0];
008B5A  47006E     ADD W14, #0xE, W0
008B5C  781F30     MOV [W0++], [W14++]
008B5E  781720     MOV [W0--], [W14--]
168:                   xl[0] = -xl[1];
008B60  47006E     ADD W14, #0xE, W0
008B62  9000B0     MOV [W0+6], W1
008B64  900020     MOV [W0+4], W0
008B66  A2F001     BTG W1, #15
008B68  47016E     ADD W14, #0xE, W2
008B6A  BE8900     MOV.D W0, [W2]
169:                   xl[1] = temp;
008B6C  47006E     ADD W14, #0xE, W0
008B6E  BE011E     MOV.D [W14], W2
008B70  980022     MOV W2, [W0+4]
008B72  980033     MOV W3, [W0+6]
170:               
171:                   gxy = sqrtf(xl[0]*xl[0] + xl[1]*xl[1]);
008B74  47006E     ADD W14, #0xE, W0
008B76  BE0210     MOV.D [W0], W4
008B78  47006E     ADD W14, #0xE, W0
008B7A  BE0010     MOV.D [W0], W0
008B7C  BE0100     MOV.D W0, W2
008B7E  BE0004     MOV.D W4, W0
008B80  022C36     CALL ___mulsf3
008B82  000000     NOP
008B84  BE0400     MOV.D W0, W8
008B86  47006E     ADD W14, #0xE, W0
008B88  900220     MOV [W0+4], W4
008B8A  9002B0     MOV [W0+6], W5
008B8C  47006E     ADD W14, #0xE, W0
008B8E  9000B0     MOV [W0+6], W1
008B90  900020     MOV [W0+4], W0
008B92  BE0100     MOV.D W0, W2
008B94  BE0004     MOV.D W4, W0
008B96  022C36     CALL ___mulsf3
008B98  000000     NOP
008B9A  BE0100     MOV.D W0, W2
008B9C  BE0008     MOV.D W8, W0
008B9E  022A6C     CALL ___addsf3
008BA0  000000     NOP
008BA2  023050     CALL _sqrtfx
008BA4  000000     NOP
008BA6  980720     MOV W0, [W14+4]
008BA8  980731     MOV W1, [W14+6]
172:                   a_2 = (BAMS16_PI_2 + bams16Atan2(xl[2], gxy))/2;
008BAA  47006E     ADD W14, #0xE, W0
008BAC  9000D0     MOV [W0+10], W1
008BAE  900040     MOV [W0+8], W0
008BB0  90012E     MOV [W14+4], W2
008BB2  9001BE     MOV [W14+6], W3
008BB4  0271AA     CALL bams16Atan2
008BB6  000000     NOP
008BB8  240001     MOV #0x4000, W1
008BBA  400081     ADD W0, W1, W1
008BBC  200020     MOV #0x2, W0
008BBE  780180     MOV W0, W3
008BC0  090011     REPEAT #0x11
008BC2  D80083     DIV.SW W1, W3
008BC4  980740     MOV W0, [W14+8]
173:                   sina_2 = bams16SinFine(a_2);
008BC6  90004E     MOV [W14+8], W0
008BC8  026D7A     CALL bams16SinFine
008BCA  000000     NOP
008BCC  980750     MOV W0, [W14+10]
008BCE  980761     MOV W1, [W14+12]
174:               
175:                   pose_quat.w = bams16CosFine(a_2)*gxy;
008BD0  90004E     MOV [W14+8], W0
008BD2  026DCA     CALL bams16CosFine
008BD4  000000     NOP
008BD6  90012E     MOV [W14+4], W2
008BD8  9001BE     MOV [W14+6], W3
008BDA  022C36     CALL ___mulsf3
008BDC  000000     NOP
008BDE  890630     MOV W0, pose_quat
008BE0  890641     MOV W1, 0x20C8
176:                   pose_quat.x = sina_2*(-xl[1]);
008BE2  47006E     ADD W14, #0xE, W0
008BE4  9000B0     MOV [W0+6], W1
008BE6  900020     MOV [W0+4], W0
008BE8  A2F001     BTG W1, #15
008BEA  90015E     MOV [W14+10], W2
008BEC  9001EE     MOV [W14+12], W3
008BEE  022C36     CALL ___mulsf3
008BF0  000000     NOP
008BF2  890650     MOV W0, 0x20CA
008BF4  890661     MOV W1, 0x20CC
177:                   pose_quat.y = sina_2*(xl[0]);
008BF6  47006E     ADD W14, #0xE, W0
008BF8  BE0010     MOV.D [W0], W0
008BFA  90015E     MOV [W14+10], W2
008BFC  9001EE     MOV [W14+12], W3
008BFE  022C36     CALL ___mulsf3
008C00  000000     NOP
008C02  890670     MOV W0, 0x20CE
008C04  890681     MOV W1, 0x20D0
178:                   pose_quat.z = 0.0;
008C06  B80060     MUL.UU W0, #0, W0
008C08  890690     MOV W0, 0x20D2
008C0A  8906A1     MOV W1, 0x20D4
179:                   quatNormalize(&pose_quat);
008C0C  220C60     MOV #0x20C6, W0
008C0E  02A72C     CALL quatNormalize
008C10  000000     NOP
180:               
181:               }
008C12  BE044F     MOV.D [--W15], W8
008C14  FA8000     ULNK
008C16  060000     RETURN
182:               
183:               // 3750 cycles
184:               void attEstimatePose(void) {
008C18  FA002C     LNK #0x2C
008C1A  BE9F88     MOV.D W8, [W15++]
185:               
186:                   Quaternion displacement_quat;
187:                   float rate[3], norm, sina_2, square_sum;
188:                   bams32_t a_2;
189:               
190:                   if(!is_ready) { return; }
008C1C  220D60     MOV #0x20D6, W0
008C1E  784090     MOV.B [W0], W1
008C20  EB4000     CLR.B W0
008C22  50CF80     SUB.B W1, W0, [W15]
008C24  3200A0     BRA Z, 0x8D66
008D66  000000     NOP
008D68  370001     BRA 0x8D6C
191:                   if(!is_running) { return; }
008C26  220D70     MOV #0x20D7, W0
008C28  784090     MOV.B [W0], W1
008C2A  EB4000     CLR.B W0
008C2C  50CF80     SUB.B W1, W0, [W15]
008C2E  32009D     BRA Z, 0x8D6A
008D6A  000000     NOP
192:               
193:                   gyroGetRadXYZ(rate);    // Get last read gyro values
008C30  200200     MOV #0x20, W0
008C32  40000E     ADD W0, W14, W0
008C34  029688     CALL gyroGetRadXYZ
008C36  000000     NOP
194:                   //rate[1] = -rate[1];     // Reorient axes
195:                   //rate[2] = -rate[2];
196:               
197:                   //timestamp = swatchToc(); // Record timestamp
198:               
199:                   // Calculate magnitude and disiplacement
200:                   square_sum = rate[0]*rate[0] + rate[1]*rate[1] + rate[2]*rate[2];
008C38  200200     MOV #0x20, W0
008C3A  40000E     ADD W0, W14, W0
008C3C  BE0210     MOV.D [W0], W4
008C3E  200200     MOV #0x20, W0
008C40  40000E     ADD W0, W14, W0
008C42  BE0010     MOV.D [W0], W0
008C44  BE0100     MOV.D W0, W2
008C46  BE0004     MOV.D W4, W0
008C48  022C36     CALL ___mulsf3
008C4A  000000     NOP
008C4C  BE0400     MOV.D W0, W8
008C4E  200200     MOV #0x20, W0
008C50  40000E     ADD W0, W14, W0
008C52  900220     MOV [W0+4], W4
008C54  9002B0     MOV [W0+6], W5
008C56  200200     MOV #0x20, W0
008C58  40000E     ADD W0, W14, W0
008C5A  9000B0     MOV [W0+6], W1
008C5C  900020     MOV [W0+4], W0
008C5E  BE0100     MOV.D W0, W2
008C60  BE0004     MOV.D W4, W0
008C62  022C36     CALL ___mulsf3
008C64  000000     NOP
008C66  BE0100     MOV.D W0, W2
008C68  BE0008     MOV.D W8, W0
008C6A  022A6C     CALL ___addsf3
008C6C  000000     NOP
008C6E  BE0400     MOV.D W0, W8
008C70  200200     MOV #0x20, W0
008C72  40000E     ADD W0, W14, W0
008C74  900240     MOV [W0+8], W4
008C76  9002D0     MOV [W0+10], W5
008C78  200200     MOV #0x20, W0
008C7A  40000E     ADD W0, W14, W0
008C7C  9000D0     MOV [W0+10], W1
008C7E  900040     MOV [W0+8], W0
008C80  BE0100     MOV.D W0, W2
008C82  BE0004     MOV.D W4, W0
008C84  022C36     CALL ___mulsf3
008C86  000000     NOP
008C88  BE0100     MOV.D W0, W2
008C8A  BE0008     MOV.D W8, W0
008C8C  022A6C     CALL ___addsf3
008C8E  000000     NOP
008C90  BE8F00     MOV.D W0, [W14]
201:               
202:                   // Special case when no movement
203:                   if(square_sum == 0.0) {
008C92  B81160     MUL.UU W2, #0, W2
008C94  BE001E     MOV.D [W14], W0
008C96  0225A4     CALL ___lesf2
008C98  000000     NOP
008C9A  EB0080     CLR W1
008C9C  500F81     SUB W0, W1, [W15]
008C9E  3A0011     BRA NZ, 0x8CC2
204:               
205:                       displacement_quat.w = 1.0;
008CA0  470170     ADD W14, #0x10, W2
008CA2  200000     MOV #0x0, W0
008CA4  23F801     MOV #0x3F80, W1
008CA6  BE8900     MOV.D W0, [W2]
206:                       displacement_quat.x = 0.0;
008CA8  470170     ADD W14, #0x10, W2
008CAA  B80060     MUL.UU W0, #0, W0
008CAC  980120     MOV W0, [W2+4]
008CAE  980131     MOV W1, [W2+6]
207:                       displacement_quat.y = 0.0;
008CB0  470170     ADD W14, #0x10, W2
008CB2  B80060     MUL.UU W0, #0, W0
008CB4  980140     MOV W0, [W2+8]
008CB6  980151     MOV W1, [W2+10]
208:                       displacement_quat.z = 0.0;
008CB8  470170     ADD W14, #0x10, W2
008CBA  B80060     MUL.UU W0, #0, W0
008CBC  980160     MOV W0, [W2+12]
008CBE  980171     MOV W1, [W2+14]
008CC0  370048     BRA 0x8D52
209:               
210:                   } else {
211:               
212:                       norm = sqrtf(square_sum);
008CC2  BE001E     MOV.D [W14], W0
008CC4  023050     CALL _sqrtfx
008CC6  000000     NOP
008CC8  980720     MOV W0, [W14+4]
008CCA  980731     MOV W1, [W14+6]
213:                       // Generate displacement rotation quaternion
214:                       // Normally this is w = cos(a/2), but we can delay normalizing
215:                       // by multiplying all terms by norm
216:                       a_2 = floatToBams32Rad(norm*sample_period)/2;
008CCC  810710     MOV sample_period, W0
008CCE  810721     MOV 0x20E4, W1
008CD0  90012E     MOV [W14+4], W2
008CD2  9001BE     MOV [W14+6], W3
008CD4  022C36     CALL ___mulsf3
008CD6  000000     NOP
008CD8  026C4C     CALL floatToBams32Rad
008CDA  000000     NOP
008CDC  DE094F     LSR W1, #15, W2
008CDE  200003     MOV #0x0, W3
008CE0  400002     ADD W0, W2, W0
008CE2  488083     ADDC W1, W3, W1
008CE4  D18081     ASR W1, W1
008CE6  D38000     RRC W0, W0
008CE8  980740     MOV W0, [W14+8]
008CEA  980751     MOV W1, [W14+10]
217:                       sina_2 = bams32SinFine(a_2);
008CEC  90004E     MOV [W14+8], W0
008CEE  9000DE     MOV [W14+10], W1
008CF0  026E30     CALL bams32SinFine
008CF2  000000     NOP
008CF4  980760     MOV W0, [W14+12]
008CF6  980771     MOV W1, [W14+14]
218:               
219:                       displacement_quat.w = bams32CosFine(a_2)*norm;
008CF8  90004E     MOV [W14+8], W0
008CFA  9000DE     MOV [W14+10], W1
008CFC  026EDE     CALL bams32CosFine
008CFE  000000     NOP
008D00  90012E     MOV [W14+4], W2
008D02  9001BE     MOV [W14+6], W3
008D04  022C36     CALL ___mulsf3
008D06  000000     NOP
008D08  470170     ADD W14, #0x10, W2
008D0A  BE8900     MOV.D W0, [W2]
220:                       displacement_quat.x = sina_2*rate[0];
008D0C  200200     MOV #0x20, W0
008D0E  40000E     ADD W0, W14, W0
008D10  BE0010     MOV.D [W0], W0
008D12  90016E     MOV [W14+12], W2
008D14  9001FE     MOV [W14+14], W3
008D16  022C36     CALL ___mulsf3
008D18  000000     NOP
008D1A  470170     ADD W14, #0x10, W2
008D1C  980120     MOV W0, [W2+4]
008D1E  980131     MOV W1, [W2+6]
221:                       displacement_quat.y = sina_2*rate[1];
008D20  200200     MOV #0x20, W0
008D22  40000E     ADD W0, W14, W0
008D24  9000B0     MOV [W0+6], W1
008D26  900020     MOV [W0+4], W0
008D28  90016E     MOV [W14+12], W2
008D2A  9001FE     MOV [W14+14], W3
008D2C  022C36     CALL ___mulsf3
008D2E  000000     NOP
008D30  470170     ADD W14, #0x10, W2
008D32  980140     MOV W0, [W2+8]
008D34  980151     MOV W1, [W2+10]
222:                       displacement_quat.z = sina_2*rate[2];
008D36  200200     MOV #0x20, W0
008D38  40000E     ADD W0, W14, W0
008D3A  9000D0     MOV [W0+10], W1
008D3C  900040     MOV [W0+8], W0
008D3E  90016E     MOV [W14+12], W2
008D40  9001FE     MOV [W14+14], W3
008D42  022C36     CALL ___mulsf3
008D44  000000     NOP
008D46  470170     ADD W14, #0x10, W2
008D48  980160     MOV W0, [W2+12]
008D4A  980171     MOV W1, [W2+14]
223:                       quatNormalize(&displacement_quat);
008D4C  470070     ADD W14, #0x10, W0
008D4E  02A72C     CALL quatNormalize
008D50  000000     NOP
224:                       
225:                   }
226:               
227:                   // Apply displacement to pose
228:                   quatMult(&pose_quat, &displacement_quat, &pose_quat);
008D52  470070     ADD W14, #0x10, W0
008D54  220C62     MOV #0x20C6, W2
008D56  780080     MOV W0, W1
008D58  220C60     MOV #0x20C6, W0
008D5A  02A54E     CALL quatMult
008D5C  000000     NOP
229:               
230:                   // Normalize pose quaternion to account for unnormalized displacement quaternion
231:                   quatNormalize(&pose_quat);    
008D5E  220C60     MOV #0x20C6, W0
008D60  02A72C     CALL quatNormalize
008D62  000000     NOP
008D64  370003     BRA 0x8D6C
232:               
233:               }
008D6C  BE044F     MOV.D [--W15], W8
008D6E  FA8000     ULNK
008D70  060000     RETURN
234:               
235:               static void calculateEulerAngles(void) {
008D72  FA0008     LNK #0x8
008D74  BE9F88     MOV.D W8, [W15++]
236:               
237:                   float temp1, temp2;
238:               
239:                   // Convert back to Euler angles
240:                   temp1 = pose_quat.w*pose_quat.y - pose_quat.z*pose_quat.x;
008D76  810634     MOV pose_quat, W4
008D78  810645     MOV 0x20C8, W5
008D7A  810670     MOV 0x20CE, W0
008D7C  810681     MOV 0x20D0, W1
008D7E  BE0100     MOV.D W0, W2
008D80  BE0004     MOV.D W4, W0
008D82  022C36     CALL ___mulsf3
008D84  000000     NOP
008D86  BE0400     MOV.D W0, W8
008D88  810694     MOV 0x20D2, W4
008D8A  8106A5     MOV 0x20D4, W5
008D8C  810650     MOV 0x20CA, W0
008D8E  810661     MOV 0x20CC, W1
008D90  BE0100     MOV.D W0, W2
008D92  BE0004     MOV.D W4, W0
008D94  022C36     CALL ___mulsf3
008D96  000000     NOP
008D98  BE0100     MOV.D W0, W2
008D9A  BE0008     MOV.D W8, W0
008D9C  022A5A     CALL ___subsf3
008D9E  000000     NOP
008DA0  BE8F00     MOV.D W0, [W14]
241:                   if(temp1 > QUAT_POLE_LIMIT) {
008DA2  B3C018     MOV #0x1, W8
008DA4  27CEE2     MOV #0x7CEE, W2
008DA6  23EFF3     MOV #0x3EFF, W3
008DA8  BE001E     MOV.D [W14], W0
008DAA  0225A8     CALL ___gtsf2
008DAC  000000     NOP
008DAE  EB0080     CLR W1
008DB0  500F81     SUB W0, W1, [W15]
008DB2  3C0001     BRA GT, 0x8DB6
008DB4  EB4400     CLR.B W8
008DB6  EB4000     CLR.B W0
008DB8  544F80     SUB.B W8, W0, [W15]
008DBA  32000D     BRA Z, 0x8DD6
242:                       psi = 2*bams16Atan2(pose_quat.w, pose_quat.x);
008DBC  810650     MOV 0x20CA, W0
008DBE  810661     MOV 0x20CC, W1
008DC0  810634     MOV pose_quat, W4
008DC2  810645     MOV 0x20C8, W5
008DC4  BE0100     MOV.D W0, W2
008DC6  BE0004     MOV.D W4, W0
008DC8  0271AA     CALL bams16Atan2
008DCA  000000     NOP
008DCC  400000     ADD W0, W0, W0
008DCE  8906E0     MOV W0, psi
243:                       theta = -BAMS16_PI_2;
008DD0  2C0000     MOV #0xC000, W0
008DD2  8906D0     MOV W0, theta
008DD4  3700A0     BRA 0x8F16
244:                   } else if(temp1 < -QUAT_POLE_LIMIT) {
008DD6  B3C018     MOV #0x1, W8
008DD8  27CEE2     MOV #0x7CEE, W2
008DDA  2BEFF3     MOV #0xBEFF, W3
008DDC  BE001E     MOV.D [W14], W0
008DDE  0225A4     CALL ___lesf2
008DE0  000000     NOP
008DE2  EB0080     CLR W1
008DE4  500F81     SUB W0, W1, [W15]
008DE6  350001     BRA LT, 0x8DEA
008DE8  EB4400     CLR.B W8
008DEA  EB4000     CLR.B W0
008DEC  544F80     SUB.B W8, W0, [W15]
008DEE  32000F     BRA Z, 0x8E0E
245:                       psi = -2*bams16Atan2(pose_quat.w, pose_quat.x);
008DF0  810650     MOV 0x20CA, W0
008DF2  810661     MOV 0x20CC, W1
008DF4  810634     MOV pose_quat, W4
008DF6  810645     MOV 0x20C8, W5
008DF8  BE0100     MOV.D W0, W2
008DFA  BE0004     MOV.D W4, W0
008DFC  0271AA     CALL bams16Atan2
008DFE  000000     NOP
008E00  2FFFE1     MOV #0xFFFE, W1
008E02  B98001     MUL.SS W0, W1, W0
008E04  780000     MOV W0, W0
008E06  8906E0     MOV W0, psi
246:                       theta = BAMS16_PI_2;
008E08  240000     MOV #0x4000, W0
008E0A  8906D0     MOV W0, theta
008E0C  370084     BRA 0x8F16
247:                   } else {
248:                       theta = -bams16Asin(2.0*temp1);
008E0E  BE001E     MOV.D [W14], W0
008E10  BE0100     MOV.D W0, W2
008E12  022A6C     CALL ___addsf3
008E14  000000     NOP
008E16  026F2E     CALL bams16Asin
008E18  000000     NOP
008E1A  EA0000     NEG W0, W0
008E1C  8906D0     MOV W0, theta
249:                       temp1 = 2.0*(pose_quat.w*pose_quat.x + pose_quat.y*pose_quat.z);
008E1E  810634     MOV pose_quat, W4
008E20  810645     MOV 0x20C8, W5
008E22  810650     MOV 0x20CA, W0
008E24  810661     MOV 0x20CC, W1
008E26  BE0100     MOV.D W0, W2
008E28  BE0004     MOV.D W4, W0
008E2A  022C36     CALL ___mulsf3
008E2C  000000     NOP
008E2E  BE0400     MOV.D W0, W8
008E30  810674     MOV 0x20CE, W4
008E32  810685     MOV 0x20D0, W5
008E34  810690     MOV 0x20D2, W0
008E36  8106A1     MOV 0x20D4, W1
008E38  BE0100     MOV.D W0, W2
008E3A  BE0004     MOV.D W4, W0
008E3C  022C36     CALL ___mulsf3
008E3E  000000     NOP
008E40  BE0100     MOV.D W0, W2
008E42  BE0008     MOV.D W8, W0
008E44  022A6C     CALL ___addsf3
008E46  000000     NOP
008E48  BE0100     MOV.D W0, W2
008E4A  022A6C     CALL ___addsf3
008E4C  000000     NOP
008E4E  BE8F00     MOV.D W0, [W14]
250:                       temp2 = 1.0 - 2.0*(pose_quat.x*pose_quat.x + pose_quat.y*pose_quat.y);
008E50  810654     MOV 0x20CA, W4
008E52  810665     MOV 0x20CC, W5
008E54  810650     MOV 0x20CA, W0
008E56  810661     MOV 0x20CC, W1
008E58  BE0100     MOV.D W0, W2
008E5A  BE0004     MOV.D W4, W0
008E5C  022C36     CALL ___mulsf3
008E5E  000000     NOP
008E60  BE0400     MOV.D W0, W8
008E62  810674     MOV 0x20CE, W4
008E64  810685     MOV 0x20D0, W5
008E66  810670     MOV 0x20CE, W0
008E68  810681     MOV 0x20D0, W1
008E6A  BE0100     MOV.D W0, W2
008E6C  BE0004     MOV.D W4, W0
008E6E  022C36     CALL ___mulsf3
008E70  000000     NOP
008E72  BE0100     MOV.D W0, W2
008E74  BE0008     MOV.D W8, W0
008E76  022A6C     CALL ___addsf3
008E78  000000     NOP
008E7A  BE0100     MOV.D W0, W2
008E7C  022A6C     CALL ___addsf3
008E7E  000000     NOP
008E80  BE0100     MOV.D W0, W2
008E82  200000     MOV #0x0, W0
008E84  23F801     MOV #0x3F80, W1
008E86  022A5A     CALL ___subsf3
008E88  000000     NOP
008E8A  980720     MOV W0, [W14+4]
008E8C  980731     MOV W1, [W14+6]
251:                       phi = bams16Atan2(temp1, temp2);
008E8E  90012E     MOV [W14+4], W2
008E90  9001BE     MOV [W14+6], W3
008E92  BE001E     MOV.D [W14], W0
008E94  0271AA     CALL bams16Atan2
008E96  000000     NOP
008E98  8906C0     MOV W0, phi
252:                       temp1 = 2.0*(pose_quat.w*pose_quat.z + pose_quat.x*pose_quat.y);
008E9A  810634     MOV pose_quat, W4
008E9C  810645     MOV 0x20C8, W5
008E9E  810690     MOV 0x20D2, W0
008EA0  8106A1     MOV 0x20D4, W1
008EA2  BE0100     MOV.D W0, W2
008EA4  BE0004     MOV.D W4, W0
008EA6  022C36     CALL ___mulsf3
008EA8  000000     NOP
008EAA  BE0400     MOV.D W0, W8
008EAC  810654     MOV 0x20CA, W4
008EAE  810665     MOV 0x20CC, W5
008EB0  810670     MOV 0x20CE, W0
008EB2  810681     MOV 0x20D0, W1
008EB4  BE0100     MOV.D W0, W2
008EB6  BE0004     MOV.D W4, W0
008EB8  022C36     CALL ___mulsf3
008EBA  000000     NOP
008EBC  BE0100     MOV.D W0, W2
008EBE  BE0008     MOV.D W8, W0
008EC0  022A6C     CALL ___addsf3
008EC2  000000     NOP
008EC4  BE0100     MOV.D W0, W2
008EC6  022A6C     CALL ___addsf3
008EC8  000000     NOP
008ECA  BE8F00     MOV.D W0, [W14]
253:                       temp2 = 1.0 - 2.0*(pose_quat.y*pose_quat.y + pose_quat.z*pose_quat.z);
008ECC  810674     MOV 0x20CE, W4
008ECE  810685     MOV 0x20D0, W5
008ED0  810670     MOV 0x20CE, W0
008ED2  810681     MOV 0x20D0, W1
008ED4  BE0100     MOV.D W0, W2
008ED6  BE0004     MOV.D W4, W0
008ED8  022C36     CALL ___mulsf3
008EDA  000000     NOP
008EDC  BE0400     MOV.D W0, W8
008EDE  810694     MOV 0x20D2, W4
008EE0  8106A5     MOV 0x20D4, W5
008EE2  810690     MOV 0x20D2, W0
008EE4  8106A1     MOV 0x20D4, W1
008EE6  BE0100     MOV.D W0, W2
008EE8  BE0004     MOV.D W4, W0
008EEA  022C36     CALL ___mulsf3
008EEC  000000     NOP
008EEE  BE0100     MOV.D W0, W2
008EF0  BE0008     MOV.D W8, W0
008EF2  022A6C     CALL ___addsf3
008EF4  000000     NOP
008EF6  BE0100     MOV.D W0, W2
008EF8  022A6C     CALL ___addsf3
008EFA  000000     NOP
008EFC  BE0100     MOV.D W0, W2
008EFE  200000     MOV #0x0, W0
008F00  23F801     MOV #0x3F80, W1
008F02  022A5A     CALL ___subsf3
008F04  000000     NOP
008F06  980720     MOV W0, [W14+4]
008F08  980731     MOV W1, [W14+6]
254:                       psi = bams16Atan2(temp1, temp2);
008F0A  90012E     MOV [W14+4], W2
008F0C  9001BE     MOV [W14+6], W3
008F0E  BE001E     MOV.D [W14], W0
008F10  0271AA     CALL bams16Atan2
008F12  000000     NOP
008F14  8906E0     MOV W0, psi
255:                   }
256:               
257:               }
008F16  BE044F     MOV.D [--W15], W8
008F18  FA8000     ULNK
008F1A  060000     RETURN
258:               
259:               // Quick accelerometer hack to help with estimation drift
260:               //static void compensateDrift(void) {
261:               //
262:               //    float gxy, sina_2, sNorm, xl[3], temp, confidence;
263:               //    float w_est, w_grav;
264:               //    bams16_t a_2;
265:               //    Quaternion grav_quat;
266:               //
267:               //    xlGetFloatXYZ(xl);
268:               //
269:               //    // Convert frames so that z axis is oriented upwards, x is forward, y is side
270:               //    xl[2] = -xl[2];
271:               //    temp = xl[0];
272:               //    xl[0] = -xl[1];
273:               //    xl[1] = temp;
274:               //
275:               //    sNorm = (xl[0]*xl[0] + xl[1]*xl[1] + xl[2]*xl[2])*xl_scale;
276:               //
277:               //    // High confidence when norm matches gravity
278:               //    if(sNorm > GRAVITY_SQUARED) {
279:               //        confidence = 1.0 - (sNorm - GRAVITY_SQUARED);
280:               //    } else {
281:               //        confidence = 1.0 - (GRAVITY_SQUARED - sNorm);
282:               //    }
283:               //    if(sNorm < 0.0) { sNorm = 0.0; }
284:               //
285:               //    gxy = sqrtf(xl[0]*xl[0] + xl[1]*xl[1]);
286:               //    a_2 = (BAMS16_PI_2 + bams16Atan2(xl[2], gxy))/2;
287:               //    sina_2 = bams16SinFine(a_2);
288:               //
289:               //    grav_quat.w = bams16CosFine(a_2)*gxy;
290:               //    grav_quat.x = sina_2*(-xl[1]);
291:               //    grav_quat.y = sina_2*(xl[0]);
292:               //    grav_quat.z = 0.0;
293:               //    quatNormalize(&grav_quat);
294:               //
295:               //    w_est = 1.0 - confidence;
296:               //    w_grav = confidence;
297:               //
298:               //    pose_quat.w = pose_quat.w*w_est + grav_quat.w*w_grav;
299:               //    pose_quat.x = pose_quat.x*w_est + grav_quat.x*w_grav;
300:               //    pose_quat.y = pose_quat.y*w_est + grav_quat.y*w_grav;
301:               //    pose_quat.z = pose_quat.z*w_est + grav_quat.z*w_grav;
302:               //    quatNormalize(&pose_quat);
303:               //
304:               //}
305:               
306:               //static void measureXLScale(unsigned int num_samples) {
307:               //
308:               //    float xl[3], sum[3], sNorm;
309:               //    unsigned int i;
310:               //
311:               //    for(i = 0; i < num_samples; i++) {
312:               //        xlReadXYZ();
313:               //        xlGetFloatXYZ(xl);
314:               //        sum[0] += xl[0];
315:               //        sum[1] += xl[1];
316:               //        sum[2] += xl[2];
317:               //    }
318:               //    sum[0] = sum[0]/num_samples;
319:               //    sum[1] = sum[1]/num_samples;
320:               //    sum[2] = sum[2]/num_samples;
321:               //
322:               //    sNorm = sum[0]*sum[0] + sum[1]*sum[1] + sum[2]*sum[2];
323:               //
324:               //    xl_scale = (GRAVITY_SQUARED)/sNorm;
325:               //
326:               //}
327:               
---  C:/Users/Cameron/Documents/Git/imageproc-lib/at86rf231_driver.c  -----------------------------------
1:                 /**
2:                  * Copyright (c) 2011, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Atmel AT86RF231 802.15.4 RF Transceiver IC Driver
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v0.4
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu         2012-01-06      Initial implementation
38:                 *  Humphrey Hu         2012-02-08      Added state transition methods                     
39:                 *
40:                 * Notes:
41:                 *    No-Clock (sleep) RX listening mode not yet implemented
42:                 */
43:                
44:                #include "at86rf231.h"
45:                #include "at86rf231_driver.h"
46:                #include "ports.h"     
47:                #include "mac_packet.h"
48:                #include "payload.h"
49:                #include "spi.h"                // SFRs
50:                #include "radio.h"              // Need radio status codes
51:                #include "spi_controller.h"
52:                #include "utils.h"
53:                #include "led.h"
54:                
55:                #include <string.h>
56:                
57:                #define SPI_CON1bits        (SPI1CON1bits)
58:                #define SPI_CON2            (SPI1CON2)
59:                #define SPI_STATbits        (SPI1STATbits)    
60:                #define SLPTR               (_LATB15) // Sleep/Transmit Pin
61:                
62:                // Basic commands
63:                #define TRX_CMD_RW          (0xC0) // Register Write
64:                #define TRX_CMD_RR          (0x80) // Register Read 
65:                #define TRX_CMD_FW          (0x60) // Frame Transmit Mode
66:                #define TRX_CMD_FR          (0x20) // Frame Receive Mode
67:                #define TRX_CMD_SW          (0x40) // SRAM Write.
68:                #define TRX_CMD_SR          (0x00) // SRAM Read.
69:                
70:                
71:                // Based on 16-bit addressing for PAN and device and no 
72:                // auxiliary security header
73:                // TODO: Move to appropriate header file, probably mac_packet.h
74:                #define MAC_HEADER_LENGTH       (9)
75:                #define CRC_LENGTH              (2)
76:                #define FRAME_BUFFER_SIZE       (128)
77:                #define DEFAULT_CSMA_RETRIES    (4)     /** Number of times to attempt medium acquisition */
78:                #define DEFAULT_FRAME_RETRIES   (3)     /** Number of times to attempt frame resend */
79:                
80:                // =========== Function stubs =================================================
81:                
82:                static void trxSpiCallback(unsigned int irq_cause);
83:                static void trxFillBuffer(void);
84:                static void trxReadBuffer(void);
85:                
86:                static void setupSPI(void);
87:                static inline void trxSetSlptr(unsigned char);
88:                
89:                static void trxWriteReg(unsigned char addr, unsigned char val);
90:                static unsigned char trxReadReg(unsigned char addr);
91:                
92:                static void trxWriteSubReg(unsigned char addr, unsigned char mask, unsigned char pos, unsigned char val);
93:                static unsigned char trxReadSubReg(unsigned char addr, unsigned char mask, unsigned char pos);
94:                
95:                
96:                // =========== Static variables ===============================================
97:                
98:                static TrxIrqHandler irqCallback;
99:                // See at86rf231.h
100:               static tal_trx_status_t trx_state;
101:               static unsigned char frame_buffer[FRAME_BUFFER_SIZE];
102:               
103:               // =========== Public functions ===============================================
104:               
105:               void trxSetup(void) {
0072B8  FA0000     LNK #0x0
106:               
107:                   setupSPI();     // Set up SPI com port
0072BA  07033D     RCALL setupSPI
108:                   spicSetupChannel1();
0072BC  02AB74     CALL spicSetupChannel1
0072BE  000000     NOP
109:                   spic1SetCallback(&trxSpiCallback);  // Configure callback for spi interrupts
0072C0  278D60     MOV #0x78D6, W0
0072C2  02AB8C     CALL spic1SetCallback
0072C4  000000     NOP
110:                   trxReadReg(RG_IRQ_STATUS);   // Clear pending interrupts          
0072C6  B3C0F0     MOV #0xF, W0
0072C8  070259     RCALL trxReadReg
111:                   trxSetStateOff();       // Transition to TRX_OFF for configuring device    
0072CA  070203     RCALL trxSetStateOff
112:                   trxWriteSubReg(SR_IRQ_MASK, TRX_IRQ_TRX_END);   // Interrupt at end of transceive
0072CC  B3C083     MOV #0x8, W3
0072CE  EB4100     CLR.B W2
0072D0  EBC080     SETM.B W1
0072D2  B3C0E0     MOV #0xE, W0
0072D4  070264     RCALL trxWriteSubReg
113:                   trxWriteSubReg(SR_SLOTTED_OPERATION, 0);    // Disable slotted operation
0072D6  EB4180     CLR.B W3
0072D8  EB4100     CLR.B W2
0072DA  B3C011     MOV #0x1, W1
0072DC  B3C2C0     MOV #0x2C, W0
0072DE  07025F     RCALL trxWriteSubReg
114:                   trxWriteSubReg(SR_TX_AUTO_CRC_ON, 1);   // Enable automatic TX CRC
0072E0  B3C013     MOV #0x1, W3
0072E2  B3C052     MOV #0x5, W2
0072E4  B3C201     MOV #0x20, W1
0072E6  B3C040     MOV #0x4, W0
0072E8  07025A     RCALL trxWriteSubReg
115:                   trxWriteSubReg(SR_CLKM_CTRL, CLKM_NO_CLOCK);    // No clock on CLKM pin
0072EA  EB4180     CLR.B W3
0072EC  EB4100     CLR.B W2
0072EE  B3C071     MOV #0x7, W1
0072F0  B3C030     MOV #0x3, W0
0072F2  070255     RCALL trxWriteSubReg
116:                   trxWriteSubReg(SR_IRQ_MASK_MODE, IRQ_MASK_MODE_ON);    // Turn off interrupt polling
0072F4  B3C013     MOV #0x1, W3
0072F6  B3C012     MOV #0x1, W2
0072F8  B3C021     MOV #0x2, W1
0072FA  B3C040     MOV #0x4, W0
0072FC  070250     RCALL trxWriteSubReg
117:                   trxWriteSubReg(SR_MAX_CSMA_RETRIES, DEFAULT_CSMA_RETRIES);  // Set CSMA attempts
0072FE  B3C043     MOV #0x4, W3
007300  B3C012     MOV #0x1, W2
007302  B3C0E1     MOV #0xE, W1
007304  B3C2C0     MOV #0x2C, W0
007306  07024B     RCALL trxWriteSubReg
118:                   trxWriteSubReg(SR_MAX_FRAME_RETRIES, DEFAULT_FRAME_RETRIES);    // Set resend attempts
007308  B3C033     MOV #0x3, W3
00730A  B3C042     MOV #0x4, W2
00730C  B3CF01     MOV #0xF0, W1
00730E  B3C2C0     MOV #0x2C, W0
007310  070246     RCALL trxWriteSubReg
119:                   trxWriteSubReg(SR_RX_SAFE_MODE, 0);
007312  EB4180     CLR.B W3
007314  B3C072     MOV #0x7, W2
007316  B3C801     MOV #0x80, W1
007318  B3C0C0     MOV #0xC, W0
00731A  070241     RCALL trxWriteSubReg
120:                   trxWriteSubReg(SR_AACK_FVN_MODE, FRAME_VERSION_IGNORED);
00731C  B3C033     MOV #0x3, W3
00731E  B3C062     MOV #0x6, W2
007320  B3CC01     MOV #0xC0, W1
007322  B3C2E0     MOV #0x2E, W0
007324  07023C     RCALL trxWriteSubReg
121:               //    trxWriteSubReg(SR_AACK_PROM_MODE, 1);
122:               //    trxWriteSubReg(SR_AACK_DIS_ACK, 1);
123:                   trxSetStateIdle();
007326  070190     RCALL trxSetStateIdle
124:                   ConfigINT4(RISING_EDGE_INT & EXT_INT_ENABLE & EXT_INT_PRI_4); // Radio IC interrupt
007328  2FFEC0     MOV #0xFFEC, W0
00732A  0223A8     CALL _ConfigINT4
00732C  000000     NOP
125:               
126:               }
00732E  FA8000     ULNK
007330  060000     RETURN
127:               
128:               
129:               void trxReset(void) {
007332  FA0002     LNK #0x2
130:               
131:                   unsigned int i;
132:               
133:                   spic1Reset();   // Reset comm
007334  02ABE8     CALL spic1Reset
007336  000000     NOP
134:                   trxWriteSubReg(SR_TRX_CMD, CMD_TRX_OFF);  // Force to off state
007338  B3C083     MOV #0x8, W3
00733A  EB4100     CLR.B W2
00733C  B3C1F1     MOV #0x1F, W1
00733E  B3C020     MOV #0x2, W0
007340  07022E     RCALL trxWriteSubReg
135:                   
136:                   i = 0;
007342  EB0000     CLR W0
007344  780F00     MOV W0, [W14]
137:                   while(i < 0xFFF0) {
007346  370008     BRA 0x7358
007358  78009E     MOV [W14], W1
00735A  2FFEF0     MOV #0xFFEF, W0
00735C  508F80     SUB W1, W0, [W15]
00735E  36FFF4     BRA LEU, 0x7348
007360  370001     BRA 0x7364
138:                       if(trxReadSubReg(SR_TRX_STATUS) == TRX_OFF) { break; }
007348  EB4100     CLR.B W2
00734A  B3C1F1     MOV #0x1F, W1
00734C  B3C010     MOV #0x1, W0
00734E  070246     RCALL trxReadSubReg
007350  B3C081     MOV #0x8, W1
007352  504F81     SUB.B W0, W1, [W15]
007354  320006     BRA Z, 0x7362
007362  000000     NOP
139:                       i++;
007356  E80F1E     INC [W14], [W14]
140:                   }
141:                   trx_state = TRX_OFF;
007364  200080     MOV #0x8, W0
007366  890030     MOV W0, trx_state
142:               
143:               }
007368  FA8000     ULNK
00736A  060000     RETURN
144:               
145:               void trxCalibrate(void) {
00736C  FA0000     LNK #0x0
146:               
147:                   trxWriteSubReg(SR_FTN_START, 1);    // Begin calibration routine
00736E  B3C013     MOV #0x1, W3
007370  B3C072     MOV #0x7, W2
007372  B3C801     MOV #0x80, W1
007374  B3C180     MOV #0x18, W0
007376  070213     RCALL trxWriteSubReg
148:                   while(trxReadSubReg(SR_FTN_START) != 0);    // Wait for completion
007378  000000     NOP
00737A  B3C072     MOV #0x7, W2
00737C  B3C801     MOV #0x80, W1
00737E  B3C180     MOV #0x18, W0
007380  07022D     RCALL trxReadSubReg
007382  EB4080     CLR.B W1
007384  504F81     SUB.B W0, W1, [W15]
007386  3AFFF9     BRA NZ, 0x737A
149:               
150:               }
007388  FA8000     ULNK
00738A  060000     RETURN
151:                
152:               void trxSetAddress(unsigned int addr) {
00738C  FA0002     LNK #0x2
00738E  780F00     MOV W0, [W14]
153:               
154:                   trxWriteReg(RG_SHORT_ADDR_0, (addr & 0xff));
007390  78001E     MOV [W14], W0
007392  784000     MOV.B W0, W0
007394  784080     MOV.B W0, W1
007396  B3C200     MOV #0x20, W0
007398  0701E1     RCALL trxWriteReg
155:                   trxWriteReg(RG_SHORT_ADDR_1, ((addr >> 8) & 0xff));
00739A  78001E     MOV [W14], W0
00739C  DE0048     LSR W0, #8, W0
00739E  784000     MOV.B W0, W0
0073A0  784080     MOV.B W0, W1
0073A2  B3C210     MOV #0x21, W0
0073A4  0701DB     RCALL trxWriteReg
156:               
157:               }
0073A6  FA8000     ULNK
0073A8  060000     RETURN
158:                
159:               void trxSetPan(unsigned int pan) {
0073AA  FA0002     LNK #0x2
0073AC  780F00     MOV W0, [W14]
160:               
161:                   trxWriteReg(RG_PAN_ID_0, (pan & 0xff));
0073AE  78001E     MOV [W14], W0
0073B0  784000     MOV.B W0, W0
0073B2  784080     MOV.B W0, W1
0073B4  B3C220     MOV #0x22, W0
0073B6  0701D2     RCALL trxWriteReg
162:                   trxWriteReg(RG_PAN_ID_1, ((pan >> 8) & 0xff));
0073B8  78001E     MOV [W14], W0
0073BA  DE0048     LSR W0, #8, W0
0073BC  784000     MOV.B W0, W0
0073BE  784080     MOV.B W0, W1
0073C0  B3C230     MOV #0x23, W0
0073C2  0701CC     RCALL trxWriteReg
163:               
164:               }
0073C4  FA8000     ULNK
0073C6  060000     RETURN
165:               
166:               void trxSetChannel(unsigned char channel) {
0073C8  FA0002     LNK #0x2
0073CA  784F00     MOV.B W0, [W14]
167:               
168:                   trxWriteSubReg(SR_CHANNEL, channel);
0073CC  78419E     MOV.B [W14], W3
0073CE  EB4100     CLR.B W2
0073D0  B3C1F1     MOV #0x1F, W1
0073D2  B3C080     MOV #0x8, W0
0073D4  0701E4     RCALL trxWriteSubReg
169:               
170:               }
0073D6  FA8000     ULNK
0073D8  060000     RETURN
171:                
172:               void trxSetRetries(unsigned int retries) {
0073DA  FA0002     LNK #0x2
0073DC  780F00     MOV W0, [W14]
173:               
174:                   trxWriteSubReg(SR_MAX_FRAME_RETRIES, retries); 
0073DE  78001E     MOV [W14], W0
0073E0  784000     MOV.B W0, W0
0073E2  784180     MOV.B W0, W3
0073E4  B3C042     MOV #0x4, W2
0073E6  B3CF01     MOV #0xF0, W1
0073E8  B3C2C0     MOV #0x2C, W0
0073EA  0701D9     RCALL trxWriteSubReg
175:                   
176:               }
0073EC  FA8000     ULNK
0073EE  060000     RETURN
177:                
178:               void trxSetIrqCallback(TrxIrqHandler handler) {
0073F0  FA0002     LNK #0x2
0073F2  780F00     MOV W0, [W14]
179:               
180:                   irqCallback = handler;
0073F4  78001E     MOV [W14], W0
0073F6  890020     MOV W0, irqCallback
181:                   
182:               }
0073F8  FA8000     ULNK
0073FA  060000     RETURN
183:               
184:               void trxReadId(unsigned char *id) {
0073FC  FA0002     LNK #0x2
0073FE  781F88     MOV W8, [W15++]
007400  780F00     MOV W0, [W14]
185:               
186:                   id[0] = trxReadReg(RG_PART_NUM);      // should be 3
007402  B3C1C0     MOV #0x1C, W0
007404  0701BB     RCALL trxReadReg
007406  78009E     MOV [W14], W1
007408  784880     MOV.B W0, [W1]
187:                   id[1] = trxReadReg(RG_VERSION_NUM);   // should be 2
00740A  E8041E     INC [W14], W8
00740C  B3C1D0     MOV #0x1D, W0
00740E  0701B6     RCALL trxReadReg
007410  784C00     MOV.B W0, [W8]
188:                   id[2] = trxReadReg(RG_MAN_ID_1);      // should be 0x1F
007412  E8841E     INC2 [W14], W8
007414  B3C1F0     MOV #0x1F, W0
007416  0701B2     RCALL trxReadReg
007418  784C00     MOV.B W0, [W8]
189:                   id[3] = trxReadReg(RG_MAN_ID_0);      // should be 0
00741A  78001E     MOV [W14], W0
00741C  400463     ADD W0, #0x3, W8
00741E  B3C1E0     MOV #0x1E, W0
007420  0701AD     RCALL trxReadReg
007422  784C00     MOV.B W0, [W8]
190:               
191:               }
007424  78044F     MOV [--W15], W8
007426  FA8000     ULNK
007428  060000     RETURN
192:                
193:               void trxWriteFrameBuffer(MacPacket packet) {
00742A  FA0008     LNK #0x8
00742C  781F88     MOV W8, [W15++]
00742E  980730     MOV W0, [W14+6]
194:                   
195:                   unsigned int i;
196:                   unsigned char phy_len;
197:                   Payload pld;
198:                   
199:                   // Linearize contents in buffer
200:                   i = 0;
007430  EB0000     CLR W0
007432  780F00     MOV W0, [W14]
201:                   phy_len = packet->payload_length + MAC_HEADER_LENGTH + CRC_LENGTH;
007434  90003E     MOV [W14+6], W0
007436  904860     MOV.B [W0+14], W0
007438  40406B     ADD.B W0, #0xB, W0
00743A  984720     MOV.B W0, [W14+2]
202:                   
203:                   frame_buffer[i++] = phy_len; //packet->payload_length + MAC_HEADER_LENGTH + CRC_LENGTH;
00743C  220080     MOV #0x2008, W0
00743E  40001E     ADD W0, [W14], W0
007440  9040AE     MOV.B [W14+2], W1
007442  784801     MOV.B W1, [W0]
007444  E80F1E     INC [W14], [W14]
204:                   frame_buffer[i++] = packet->frame_ctrl.val.byte.LB;
007446  90003E     MOV [W14+6], W0
007448  784010     MOV.B [W0], W0
00744A  220081     MOV #0x2008, W1
00744C  40809E     ADD W1, [W14], W1
00744E  784880     MOV.B W0, [W1]
007450  E80F1E     INC [W14], [W14]
205:                   frame_buffer[i++] = packet->frame_ctrl.val.byte.HB;
007452  90003E     MOV [W14+6], W0
007454  904010     MOV.B [W0+1], W0
007456  220081     MOV #0x2008, W1
007458  40809E     ADD W1, [W14], W1
00745A  784880     MOV.B W0, [W1]
00745C  E80F1E     INC [W14], [W14]
206:                   frame_buffer[i++] = packet->seq_num;
00745E  90003E     MOV [W14+6], W0
007460  904020     MOV.B [W0+2], W0
007462  220081     MOV #0x2008, W1
007464  40809E     ADD W1, [W14], W1
007466  784880     MOV.B W0, [W1]
007468  E80F1E     INC [W14], [W14]
207:                   frame_buffer[i++] = packet->dest_pan_id.byte.LB;
00746A  90003E     MOV [W14+6], W0
00746C  904040     MOV.B [W0+4], W0
00746E  220081     MOV #0x2008, W1
007470  40809E     ADD W1, [W14], W1
007472  784880     MOV.B W0, [W1]
007474  E80F1E     INC [W14], [W14]
208:                   frame_buffer[i++] = packet->dest_pan_id.byte.HB;
007476  90003E     MOV [W14+6], W0
007478  904050     MOV.B [W0+5], W0
00747A  220081     MOV #0x2008, W1
00747C  40809E     ADD W1, [W14], W1
00747E  784880     MOV.B W0, [W1]
007480  E80F1E     INC [W14], [W14]
209:                   frame_buffer[i++] = packet->dest_addr.byte.LB;
007482  90003E     MOV [W14+6], W0
007484  904060     MOV.B [W0+6], W0
007486  220081     MOV #0x2008, W1
007488  40809E     ADD W1, [W14], W1
00748A  784880     MOV.B W0, [W1]
00748C  E80F1E     INC [W14], [W14]
210:                   frame_buffer[i++] = packet->dest_addr.byte.HB;
00748E  90003E     MOV [W14+6], W0
007490  904070     MOV.B [W0+7], W0
007492  220081     MOV #0x2008, W1
007494  40809E     ADD W1, [W14], W1
007496  784880     MOV.B W0, [W1]
007498  E80F1E     INC [W14], [W14]
211:                   frame_buffer[i++] = packet->src_addr.byte.LB;
00749A  90003E     MOV [W14+6], W0
00749C  904820     MOV.B [W0+10], W0
00749E  220081     MOV #0x2008, W1
0074A0  40809E     ADD W1, [W14], W1
0074A2  784880     MOV.B W0, [W1]
0074A4  E80F1E     INC [W14], [W14]
212:                   frame_buffer[i++] = packet->src_addr.byte.HB;
0074A6  90003E     MOV [W14+6], W0
0074A8  904830     MOV.B [W0+11], W0
0074AA  220081     MOV #0x2008, W1
0074AC  40809E     ADD W1, [W14], W1
0074AE  784880     MOV.B W0, [W1]
0074B0  E80F1E     INC [W14], [W14]
213:               
214:                   pld = macGetPayload(packet);
0074B2  90003E     MOV [W14+6], W0
0074B4  0286E6     CALL macGetPayload
0074B6  000000     NOP
0074B8  980720     MOV W0, [W14+4]
215:                   if(pld == NULL) { return; }
0074BA  9000AE     MOV [W14+4], W1
0074BC  EB0000     CLR W0
0074BE  508F80     SUB W1, W0, [W15]
0074C0  32001E     BRA Z, 0x74FE
0074FE  000000     NOP
216:                   
217:                   memcpy(frame_buffer + i, payToString(pld), payGetPayloadLength(pld));
0074C2  90002E     MOV [W14+4], W0
0074C4  02CAC4     CALL payGetPayloadLength
0074C6  000000     NOP
0074C8  FB8400     ZE W0, W8
0074CA  90002E     MOV [W14+4], W0
0074CC  02CA34     CALL payToString
0074CE  000000     NOP
0074D0  780080     MOV W0, W1
0074D2  220080     MOV #0x2008, W0
0074D4  40001E     ADD W0, [W14], W0
0074D6  780108     MOV W8, W2
0074D8  023582     CALL _memcpy
0074DA  000000     NOP
218:                   
219:                   spic1BeginTransaction();
0074DC  02ABA4     CALL spic1BeginTransaction
0074DE  000000     NOP
220:                   spic1Transmit(TRX_CMD_FW);
0074E0  B3C600     MOV #0x60, W0
0074E2  02AC08     CALL spic1Transmit
0074E4  000000     NOP
221:                   spic1MassTransmit(phy_len, frame_buffer, phy_len*3); // 3*length microseconds timeout seems to work well
0074E6  90402E     MOV.B [W14+2], W0
0074E8  FB8000     ZE W0, W0
0074EA  B90063     MUL.SU W0, #3, W0
0074EC  780000     MOV W0, W0
0074EE  780080     MOV W0, W1
0074F0  90402E     MOV.B [W14+2], W0
0074F2  FB8000     ZE W0, W0
0074F4  780101     MOV W1, W2
0074F6  220081     MOV #0x2008, W1
0074F8  02ACB8     CALL spic1MassTransmit
0074FA  000000     NOP
0074FC  370001     BRA 0x7500
222:                   
223:               }
007500  78044F     MOV [--W15], W8
007502  FA8000     ULNK
007504  060000     RETURN
224:                
225:               unsigned int trxReadFrameBuffer(MacPacket packet) {
007506  FA0002     LNK #0x2
007508  780F00     MOV W0, [W14]
226:                   
227:                   // Read received data from DMA memory into buffer        
228:                   return macReadFrame(frame_buffer, packet); // Decode frame data
00750A  78009E     MOV [W14], W1
00750C  220080     MOV #0x2008, W0
00750E  0287EE     CALL macReadFrame
007510  000000     NOP
229:                   
230:               }
007512  FA8000     ULNK
007514  060000     RETURN
231:                
232:               unsigned int trxReadBufferDataLength(void) {   
007516  FA0000     LNK #0x0
233:               
234:                   return macReadDataLength(frame_buffer);
007518  220080     MOV #0x2008, W0
00751A  028700     CALL macReadDataLength
00751C  000000     NOP
235:               
236:               }
00751E  FA8000     ULNK
007520  060000     RETURN
237:                
238:               void trxBeginTransmission(void) {
007522  FA0000     LNK #0x0
239:               
240:                   trxSetSlptr(1);
007524  B3C010     MOV #0x1, W0
007526  070221     RCALL trxSetSlptr
241:                   trxSetSlptr(0);
007528  EB4000     CLR.B W0
00752A  07021F     RCALL trxSetSlptr
242:                   trx_state = BUSY_TX_ARET;   // Update state accordingly
00752C  200120     MOV #0x12, W0
00752E  890030     MOV W0, trx_state
243:               
244:               }
007530  FA8000     ULNK
007532  060000     RETURN
245:               
246:               void trxSetStateTx(void) {
007534  FA0008     LNK #0x8
247:                   
248:                   CRITICAL_SECTION_START;
007536  800210     MOV SR, W0
007538  DE0045     LSR W0, #5, W0
00753A  604067     AND.B W0, #0x7, W0
00753C  784F00     MOV.B W0, [W14]
00753E  800290     MOV DISICNT, W0
007540  980710     MOV W0, [W14+2]
007542  FC3FFF     DISI #0x3FFF
007544  800211     MOV SR, W1
007546  200E00     MOV #0xE0, W0
007548  708000     IOR W1, W0, W0
00754A  880210     MOV W0, SR
00754C  90001E     MOV [W14+2], W0
00754E  880290     MOV W0, DISICNT
007550  880000     MOV W0, WREG0
249:                   
250:                   if(trx_state == TX_ARET_ON) { // Fast return if already in desired state
007552  810031     MOV trx_state, W1
007554  200190     MOV #0x19, W0
007556  508F80     SUB W1, W0, [W15]
007558  3A0011     BRA NZ, 0x757C
251:                       CRITICAL_SECTION_END;
00755A  800290     MOV DISICNT, W0
00755C  980720     MOV W0, [W14+4]
00755E  FC3FFF     DISI #0x3FFF
007560  78401E     MOV.B [W14], W0
007562  604067     AND.B W0, #0x7, W0
007564  FB8000     ZE W0, W0
007566  600067     AND W0, #0x7, W0
007568  DD0045     SL W0, #5, W0
00756A  800212     MOV SR, W2
00756C  2FF1F1     MOV #0xFF1F, W1
00756E  610081     AND W2, W1, W1
007570  708000     IOR W1, W0, W0
007572  880210     MOV W0, SR
007574  90002E     MOV [W14+4], W0
007576  880290     MOV W0, DISICNT
007578  880000     MOV W0, WREG0
252:                       return; 
00757A  37001F     BRA 0x75BA
253:                   } 
254:                   
255:                   trxWriteSubReg(SR_TRX_CMD, CMD_TX_ARET_ON); // Begin transition
00757C  B3C193     MOV #0x19, W3
00757E  EB4100     CLR.B W2
007580  B3C1F1     MOV #0x1F, W1
007582  B3C020     MOV #0x2, W0
007584  07010C     RCALL trxWriteSubReg
256:                   while(trxReadSubReg(SR_TRX_STATUS) != TX_ARET_ON);  // Wait for completion
007586  000000     NOP
007588  EB4100     CLR.B W2
00758A  B3C1F1     MOV #0x1F, W1
00758C  B3C010     MOV #0x1, W0
00758E  070126     RCALL trxReadSubReg
007590  B3C191     MOV #0x19, W1
007592  504F81     SUB.B W0, W1, [W15]
007594  3AFFF9     BRA NZ, 0x7588
257:                   trx_state = TX_ARET_ON; // Update state
007596  200190     MOV #0x19, W0
007598  890030     MOV W0, trx_state
258:                   
259:                   CRITICAL_SECTION_END;
00759A  800290     MOV DISICNT, W0
00759C  980730     MOV W0, [W14+6]
00759E  FC3FFF     DISI #0x3FFF
0075A0  78401E     MOV.B [W14], W0
0075A2  604067     AND.B W0, #0x7, W0
0075A4  FB8000     ZE W0, W0
0075A6  600067     AND W0, #0x7, W0
0075A8  DD0045     SL W0, #5, W0
0075AA  800212     MOV SR, W2
0075AC  2FF1F1     MOV #0xFF1F, W1
0075AE  610081     AND W2, W1, W1
0075B0  708000     IOR W1, W0, W0
0075B2  880210     MOV W0, SR
0075B4  90003E     MOV [W14+6], W0
0075B6  880290     MOV W0, DISICNT
0075B8  880000     MOV W0, WREG0
260:               
261:               }
0075BA  FA8000     ULNK
0075BC  060000     RETURN
262:               
263:               void trxSetStateRx(void) {
0075BE  FA0008     LNK #0x8
264:                   
265:                   CRITICAL_SECTION_START;
0075C0  800210     MOV SR, W0
0075C2  DE0045     LSR W0, #5, W0
0075C4  604067     AND.B W0, #0x7, W0
0075C6  784F00     MOV.B W0, [W14]
0075C8  800290     MOV DISICNT, W0
0075CA  980710     MOV W0, [W14+2]
0075CC  FC3FFF     DISI #0x3FFF
0075CE  800211     MOV SR, W1
0075D0  200E00     MOV #0xE0, W0
0075D2  708000     IOR W1, W0, W0
0075D4  880210     MOV W0, SR
0075D6  90001E     MOV [W14+2], W0
0075D8  880290     MOV W0, DISICNT
0075DA  880000     MOV W0, WREG0
266:                   
267:                   if(trx_state == RX_AACK_ON) {  // Fast return
0075DC  810031     MOV trx_state, W1
0075DE  200160     MOV #0x16, W0
0075E0  508F80     SUB W1, W0, [W15]
0075E2  3A0011     BRA NZ, 0x7606
268:                       CRITICAL_SECTION_END;
0075E4  800290     MOV DISICNT, W0
0075E6  980720     MOV W0, [W14+4]
0075E8  FC3FFF     DISI #0x3FFF
0075EA  78401E     MOV.B [W14], W0
0075EC  604067     AND.B W0, #0x7, W0
0075EE  FB8000     ZE W0, W0
0075F0  600067     AND W0, #0x7, W0
0075F2  DD0045     SL W0, #5, W0
0075F4  800212     MOV SR, W2
0075F6  2FF1F1     MOV #0xFF1F, W1
0075F8  610081     AND W2, W1, W1
0075FA  708000     IOR W1, W0, W0
0075FC  880210     MOV W0, SR
0075FE  90002E     MOV [W14+4], W0
007600  880290     MOV W0, DISICNT
007602  880000     MOV W0, WREG0
269:                       return; 
007604  37001F     BRA 0x7644
270:                   }
271:                   
272:                   trxWriteSubReg(SR_TRX_CMD, CMD_RX_AACK_ON); // Begin transition
007606  B3C163     MOV #0x16, W3
007608  EB4100     CLR.B W2
00760A  B3C1F1     MOV #0x1F, W1
00760C  B3C020     MOV #0x2, W0
00760E  0700C7     RCALL trxWriteSubReg
273:                   while(trxReadSubReg(SR_TRX_STATUS) != RX_AACK_ON);  // Wait for completion
007610  000000     NOP
007612  EB4100     CLR.B W2
007614  B3C1F1     MOV #0x1F, W1
007616  B3C010     MOV #0x1, W0
007618  0700E1     RCALL trxReadSubReg
00761A  B3C161     MOV #0x16, W1
00761C  504F81     SUB.B W0, W1, [W15]
00761E  3AFFF9     BRA NZ, 0x7612
274:                   trx_state = RX_AACK_ON; // Update state
007620  200160     MOV #0x16, W0
007622  890030     MOV W0, trx_state
275:                   
276:                   CRITICAL_SECTION_END;
007624  800290     MOV DISICNT, W0
007626  980730     MOV W0, [W14+6]
007628  FC3FFF     DISI #0x3FFF
00762A  78401E     MOV.B [W14], W0
00762C  604067     AND.B W0, #0x7, W0
00762E  FB8000     ZE W0, W0
007630  600067     AND W0, #0x7, W0
007632  DD0045     SL W0, #5, W0
007634  800212     MOV SR, W2
007636  2FF1F1     MOV #0xFF1F, W1
007638  610081     AND W2, W1, W1
00763A  708000     IOR W1, W0, W0
00763C  880210     MOV W0, SR
00763E  90003E     MOV [W14+6], W0
007640  880290     MOV W0, DISICNT
007642  880000     MOV W0, WREG0
277:               
278:               }
007644  FA8000     ULNK
007646  060000     RETURN
279:               
280:               void trxSetStateIdle(void) {    
007648  FA0008     LNK #0x8
281:                   
282:                   CRITICAL_SECTION_START;
00764A  800210     MOV SR, W0
00764C  DE0045     LSR W0, #5, W0
00764E  604067     AND.B W0, #0x7, W0
007650  784F00     MOV.B W0, [W14]
007652  800290     MOV DISICNT, W0
007654  980710     MOV W0, [W14+2]
007656  FC3FFF     DISI #0x3FFF
007658  800211     MOV SR, W1
00765A  200E00     MOV #0xE0, W0
00765C  708000     IOR W1, W0, W0
00765E  880210     MOV W0, SR
007660  90001E     MOV [W14+2], W0
007662  880290     MOV W0, DISICNT
007664  880000     MOV W0, WREG0
283:                   
284:                   if(trx_state == PLL_ON) {  // Fast return
007666  810031     MOV trx_state, W1
007668  200090     MOV #0x9, W0
00766A  508F80     SUB W1, W0, [W15]
00766C  3A0011     BRA NZ, 0x7690
285:                       CRITICAL_SECTION_END;
00766E  800290     MOV DISICNT, W0
007670  980720     MOV W0, [W14+4]
007672  FC3FFF     DISI #0x3FFF
007674  78401E     MOV.B [W14], W0
007676  604067     AND.B W0, #0x7, W0
007678  FB8000     ZE W0, W0
00767A  600067     AND W0, #0x7, W0
00767C  DD0045     SL W0, #5, W0
00767E  800212     MOV SR, W2
007680  2FF1F1     MOV #0xFF1F, W1
007682  610081     AND W2, W1, W1
007684  708000     IOR W1, W0, W0
007686  880210     MOV W0, SR
007688  90002E     MOV [W14+4], W0
00768A  880290     MOV W0, DISICNT
00768C  880000     MOV W0, WREG0
286:                       return; 
00768E  37001F     BRA 0x76CE
287:                   }
288:                   
289:                   trxWriteSubReg(SR_TRX_CMD, CMD_PLL_ON); // Begin transition
007690  B3C093     MOV #0x9, W3
007692  EB4100     CLR.B W2
007694  B3C1F1     MOV #0x1F, W1
007696  B3C020     MOV #0x2, W0
007698  070082     RCALL trxWriteSubReg
290:                   while(trxReadSubReg(SR_TRX_STATUS) != PLL_ON);  // Wait for completion
00769A  000000     NOP
00769C  EB4100     CLR.B W2
00769E  B3C1F1     MOV #0x1F, W1
0076A0  B3C010     MOV #0x1, W0
0076A2  07009C     RCALL trxReadSubReg
0076A4  B3C091     MOV #0x9, W1
0076A6  504F81     SUB.B W0, W1, [W15]
0076A8  3AFFF9     BRA NZ, 0x769C
291:                   trx_state = PLL_ON; // Update state
0076AA  200090     MOV #0x9, W0
0076AC  890030     MOV W0, trx_state
292:                   
293:                   CRITICAL_SECTION_END;
0076AE  800290     MOV DISICNT, W0
0076B0  980730     MOV W0, [W14+6]
0076B2  FC3FFF     DISI #0x3FFF
0076B4  78401E     MOV.B [W14], W0
0076B6  604067     AND.B W0, #0x7, W0
0076B8  FB8000     ZE W0, W0
0076BA  600067     AND W0, #0x7, W0
0076BC  DD0045     SL W0, #5, W0
0076BE  800212     MOV SR, W2
0076C0  2FF1F1     MOV #0xFF1F, W1
0076C2  610081     AND W2, W1, W1
0076C4  708000     IOR W1, W0, W0
0076C6  880210     MOV W0, SR
0076C8  90003E     MOV [W14+6], W0
0076CA  880290     MOV W0, DISICNT
0076CC  880000     MOV W0, WREG0
294:               
295:               }
0076CE  FA8000     ULNK
0076D0  060000     RETURN
296:               
297:               void trxSetStateOff(void) {
0076D2  FA0008     LNK #0x8
298:                   
299:                   CRITICAL_SECTION_START;
0076D4  800210     MOV SR, W0
0076D6  DE0045     LSR W0, #5, W0
0076D8  604067     AND.B W0, #0x7, W0
0076DA  784F00     MOV.B W0, [W14]
0076DC  800290     MOV DISICNT, W0
0076DE  980710     MOV W0, [W14+2]
0076E0  FC3FFF     DISI #0x3FFF
0076E2  800211     MOV SR, W1
0076E4  200E00     MOV #0xE0, W0
0076E6  708000     IOR W1, W0, W0
0076E8  880210     MOV W0, SR
0076EA  90001E     MOV [W14+2], W0
0076EC  880290     MOV W0, DISICNT
0076EE  880000     MOV W0, WREG0
300:                   
301:                   if(trx_state == TRX_OFF) {     // Fast return
0076F0  810031     MOV trx_state, W1
0076F2  200080     MOV #0x8, W0
0076F4  508F80     SUB W1, W0, [W15]
0076F6  3A0011     BRA NZ, 0x771A
302:                       CRITICAL_SECTION_END;
0076F8  800290     MOV DISICNT, W0
0076FA  980720     MOV W0, [W14+4]
0076FC  FC3FFF     DISI #0x3FFF
0076FE  78401E     MOV.B [W14], W0
007700  604067     AND.B W0, #0x7, W0
007702  FB8000     ZE W0, W0
007704  600067     AND W0, #0x7, W0
007706  DD0045     SL W0, #5, W0
007708  800212     MOV SR, W2
00770A  2FF1F1     MOV #0xFF1F, W1
00770C  610081     AND W2, W1, W1
00770E  708000     IOR W1, W0, W0
007710  880210     MOV W0, SR
007712  90002E     MOV [W14+4], W0
007714  880290     MOV W0, DISICNT
007716  880000     MOV W0, WREG0
303:                       return; 
007718  37001F     BRA 0x7758
304:                   }
305:                   
306:                   trxWriteSubReg(SR_TRX_CMD, CMD_TRX_OFF);    // Begin transition
00771A  B3C083     MOV #0x8, W3
00771C  EB4100     CLR.B W2
00771E  B3C1F1     MOV #0x1F, W1
007720  B3C020     MOV #0x2, W0
007722  07003D     RCALL trxWriteSubReg
307:                   while(trxReadSubReg(SR_TRX_STATUS) != TRX_OFF); // Wait for completion
007724  000000     NOP
007726  EB4100     CLR.B W2
007728  B3C1F1     MOV #0x1F, W1
00772A  B3C010     MOV #0x1, W0
00772C  070057     RCALL trxReadSubReg
00772E  B3C081     MOV #0x8, W1
007730  504F81     SUB.B W0, W1, [W15]
007732  3AFFF9     BRA NZ, 0x7726
308:                   trx_state = TRX_OFF;    // Update state
007734  200080     MOV #0x8, W0
007736  890030     MOV W0, trx_state
309:                   
310:                   CRITICAL_SECTION_END;
007738  800290     MOV DISICNT, W0
00773A  980730     MOV W0, [W14+6]
00773C  FC3FFF     DISI #0x3FFF
00773E  78401E     MOV.B [W14], W0
007740  604067     AND.B W0, #0x7, W0
007742  FB8000     ZE W0, W0
007744  600067     AND W0, #0x7, W0
007746  DD0045     SL W0, #5, W0
007748  800212     MOV SR, W2
00774A  2FF1F1     MOV #0xFF1F, W1
00774C  610081     AND W2, W1, W1
00774E  708000     IOR W1, W0, W0
007750  880210     MOV W0, SR
007752  90003E     MOV [W14+6], W0
007754  880290     MOV W0, DISICNT
007756  880000     MOV W0, WREG0
311:                   
312:               }
007758  FA8000     ULNK
00775A  060000     RETURN
313:               
314:               // =========== Private functions ==============================================
315:               
316:               /**
317:                * Writes a byte to a transceiver register.
318:                *
319:                * @param addr 8-bit register address. Use definitions in at86rf231.h
320:                * @param val 8-bit value to write to the register
321:                */
322:               static void trxWriteReg(unsigned char addr, unsigned char val) {
00775C  FA0002     LNK #0x2
00775E  784F00     MOV.B W0, [W14]
007760  984711     MOV.B W1, [W14+1]
323:                  
324:                   spic1BeginTransaction();
007762  02ABA4     CALL spic1BeginTransaction
007764  000000     NOP
325:                   spic1Transmit(TRX_CMD_RW | addr);
007766  B3CC00     MOV #0xC0, W0
007768  70401E     IOR.B W0, [W14], W0
00776A  02AC08     CALL spic1Transmit
00776C  000000     NOP
326:                   spic1Transmit(val);
00776E  90401E     MOV.B [W14+1], W0
007770  02AC08     CALL spic1Transmit
007772  000000     NOP
327:                   spic1EndTransaction();
007774  02ABD0     CALL spic1EndTransaction
007776  000000     NOP
328:                   
329:               }
007778  FA8000     ULNK
00777A  060000     RETURN
330:               
331:               /**
332:                * Reads a byte from a transceiver register.
333:                *
334:                * @param addr 8-bit register address. Use definitions in at86rf231.h
335:                * @return Read register contents
336:                */
337:               static unsigned char trxReadReg(unsigned char addr) {
00777C  FA0004     LNK #0x4
00777E  984720     MOV.B W0, [W14+2]
338:               
339:                   unsigned char c;
340:                   spic1BeginTransaction();
007780  02ABA4     CALL spic1BeginTransaction
007782  000000     NOP
341:                   spic1Transmit(TRX_CMD_RR | addr);
007784  9040AE     MOV.B [W14+2], W1
007786  B3C800     MOV #0x80, W0
007788  70C000     IOR.B W1, W0, W0
00778A  02AC08     CALL spic1Transmit
00778C  000000     NOP
342:                   c = spic1Receive();
00778E  02AC64     CALL spic1Receive
007790  000000     NOP
007792  784F00     MOV.B W0, [W14]
343:                   spic1EndTransaction();
007794  02ABD0     CALL spic1EndTransaction
007796  000000     NOP
344:                   return c;
007798  78401E     MOV.B [W14], W0
345:               
346:               }
00779A  FA8000     ULNK
00779C  060000     RETURN
347:               
348:               /**
349:                * Write bits to a transceiver subregister.
350:                *
351:                * @param addr 8-bit main register address. Use definitions in at86rf231.h
352:                * @param mask Bitfield mask to apply to register value
353:                * @param pos Subregister position offset from main register LSB
354:                * @param val Value to write to subregister
355:                */
356:               static void trxWriteSubReg(unsigned char addr, unsigned char mask, unsigned char pos, unsigned char val) {
00779E  FA0006     LNK #0x6
0077A0  984720     MOV.B W0, [W14+2]
0077A2  984731     MOV.B W1, [W14+3]
0077A4  984742     MOV.B W2, [W14+4]
0077A6  984753     MOV.B W3, [W14+5]
357:                   
358:                   unsigned char temp;
359:                   temp = trxReadReg(addr);
0077A8  90402E     MOV.B [W14+2], W0
0077AA  07FFE8     RCALL trxReadReg
0077AC  784F00     MOV.B W0, [W14]
360:                   temp &= ~mask;
0077AE  90403E     MOV.B [W14+3], W0
0077B0  EAC080     COM.B W0, W1
0077B2  78401E     MOV.B [W14], W0
0077B4  60C000     AND.B W1, W0, W0
0077B6  784F00     MOV.B W0, [W14]
361:                   val <<= pos;
0077B8  90405E     MOV.B [W14+5], W0
0077BA  FB8080     ZE W0, W1
0077BC  90404E     MOV.B [W14+4], W0
0077BE  FB8000     ZE W0, W0
0077C0  DD0800     SL W1, W0, W0
0077C2  984750     MOV.B W0, [W14+5]
362:                   val &= mask;
0077C4  9040DE     MOV.B [W14+5], W1
0077C6  90403E     MOV.B [W14+3], W0
0077C8  60C000     AND.B W1, W0, W0
0077CA  984750     MOV.B W0, [W14+5]
363:                   val |= temp;
0077CC  90405E     MOV.B [W14+5], W0
0077CE  70401E     IOR.B W0, [W14], W0
0077D0  984750     MOV.B W0, [W14+5]
364:                   trxWriteReg(addr, val);
0077D2  9040DE     MOV.B [W14+5], W1
0077D4  90402E     MOV.B [W14+2], W0
0077D6  07FFC2     RCALL trxWriteReg
365:                   
366:               }
0077D8  FA8000     ULNK
0077DA  060000     RETURN
367:                
368:               /**
369:                * Read bits from a transceiver subregister.
370:                *
371:                * @param addr 8-bit main register address. Use definitions in at86rf231.h
372:                * @param mask Bitfield mask to apply to register value
373:                * @param pos Subregister position offset from main register LSB
374:                * @return Value read from subregister.
375:                */  
376:               static unsigned char trxReadSubReg(unsigned char addr, unsigned char mask, unsigned char pos) {
0077DC  FA0006     LNK #0x6
0077DE  984720     MOV.B W0, [W14+2]
0077E0  984731     MOV.B W1, [W14+3]
0077E2  984742     MOV.B W2, [W14+4]
377:               
378:                   unsigned char data;
379:                   data = trxReadReg(addr);
0077E4  90402E     MOV.B [W14+2], W0
0077E6  07FFCA     RCALL trxReadReg
0077E8  784F00     MOV.B W0, [W14]
380:                   data &= mask;
0077EA  90403E     MOV.B [W14+3], W0
0077EC  604F1E     AND.B W0, [W14], [W14]
381:                   data >>= pos;
0077EE  78401E     MOV.B [W14], W0
0077F0  FB8080     ZE W0, W1
0077F2  90404E     MOV.B [W14+4], W0
0077F4  FB8000     ZE W0, W0
0077F6  DE8800     ASR W1, W0, W0
0077F8  784F00     MOV.B W0, [W14]
382:                   return data;
0077FA  78401E     MOV.B [W14], W0
383:                   
384:               }
0077FC  FA8000     ULNK
0077FE  060000     RETURN
385:               
386:               void __attribute__((interrupt, no_auto_psv)) _INT4Interrupt(void) {
007800  F80036     PUSH RCOUNT
007802  BE9F80     MOV.D W0, [W15++]
007804  BE9F82     MOV.D W2, [W15++]
007806  BE9F84     MOV.D W4, [W15++]
007808  BE9F86     MOV.D W6, [W15++]
00780A  FA0002     LNK #0x2
387:               
388:                   unsigned char irq_cause, status;
389:                   irq_cause = 0;
00780C  EB4000     CLR.B W0
00780E  784F00     MOV.B W0, [W14]
390:                   status = 0xFF;
007810  EBC000     SETM.B W0
007812  984710     MOV.B W0, [W14+1]
391:                   
392:                   irq_cause = trxReadReg(RG_IRQ_STATUS);    // Read and clear irq source
007814  B3C0F0     MOV #0xF, W0
007816  07FFB2     RCALL trxReadReg
007818  784F00     MOV.B W0, [W14]
393:                   
394:                   if(irq_cause & TRX_IRQ_TRX_END) {
00781A  78409E     MOV.B [W14], W1
00781C  FB8001     ZE W1, W0
00781E  6000E8     AND W0, #0x8, W1
007820  EB0000     CLR W0
007822  508F80     SUB W1, W0, [W15]
007824  320050     BRA Z, 0x78C6
395:                       
396:                       status = trxReadSubReg(SR_TRAC_STATUS); // Determine transaction status
007826  B3C052     MOV #0x5, W2
007828  B3CE01     MOV #0xE0, W1
00782A  B3C020     MOV #0x2, W0
00782C  07FFD7     RCALL trxReadSubReg
00782E  984710     MOV.B W0, [W14+1]
397:                   
398:                       // Transmit complete case
399:                       if(trx_state == BUSY_TX_ARET) {
007830  810031     MOV trx_state, W1
007832  200120     MOV #0x12, W0
007834  508F80     SUB W1, W0, [W15]
007836  3A002A     BRA NZ, 0x788C
400:                       
401:                           trx_state = TX_ARET_ON; // State transition
007838  200190     MOV #0x19, W0
00783A  890030     MOV W0, trx_state
402:                       
403:                           if(status == TRAC_SUCCESS) {
00783C  90409E     MOV.B [W14+1], W1
00783E  EB4000     CLR.B W0
007840  50CF80     SUB.B W1, W0, [W15]
007842  3A0004     BRA NZ, 0x784C
404:                               irqCallback(RADIO_TX_SUCCESS);
007844  810021     MOV irqCallback, W1
007846  EB0000     CLR W0
007848  010001     CALL W1
00784A  37003D     BRA 0x78C6
405:                           } else if(status == TRAC_SUCCESS_DATA_PENDING) {
00784C  90409E     MOV.B [W14+1], W1
00784E  B3C010     MOV #0x1, W0
007850  50CF80     SUB.B W1, W0, [W15]
007852  3A0004     BRA NZ, 0x785C
406:                               irqCallback(RADIO_TX_SUCCESS);
007854  810021     MOV irqCallback, W1
007856  EB0000     CLR W0
007858  010001     CALL W1
00785A  370035     BRA 0x78C6
407:                           } else if(status == TRAC_CHANNEL_ACCESS_FAILURE) {
00785C  90409E     MOV.B [W14+1], W1
00785E  B3C030     MOV #0x3, W0
007860  50CF80     SUB.B W1, W0, [W15]
007862  3A0004     BRA NZ, 0x786C
408:                               irqCallback(RADIO_TX_FAILURE);            
007864  810021     MOV irqCallback, W1
007866  200010     MOV #0x1, W0
007868  010001     CALL W1
00786A  37002D     BRA 0x78C6
409:                           } else if(status == TRAC_NO_ACK) {
00786C  90409E     MOV.B [W14+1], W1
00786E  B3C050     MOV #0x5, W0
007870  50CF80     SUB.B W1, W0, [W15]
007872  3A0004     BRA NZ, 0x787C
410:                               irqCallback(RADIO_TX_FAILURE);            
007874  810021     MOV irqCallback, W1
007876  200010     MOV #0x1, W0
007878  010001     CALL W1
00787A  370025     BRA 0x78C6
411:                           } else if(status == TRAC_INVALID) {
00787C  90409E     MOV.B [W14+1], W1
00787E  B3C070     MOV #0x7, W0
007880  50CF80     SUB.B W1, W0, [W15]
007882  3A0021     BRA NZ, 0x78C6
412:                               irqCallback(RADIO_TX_FAILURE);
007884  810021     MOV irqCallback, W1
007886  200010     MOV #0x1, W0
007888  010001     CALL W1
00788A  37001D     BRA 0x78C6
413:                           }
414:                           
415:                       } else if(trx_state == RX_AACK_ON) {
00788C  810031     MOV trx_state, W1
00788E  200160     MOV #0x16, W0
007890  508F80     SUB W1, W0, [W15]
007892  3A0019     BRA NZ, 0x78C6
416:               
417:                           // crc_valid = trxReadSubReg(SR_RX_CRC_VALID);
418:                           // if(!crc_valid) {
419:                           //    Drop packet if invalid
420:                           // }
421:                           if(status == TRAC_SUCCESS) {
007894  90409E     MOV.B [W14+1], W1
007896  EB4000     CLR.B W0
007898  50CF80     SUB.B W1, W0, [W15]
00789A  3A0005     BRA NZ, 0x78A6
422:                               trxFillBuffer();
00789C  070038     RCALL trxFillBuffer
423:                               irqCallback(RADIO_RX_START);                
00789E  810021     MOV irqCallback, W1
0078A0  200020     MOV #0x2, W0
0078A2  010001     CALL W1
0078A4  370010     BRA 0x78C6
424:                           } else if(status == TRAC_WAIT_FOR_ACK) {                               
0078A6  90409E     MOV.B [W14+1], W1
0078A8  B3C020     MOV #0x2, W0
0078AA  50CF80     SUB.B W1, W0, [W15]
0078AC  3A0005     BRA NZ, 0x78B8
425:                               trxFillBuffer();
0078AE  07002F     RCALL trxFillBuffer
426:                               irqCallback(RADIO_RX_START);                
0078B0  810021     MOV irqCallback, W1
0078B2  200020     MOV #0x2, W0
0078B4  010001     CALL W1
0078B6  370007     BRA 0x78C6
427:                               // TODO: Add support for proper slotted ACK operation
428:                           } else if(status == TRAC_INVALID) {
0078B8  90409E     MOV.B [W14+1], W1
0078BA  B3C070     MOV #0x7, W0
0078BC  50CF80     SUB.B W1, W0, [W15]
0078BE  3A0003     BRA NZ, 0x78C6
429:                               irqCallback(RADIO_RX_FAILURE);
0078C0  810021     MOV irqCallback, W1
0078C2  200040     MOV #0x4, W0
0078C4  010001     CALL W1
430:                           }
431:                       }    
432:                   }
433:                   
434:                   _INT4IF = 0;                                // Clear interrupt flag
0078C6  A9C08A     BCLR IFS3, #6
435:                   
436:               }
0078C8  FA8000     ULNK
0078CA  BE034F     MOV.D [--W15], W6
0078CC  BE024F     MOV.D [--W15], W4
0078CE  BE014F     MOV.D [--W15], W2
0078D0  BE004F     MOV.D [--W15], W0
0078D2  F90036     POP RCOUNT
0078D4  064000     RETFIE
437:               
438:               static void trxSpiCallback(unsigned int interrupt_code) {
0078D6  FA0002     LNK #0x2
0078D8  780F00     MOV W0, [W14]
439:               
440:                   if(interrupt_code == SPIC_TRANS_SUCCESS) {
0078DA  78009E     MOV [W14], W1
0078DC  EB0000     CLR W0
0078DE  508F80     SUB W1, W0, [W15]
0078E0  3A000B     BRA NZ, 0x78F8
441:                              
442:                       spic1EndTransaction(); // End previous transaction
0078E2  02ABD0     CALL spic1EndTransaction
0078E4  000000     NOP
443:                   
444:                       if(trx_state == RX_AACK_ON) {
0078E6  810031     MOV trx_state, W1
0078E8  200160     MOV #0x16, W0
0078EA  508F80     SUB W1, W0, [W15]
0078EC  3A000E     BRA NZ, 0x790A
445:                           trxReadBuffer();    
0078EE  07001C     RCALL trxReadBuffer
446:                           irqCallback(RADIO_RX_SUCCESS);
0078F0  810021     MOV irqCallback, W1
0078F2  200030     MOV #0x3, W0
0078F4  010001     CALL W1
0078F6  370009     BRA 0x790A
447:                           
448:                       } else if(trx_state == TX_ARET_ON) {
449:                           
450:                           // Packet was successfully transferred to the radio buffer
451:                           // Do something?
452:                       
453:                       }
454:               
455:                   } else if(interrupt_code == SPIC_TRANS_TIMEOUT) {
0078F8  78009E     MOV [W14], W1
0078FA  200010     MOV #0x1, W0
0078FC  508F80     SUB W1, W0, [W15]
0078FE  3A0005     BRA NZ, 0x790A
456:                       
457:                       // This is indicative of some form of failure! 
458:                       spic1Reset();
007900  02ABE8     CALL spic1Reset
007902  000000     NOP
459:                       irqCallback(RADIO_HW_FAILURE);
007904  810021     MOV irqCallback, W1
007906  200050     MOV #0x5, W0
007908  010001     CALL W1
460:                       
461:                   }
462:                   
463:               }
00790A  FA8000     ULNK
00790C  060000     RETURN
464:               
465:               /**
466:                * Begin transfer of frame data from transceiver into DMA buffer
467:                */
468:               static void trxFillBuffer(void) {
00790E  FA0000     LNK #0x0
469:                   
470:                   spic1BeginTransaction();
007910  02ABA4     CALL spic1BeginTransaction
007912  000000     NOP
471:                   spic1Transmit(TRX_CMD_FR);  // Begin frame read
007914  B3C200     MOV #0x20, W0
007916  02AC08     CALL spic1Transmit
007918  000000     NOP
472:                   //current_phy_len = spic1Receive(); // Read physical frame size
473:                   //spic1MassTransmit(current_phy_len, NULL, current_phy_len*3); // DMA rest into buffer                                                    
474:                   spic1MassTransmit(FRAME_BUFFER_SIZE, NULL, FRAME_BUFFER_SIZE*3); // DMA entire frame buffer into memory
00791A  201802     MOV #0x180, W2
00791C  EB0080     CLR W1
00791E  200800     MOV #0x80, W0
007920  02ACB8     CALL spic1MassTransmit
007922  000000     NOP
475:                   
476:               }
007924  FA8000     ULNK
007926  060000     RETURN
477:               
478:               /**
479:                * Copy frame buffer contents from DMA into static software buffer
480:                */
481:               static void trxReadBuffer(void) {
007928  FA0000     LNK #0x0
482:                   
483:                   spic1ReadBuffer(FRAME_BUFFER_SIZE, frame_buffer);         
00792A  220081     MOV #0x2008, W1
00792C  200800     MOV #0x80, W0
00792E  02AD40     CALL spic1ReadBuffer
007930  000000     NOP
484:               
485:               }
007932  FA8000     ULNK
007934  060000     RETURN
486:               
487:               static void setupSPI(void) {
007936  FA0000     LNK #0x0
488:               
489:                   // SPI interrupt is not used.
490:                   _SPI1IF = 0;    // Clear the interrupt flag
007938  A94085     BCLR 0x85, #2
491:                   _SPI1IE = 0;    // Disable interrupts
00793A  A94095     BCLR 0x95, #2
492:               
493:                   // SPI1CON1 Register Settings
494:                   SPI_CON1bits.MSTEN = 1; // Master mode Enabled
00793C  A8A242     BSET SPI1CON1, #5
495:                   SPI_CON1bits.DISSCK = 0; // Internal Serial Clock is Enabled
00793E  A98243     BCLR 0x243, #4
496:                   SPI_CON1bits.DISSDO = 0; // SDOx pin is controlled by the module
007940  A96243     BCLR 0x243, #3
497:                   SPI_CON1bits.MODE16 = 0; // Communication is byte-wide (8 bits)
007942  A94243     BCLR 0x243, #2
498:                   SPI_CON1bits.SMP = 0; // Input data is sampled at middle of data output time
007944  A92243     BCLR 0x243, #1
499:                   SPI_CON1bits.SSEN = 0; // SSx pin is used
007946  A9E242     BCLR SPI1CON1, #7
500:                   SPI_CON1bits.CKE = 1; // Serial output data changes on transition
007948  A80243     BSET 0x243, #0
501:                                       // from active clock trx_state to idle clock trx_state
502:                   SPI_CON1bits.CKP = 0; // Idle trx_state for clock is a low level;
00794A  A9C242     BCLR SPI1CON1, #6
503:                                           // active trx_state is a high level
504:               
505:                   // Set up SCK frequency of 6.667Mhz for 40 MIPS
506:                   SPI_CON1bits.SPRE = 0b010; // Secondary prescale    6:1
00794C  801211     MOV SPI1CON1, W1
00794E  2FFE30     MOV #0xFFE3, W0
007950  608000     AND W1, W0, W0
007952  A03000     BSET W0, #3
007954  881210     MOV W0, SPI1CON1
507:                   SPI_CON1bits.PPRE = 0b11; // Primary prescale       1:1
007956  801210     MOV SPI1CON1, W0
007958  B30030     IOR #0x3, W0
00795A  881210     MOV W0, SPI1CON1
508:               
509:                   // SPI2CON2 Register Settings
510:                   SPI_CON2 = 0x0000; // Framed SPI2 support disabled
00795C  EB0000     CLR W0
00795E  881220     MOV W0, SPI1CON2
511:               
512:                   // SPI2STAT Register Settings
513:                   SPI_STATbits.SPISIDL = 1; // Discontinue module when device enters idle mode
007960  A8A241     BSET 0x241, #5
514:                   SPI_STATbits.SPIROV = 0; // Clear Overflow
007962  A9C240     BCLR SPI1STAT, #6
515:                   SPI_STATbits.SPIEN = 1; // Enable SPI module
007964  A8E241     BSET 0x241, #7
516:               
517:               }
007966  FA8000     ULNK
007968  060000     RETURN
518:               
519:               
520:               static inline void trxSetSlptr(unsigned char val) {      
00796A  FA0002     LNK #0x2
00796C  784F00     MOV.B W0, [W14]
521:                   SLPTR = val;
00796E  78409E     MOV.B [W14], W1
007970  60C061     AND.B W1, #0x1, W0
007972  FB8000     ZE W0, W0
007974  DD004F     SL W0, #15, W0
007976  801652     MOV LATB, W2
007978  27FFF1     MOV #0x7FFF, W1
00797A  610081     AND W2, W1, W1
00797C  708000     IOR W1, W0, W0
00797E  881650     MOV W0, LATB
522:                   Nop();
007980  000000     NOP
523:                   Nop();
007982  000000     NOP
524:               }
007984  FA8000     ULNK
007986  060000     RETURN
525:               
---  C:/Users/Cameron/Documents/Git/ibird-lib/telemetry.c  ----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2011-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Telemetry module
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v. beta
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu      2011-10-26    Initial implementation
38:                 *                      
39:                 * 
40:                 */
41:                
42:                #include "sys_clock.h"
43:                #include "telemetry.h"
44:                #include "radio.h"
45:                #include "net.h"
46:                #include "mac_packet.h"
47:                #include "payload.h"
48:                #include "regulator.h"
49:                #include "attitude.h"
50:                #include "cmd_const.h"
51:                #include "dfmem.h"
52:                #include "led.h"
53:                #include "utils.h"
54:                #include "pbuff.h"
55:                
56:                #include <string.h>
57:                
58:                #define DEFAULT_START_PAGE      (0x80)
59:                #define TELEM_BUFF_SIZE         (5)
60:                #define DEFAULT_SUBSAMPLE       (1)
61:                
62:                typedef enum {
63:                    TELEM_IDLE = 0,
64:                    TELEM_LOGGING,
65:                    TELEM_ERROR,
66:                } TelemStatus;
67:                
68:                // =========== Static Variables ================================================
69:                static unsigned char is_ready = 0, is_streaming = 0;
70:                static TelemStatus status = TELEM_IDLE;
71:                static unsigned int iter_num, subsample_period, stream_addr, send_iter;
72:                
73:                static PoolBuffStruct telem_buff;
74:                static TelemetryDatapoint datapoints[TELEM_BUFF_SIZE];
75:                
76:                static DfmemGeometryStruct mem_geo;
77:                static unsigned int mem_page_pos, mem_byte_pos, mem_buff_index;
78:                
79:                // =========== Function Stubs ==================================================
80:                void telemPopulateB(TelemetryB); 
81:                void telemPopulateAttitude(TelemetryAttitude);
82:                
83:                // =========== Public Methods ==================================================
84:                void telemSetup(void) {
00B53C  FA000C     LNK #0xC
85:                
86:                    unsigned int i;
87:                    TelemetryDatapoint *s[TELEM_BUFF_SIZE];
88:                
89:                    dfmemGetGeometryParams(&mem_geo); // Read memory chip sizing
00B53E  21DD80     MOV #0x1DD8, W0
00B540  027EE2     CALL dfmemGetGeometryParams
00B542  000000     NOP
90:                    mem_page_pos = DEFAULT_START_PAGE;    
00B544  200800     MOV #0x80, W0
00B546  88EF40     MOV W0, mem_page_pos
91:                    mem_byte_pos = 0;
00B548  EB0000     CLR W0
00B54A  88EF50     MOV W0, mem_byte_pos
92:                    mem_buff_index = 0;    
00B54C  EB0000     CLR W0
00B54E  88EF60     MOV W0, mem_buff_index
93:                
94:                    for(i = 0; i < TELEM_BUFF_SIZE; i++) {
00B550  EB0000     CLR W0
00B552  780F00     MOV W0, [W14]
00B554  37000C     BRA 0xB56E
00B56C  E80F1E     INC [W14], [W14]
00B56E  78009E     MOV [W14], W1
00B570  200040     MOV #0x4, W0
00B572  508F80     SUB W1, W0, [W15]
00B574  36FFF0     BRA LEU, 0xB556
95:                        s[i] = &datapoints[i];
00B556  78009E     MOV [W14], W1
00B558  200440     MOV #0x44, W0
00B55A  B98800     MUL.SS W1, W0, W0
00B55C  780080     MOV W0, W1
00B55E  21C840     MOV #0x1C84, W0
00B560  408080     ADD W1, W0, W1
00B562  E8810E     INC2 W14, W2
00B564  78001E     MOV [W14], W0
00B566  400000     ADD W0, W0, W0
00B568  410000     ADD W2, W0, W0
00B56A  780801     MOV W1, [W0]
96:                    }
97:                
98:                    pbuffInit(&telem_buff, TELEM_BUFF_SIZE, (void**)s);
00B576  E8800E     INC2 W14, W0
00B578  780100     MOV W0, W2
00B57A  200051     MOV #0x5, W1
00B57C  21C7E0     MOV #0x1C7E, W0
00B57E  02D25A     CALL pbuffInit
00B580  000000     NOP
99:                    if(telem_buff.valid == 0) { return; }
00B582  21C7E0     MOV #0x1C7E, W0
00B584  784090     MOV.B [W0], W1
00B586  EB4000     CLR.B W0
00B588  50CF80     SUB.B W1, W0, [W15]
00B58A  32000B     BRA Z, 0xB5A2
00B5A2  000000     NOP
100:               
101:                   iter_num = 0;
00B58C  EB0000     CLR W0
00B58E  88E3B0     MOV W0, iter_num
102:                   subsample_period = DEFAULT_SUBSAMPLE;
00B590  200010     MOV #0x1, W0
00B592  88E3C0     MOV W0, subsample_period
103:                   
104:                   is_ready = 1;
00B594  21C721     MOV #0x1C72, W1
00B596  B3C010     MOV #0x1, W0
00B598  784880     MOV.B W0, [W1]
105:                   is_streaming = 0;
00B59A  21C731     MOV #0x1C73, W1
00B59C  EB4000     CLR.B W0
00B59E  784880     MOV.B W0, [W1]
00B5A0  370001     BRA 0xB5A4
106:               
107:               }
00B5A4  FA8000     ULNK
00B5A6  060000     RETURN
108:               
109:               void telemSetSubsampleRate(unsigned int rate) {
00B5A8  FA0002     LNK #0x2
00B5AA  780F00     MOV W0, [W14]
110:                   subsample_period = rate;
00B5AC  78001E     MOV [W14], W0
00B5AE  88E3C0     MOV W0, subsample_period
111:               }
00B5B0  FA8000     ULNK
00B5B2  060000     RETURN
112:               
113:               void telemToggleStreaming(unsigned int addr) {
00B5B4  FA0002     LNK #0x2
00B5B6  780F00     MOV W0, [W14]
114:                   if(is_streaming) {
00B5B8  21C730     MOV #0x1C73, W0
00B5BA  784090     MOV.B [W0], W1
00B5BC  EB4000     CLR.B W0
00B5BE  50CF80     SUB.B W1, W0, [W15]
00B5C0  320004     BRA Z, 0xB5CA
115:                       is_streaming = 0;
00B5C2  21C731     MOV #0x1C73, W1
00B5C4  EB4000     CLR.B W0
00B5C6  784880     MOV.B W0, [W1]
00B5C8  370005     BRA 0xB5D4
116:                   } else {
117:                       is_streaming = 1;
00B5CA  21C731     MOV #0x1C73, W1
00B5CC  B3C010     MOV #0x1, W0
00B5CE  784880     MOV.B W0, [W1]
118:                       stream_addr = addr;
00B5D0  78001E     MOV [W14], W0
00B5D2  88E3D0     MOV W0, stream_addr
119:                   }
120:               }
00B5D4  FA8000     ULNK
00B5D6  060000     RETURN
121:               
122:               void telemStartLogging(void) {
00B5D8  FA0000     LNK #0x0
123:               
124:                   if(!is_ready) { return; }
00B5DA  21C720     MOV #0x1C72, W0
00B5DC  784090     MOV.B [W0], W1
00B5DE  EB4000     CLR.B W0
00B5E0  50CF80     SUB.B W1, W0, [W15]
00B5E2  320012     BRA Z, 0xB608
00B608  000000     NOP
125:               
126:                   mem_page_pos = DEFAULT_START_PAGE;
00B5E4  200800     MOV #0x80, W0
00B5E6  88EF40     MOV W0, mem_page_pos
127:                   mem_byte_pos = 0;
00B5E8  EB0000     CLR W0
00B5EA  88EF50     MOV W0, mem_byte_pos
128:                   mem_buff_index = 0;
00B5EC  EB0000     CLR W0
00B5EE  88EF60     MOV W0, mem_buff_index
129:               
130:                   dfmemEraseChip();
00B5F0  027C96     CALL dfmemEraseChip
00B5F2  000000     NOP
131:               //    unsigned int i;
132:               //    i = mem_page_pos;
133:               //    while(i < mem_geo.max_pages/4) {
134:               //        dfmemEraseSector(i);
135:               //        i += mem_geo.pages_per_sector;
136:               //    }
137:                   
138:                   while(!dfmemIsReady());
00B5F4  000000     NOP
00B5F6  027CBA     CALL dfmemIsReady
00B5F8  000000     NOP
00B5FA  EB4080     CLR.B W1
00B5FC  504F81     SUB.B W0, W1, [W15]
00B5FE  32FFFB     BRA Z, 0xB5F6
139:                   status = TELEM_LOGGING;
00B600  200010     MOV #0x1, W0
00B602  88E3A0     MOV W0, status
140:                   LED_RED = 1;
00B604  A882CB     BSET 0x2CB, #4
00B606  370001     BRA 0xB60A
141:               
142:               }
00B60A  FA8000     ULNK
00B60C  060000     RETURN
143:               
144:               void telemStopLogging(void) {
00B60E  FA0000     LNK #0x0
145:                   
146:                   // TODO: Check for error condition
147:                   status = TELEM_IDLE;
00B610  EB0000     CLR W0
00B612  88E3A0     MOV W0, status
148:                   LED_RED = 0;
00B614  A982CB     BCLR 0x2CB, #4
149:                   
150:               }
00B616  FA8000     ULNK
00B618  060000     RETURN
151:               
152:               
153:               
154:               void telemLog(void) {
00B61A  FA0002     LNK #0x2
155:               
156:                   TelemetryDatapoint *data;
157:                   //RadioStatus radio_stat;
158:                   
159:                   if(!is_ready) { return; }
00B61C  21C720     MOV #0x1C72, W0
00B61E  784090     MOV.B [W0], W1
00B620  EB4000     CLR.B W0
00B622  50CF80     SUB.B W1, W0, [W15]
00B624  320021     BRA Z, 0xB668
00B668  000000     NOP
00B66A  370005     BRA 0xB676
160:                   if(status != TELEM_LOGGING) { return; }
00B626  80E3A1     MOV status, W1
00B628  200010     MOV #0x1, W0
00B62A  508F80     SUB W1, W0, [W15]
00B62C  3A001F     BRA NZ, 0xB66C
00B66C  000000     NOP
00B66E  370003     BRA 0xB676
161:                   
162:                   iter_num++;    
00B62E  80E3B0     MOV iter_num, W0
00B630  E80000     INC W0, W0
00B632  88E3B0     MOV W0, iter_num
163:                   if(iter_num % subsample_period != 0) { return; }
00B634  80E3B1     MOV iter_num, W1
00B636  80E3C0     MOV subsample_period, W0
00B638  780100     MOV W0, W2
00B63A  090011     REPEAT #0x11
00B63C  D88082     DIV.UW W1, W2
00B63E  FD0080     EXCH W0, W1
00B640  780080     MOV W0, W1
00B642  EB0000     CLR W0
00B644  508F80     SUB W1, W0, [W15]
00B646  3A0014     BRA NZ, 0xB670
00B670  000000     NOP
00B672  370001     BRA 0xB676
164:                   
165:                   data = pbuffGetIdle(&telem_buff);
00B648  21C7E0     MOV #0x1C7E, W0
00B64A  02D37A     CALL pbuffGetIdle
00B64C  000000     NOP
00B64E  780F00     MOV W0, [W14]
166:                   if(data == NULL) { return; }
00B650  78009E     MOV [W14], W1
00B652  EB0000     CLR W0
00B654  508F80     SUB W1, W0, [W15]
00B656  32000E     BRA Z, 0xB674
00B674  000000     NOP
167:                   
168:                   rgltrGetState(&data->reg_state); // Fetch regulator data
00B658  78001E     MOV [W14], W0
00B65A  024338     CALL rgltrGetState
00B65C  000000     NOP
169:                   //(&radio_stat);
170:                   //data->ED = radio_stat.last_ed;
171:                   //data->RSSI = radio_stat.last_rssi;
172:                   pbuffAddActive(&telem_buff, data); // Queue data
00B65E  78009E     MOV [W14], W1
00B660  21C7E0     MOV #0x1C7E, W0
00B662  02D2F2     CALL pbuffAddActive
00B664  000000     NOP
00B666  370007     BRA 0xB676
173:               
174:               }
00B676  FA8000     ULNK
00B678  060000     RETURN
175:               
176:               void telemStream(void) {
00B67A  FA0000     LNK #0x0
177:                   if(!is_ready) { return; }
00B67C  21C720     MOV #0x1C72, W0
00B67E  784090     MOV.B [W0], W1
00B680  EB4000     CLR.B W0
00B682  50CF80     SUB.B W1, W0, [W15]
00B684  320015     BRA Z, 0xB6B0
00B6B0  000000     NOP
00B6B2  370003     BRA 0xB6BA
178:                   if(!is_streaming) { return; }
00B686  21C730     MOV #0x1C73, W0
00B688  784090     MOV.B [W0], W1
00B68A  EB4000     CLR.B W0
00B68C  50CF80     SUB.B W1, W0, [W15]
00B68E  320012     BRA Z, 0xB6B4
00B6B4  000000     NOP
00B6B6  370001     BRA 0xB6BA
179:               
180:                   send_iter++;
00B690  80E3E0     MOV send_iter, W0
00B692  E80000     INC W0, W0
00B694  88E3E0     MOV W0, send_iter
181:                   if(send_iter % subsample_period != 0) { return; }
00B696  80E3E1     MOV send_iter, W1
00B698  80E3C0     MOV subsample_period, W0
00B69A  780100     MOV W0, W2
00B69C  090011     REPEAT #0x11
00B69E  D88082     DIV.UW W1, W2
00B6A0  FD0080     EXCH W0, W1
00B6A2  780080     MOV W0, W1
00B6A4  EB0000     CLR W0
00B6A6  508F80     SUB W1, W0, [W15]
00B6A8  3A0007     BRA NZ, 0xB6B8
00B6B8  000000     NOP
182:               
183:                   telemSendB(stream_addr);
00B6AA  80E3D0     MOV stream_addr, W0
00B6AC  07004D     RCALL telemSendB
00B6AE  370005     BRA 0xB6BA
184:               }
00B6BA  FA8000     ULNK
00B6BC  060000     RETURN
185:               
186:               void telemProcess(void) {
00B6BE  FA0002     LNK #0x2
187:               
188:                   TelemetryDatapoint *data;
189:               
190:                   if(!is_ready) { return; }
00B6C0  21C720     MOV #0x1C72, W0
00B6C2  784090     MOV.B [W0], W1
00B6C4  EB4000     CLR.B W0
00B6C6  50CF80     SUB.B W1, W0, [W15]
00B6C8  320038     BRA Z, 0xB73A
00B73A  000000     NOP
00B73C  370003     BRA 0xB744
191:               
192:                   if(mem_page_pos >= mem_geo.max_pages) { telemStopLogging(); }
00B6CA  80EEE1     MOV 0x1DDC, W1
00B6CC  80EF40     MOV mem_page_pos, W0
00B6CE  508F80     SUB W1, W0, [W15]
00B6D0  3E0001     BRA GTU, 0xB6D4
00B6D2  07FF9D     RCALL telemStopLogging
193:                   if(status != TELEM_LOGGING) { return; }
00B6D4  80E3A1     MOV status, W1
00B6D6  200010     MOV #0x1, W0
00B6D8  508F80     SUB W1, W0, [W15]
00B6DA  3A0031     BRA NZ, 0xB73E
00B73E  000000     NOP
00B740  370001     BRA 0xB744
194:                   
195:                   data = pbuffGetOldestActive(&telem_buff);
00B6DC  21C7E0     MOV #0x1C7E, W0
00B6DE  02D332     CALL pbuffGetOldestActive
00B6E0  000000     NOP
00B6E2  780F00     MOV W0, [W14]
196:                   if(data == NULL) { return; }    
00B6E4  78009E     MOV [W14], W1
00B6E6  EB0000     CLR W0
00B6E8  508F80     SUB W1, W0, [W15]
00B6EA  32002B     BRA Z, 0xB742
00B742  000000     NOP
197:                   
198:                   dfmemWriteBuffer((unsigned char*)data, sizeof(TelemetryDatapoint), mem_byte_pos, mem_buff_index);
00B6EC  80EF60     MOV mem_buff_index, W0
00B6EE  784000     MOV.B W0, W0
00B6F0  80EF51     MOV mem_byte_pos, W1
00B6F2  78021E     MOV [W14], W4
00B6F4  784180     MOV.B W0, W3
00B6F6  780101     MOV W1, W2
00B6F8  200441     MOV #0x44, W1
00B6FA  780004     MOV W4, W0
00B6FC  027A22     CALL dfmemWriteBuffer
00B6FE  000000     NOP
199:                   mem_byte_pos += sizeof(TelemetryDatapoint);
00B700  80EF50     MOV mem_byte_pos, W0
00B702  B00440     ADD #0x44, W0
00B704  88EF50     MOV W0, mem_byte_pos
200:                   
201:                   if(mem_byte_pos + sizeof(TelemetryDatapoint) > mem_geo.bytes_per_page) {
00B706  80EF50     MOV mem_byte_pos, W0
00B708  200441     MOV #0x44, W1
00B70A  408080     ADD W1, W0, W1
00B70C  80EF00     MOV 0x1DE0, W0
00B70E  508F80     SUB W1, W0, [W15]
00B710  36000F     BRA LEU, 0xB730
202:                   
203:                       dfmemWriteBuffer2MemoryNoErase(mem_page_pos, mem_buff_index);
00B712  80EF60     MOV mem_buff_index, W0
00B714  784000     MOV.B W0, W0
00B716  80EF42     MOV mem_page_pos, W2
00B718  784080     MOV.B W0, W1
00B71A  780002     MOV W2, W0
00B71C  027A8A     CALL dfmemWriteBuffer2MemoryNoErase
00B71E  000000     NOP
204:                       mem_buff_index ^= 0x01;
00B720  80EF60     MOV mem_buff_index, W0
00B722  A20000     BTG W0, #0
00B724  88EF60     MOV W0, mem_buff_index
205:                       mem_byte_pos = 0;
00B726  EB0000     CLR W0
00B728  88EF50     MOV W0, mem_byte_pos
206:                       mem_page_pos++;                
00B72A  80EF40     MOV mem_page_pos, W0
00B72C  E80000     INC W0, W0
00B72E  88EF40     MOV W0, mem_page_pos
207:                       
208:                   }
209:               
210:                   pbuffReturn(&telem_buff, data);
00B730  78009E     MOV [W14], W1
00B732  21C7E0     MOV #0x1C7E, W0
00B734  02D3D4     CALL pbuffReturn
00B736  000000     NOP
00B738  370005     BRA 0xB744
211:               
212:               
213:               }
00B744  FA8000     ULNK
00B746  060000     RETURN
214:               
215:               void telemSendB(unsigned int addr) {
00B748  FA004E     LNK #0x4E
00B74A  982760     MOV W0, [W14+76]
216:               
217:               	MacPacket packet;
218:               	Payload pld;
219:               	TelemetryStructB telemetryB;
220:               	
221:               	// Populate the telemetry fields
222:               	telemPopulateB(&telemetryB);
00B74C  470064     ADD W14, #0x4, W0
00B74E  07005E     RCALL telemPopulateB
223:               	
224:               	// Create a radio packet
225:               	packet = radioRequestPacket(TELEMETRY_B_SIZE);
00B750  200480     MOV #0x48, W0
00B752  0281B2     CALL radioRequestPacket
00B754  000000     NOP
00B756  780F00     MOV W0, [W14]
226:               	if(packet == NULL) { return; }
00B758  78009E     MOV [W14], W1
00B75A  EB0000     CLR W0
00B75C  508F80     SUB W1, W0, [W15]
00B75E  320022     BRA Z, 0xB7A4
00B7A4  000000     NOP
227:                       macSetDestAddr(packet, addr);
00B760  9020EE     MOV [W14+76], W1
00B762  78001E     MOV [W14], W0
00B764  02863C     CALL macSetDestAddr
00B766  000000     NOP
228:                       macSetDestPan(packet, netGetLocalPanID());
00B768  02C31E     CALL netGetLocalPanID
00B76A  000000     NOP
00B76C  780080     MOV W0, W1
00B76E  78001E     MOV [W14], W0
00B770  02864C     CALL macSetDestPan
00B772  000000     NOP
229:               
230:               	// Write the telemetry struct into the packet payload
231:               	pld = macGetPayload(packet);
00B774  78001E     MOV [W14], W0
00B776  0286E6     CALL macGetPayload
00B778  000000     NOP
00B77A  980710     MOV W0, [W14+2]
232:               	paySetType(pld, CMD_RESPONSE_TELEMETRY);
00B77C  B3C2E1     MOV #0x2E, W1
00B77E  90001E     MOV [W14+2], W0
00B780  02CADE     CALL paySetType
00B782  000000     NOP
233:               	paySetData(pld, TELEMETRY_B_SIZE, (unsigned char *) &telemetryB);
00B784  470064     ADD W14, #0x4, W0
00B786  780100     MOV W0, W2
00B788  B3C481     MOV #0x48, W1
00B78A  90001E     MOV [W14+2], W0
00B78C  02CAAE     CALL paySetData
00B78E  000000     NOP
234:               	if(!radioEnqueueTxPacket(packet)) {
00B790  78001E     MOV [W14], W0
00B792  028128     CALL radioEnqueueTxPacket
00B794  000000     NOP
00B796  EB0080     CLR W1
00B798  500F81     SUB W0, W1, [W15]
00B79A  3A0005     BRA NZ, 0xB7A6
235:               		radioReturnPacket(packet);	// Delete packet if append fails
00B79C  78001E     MOV [W14], W0
00B79E  028240     CALL radioReturnPacket
00B7A0  000000     NOP
00B7A2  370001     BRA 0xB7A6
236:               	}
237:               	
238:               }
00B7A6  FA8000     ULNK
00B7A8  060000     RETURN
239:               
240:               void telemSendAttitude(unsigned int addr) {
00B7AA  FA0016     LNK #0x16
00B7AC  980F20     MOV W0, [W14+20]
241:               
242:                   MacPacket packet;
243:               	Payload pld;
244:               	TelemetryStructAttitude telemetryAtt;
245:               	
246:               	// Populate the telemetry fields
247:               	telemPopulateAttitude(&telemetryAtt);
00B7AE  470064     ADD W14, #0x4, W0
00B7B0  070039     RCALL telemPopulateAttitude
248:               	
249:               	// Create a radio packet
250:               	packet = radioRequestPacket(TELEMETRY_ATT_SIZE);
00B7B2  200100     MOV #0x10, W0
00B7B4  0281B2     CALL radioRequestPacket
00B7B6  000000     NOP
00B7B8  780F00     MOV W0, [W14]
251:               	if(packet == NULL) { return; }
00B7BA  78009E     MOV [W14], W1
00B7BC  EB0000     CLR W0
00B7BE  508F80     SUB W1, W0, [W15]
00B7C0  320022     BRA Z, 0xB806
00B806  000000     NOP
252:                       macSetDestAddr(packet, addr);
00B7C2  9008AE     MOV [W14+20], W1
00B7C4  78001E     MOV [W14], W0
00B7C6  02863C     CALL macSetDestAddr
00B7C8  000000     NOP
253:                       macSetDestPan(packet, netGetLocalPanID());
00B7CA  02C31E     CALL netGetLocalPanID
00B7CC  000000     NOP
00B7CE  780080     MOV W0, W1
00B7D0  78001E     MOV [W14], W0
00B7D2  02864C     CALL macSetDestPan
00B7D4  000000     NOP
254:               
255:               	// Write the telemetry struct into the packet payload
256:               	pld = macGetPayload(packet);
00B7D6  78001E     MOV [W14], W0
00B7D8  0286E6     CALL macGetPayload
00B7DA  000000     NOP
00B7DC  980710     MOV W0, [W14+2]
257:               	paySetType(pld, CMD_RESPONSE_ATTITUDE);
00B7DE  B3C511     MOV #0x51, W1
00B7E0  90001E     MOV [W14+2], W0
00B7E2  02CADE     CALL paySetType
00B7E4  000000     NOP
258:               	paySetData(pld, TELEMETRY_ATT_SIZE, (unsigned char *) &telemetryAtt);
00B7E6  470064     ADD W14, #0x4, W0
00B7E8  780100     MOV W0, W2
00B7EA  B3C101     MOV #0x10, W1
00B7EC  90001E     MOV [W14+2], W0
00B7EE  02CAAE     CALL paySetData
00B7F0  000000     NOP
259:               	if(!radioEnqueueTxPacket(packet)) {
00B7F2  78001E     MOV [W14], W0
00B7F4  028128     CALL radioEnqueueTxPacket
00B7F6  000000     NOP
00B7F8  EB0080     CLR W1
00B7FA  500F81     SUB W0, W1, [W15]
00B7FC  3A0005     BRA NZ, 0xB808
260:                       radioReturnPacket(packet);	// Delete packet if append fails
00B7FE  78001E     MOV [W14], W0
00B800  028240     CALL radioReturnPacket
00B802  000000     NOP
00B804  370001     BRA 0xB808
261:               	}
262:               	
263:               }
00B808  FA8000     ULNK
00B80A  060000     RETURN
264:               
265:               void telemPopulateB(TelemetryB telemetry) {	    
00B80C  FA0046     LNK #0x46
00B80E  982720     MOV W0, [W14+68]
266:               
267:                   RegulatorStateStruct state;
268:               
269:                   rgltrGetState(&state);
00B810  78000E     MOV W14, W0
00B812  024338     CALL rgltrGetState
00B814  000000     NOP
270:                   memcpy(telemetry, &state, sizeof(RegulatorStateStruct));
00B816  200442     MOV #0x44, W2
00B818  78008E     MOV W14, W1
00B81A  90202E     MOV [W14+68], W0
00B81C  023582     CALL _memcpy
00B81E  000000     NOP
271:               
272:               }
00B820  FA8000     ULNK
00B822  060000     RETURN
273:               
274:               void telemPopulateAttitude(TelemetryAttitude att) {
00B824  FA0012     LNK #0x12
00B826  980F00     MOV W0, [W14+16]
275:               
276:                   Quaternion pose;
277:                   
278:                   attGetQuat(&pose);
00B828  78000E     MOV W14, W0
00B82A  028ABC     CALL attGetQuat
00B82C  000000     NOP
279:                   memcpy(att, &pose, sizeof(Quaternion));    
00B82E  200102     MOV #0x10, W2
00B830  78008E     MOV W14, W1
00B832  90080E     MOV [W14+16], W0
00B834  023582     CALL _memcpy
00B836  000000     NOP
280:               
281:               }
00B838  FA8000     ULNK
00B83A  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/sys_clock.c  ----------------------------------------------
1:                 /**
2:                  * Copyright (c) 2008-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * System Time Module
31:                 *
32:                 * by Humphrey Hu
33:                 * based on "stopwatch.c" by Stanley S. Baek
34:                 *
35:                 * v.beta
36:                 *
37:                 * Revisions:
38:                 *  Stanley S. Baek     2010-06-16      Initial release of "stopwatch.c"
39:                 *  Humphrey Hu         2012-02-20      Initial release
40:                 *                      
41:                 * Notes:
42:                 *  - MCU resources requied for this module:
43:                 *      Timer8 & Timer9 are used for a 32-bit timer. 
44:                 *
45:                 * Usage:
46:                 */
47:                 
48:                #include "timer.h"
49:                #include "sys_clock.h"
50:                
51:                #define TMR_MSW         (TMR9HLD)
52:                #define TMR_LSW         (TMR8)
53:                #define MILLIS_FACTOR   (625)
54:                
55:                // Time is represented by a 32-bit number
56:                typedef union {
57:                    unsigned long time;
58:                    struct {
59:                        unsigned int lsw;
60:                        unsigned int msw;
61:                    } half;    
62:                } Time;
63:                
64:                /*-----------------------------------------------------------------------------
65:                 *          Static Variables
66:                -----------------------------------------------------------------------------*/
67:                
68:                static Time sclock_offset;
69:                
70:                /*-----------------------------------------------------------------------------
71:                 *          Declaration of static functions
72:                -----------------------------------------------------------------------------*/
73:                
74:                static void sclockSetupPeripheral(void);
75:                
76:                // =========== Public Functions ===============================================
77:                void sclockSetup(void) {
00DE0A  FA0000     LNK #0x0
78:                
79:                    sclockSetupPeripheral();
00DE0C  070057     RCALL sclockSetupPeripheral
80:                    sclockReset();
00DE0E  070002     RCALL sclockReset
81:                
82:                }
00DE10  FA8000     ULNK
00DE12  060000     RETURN
83:                
84:                // TODO: Make private
85:                void sclockReset(void) {
00DE14  FA0000     LNK #0x0
86:                
87:                    // do not change the order of the following two lines.
88:                    TMR_MSW = 0;
00DE16  EB0000     CLR W0
00DE18  880990     MOV W0, TMR9HLD
89:                    TMR_LSW = 0;
00DE1A  EB0000     CLR W0
00DE1C  880980     MOV W0, TMR8
90:                    sclock_offset.time = 0;
00DE1E  B80060     MUL.UU W0, #0, W0
00DE20  891110     MOV W0, _sclock_offset
00DE22  891121     MOV W1, 0x2224
91:                
92:                }
00DE24  FA8000     ULNK
00DE26  060000     RETURN
93:                
94:                unsigned long sclockGetGlobalTicks(void) {
00DE28  FA0004     LNK #0x4
95:                
96:                    Time time;
97:                    time.half.lsw = TMR_LSW;
00DE2A  800980     MOV TMR8, W0
00DE2C  780F00     MOV W0, [W14]
98:                    time.half.msw = TMR_MSW;
00DE2E  800990     MOV TMR9HLD, W0
00DE30  980710     MOV W0, [W14+2]
99:                    return time.time + sclock_offset.time;
00DE32  BE011E     MOV.D [W14], W2
00DE34  811110     MOV _sclock_offset, W0
00DE36  811121     MOV 0x2224, W1
00DE38  400002     ADD W0, W2, W0
00DE3A  488083     ADDC W1, W3, W1
100:               
101:               }
00DE3C  FA8000     ULNK
00DE3E  060000     RETURN
102:               
103:               unsigned long sclockGetGlobalMillis(void) {
00DE40  FA0000     LNK #0x0
104:               
105:                   return sclockGetGlobalTicks()/MILLIS_FACTOR;
00DE42  07FFF2     RCALL sclockGetGlobalTicks
00DE44  202712     MOV #0x271, W2
00DE46  200003     MOV #0x0, W3
00DE48  022D42     CALL ___udivsi3x
00DE4A  000000     NOP
106:               
107:               }
00DE4C  FA8000     ULNK
00DE4E  060000     RETURN
108:               
109:               unsigned long sclockGetLocalTicks(void) {
00DE50  FA0004     LNK #0x4
110:               
111:                   Time time;
112:                   time.half.lsw = TMR_LSW;
00DE52  800980     MOV TMR8, W0
00DE54  780F00     MOV W0, [W14]
113:                   time.half.msw = TMR_MSW;
00DE56  800990     MOV TMR9HLD, W0
00DE58  980710     MOV W0, [W14+2]
114:                   return time.time;
00DE5A  BE001E     MOV.D [W14], W0
115:               
116:               }
00DE5C  FA8000     ULNK
00DE5E  060000     RETURN
117:               
118:               unsigned long sclockGetLocalMillis(void) {
00DE60  FA0000     LNK #0x0
119:               
120:                   return sclockGetLocalTicks()/MILLIS_FACTOR;
00DE62  07FFF6     RCALL sclockGetLocalTicks
00DE64  202712     MOV #0x271, W2
00DE66  200003     MOV #0x0, W3
00DE68  022D42     CALL ___udivsi3x
00DE6A  000000     NOP
121:               
122:               }
00DE6C  FA8000     ULNK
00DE6E  060000     RETURN
123:               
124:               unsigned long sclockGetOffsetTicks(void) {
00DE70  FA0000     LNK #0x0
125:                   
126:                   return sclock_offset.time;
00DE72  811110     MOV _sclock_offset, W0
00DE74  811121     MOV 0x2224, W1
127:               
128:               }
00DE76  FA8000     ULNK
00DE78  060000     RETURN
129:               
130:               unsigned long sclockGetOffsetMillis(void) {
00DE7A  FA0000     LNK #0x0
131:               
132:                   return sclockGetOffsetTicks()/MILLIS_FACTOR;
00DE7C  07FFF9     RCALL sclockGetOffsetTicks
00DE7E  202712     MOV #0x271, W2
00DE80  200003     MOV #0x0, W3
00DE82  022D42     CALL ___udivsi3x
00DE84  000000     NOP
133:               
134:               }
00DE86  FA8000     ULNK
00DE88  060000     RETURN
135:               
136:               void sclockSetOffsetTicks(unsigned long offset) {
00DE8A  FA0004     LNK #0x4
00DE8C  BE8F00     MOV.D W0, [W14]
137:               
138:                   sclock_offset.time = offset;
00DE8E  BE001E     MOV.D [W14], W0
00DE90  891110     MOV W0, _sclock_offset
00DE92  891121     MOV W1, 0x2224
139:               
140:               }
00DE94  FA8000     ULNK
00DE96  060000     RETURN
141:               
142:               void sclockSetOffsetMillis(unsigned long offset) {
00DE98  FA0004     LNK #0x4
00DE9A  BE8F00     MOV.D W0, [W14]
143:               
144:                   sclockSetOffsetTicks(offset*MILLIS_FACTOR);
00DE9C  90009E     MOV [W14+2], W1
00DE9E  202710     MOV #0x271, W0
00DEA0  B98800     MUL.SS W1, W0, W0
00DEA2  780100     MOV W0, W2
00DEA4  78001E     MOV [W14], W0
00DEA6  B90060     MUL.SU W0, #0, W0
00DEA8  780000     MOV W0, W0
00DEAA  410100     ADD W2, W0, W2
00DEAC  78009E     MOV [W14], W1
00DEAE  202710     MOV #0x271, W0
00DEB0  B80800     MUL.UU W1, W0, W0
00DEB2  410101     ADD W2, W1, W2
00DEB4  780082     MOV W2, W1
00DEB6  07FFE9     RCALL sclockSetOffsetTicks
145:               
146:               }
00DEB8  FA8000     ULNK
00DEBA  060000     RETURN
147:               
148:               // =========== Private Functions ==============================================
149:               
150:               /**
151:                * Timer ticks 625 times per millisecond with 64:1 prescale
152:                */
153:               static void sclockSetupPeripheral(void) {
00DEBC  FA0004     LNK #0x4
154:               
155:                   unsigned int T8CONvalue, T8PERvalue;
156:                   T8CONvalue =    T8_OFF &         
00DEBE  25FAD0     MOV #0x5FAD, W0
00DEC0  780F00     MOV W0, [W14]
157:                                   T8_IDLE_CON &
158:                                   T8_GATE_OFF &
159:                                   T8_PS_1_64 &
160:                                   T8_32BIT_MODE_ON &
161:                                   T8_SOURCE_INT;
162:                   T8PERvalue = 40;    // this value doesn't really mean anything here.
00DEC2  200280     MOV #0x28, W0
00DEC4  980710     MOV W0, [W14+2]
163:                   OpenTimer8(T8CONvalue, T8PERvalue);	
00DEC6  90009E     MOV [W14+2], W1
00DEC8  78001E     MOV [W14], W0
00DECA  022566     CALL _OpenTimer8
00DECC  000000     NOP
164:                   T8CONbits.TON = 1;
00DECE  A8E13B     BSET 0x13B, #7
165:                   
166:               }
00DED0  FA8000     ULNK
00DED2  060000     RETURN
167:               
168:               
169:               
170:               
---  C:/Users/Cameron/Documents/Git/ibird-lib/sync_servo.c  ---------------------------------------------
1:                 /*
2:                 * Copyright (c) 2009 - 2010, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Synchronous Software Servo (RC PWM) Module
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v.alpha
35:                *
36:                * Revisions:
37:                *  Humphrey Hu             2011-9-23      Initial implementation
38:                *  Humphrey Hu             2012-6-21      Switched to normalized float inputs
39:                *
40:                */
41:                
42:                #include "sync_servo.h"
43:                #include "utils.h"
44:                #include "timer.h"
45:                
46:                #define SERVO_A                 _LATE1
47:                
48:                #define FCY                     (40000000)
49:                #define PWM_FREQUENCY           (50)
50:                #define PWM_PERIOD              (12500) // 40 MIPS/(prescale * frequency)
51:                
52:                #define PULSE_MAX_LENGTH        (1250)
53:                #define PULSE_MIN_LENGTH        (625)
54:                #define PULSE_AMPLITUDE         ((PULSE_MAX_LENGTH - PULSE_MIN_LENGTH)/2) // 312
55:                #define PULSE_ZERO_LENGTH       ((PULSE_MAX_LENGTH + PULSE_MIN_LENGTH)/2) // 937
56:                
57:                // =========== Function Prototypes ============================================ 
58:                static void setupTimer4(unsigned int frequency);
59:                
60:                // =========== Static Variables ===============================================
61:                static unsigned char pin_is_high;
62:                static unsigned int pulse_length, setpoint;
63:                static int current_setpoint;
64:                
65:                // =========== Public Methods =================================================
66:                void servoSetup(void) {
00D946  FA0000     LNK #0x0
67:                
68:                    setupTimer4(PWM_FREQUENCY);
00D948  200320     MOV #0x32, W0
00D94A  070073     RCALL setupTimer4
69:                
70:                    pin_is_high = 0;
00D94C  221F81     MOV #0x21F8, W1
00D94E  EB4000     CLR.B W0
00D950  784880     MOV.B W0, [W1]
71:                    SERVO_A = 0;
00D952  A922DC     BCLR LATE, #1
72:                    current_setpoint = 0;
00D954  EB0000     CLR W0
00D956  890FF0     MOV W0, _current_setpoint
73:                    setpoint = PULSE_ZERO_LENGTH;
00D958  203A90     MOV #0x3A9, W0
00D95A  890FE0     MOV W0, _setpoint
74:                    pulse_length = PULSE_ZERO_LENGTH;
00D95C  203A90     MOV #0x3A9, W0
00D95E  890FD0     MOV W0, _pulse_length
75:                
76:                    servoStop();
00D960  07003A     RCALL servoStop
77:                
78:                }
00D962  FA8000     ULNK
00D964  060000     RETURN
79:                
80:                // Set is in +- 1.0, Track is in +- 312
81:                void servoSet(float set) {
00D966  FA0004     LNK #0x4
00D968  781F88     MOV W8, [W15++]
00D96A  BE8F00     MOV.D W0, [W14]
82:                
83:                    if(set > 1.0) { set = 1.0; }
00D96C  B3C018     MOV #0x1, W8
00D96E  200002     MOV #0x0, W2
00D970  23F803     MOV #0x3F80, W3
00D972  BE001E     MOV.D [W14], W0
00D974  0225A8     CALL ___gtsf2
00D976  000000     NOP
00D978  EB0080     CLR W1
00D97A  500F81     SUB W0, W1, [W15]
00D97C  3C0001     BRA GT, 0xD980
00D97E  EB4400     CLR.B W8
00D980  EB4000     CLR.B W0
00D982  544F80     SUB.B W8, W0, [W15]
00D984  320004     BRA Z, 0xD98E
00D986  200000     MOV #0x0, W0
00D988  23F801     MOV #0x3F80, W1
00D98A  BE8F00     MOV.D W0, [W14]
00D98C  370010     BRA 0xD9AE
84:                    else if(set < -1.0) { set = -1.0; }
00D98E  B3C018     MOV #0x1, W8
00D990  200002     MOV #0x0, W2
00D992  2BF803     MOV #0xBF80, W3
00D994  BE001E     MOV.D [W14], W0
00D996  0225A4     CALL ___lesf2
00D998  000000     NOP
00D99A  EB0080     CLR W1
00D99C  500F81     SUB W0, W1, [W15]
00D99E  350001     BRA LT, 0xD9A2
00D9A0  EB4400     CLR.B W8
00D9A2  EB4000     CLR.B W0
00D9A4  544F80     SUB.B W8, W0, [W15]
00D9A6  320003     BRA Z, 0xD9AE
00D9A8  200000     MOV #0x0, W0
00D9AA  2BF801     MOV #0xBF80, W1
00D9AC  BE8F00     MOV.D W0, [W14]
85:                    
86:                    setpoint = (unsigned int)(PULSE_ZERO_LENGTH + (int)(set*PULSE_AMPLITUDE));
00D9AE  200002     MOV #0x0, W2
00D9B0  2439C3     MOV #0x439C, W3
00D9B2  BE001E     MOV.D [W14], W0
00D9B4  022C36     CALL ___mulsf3
00D9B6  000000     NOP
00D9B8  0225AC     CALL ___fixsfsi
00D9BA  000000     NOP
00D9BC  780000     MOV W0, W0
00D9BE  B03A90     ADD #0x3A9, W0
00D9C0  890FE0     MOV W0, _setpoint
87:                
88:                }
00D9C2  78044F     MOV [--W15], W8
00D9C4  FA8000     ULNK
00D9C6  060000     RETURN
89:                
90:                void servoStart(void) {
00D9C8  FA0000     LNK #0x0
91:                
92:                    WriteTimer4(0);
00D9CA  EB0000     CLR W0
00D9CC  022572     CALL _WriteTimer4
00D9CE  000000     NOP
93:                    _T4IE = 1;
00D9D0  A86097     BSET 0x97, #3
94:                
95:                }
00D9D2  FA8000     ULNK
00D9D4  060000     RETURN
96:                
97:                void servoStop(void) {
00D9D6  FA0000     LNK #0x0
98:                
99:                    _T4IE = 0;
00D9D8  A96097     BCLR 0x97, #3
100:               }
00D9DA  FA8000     ULNK
00D9DC  060000     RETURN
101:               
102:               // =========== Private Functions ===============================================
103:               
104:               void __attribute__((interrupt, no_auto_psv)) _T4Interrupt(void) {
00D9DE  F80036     PUSH RCOUNT
00D9E0  BE9F80     MOV.D W0, [W15++]
00D9E2  BE9F82     MOV.D W2, [W15++]
00D9E4  BE9F84     MOV.D W4, [W15++]
00D9E6  BE9F86     MOV.D W6, [W15++]
00D9E8  FA0000     LNK #0x0
105:               
106:                   if(pin_is_high) {
00D9EA  221F80     MOV #0x21F8, W0
00D9EC  784090     MOV.B [W0], W1
00D9EE  EB4000     CLR.B W0
00D9F0  50CF80     SUB.B W1, W0, [W15]
00D9F2  32000C     BRA Z, 0xDA0C
107:                       
108:                       SERVO_A = 0; // End pulse
00D9F4  A922DC     BCLR LATE, #1
109:                       pin_is_high = 0;
00D9F6  221F81     MOV #0x21F8, W1
00D9F8  EB4000     CLR.B W0
00D9FA  784880     MOV.B W0, [W1]
110:                       
111:                       WriteTimer4(0); // Wait until next pulse start
00D9FC  EB0000     CLR W0
00D9FE  022572     CALL _WriteTimer4
00DA00  000000     NOP
112:                       PR4 = PWM_PERIOD - pulse_length;
00DA02  810FD0     MOV _pulse_length, W0
00DA04  230D41     MOV #0x30D4, W1
00DA06  508000     SUB W1, W0, W0
00DA08  8808D0     MOV W0, PR4
00DA0A  37000B     BRA 0xDA22
113:                   } else {
114:                               
115:                       pulse_length = setpoint; // Buffer pulse length
00DA0C  810FE0     MOV _setpoint, W0
00DA0E  890FD0     MOV W0, _pulse_length
116:                       WriteTimer4(0);
00DA10  EB0000     CLR W0
00DA12  022572     CALL _WriteTimer4
00DA14  000000     NOP
117:                       PR4 = pulse_length;
00DA16  810FD0     MOV _pulse_length, W0
00DA18  8808D0     MOV W0, PR4
118:                       
119:                       SERVO_A = 1; // Begin pulse
00DA1A  A822DC     BSET LATE, #1
120:                       pin_is_high = 1;
00DA1C  221F81     MOV #0x21F8, W1
00DA1E  B3C010     MOV #0x1, W0
00DA20  784880     MOV.B W0, [W1]
121:                   }
122:               
123:                   _T4IF = 0;
00DA22  A96087     BCLR 0x87, #3
124:                   
125:               }
00DA24  FA8000     ULNK
00DA26  BE034F     MOV.D [--W15], W6
00DA28  BE024F     MOV.D [--W15], W4
00DA2A  BE014F     MOV.D [--W15], W2
00DA2C  BE004F     MOV.D [--W15], W0
00DA2E  F90036     POP RCOUNT
00DA30  064000     RETFIE
126:               
127:               void setupTimer4(unsigned int frequency) {
00DA32  FA0006     LNK #0x6
00DA34  980720     MOV W0, [W14+4]
128:               
129:                   unsigned int con_reg, period;
130:               
131:                   // prescale 1:64
132:                   con_reg =     T4_ON & 
00DA36  2FFA50     MOV #0xFFA5, W0
00DA38  780F00     MOV W0, [W14]
133:                   T4_IDLE_STOP & 
134:                   T4_GATE_OFF & 
135:                   T4_PS_1_64 & 
136:                   T4_SOURCE_INT &
137:                   T4_32BIT_MODE_OFF;
138:               
139:                   // period value = Fcy/(prescale*Ftimer)
140:                   period = FCY/(64*frequency); 
00DA3A  90002E     MOV [W14+4], W0
00DA3C  DD0046     SL W0, #6, W0
00DA3E  200001     MOV #0x0, W1
00DA40  BE0100     MOV.D W0, W2
00DA42  25A000     MOV #0x5A00, W0
00DA44  202621     MOV #0x262, W1
00DA46  022586     CALL ___divsi3
00DA48  000000     NOP
00DA4A  980710     MOV W0, [W14+2]
141:               
142:                   OpenTimer4(con_reg, period);
00DA4C  90009E     MOV [W14+2], W1
00DA4E  78001E     MOV [W14], W0
00DA50  022544     CALL _OpenTimer4
00DA52  000000     NOP
143:                   ConfigIntTimer4(T4_INT_PRIOR_5 & T4_INT_ON);
00DA54  2FFFD0     MOV #0xFFFD, W0
00DA56  0224A8     CALL _ConfigIntTimer4
00DA58  000000     NOP
144:               
145:               }
00DA5A  FA8000     ULNK
00DA5C  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/sqrti.c  --------------------------------------------------
1:                 // Taken without permission from Microchip Forums, Jack Peacock
2:                 // Modified by Humphrey Hu
3:                 
4:                 unsigned char sqrtI(unsigned int sqrtArg) {
00E182  FA0006     LNK #0x6
00E184  980720     MOV W0, [W14+4]
5:                     
6:                     unsigned char answer, x;
7:                     unsigned int temp;
8:                 
9:                     if ( sqrtArg == 0 ) return 0; // undefined result
00E186  9000AE     MOV [W14+4], W1
00E188  EB0000     CLR W0
00E18A  508F80     SUB W1, W0, [W15]
00E18C  3A0002     BRA NZ, 0xE192
00E18E  EB4000     CLR.B W0
00E190  370029     BRA 0xE1E4
10:                    if ( sqrtArg == 1 ) return 1; // identity
00E192  9000AE     MOV [W14+4], W1
00E194  200010     MOV #0x1, W0
00E196  508F80     SUB W1, W0, [W15]
00E198  3A0002     BRA NZ, 0xE19E
00E19A  B3C010     MOV #0x1, W0
00E19C  370023     BRA 0xE1E4
11:                    answer = 0;                     // integer square root
00E19E  EB4000     CLR.B W0
00E1A0  784F00     MOV.B W0, [W14]
12:                    for( x=0x80; x>0; x=x>>1 ) {                        
00E1A2  B3C800     MOV #0x80, W0
00E1A4  984710     MOV.B W0, [W14+1]
00E1A6  370017     BRA 0xE1D6
00E1CE  90401E     MOV.B [W14+1], W0
00E1D0  FB8000     ZE W0, W0
00E1D2  D10000     LSR W0, W0
00E1D4  984710     MOV.B W0, [W14+1]
00E1D6  90409E     MOV.B [W14+1], W1
00E1D8  EB4000     CLR.B W0
00E1DA  50CF80     SUB.B W1, W0, [W15]
00E1DC  3AFFE5     BRA NZ, 0xE1A8
00E1DE  370001     BRA 0xE1E2
13:                        answer |= x;             // possible bit in root
00E1A8  90401E     MOV.B [W14+1], W0
00E1AA  704F1E     IOR.B W0, [W14], [W14]
14:                        temp = answer*answer;
00E1AC  78401E     MOV.B [W14], W0
00E1AE  FB8080     ZE W0, W1
00E1B0  78411E     MOV.B [W14], W2
00E1B2  FB8002     ZE W2, W0
00E1B4  B98800     MUL.SS W1, W0, W0
00E1B6  780000     MOV W0, W0
00E1B8  980710     MOV W0, [W14+2]
15:                        if (temp == sqrtArg) break; // exact, found it
00E1BA  90009E     MOV [W14+2], W1
00E1BC  90002E     MOV [W14+4], W0
00E1BE  508F80     SUB W1, W0, [W15]
00E1C0  32000F     BRA Z, 0xE1E0
00E1E0  000000     NOP
16:                        if (temp > sqrtArg) answer ^= x; // too large, reverse bit
00E1C2  90009E     MOV [W14+2], W1
00E1C4  90002E     MOV [W14+4], W0
00E1C6  508F80     SUB W1, W0, [W15]
00E1C8  360002     BRA LEU, 0xE1CE
00E1CA  90401E     MOV.B [W14+1], W0
00E1CC  684F1E     XOR.B W0, [W14], [W14]
17:                    }
18:                    return answer; // approximate root
00E1E2  78401E     MOV.B [W14], W0
19:                    
20:                }
00E1E4  FA8000     ULNK
00E1E6  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/slew.c  ---------------------------------------------------
1:                 /*
2:                 * Copyright (c) 2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Reference Slew Rate Limiter
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v.0.1
35:                *
36:                * Revisions: 
37:                *  Humphrey Hu		    2012-07-22       Initial implementation
38:                */
39:                
40:                #include "slew.h"
41:                #include "quat.h"
42:                #include "bams.h"
43:                #include <stdlib.h>
44:                
45:                // =========== Static Variables ===============================================
46:                static unsigned char is_ready = 0, is_running;
47:                static Quaternion prev_ref;
48:                static float max_slew_rate, period;
49:                static bams32_t max_angular_displacement;
50:                
51:                // =========== Public Methods ===============================================
52:                void slewSetup(float ts) {
00CD14  FA0004     LNK #0x4
00CD16  BE8F00     MOV.D W0, [W14]
53:                    
54:                    prev_ref.w = 1.0;
00CD18  200000     MOV #0x0, W0
00CD1A  23F801     MOV #0x3F80, W1
00CD1C  890740     MOV W0, _prev_ref
00CD1E  890751     MOV W1, 0x20EA
55:                    prev_ref.x = 0.0;
00CD20  B80060     MUL.UU W0, #0, W0
00CD22  890760     MOV W0, 0x20EC
00CD24  890771     MOV W1, 0x20EE
56:                    prev_ref.y = 0.0;
00CD26  B80060     MUL.UU W0, #0, W0
00CD28  890780     MOV W0, 0x20F0
00CD2A  890791     MOV W1, 0x20F2
57:                    prev_ref.z = 0.0;
00CD2C  B80060     MUL.UU W0, #0, W0
00CD2E  8907A0     MOV W0, 0x20F4
00CD30  8907B1     MOV W1, 0x20F6
58:                    
59:                    period = ts;
00CD32  BE001E     MOV.D [W14], W0
00CD34  8907E0     MOV W0, period
00CD36  8907F1     MOV W1, 0x20FE
60:                    
61:                    is_running = 0; // TODO: Should be changed to off by default
00CD38  220E71     MOV #0x20E7, W1
00CD3A  EB4000     CLR.B W0
00CD3C  784880     MOV.B W0, [W1]
62:                    is_ready = 1;
00CD3E  220E61     MOV #0x20E6, W1
00CD40  B3C010     MOV #0x1, W0
00CD42  784880     MOV.B W0, [W1]
63:                    
64:                }
00CD44  FA8000     ULNK
00CD46  060000     RETURN
65:                
66:                void slewEnable(void) {
00CD48  FA0000     LNK #0x0
67:                    is_running = 1;
00CD4A  220E71     MOV #0x20E7, W1
00CD4C  B3C010     MOV #0x1, W0
00CD4E  784880     MOV.B W0, [W1]
68:                }
00CD50  FA8000     ULNK
00CD52  060000     RETURN
69:                
70:                void slewDisable(void) {
00CD54  FA0000     LNK #0x0
71:                    is_running = 0;
00CD56  220E71     MOV #0x20E7, W1
00CD58  EB4000     CLR.B W0
00CD5A  784880     MOV.B W0, [W1]
72:                }
00CD5C  FA8000     ULNK
00CD5E  060000     RETURN
73:                
74:                // qtarget = qcurr*qdisp
75:                // qcurr'*qtarget = qdisp
76:                void slewProcess(Quaternion *input, Quaternion *output) {
00CD60  FA0038     LNK #0x38
00CD62  981F20     MOV W0, [W14+52]
00CD64  981F31     MOV W1, [W14+54]
77:                
78:                    Quaternion conjugate, displacement;    
79:                    bams32_t input_angle, limited_angle;
80:                    float sin_input, sin_limited, scale;
81:                    
82:                    if(!is_ready || !is_running || max_angular_displacement == 0) {
00CD66  220E60     MOV #0x20E6, W0
00CD68  784090     MOV.B [W0], W1
00CD6A  EB4000     CLR.B W0
00CD6C  50CF80     SUB.B W1, W0, [W15]
00CD6E  32000B     BRA Z, 0xCD86
00CD70  220E70     MOV #0x20E7, W0
00CD72  784090     MOV.B [W0], W1
00CD74  EB4000     CLR.B W0
00CD76  50CF80     SUB.B W1, W0, [W15]
00CD78  320006     BRA Z, 0xCD86
00CD7A  810802     MOV _max_angular_displacement, W2
00CD7C  810813     MOV 0x2102, W3
00CD7E  B80060     MUL.UU W0, #0, W0
00CD80  510F80     SUB W2, W0, [W15]
00CD82  598F81     SUBB W3, W1, [W15]
00CD84  3A0005     BRA NZ, 0xCD90
83:                        quatCopy(output, input); 
00CD86  9018AE     MOV [W14+52], W1
00CD88  90183E     MOV [W14+54], W0
00CD8A  02A488     CALL quatCopy
00CD8C  000000     NOP
84:                        return;
00CD8E  37009B     BRA 0xCEC6
85:                    }    
86:                    
87:                    // Calculate displacement
88:                    quatConj(&prev_ref, &conjugate);
00CD90  470074     ADD W14, #0x14, W0
00CD92  780080     MOV W0, W1
00CD94  220E80     MOV #0x20E8, W0
00CD96  02A4FA     CALL quatConj
00CD98  000000     NOP
89:                    quatMult(&conjugate, input, &displacement);
00CD9A  200241     MOV #0x24, W1
00CD9C  40808E     ADD W1, W14, W1
00CD9E  470074     ADD W14, #0x14, W0
00CDA0  780101     MOV W1, W2
00CDA2  9018AE     MOV [W14+52], W1
00CDA4  02A54E     CALL quatMult
00CDA6  000000     NOP
90:                
91:                    // Calculate displacement magnitude
92:                    input_angle = bams16ToBams32(bams16Acos(displacement.w)*2);
00CDA8  200240     MOV #0x24, W0
00CDAA  40000E     ADD W0, W14, W0
00CDAC  BE0010     MOV.D [W0], W0
00CDAE  026F88     CALL bams16Acos
00CDB0  000000     NOP
00CDB2  400000     ADD W0, W0, W0
00CDB4  026D0C     CALL bams16ToBams32
00CDB6  000000     NOP
00CDB8  980720     MOV W0, [W14+4]
00CDBA  980731     MOV W1, [W14+6]
93:                    if(input_angle == 0) { // Check for no displacement case
00CDBC  90012E     MOV [W14+4], W2
00CDBE  9001BE     MOV [W14+6], W3
00CDC0  B80060     MUL.UU W0, #0, W0
00CDC2  510F80     SUB W2, W0, [W15]
00CDC4  598F81     SUBB W3, W1, [W15]
00CDC6  3A0005     BRA NZ, 0xCDD2
94:                        quatCopy(output, input);
00CDC8  9018AE     MOV [W14+52], W1
00CDCA  90183E     MOV [W14+54], W0
00CDCC  02A488     CALL quatCopy
00CDCE  000000     NOP
95:                        return;
00CDD0  37007A     BRA 0xCEC6
96:                    }    
97:                    sin_input = bams32Sin(input_angle/2);
00CDD2  90002E     MOV [W14+4], W0
00CDD4  9000BE     MOV [W14+6], W1
00CDD6  DE094F     LSR W1, #15, W2
00CDD8  200003     MOV #0x0, W3
00CDDA  400002     ADD W0, W2, W0
00CDDC  488083     ADDC W1, W3, W1
00CDDE  D18081     ASR W1, W1
00CDE0  D38000     RRC W0, W0
00CDE2  026E14     CALL bams32Sin
00CDE4  000000     NOP
00CDE6  980740     MOV W0, [W14+8]
00CDE8  980751     MOV W1, [W14+10]
98:                    
99:                    // Apply displacement limits
100:                   if(input_angle > max_angular_displacement) {
00CDEA  810800     MOV _max_angular_displacement, W0
00CDEC  810811     MOV 0x2102, W1
00CDEE  90012E     MOV [W14+4], W2
00CDF0  9001BE     MOV [W14+6], W3
00CDF2  510F80     SUB W2, W0, [W15]
00CDF4  598F81     SUBB W3, W1, [W15]
00CDF6  340004     BRA LE, 0xCE00
101:                       limited_angle = max_angular_displacement;
00CDF8  810800     MOV _max_angular_displacement, W0
00CDFA  810811     MOV 0x2102, W1
00CDFC  BE8F00     MOV.D W0, [W14]
00CDFE  370012     BRA 0xCE24
102:                   } else if(input_angle < -max_angular_displacement) {
00CE00  810800     MOV _max_angular_displacement, W0
00CE02  810811     MOV 0x2102, W1
00CE04  100160     SUBR W0, #0x0, W2
00CE06  1881E0     SUBBR W1, #0x0, W3
00CE08  90002E     MOV [W14+4], W0
00CE0A  9000BE     MOV [W14+6], W1
00CE0C  510F80     SUB W2, W0, [W15]
00CE0E  598F81     SUBB W3, W1, [W15]
00CE10  340006     BRA LE, 0xCE1E
103:                       limited_angle = -max_angular_displacement;
00CE12  810800     MOV _max_angular_displacement, W0
00CE14  810811     MOV 0x2102, W1
00CE16  100060     SUBR W0, #0x0, W0
00CE18  1880E0     SUBBR W1, #0x0, W1
00CE1A  BE8F00     MOV.D W0, [W14]
00CE1C  370003     BRA 0xCE24
104:                   } else {
105:                       limited_angle = input_angle;
00CE1E  90002E     MOV [W14+4], W0
00CE20  9000BE     MOV [W14+6], W1
00CE22  BE8F00     MOV.D W0, [W14]
106:                   }
107:                   
108:                   sin_limited = bams32SinFine(limited_angle/2);
00CE24  BE001E     MOV.D [W14], W0
00CE26  DE094F     LSR W1, #15, W2
00CE28  200003     MOV #0x0, W3
00CE2A  400002     ADD W0, W2, W0
00CE2C  488083     ADDC W1, W3, W1
00CE2E  D18081     ASR W1, W1
00CE30  D38000     RRC W0, W0
00CE32  026E30     CALL bams32SinFine
00CE34  000000     NOP
00CE36  980760     MOV W0, [W14+12]
00CE38  980771     MOV W1, [W14+14]
109:                   scale = sin_limited/sin_input;
00CE3A  90014E     MOV [W14+8], W2
00CE3C  9001DE     MOV [W14+10], W3
00CE3E  90006E     MOV [W14+12], W0
00CE40  9000FE     MOV [W14+14], W1
00CE42  022E80     CALL ___divsf3x
00CE44  000000     NOP
00CE46  980F00     MOV W0, [W14+16]
00CE48  980F11     MOV W1, [W14+18]
110:                   
111:                   displacement.w = bams32CosFine(limited_angle/2);
00CE4A  BE001E     MOV.D [W14], W0
00CE4C  DE094F     LSR W1, #15, W2
00CE4E  200003     MOV #0x0, W3
00CE50  400002     ADD W0, W2, W0
00CE52  488083     ADDC W1, W3, W1
00CE54  D18081     ASR W1, W1
00CE56  D38000     RRC W0, W0
00CE58  026EDE     CALL bams32CosFine
00CE5A  000000     NOP
00CE5C  200242     MOV #0x24, W2
00CE5E  41010E     ADD W2, W14, W2
00CE60  BE8900     MOV.D W0, [W2]
112:                   displacement.x = displacement.x*scale;
00CE62  200240     MOV #0x24, W0
00CE64  40000E     ADD W0, W14, W0
00CE66  9000B0     MOV [W0+6], W1
00CE68  900020     MOV [W0+4], W0
00CE6A  90090E     MOV [W14+16], W2
00CE6C  90099E     MOV [W14+18], W3
00CE6E  022C36     CALL ___mulsf3
00CE70  000000     NOP
00CE72  200242     MOV #0x24, W2
00CE74  41010E     ADD W2, W14, W2
00CE76  980120     MOV W0, [W2+4]
00CE78  980131     MOV W1, [W2+6]
113:                   displacement.y = displacement.y*scale;
00CE7A  200240     MOV #0x24, W0
00CE7C  40000E     ADD W0, W14, W0
00CE7E  9000D0     MOV [W0+10], W1
00CE80  900040     MOV [W0+8], W0
00CE82  90090E     MOV [W14+16], W2
00CE84  90099E     MOV [W14+18], W3
00CE86  022C36     CALL ___mulsf3
00CE88  000000     NOP
00CE8A  200242     MOV #0x24, W2
00CE8C  41010E     ADD W2, W14, W2
00CE8E  980140     MOV W0, [W2+8]
00CE90  980151     MOV W1, [W2+10]
114:                   displacement.z = displacement.z*scale;
00CE92  200240     MOV #0x24, W0
00CE94  40000E     ADD W0, W14, W0
00CE96  9000F0     MOV [W0+14], W1
00CE98  900060     MOV [W0+12], W0
00CE9A  90090E     MOV [W14+16], W2
00CE9C  90099E     MOV [W14+18], W3
00CE9E  022C36     CALL ___mulsf3
00CEA0  000000     NOP
00CEA2  200242     MOV #0x24, W2
00CEA4  41010E     ADD W2, W14, W2
00CEA6  980160     MOV W0, [W2+12]
00CEA8  980171     MOV W1, [W2+14]
115:                   
116:                   // Apply limited displacement
117:                   quatMult(&prev_ref, &displacement, output);
00CEAA  200240     MOV #0x24, W0
00CEAC  40000E     ADD W0, W14, W0
00CEAE  90193E     MOV [W14+54], W2
00CEB0  780080     MOV W0, W1
00CEB2  220E80     MOV #0x20E8, W0
00CEB4  02A54E     CALL quatMult
00CEB6  000000     NOP
118:                   quatNormalize(output);
00CEB8  90183E     MOV [W14+54], W0
00CEBA  02A72C     CALL quatNormalize
00CEBC  000000     NOP
119:                   quatCopy(&prev_ref, output);
00CEBE  9018BE     MOV [W14+54], W1
00CEC0  220E80     MOV #0x20E8, W0
00CEC2  02A488     CALL quatCopy
00CEC4  000000     NOP
120:               
121:               }
00CEC6  FA8000     ULNK
00CEC8  060000     RETURN
122:               
123:               void slewSetLimit(float rate) {
00CECA  FA0004     LNK #0x4
00CECC  BE8F00     MOV.D W0, [W14]
124:               
125:                   max_slew_rate = rate;
00CECE  BE001E     MOV.D [W14], W0
00CED0  8907C0     MOV W0, _max_slew_rate
00CED2  8907D1     MOV W1, 0x20FA
126:                   max_angular_displacement = floatToBams32Rad(rate*period);
00CED4  8107E0     MOV period, W0
00CED6  8107F1     MOV 0x20FE, W1
00CED8  BE011E     MOV.D [W14], W2
00CEDA  022C36     CALL ___mulsf3
00CEDC  000000     NOP
00CEDE  026C4C     CALL floatToBams32Rad
00CEE0  000000     NOP
00CEE2  890800     MOV W0, _max_angular_displacement
00CEE4  890811     MOV W1, 0x2102
127:                   
128:               }
00CEE6  FA8000     ULNK
00CEE8  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/regulator.c  ----------------------------------------------
1:                 /*
2:                  * Copyright (c) 2009 - 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * I-Bird Attitude Regulation Module
31:                 *
32:                 * by Stanley S. Baek
33:                 *
34:                 * v.0.4
35:                 *
36:                 * Revisions:
37:                 *  Stanley S. Baek     2009-10-30      Initial release
38:                 *  Humphrey Hu		    2011-07-20      Changed to fixed point
39:                 *  Humphrey Hu         2012-02-20      Returned to floating point, restructured
40:                 *  Humphrey Hu         2012-06-30      Switched to using quaternion representation
41:                 *
42:                 * Notes:
43:                 *  I-Bird body axes are:
44:                 *      x - Forward along anteroposterior axis
45:                 *      y - Left along left-right axis
46:                 *      z - Up along dorsoventral axis
47:                 *  Rotations in body axes are:
48:                 *      yaw - Positive z direction
49:                 *      pitch - Positive y direction
50:                 *      roll - Positive x direction
51:                 *  PID loops should have references set to 0, since they take the externally
52:                 *      calculated error as an input.
53:                 */
54:                
55:                // Software modules
56:                #include "regulator.h"
57:                #include "controller.h"
58:                #include "dfilter.h"
59:                #include "attitude.h"
60:                #include "cv.h"
61:                #include "xl.h"
62:                #include "rate.h"
63:                #include "slew.h"
64:                #include "adc_pid.h"
65:                #include "led.h"
66:                #include "hall.h"
67:                
68:                // Hardware/actuator interface
69:                #include "motor_ctrl.h"
70:                #include "sync_servo.h"
71:                
72:                // Other
73:                #include "quat.h"
74:                #include "sys_clock.h"
75:                #include "bams.h"
76:                #include "utils.h"
77:                #include "ppbuff.h"
78:                #include <stdlib.h>
79:                #include <string.h>
80:                #include <math.h>
81:                
82:                typedef struct {
83:                    float thrust;
84:                    float steer;
85:                    float elevator;
86:                } RegulatorOutput;
87:                
88:                typedef struct {
89:                    float yaw_err;
90:                    float pitch_err;
91:                    float roll_err;
92:                } RegulatorError;
93:                
94:                typedef struct {
95:                    unsigned char stopped;
96:                    unsigned char enabled;
97:                    int stopPos;
98:                    int count_calib;
99:                } WingInst;
100:               
101:               #define YAW_SAT_MAX         (1.0)
102:               #define YAW_SAT_MIN         (-1.0)
103:               #define PITCH_SAT_MAX       (1.0)
104:               #define PITCH_SAT_MIN       (-1.0)
105:               #define ROLL_SAT_MAX        (1.0)
106:               #define ROLL_SAT_MIN        (0.0) // Doubling as thrust right now
107:               
108:               #define DEFAULT_SLEW_LIMIT  (1.0)
109:               
110:               // =========== Static Variables ================================================
111:               // Control loop objects
112:               CtrlPidParamStruct yawPid, pitchPid, thrustPid;
113:               DigitalFilterStruct yawRateFilter, pitchRateFilter, rollRateFilter;
114:               
115:               // State info
116:               static unsigned char is_ready = 0, is_logging = 0, temp_rot_active = 0;
117:               static unsigned char yaw_filter_ready = 0, pitch_filter_ready = 0, roll_filter_ready = 0;
118:               static RegulatorMode reg_mode;
119:               static RegulatorOutput rc_outputs;
120:               static Quaternion reference, limited_reference, pose, temp_rot;
121:               
122:               // Telemetry buffering
123:               static RegulatorStateStruct reg_states[2];
124:               static PingPongBuffer reg_state_buff;
125:               
126:               // =========== Function Stubs =================================================
127:               static float runYawControl(float yaw);
128:               static float runPitchControl(float pitch);
129:               static float runRollControl(float roll);
130:               static int updateBEMF();
131:               static void updateCrank();
132:               
133:               static void calculateError(RegulatorError *error);
134:               static void filterError(RegulatorError *error);
135:               static void calculateOutputs(RegulatorError *error, RegulatorOutput *output);
136:               static void applyOutputs(RegulatorOutput *output);
137:               static void logTrace(RegulatorError *error, RegulatorOutput *output);
138:               
139:               // =========== Local Variables ===============================================
140:               
141:               int bemf[NUM_MOTOR_PIDS]; //used to store the true, unfiltered speed
142:               int bemfLast[NUM_MOTOR_PIDS]; // Last post-median-filter value
143:               int bemfHist[NUM_MOTOR_PIDS][3]; //This is ONLY for applying the median filter to
144:               int medianFilter3(int*);
145:               float crankAngle;
146:               int zone;
147:               int bemfVals[4];
148:               int crankCalibrated;
149:               unsigned long curr_time;
150:               unsigned long prev_time;
151:               WingInst wing_status;
152:               
153:               // =========== Public Functions ===============================================
154:               
155:               void rgltrSetup(float ts) {
003ECE  FA0006     LNK #0x6
003ED0  980710     MOV W0, [W14+2]
003ED2  980721     MOV W1, [W14+4]
156:                   int i;
157:                   
158:                   // Set up drivers
159:                   servoSetup();
003ED4  02D946     CALL servoSetup
003ED6  000000     NOP
160:                   mcSetup();
003ED8  02C72A     CALL mcSetup
003EDA  000000     NOP
161:                   
162:                   // Set up dependent modules
163:                   attSetup(ts);
003EDC  90001E     MOV [W14+2], W0
003EDE  9000AE     MOV [W14+4], W1
003EE0  028A42     CALL attSetup
003EE2  000000     NOP
164:                   
165:                   
166:                   rateSetup(ts);
003EE4  90001E     MOV [W14+2], W0
003EE6  9000AE     MOV [W14+4], W1
003EE8  02C068     CALL rateSetup
003EEA  000000     NOP
167:                   
168:                   
169:                   slewSetup(ts);    
003EEC  90001E     MOV [W14+2], W0
003EEE  9000AE     MOV [W14+4], W1
003EF0  02CD14     CALL slewSetup
003EF2  000000     NOP
170:                   slewSetLimit(DEFAULT_SLEW_LIMIT);
003EF4  200000     MOV #0x0, W0
003EF6  23F801     MOV #0x3F80, W1
003EF8  02CECA     CALL slewSetLimit
003EFA  000000     NOP
171:                   slewEnable();
003EFC  02CD48     CALL slewEnable
003EFE  000000     NOP
172:                   
173:                   reg_mode = REG_OFF;  
003F00  EB0000     CLR W0
003F02  88DB20     MOV W0, reg_mode
174:               
175:                   ctrlInitPidParams(&yawPid, ts);
003F04  90011E     MOV [W14+2], W2
003F06  9001AE     MOV [W14+4], W3
003F08  2199C0     MOV #0x199C, W0
003F0A  02B0E0     CALL ctrlInitPidParams
003F0C  000000     NOP
176:                   ctrlInitPidParams(&pitchPid, ts);
003F0E  90011E     MOV [W14+2], W2
003F10  9001AE     MOV [W14+4], W3
003F12  219CE0     MOV #0x19CE, W0
003F14  02B0E0     CALL ctrlInitPidParams
003F16  000000     NOP
177:                   ctrlInitPidParams(&thrustPid, ts);    
003F18  90011E     MOV [W14+2], W2
003F1A  9001AE     MOV [W14+4], W3
003F1C  21A000     MOV #0x1A00, W0
003F1E  02B0E0     CALL ctrlInitPidParams
003F20  000000     NOP
178:               
179:                   ppbuffInit(&reg_state_buff);
003F22  21C3A0     MOV #0x1C3A, W0
003F24  02C4EE     CALL ppbuffInit
003F26  000000     NOP
180:                   ppbuffWriteActive(&reg_state_buff, &reg_states[0]);
003F28  21BB21     MOV #0x1BB2, W1
003F2A  21C3A0     MOV #0x1C3A, W0
003F2C  02C574     CALL ppbuffWriteActive
003F2E  000000     NOP
181:                   ppbuffWriteInactive(&reg_state_buff, &reg_states[1]);
003F30  21BF60     MOV #0x1BF6, W0
003F32  780080     MOV W0, W1
003F34  21C3A0     MOV #0x1C3A, W0
003F36  02C5EA     CALL ppbuffWriteInactive
003F38  000000     NOP
182:                       
183:                   reference.w = 1.0;
003F3A  200000     MOV #0x0, W0
003F3C  23F801     MOV #0x3F80, W1
003F3E  88DB90     MOV W0, reference
003F40  88DBA1     MOV W1, 0x1B74
184:                   reference.x = 0.0;
003F42  B80060     MUL.UU W0, #0, W0
003F44  88DBB0     MOV W0, 0x1B76
003F46  88DBC1     MOV W1, 0x1B78
185:                   reference.y = 0.0;
003F48  B80060     MUL.UU W0, #0, W0
003F4A  88DBD0     MOV W0, 0x1B7A
003F4C  88DBE1     MOV W1, 0x1B7C
186:                   reference.z = 0.0;   
003F4E  B80060     MUL.UU W0, #0, W0
003F50  88DBF0     MOV W0, 0x1B7E
003F52  88DC01     MOV W1, 0x1B80
187:                   
188:                   limited_reference.w = 1.0;
003F54  200000     MOV #0x0, W0
003F56  23F801     MOV #0x3F80, W1
003F58  88DC10     MOV W0, limited_reference
003F5A  88DC21     MOV W1, 0x1B84
189:                   limited_reference.x = 0.0;
003F5C  B80060     MUL.UU W0, #0, W0
003F5E  88DC30     MOV W0, 0x1B86
003F60  88DC41     MOV W1, 0x1B88
190:                   limited_reference.y = 0.0;
003F62  B80060     MUL.UU W0, #0, W0
003F64  88DC50     MOV W0, 0x1B8A
003F66  88DC61     MOV W1, 0x1B8C
191:                   limited_reference.z = 0.0;   
003F68  B80060     MUL.UU W0, #0, W0
003F6A  88DC70     MOV W0, 0x1B8E
003F6C  88DC81     MOV W1, 0x1B90
192:                   
193:                   is_logging = 0;
003F6E  21B5F1     MOV #0x1B5F, W1
003F70  EB4000     CLR.B W0
003F72  784880     MOV.B W0, [W1]
194:                   is_ready = 1;
003F74  21B5E1     MOV #0x1B5E, W1
003F76  B3C010     MOV #0x1, W0
003F78  784880     MOV.B W0, [W1]
195:               
196:                   for (i = 0; i < NUM_MOTOR_PIDS; i++) {
003F7A  EB0000     CLR W0
003F7C  780F00     MOV W0, [W14]
003F7E  37001C     BRA 0x3FB8
003FB6  E80F1E     INC [W14], [W14]
003FB8  78009E     MOV [W14], W1
003FBA  200010     MOV #0x1, W0
003FBC  508F80     SUB W1, W0, [W15]
003FBE  34FFE0     BRA LE, 0x3F80
197:                       bemfLast[i] = 0;
003F80  78001E     MOV [W14], W0
003F82  400080     ADD W0, W0, W1
003F84  21C440     MOV #0x1C44, W0
003F86  408000     ADD W1, W0, W0
003F88  EB0080     CLR W1
003F8A  780801     MOV W1, [W0]
198:                       bemfHist[i][0] = 0;
003F8C  78001E     MOV [W14], W0
003F8E  B90066     MUL.SU W0, #6, W0
003F90  780080     MOV W0, W1
003F92  21C480     MOV #0x1C48, W0
003F94  408000     ADD W1, W0, W0
003F96  EB0080     CLR W1
003F98  780801     MOV W1, [W0]
199:                       bemfHist[i][1] = 0;
003F9A  78001E     MOV [W14], W0
003F9C  B90066     MUL.SU W0, #6, W0
003F9E  780080     MOV W0, W1
003FA0  21C4A0     MOV #0x1C4A, W0
003FA2  408000     ADD W1, W0, W0
003FA4  EB0080     CLR W1
003FA6  780801     MOV W1, [W0]
200:                       bemfHist[i][2] = 0;
003FA8  78001E     MOV [W14], W0
003FAA  B90066     MUL.SU W0, #6, W0
003FAC  780080     MOV W0, W1
003FAE  21C4C0     MOV #0x1C4C, W0
003FB0  408000     ADD W1, W0, W0
003FB2  EB0080     CLR W1
003FB4  780801     MOV W1, [W0]
201:                   }
202:                   crankAngle = 0;
003FC0  B80060     MUL.UU W0, #0, W0
003FC2  88E2A0     MOV W0, crankAngle
003FC4  88E2B1     MOV W1, 0x1C56
203:                   zone = 0;
003FC6  EB0000     CLR W0
003FC8  88E2C0     MOV W0, zone
204:                   bemfVals[0] = 0;
003FCA  21C5A0     MOV #0x1C5A, W0
003FCC  EB0080     CLR W1
003FCE  780801     MOV W1, [W0]
205:                   bemfVals[1] = 0;
003FD0  21C5A0     MOV #0x1C5A, W0
003FD2  EB0080     CLR W1
003FD4  980011     MOV W1, [W0+2]
206:                   bemfVals[2] = 0;
003FD6  21C5A0     MOV #0x1C5A, W0
003FD8  EB0080     CLR W1
003FDA  980021     MOV W1, [W0+4]
207:                   bemfVals[3] = 0;
003FDC  21C5A0     MOV #0x1C5A, W0
003FDE  EB0080     CLR W1
003FE0  980031     MOV W1, [W0+6]
208:                   crankCalibrated = 0;
003FE2  EB0000     CLR W0
003FE4  88E310     MOV W0, crankCalibrated
209:                   curr_time = 0;
003FE6  B80060     MUL.UU W0, #0, W0
003FE8  88E320     MOV W0, curr_time
003FEA  88E331     MOV W1, 0x1C66
210:                   prev_time = 0;
003FEC  B80060     MUL.UU W0, #0, W0
003FEE  88E340     MOV W0, prev_time
003FF0  88E351     MOV W1, 0x1C6A
211:                   wing_status.stopPos = 0;
003FF2  EB0000     CLR W0
003FF4  88E370     MOV W0, 0x1C6E
212:                   wing_status.enabled = 0;
003FF6  21C6D1     MOV #0x1C6D, W1
003FF8  EB4000     CLR.B W0
003FFA  784880     MOV.B W0, [W1]
213:                   wing_status.stopped = 0;
003FFC  21C6C1     MOV #0x1C6C, W1
003FFE  EB4000     CLR.B W0
004000  784880     MOV.B W0, [W1]
214:                   wing_status.count_calib = 0;
004002  EB0000     CLR W0
004004  88E380     MOV W0, 0x1C70
215:               }
004006  FA8000     ULNK
004008  060000     RETURN
216:               
217:               void rgltrSetMode(unsigned char flag) {
00400A  FA0002     LNK #0x2
00400C  784F00     MOV.B W0, [W14]
218:               
219:                   if(flag == REG_OFF) {
00400E  78409E     MOV.B [W14], W1
004010  EB4000     CLR.B W0
004012  50CF80     SUB.B W1, W0, [W15]
004014  3A0003     BRA NZ, 0x401C
220:                       LED_RED = 1;
004016  A882CB     BSET 0x2CB, #4
221:                       rgltrSetOff();
004018  07000F     RCALL rgltrSetOff
00401A  37000C     BRA 0x4034
222:                       //hallPIDOff();
223:                   } else if(flag == REG_TRACK) {
00401C  78409E     MOV.B [W14], W1
00401E  B3C010     MOV #0x1, W0
004020  50CF80     SUB.B W1, W0, [W15]
004022  3A0003     BRA NZ, 0x402A
224:                       LED_RED = 0;
004024  A982CB     BCLR 0x2CB, #4
225:                       rgltrSetTrack();
004026  070018     RCALL rgltrSetTrack
004028  370005     BRA 0x4034
226:                   } else if(flag == REG_REMOTE_CONTROL) {
00402A  78409E     MOV.B [W14], W1
00402C  B3C020     MOV #0x2, W0
00402E  50CF80     SUB.B W1, W0, [W15]
004030  3A0001     BRA NZ, 0x4034
227:                       rgltrSetRemote();
004032  070022     RCALL rgltrSetRemote
228:                   }
229:                       
230:               }
004034  FA8000     ULNK
004036  060000     RETURN
231:               
232:               void rgltrSetOff(void) {
004038  FA0000     LNK #0x0
233:                   reg_mode = REG_OFF;
00403A  EB0000     CLR W0
00403C  88DB20     MOV W0, reg_mode
234:                   ctrlStop(&yawPid);
00403E  2199C0     MOV #0x199C, W0
004040  02B1F4     CALL ctrlStop
004042  000000     NOP
235:                   ctrlStop(&pitchPid);
004044  219CE0     MOV #0x19CE, W0
004046  02B1F4     CALL ctrlStop
004048  000000     NOP
236:                   ctrlStop(&thrustPid);
00404A  21A000     MOV #0x1A00, W0
00404C  02B1F4     CALL ctrlStop
00404E  000000     NOP
237:                   servoStop();
004050  02D9D6     CALL servoStop
004052  000000     NOP
238:               }
004054  FA8000     ULNK
004056  060000     RETURN
239:               
240:               void rgltrSetTrack(void) {
004058  FA0000     LNK #0x0
241:                   reg_mode = REG_TRACK;
00405A  200010     MOV #0x1, W0
00405C  88DB20     MOV W0, reg_mode
242:                   ctrlStart(&yawPid);
00405E  2199C0     MOV #0x199C, W0
004060  02B1E6     CALL ctrlStart
004062  000000     NOP
243:                   ctrlStart(&pitchPid);
004064  219CE0     MOV #0x19CE, W0
004066  02B1E6     CALL ctrlStart
004068  000000     NOP
244:                   ctrlStart(&thrustPid);
00406A  21A000     MOV #0x1A00, W0
00406C  02B1E6     CALL ctrlStart
00406E  000000     NOP
245:                   servoStart();
004070  02D9C8     CALL servoStart
004072  000000     NOP
246:               }
004074  FA8000     ULNK
004076  060000     RETURN
247:               
248:               void rgltrSetRemote(void) {
004078  FA0000     LNK #0x0
249:                   reg_mode = REG_REMOTE_CONTROL;
00407A  200020     MOV #0x2, W0
00407C  88DB20     MOV W0, reg_mode
250:                   ctrlStop(&yawPid);
00407E  2199C0     MOV #0x199C, W0
004080  02B1F4     CALL ctrlStop
004082  000000     NOP
251:                   ctrlStop(&pitchPid);
004084  219CE0     MOV #0x19CE, W0
004086  02B1F4     CALL ctrlStop
004088  000000     NOP
252:                   ctrlStop(&thrustPid);
00408A  21A000     MOV #0x1A00, W0
00408C  02B1F4     CALL ctrlStop
00408E  000000     NOP
253:                   servoStart();
004090  02D9C8     CALL servoStart
004092  000000     NOP
254:               }    
004094  FA8000     ULNK
004096  060000     RETURN
255:               
256:               void rgltrSetYawRateFilter(RateFilterParams params) {
004098  FA0002     LNK #0x2
00409A  780F00     MOV W0, [W14]
257:               
258:                   dfilterInit(&yawRateFilter, params->order, params->type, 
00409E  9001A0     MOV [W0+4], W3
0040A2  900110     MOV [W0+2], W2
0040A4  78001E     MOV [W14], W0
0040A6  904010     MOV.B [W0+1], W0
0040A8  FB8080     ZE W0, W1
0040AA  78001E     MOV [W14], W0
0040AC  784010     MOV.B [W0], W0
0040AE  780203     MOV W3, W4
0040B0  780182     MOV W2, W3
0040B2  780101     MOV W1, W2
0040B4  784080     MOV.B W0, W1
0040B6  21A320     MOV #0x1A32, W0
0040B8  02D4D2     CALL dfilterInit
0040BA  000000     NOP
259:                               params->xcoeffs, params->ycoeffs);
00409C  78001E     MOV [W14], W0
0040A0  78001E     MOV [W14], W0
260:                   yaw_filter_ready = 1;
0040BC  21B611     MOV #0x1B61, W1
0040BE  B3C010     MOV #0x1, W0
0040C0  784880     MOV.B W0, [W1]
261:                   
262:               } 
0040C2  FA8000     ULNK
0040C4  060000     RETURN
263:               
264:               
265:               void rgltrSetPitchRateFilter(RateFilterParams params) {
0040C6  FA0002     LNK #0x2
0040C8  780F00     MOV W0, [W14]
266:               
267:                   dfilterInit(&pitchRateFilter, params->order, params->type,
0040CC  9001A0     MOV [W0+4], W3
0040D0  900110     MOV [W0+2], W2
0040D2  78001E     MOV [W14], W0
0040D4  904010     MOV.B [W0+1], W0
0040D6  FB8080     ZE W0, W1
0040D8  78001E     MOV [W14], W0
0040DA  784010     MOV.B [W0], W0
0040DC  780203     MOV W3, W4
0040DE  780182     MOV W2, W3
0040E0  780101     MOV W1, W2
0040E2  784080     MOV.B W0, W1
0040E4  21A960     MOV #0x1A96, W0
0040E6  02D4D2     CALL dfilterInit
0040E8  000000     NOP
268:                               params->xcoeffs, params->ycoeffs);
0040CA  78001E     MOV [W14], W0
0040CE  78001E     MOV [W14], W0
269:                   pitch_filter_ready = 1;
0040EA  21B621     MOV #0x1B62, W1
0040EC  B3C010     MOV #0x1, W0
0040EE  784880     MOV.B W0, [W1]
270:                               
271:               } 
0040F0  FA8000     ULNK
0040F2  060000     RETURN
272:               
273:               void rgltrSetRollRateFilter(RateFilterParams params) {
0040F4  FA0002     LNK #0x2
0040F6  780F00     MOV W0, [W14]
274:               
275:                   dfilterInit(&rollRateFilter, params->order, params->type,
0040FA  9001A0     MOV [W0+4], W3
0040FE  900110     MOV [W0+2], W2
004100  78001E     MOV [W14], W0
004102  904010     MOV.B [W0+1], W0
004104  FB8080     ZE W0, W1
004106  78001E     MOV [W14], W0
004108  784010     MOV.B [W0], W0
00410A  780203     MOV W3, W4
00410C  780182     MOV W2, W3
00410E  780101     MOV W1, W2
004110  784080     MOV.B W0, W1
004112  21AFA0     MOV #0x1AFA, W0
004114  02D4D2     CALL dfilterInit
004116  000000     NOP
276:                               params->xcoeffs, params->ycoeffs);
0040F8  78001E     MOV [W14], W0
0040FC  78001E     MOV [W14], W0
277:                   roll_filter_ready = 1;
004118  21B631     MOV #0x1B63, W1
00411A  B3C010     MOV #0x1, W0
00411C  784880     MOV.B W0, [W1]
278:                   
279:               }
00411E  FA8000     ULNK
004120  060000     RETURN
280:               
281:               void rgltrSetOffsets(float *offsets) {
004122  FA0002     LNK #0x2
004124  780F00     MOV W0, [W14]
282:               
283:                   ctrlSetPidOffset(&yawPid, offsets[0]);
004126  78001E     MOV [W14], W0
004128  BE0010     MOV.D [W0], W0
00412A  BE0100     MOV.D W0, W2
00412C  2199C0     MOV #0x199C, W0
00412E  02B16E     CALL ctrlSetPidOffset
004130  000000     NOP
284:                   ctrlSetPidOffset(&pitchPid, offsets[1]);
004132  78009E     MOV [W14], W1
004134  408064     ADD W1, #0x4, W0
004136  BE0010     MOV.D [W0], W0
004138  BE0100     MOV.D W0, W2
00413A  219CE0     MOV #0x19CE, W0
00413C  02B16E     CALL ctrlSetPidOffset
00413E  000000     NOP
285:                   ctrlSetPidOffset(&thrustPid, offsets[2]);
004140  78009E     MOV [W14], W1
004142  408068     ADD W1, #0x8, W0
004144  BE0010     MOV.D [W0], W0
004146  BE0100     MOV.D W0, W2
004148  21A000     MOV #0x1A00, W0
00414A  02B16E     CALL ctrlSetPidOffset
00414C  000000     NOP
286:               
287:               }
00414E  FA8000     ULNK
004150  060000     RETURN
288:               
289:               void rgltrSetYawPid(PidParams params) {
004152  FA0002     LNK #0x2
004154  780F00     MOV W0, [W14]
290:                   
291:                   ctrlSetPidParams(&yawPid, params->ref, params->kp, params->ki, params->kd);
004156  78001E     MOV [W14], W0
004158  900B00     MOV [W0+16], W6
00415A  900B90     MOV [W0+18], W7
00415C  78001E     MOV [W14], W0
00415E  900260     MOV [W0+12], W4
004160  9002F0     MOV [W0+14], W5
004162  78001E     MOV [W14], W0
004164  900140     MOV [W0+8], W2
004166  9001D0     MOV [W0+10], W3
004168  78001E     MOV [W14], W0
00416A  BE0010     MOV.D [W0], W0
00416C  BE9F86     MOV.D W6, [W15++]
00416E  BE0304     MOV.D W4, W6
004170  BE0202     MOV.D W2, W4
004172  BE0100     MOV.D W0, W2
004174  2199C0     MOV #0x199C, W0
004176  02B11C     CALL ctrlSetPidParams
004178  000000     NOP
00417A  5787E4     SUB W15, #0x4, W15
292:                   ctrlSetPidOffset(&yawPid, params->offset);
00417C  78001E     MOV [W14], W0
00417E  9000B0     MOV [W0+6], W1
004180  900020     MOV [W0+4], W0
004182  BE0100     MOV.D W0, W2
004184  2199C0     MOV #0x199C, W0
004186  02B16E     CALL ctrlSetPidOffset
004188  000000     NOP
293:                   ctrlSetRefWeigts(&yawPid, params->beta, params->gamma);
00418A  78001E     MOV [W14], W0
00418C  900940     MOV [W0+24], W2
00418E  9009D0     MOV [W0+26], W3
004190  78001E     MOV [W14], W0
004192  9008B0     MOV [W0+22], W1
004194  900820     MOV [W0+20], W0
004196  BE0202     MOV.D W2, W4
004198  BE0100     MOV.D W0, W2
00419A  2199C0     MOV #0x199C, W0
00419C  02B192     CALL ctrlSetRefWeigts
00419E  000000     NOP
294:                   ctrlSetSaturation(&yawPid, YAW_SAT_MAX, YAW_SAT_MIN);
0041A0  200004     MOV #0x0, W4
0041A2  2BF805     MOV #0xBF80, W5
0041A4  200002     MOV #0x0, W2
0041A6  23F803     MOV #0x3F80, W3
0041A8  2199C0     MOV #0x199C, W0
0041AA  02B1B6     CALL ctrlSetSaturation
0041AC  000000     NOP
295:               
296:               }
0041AE  FA8000     ULNK
0041B0  060000     RETURN
297:               
298:               void rgltrSetPitchPid(PidParams params) {
0041B2  FA0002     LNK #0x2
0041B4  780F00     MOV W0, [W14]
299:                   
300:                   ctrlSetPidParams(&pitchPid, params->ref, params->kp, params->ki, params->kd);
0041B6  78001E     MOV [W14], W0
0041B8  900B00     MOV [W0+16], W6
0041BA  900B90     MOV [W0+18], W7
0041BC  78001E     MOV [W14], W0
0041BE  900260     MOV [W0+12], W4
0041C0  9002F0     MOV [W0+14], W5
0041C2  78001E     MOV [W14], W0
0041C4  900140     MOV [W0+8], W2
0041C6  9001D0     MOV [W0+10], W3
0041C8  78001E     MOV [W14], W0
0041CA  BE0010     MOV.D [W0], W0
0041CC  BE9F86     MOV.D W6, [W15++]
0041CE  BE0304     MOV.D W4, W6
0041D0  BE0202     MOV.D W2, W4
0041D2  BE0100     MOV.D W0, W2
0041D4  219CE0     MOV #0x19CE, W0
0041D6  02B11C     CALL ctrlSetPidParams
0041D8  000000     NOP
0041DA  5787E4     SUB W15, #0x4, W15
301:                   ctrlSetPidOffset(&pitchPid, params->offset);
0041DC  78001E     MOV [W14], W0
0041DE  9000B0     MOV [W0+6], W1
0041E0  900020     MOV [W0+4], W0
0041E2  BE0100     MOV.D W0, W2
0041E4  219CE0     MOV #0x19CE, W0
0041E6  02B16E     CALL ctrlSetPidOffset
0041E8  000000     NOP
302:                   ctrlSetRefWeigts(&pitchPid, params->beta, params->gamma);
0041EA  78001E     MOV [W14], W0
0041EC  900940     MOV [W0+24], W2
0041EE  9009D0     MOV [W0+26], W3
0041F0  78001E     MOV [W14], W0
0041F2  9008B0     MOV [W0+22], W1
0041F4  900820     MOV [W0+20], W0
0041F6  BE0202     MOV.D W2, W4
0041F8  BE0100     MOV.D W0, W2
0041FA  219CE0     MOV #0x19CE, W0
0041FC  02B192     CALL ctrlSetRefWeigts
0041FE  000000     NOP
303:                   ctrlSetSaturation(&pitchPid, PITCH_SAT_MAX, PITCH_SAT_MIN);
004200  200004     MOV #0x0, W4
004202  2BF805     MOV #0xBF80, W5
004204  200002     MOV #0x0, W2
004206  23F803     MOV #0x3F80, W3
004208  219CE0     MOV #0x19CE, W0
00420A  02B1B6     CALL ctrlSetSaturation
00420C  000000     NOP
304:               
305:               }
00420E  FA8000     ULNK
004210  060000     RETURN
306:               
307:               void rgltrSetRollPid(PidParams params) {
004212  FA0002     LNK #0x2
004214  780F00     MOV W0, [W14]
308:               
309:                   ctrlSetPidParams(&thrustPid, params->ref, params->kp, params->ki, params->kd);
004216  78001E     MOV [W14], W0
004218  900B00     MOV [W0+16], W6
00421A  900B90     MOV [W0+18], W7
00421C  78001E     MOV [W14], W0
00421E  900260     MOV [W0+12], W4
004220  9002F0     MOV [W0+14], W5
004222  78001E     MOV [W14], W0
004224  900140     MOV [W0+8], W2
004226  9001D0     MOV [W0+10], W3
004228  78001E     MOV [W14], W0
00422A  BE0010     MOV.D [W0], W0
00422C  BE9F86     MOV.D W6, [W15++]
00422E  BE0304     MOV.D W4, W6
004230  BE0202     MOV.D W2, W4
004232  BE0100     MOV.D W0, W2
004234  21A000     MOV #0x1A00, W0
004236  02B11C     CALL ctrlSetPidParams
004238  000000     NOP
00423A  5787E4     SUB W15, #0x4, W15
310:                   ctrlSetPidOffset(&thrustPid, params->offset);
00423C  78001E     MOV [W14], W0
00423E  9000B0     MOV [W0+6], W1
004240  900020     MOV [W0+4], W0
004242  BE0100     MOV.D W0, W2
004244  21A000     MOV #0x1A00, W0
004246  02B16E     CALL ctrlSetPidOffset
004248  000000     NOP
311:                   ctrlSetRefWeigts(&thrustPid, params->beta, params->gamma);
00424A  78001E     MOV [W14], W0
00424C  900940     MOV [W0+24], W2
00424E  9009D0     MOV [W0+26], W3
004250  78001E     MOV [W14], W0
004252  9008B0     MOV [W0+22], W1
004254  900820     MOV [W0+20], W0
004256  BE0202     MOV.D W2, W4
004258  BE0100     MOV.D W0, W2
00425A  21A000     MOV #0x1A00, W0
00425C  02B192     CALL ctrlSetRefWeigts
00425E  000000     NOP
312:                   ctrlSetSaturation(&thrustPid, ROLL_SAT_MAX, ROLL_SAT_MIN);
004260  B82260     MUL.UU W4, #0, W4
004262  200002     MOV #0x0, W2
004264  23F803     MOV #0x3F80, W3
004266  21A000     MOV #0x1A00, W0
004268  02B1B6     CALL ctrlSetSaturation
00426A  000000     NOP
313:               
314:               }
00426C  FA8000     ULNK
00426E  060000     RETURN
315:               
316:               void rgltrSetYawRef(float ref) {
004270  FA0004     LNK #0x4
004272  BE8F00     MOV.D W0, [W14]
317:                   ctrlSetRef(&yawPid, ref);
004274  BE011E     MOV.D [W14], W2
004276  2199C0     MOV #0x199C, W0
004278  02AECE     CALL ctrlSetRef
00427A  000000     NOP
318:               }
00427C  FA8000     ULNK
00427E  060000     RETURN
319:               
320:               void rgltrSetPitchRef(float ref) {
004280  FA0004     LNK #0x4
004282  BE8F00     MOV.D W0, [W14]
321:                   ctrlSetRef(&pitchPid, ref);
004284  BE011E     MOV.D [W14], W2
004286  219CE0     MOV #0x19CE, W0
004288  02AECE     CALL ctrlSetRef
00428A  000000     NOP
322:               }
00428C  FA8000     ULNK
00428E  060000     RETURN
323:               
324:               void rgltrSetRollRef(float ref) {
004290  FA0004     LNK #0x4
004292  BE8F00     MOV.D W0, [W14]
325:                   ctrlSetRef(&thrustPid, ref);
004294  BE011E     MOV.D [W14], W2
004296  21A000     MOV #0x1A00, W0
004298  02AECE     CALL ctrlSetRef
00429A  000000     NOP
326:               }
00429C  FA8000     ULNK
00429E  060000     RETURN
327:               
328:               void rgltrGetQuatRef(Quaternion *ref) {
0042A0  FA0002     LNK #0x2
0042A2  780F00     MOV W0, [W14]
329:                   if(ref == NULL) { return; }
0042A4  78009E     MOV [W14], W1
0042A6  EB0000     CLR W0
0042A8  508F80     SUB W1, W0, [W15]
0042AA  320005     BRA Z, 0x42B6
0042B6  000000     NOP
330:                   quatCopy(ref, &reference);
0042AC  21B721     MOV #0x1B72, W1
0042AE  78001E     MOV [W14], W0
0042B0  02A488     CALL quatCopy
0042B2  000000     NOP
0042B4  370001     BRA 0x42B8
331:               }
0042B8  FA8000     ULNK
0042BA  060000     RETURN
332:               
333:               void rgltrSetQuatRef(Quaternion *ref) {
0042BC  FA0002     LNK #0x2
0042BE  780F00     MOV W0, [W14]
334:                   if(ref == NULL) { return; }
0042C0  78009E     MOV [W14], W1
0042C2  EB0000     CLR W0
0042C4  508F80     SUB W1, W0, [W15]
0042C6  320005     BRA Z, 0x42D2
0042D2  000000     NOP
335:                   quatCopy(&reference, ref);
0042C8  78009E     MOV [W14], W1
0042CA  21B720     MOV #0x1B72, W0
0042CC  02A488     CALL quatCopy
0042CE  000000     NOP
0042D0  370001     BRA 0x42D4
336:               }
0042D4  FA8000     ULNK
0042D6  060000     RETURN
337:               
338:               void rgltrSetTempRot(Quaternion *rot) {
0042D8  FA0002     LNK #0x2
0042DA  780F00     MOV W0, [W14]
339:                   if(rot == NULL) { return; }
0042DC  78009E     MOV [W14], W1
0042DE  EB0000     CLR W0
0042E0  508F80     SUB W1, W0, [W15]
0042E2  320008     BRA Z, 0x42F4
0042F4  000000     NOP
340:                   quatCopy(&temp_rot, rot);
0042E4  78009E     MOV [W14], W1
0042E6  21BA20     MOV #0x1BA2, W0
0042E8  02A488     CALL quatCopy
0042EA  000000     NOP
341:                   temp_rot_active = 1;
0042EC  21B601     MOV #0x1B60, W1
0042EE  B3C010     MOV #0x1, W0
0042F0  784880     MOV.B W0, [W1]
0042F2  370001     BRA 0x42F6
342:               }
0042F6  FA8000     ULNK
0042F8  060000     RETURN
343:               
344:               void rgltrSetRemoteControlValues(float thrust, float steer, float elevator) {
0042FA  FA000C     LNK #0xC
0042FC  BE8F00     MOV.D W0, [W14]
0042FE  980722     MOV W2, [W14+4]
004300  980733     MOV W3, [W14+6]
004302  980744     MOV W4, [W14+8]
004304  980755     MOV W5, [W14+10]
345:                   rc_outputs.thrust = thrust;
004306  BE001E     MOV.D [W14], W0
004308  88DB30     MOV W0, rc_outputs
00430A  88DB41     MOV W1, 0x1B68
346:                   rc_outputs.steer = steer;
00430C  90002E     MOV [W14+4], W0
00430E  9000BE     MOV [W14+6], W1
004310  88DB50     MOV W0, 0x1B6A
004312  88DB61     MOV W1, 0x1B6C
347:                   rc_outputs.elevator = elevator;
004314  90004E     MOV [W14+8], W0
004316  9000DE     MOV [W14+10], W1
004318  88DB70     MOV W0, 0x1B6E
00431A  88DB81     MOV W1, 0x1B70
348:               }
00431C  FA8000     ULNK
00431E  060000     RETURN
349:               
350:               void rgltrStartLogging(void) {
004320  FA0000     LNK #0x0
351:                   is_logging = 1;
004322  21B5F1     MOV #0x1B5F, W1
004324  B3C010     MOV #0x1, W0
004326  784880     MOV.B W0, [W1]
352:               }
004328  FA8000     ULNK
00432A  060000     RETURN
353:               
354:               void rgltrStopLogging(void) {
00432C  FA0000     LNK #0x0
355:                   is_logging = 0;
00432E  21B5F1     MOV #0x1B5F, W1
004330  EB4000     CLR.B W0
004332  784880     MOV.B W0, [W1]
356:               }
004334  FA8000     ULNK
004336  060000     RETURN
357:               
358:               void rgltrGetState(RegulatorState dst) {
004338  FA0004     LNK #0x4
00433A  980710     MOV W0, [W14+2]
359:               
360:                   RegulatorState src;
361:               
362:                   src = ppbuffReadActive(&reg_state_buff);
00433C  21C3A0     MOV #0x1C3A, W0
00433E  02C664     CALL ppbuffReadActive
004340  000000     NOP
004342  780F00     MOV W0, [W14]
363:                   if(src == NULL) { // Return 0's if no unread data
004344  78009E     MOV [W14], W1
004346  EB0000     CLR W0
004348  508F80     SUB W1, W0, [W15]
00434A  3A0006     BRA NZ, 0x4358
364:                       memset(dst, 0, sizeof(RegulatorStateStruct));
00434C  200442     MOV #0x44, W2
00434E  EB0080     CLR W1
004350  90001E     MOV [W14+2], W0
004352  0235B4     CALL _memset
004354  000000     NOP
365:                       return; 
004356  370005     BRA 0x4362
366:                   }
367:                   
368:                   memcpy(dst, src, sizeof(RegulatorStateStruct));    
004358  200442     MOV #0x44, W2
00435A  78009E     MOV [W14], W1
00435C  90001E     MOV [W14+2], W0
00435E  023582     CALL _memcpy
004360  000000     NOP
369:                   
370:               }
004362  FA8000     ULNK
004364  060000     RETURN
371:               
372:               void rgltrRunController(void) {
004366  FA001A     LNK #0x1A
004368  781F88     MOV W8, [W15++]
373:                   
374:                   RegulatorError error;        
375:                   RegulatorOutput output;
376:                   int updated_bemf;
377:               
378:                   if(!is_ready) { return; }    
00436A  21B5E0     MOV #0x1B5E, W0
00436C  784090     MOV.B [W0], W1
00436E  EB4000     CLR.B W0
004370  50CF80     SUB.B W1, W0, [W15]
004372  32005F     BRA Z, 0x4432
004432  000000     NOP
379:               
380:                   attEstimatePose();  // Update attitude estimate
004374  028C18     CALL attEstimatePose
004376  000000     NOP
381:                   updated_bemf = updateBEMF();
004378  0701CA     RCALL updateBEMF
00437A  780F00     MOV W0, [W14]
382:                   if (crankCalibrated == 1 && updated_bemf == 1) {
00437C  80E311     MOV crankCalibrated, W1
00437E  200010     MOV #0x1, W0
004380  508F80     SUB W1, W0, [W15]
004382  3A0005     BRA NZ, 0x438E
004384  78009E     MOV [W14], W1
004386  200010     MOV #0x1, W0
004388  508F80     SUB W1, W0, [W15]
00438A  3A0001     BRA NZ, 0x438E
383:               //        wing_status.count_calib++;
384:               //        if (wing_status.count_calib % 100 == 0) {
385:               //            wing_status.count_calib = 0;
386:               //            calibCrank();
387:               //        }
388:                       updateCrank();
00438C  0702E7     RCALL updateCrank
389:                   }
390:               
391:               
392:                   rateProcess();      // Update limited_reference
00438E  02C15A     CALL rateProcess
004390  000000     NOP
393:                   slewProcess(&reference, &limited_reference); // Apply slew rate limiting
004392  21B821     MOV #0x1B82, W1
004394  21B720     MOV #0x1B72, W0
004396  02CD60     CALL slewProcess
004398  000000     NOP
394:               
395:                   attGetQuat(&pose);
00439A  21B920     MOV #0x1B92, W0
00439C  028ABC     CALL attGetQuat
00439E  000000     NOP
396:                   calculateError(&error);    
0043A0  E8800E     INC2 W14, W0
0043A2  07009E     RCALL calculateError
397:                   calculateOutputs(&error, &output);
0043A4  4700EE     ADD W14, #0xE, W1
0043A6  E8800E     INC2 W14, W0
0043A8  070120     RCALL calculateOutputs
398:               
399:                   if ((crankAngle > (wing_status.stopPos - 5) && crankAngle < (wing_status.stopPos + 5) && wing_status.enabled == 1) || wing_status.stopped == 1) {
0043AA  80E370     MOV 0x1C6E, W0
0043AC  500065     SUB W0, #0x5, W0
0043AE  DE80CF     ASR W0, #15, W1
0043B0  022624     CALL ___floatsisf
0043B2  000000     NOP
0043B4  BE0200     MOV.D W0, W4
0043B6  80E2A0     MOV crankAngle, W0
0043B8  80E2B1     MOV 0x1C56, W1
0043BA  B3C018     MOV #0x1, W8
0043BC  BE0100     MOV.D W0, W2
0043BE  BE0004     MOV.D W4, W0
0043C0  0225A4     CALL ___lesf2
0043C2  000000     NOP
0043C4  EB0080     CLR W1
0043C6  500F81     SUB W0, W1, [W15]
0043C8  350001     BRA LT, 0x43CC
0043CA  EB4400     CLR.B W8
0043CC  EB4000     CLR.B W0
0043CE  544F80     SUB.B W8, W0, [W15]
0043D0  320019     BRA Z, 0x4404
0043D2  80E370     MOV 0x1C6E, W0
0043D4  400065     ADD W0, #0x5, W0
0043D6  DE80CF     ASR W0, #15, W1
0043D8  022624     CALL ___floatsisf
0043DA  000000     NOP
0043DC  BE0200     MOV.D W0, W4
0043DE  80E2A0     MOV crankAngle, W0
0043E0  80E2B1     MOV 0x1C56, W1
0043E2  B3C018     MOV #0x1, W8
0043E4  BE0100     MOV.D W0, W2
0043E6  BE0004     MOV.D W4, W0
0043E8  0225A8     CALL ___gtsf2
0043EA  000000     NOP
0043EC  EB0080     CLR W1
0043EE  500F81     SUB W0, W1, [W15]
0043F0  3C0001     BRA GT, 0x43F4
0043F2  EB4400     CLR.B W8
0043F4  EB4000     CLR.B W0
0043F6  544F80     SUB.B W8, W0, [W15]
0043F8  320005     BRA Z, 0x4404
0043FA  21C6D0     MOV #0x1C6D, W0
0043FC  784090     MOV.B [W0], W1
0043FE  B3C010     MOV #0x1, W0
004400  50CF80     SUB.B W1, W0, [W15]
004402  320005     BRA Z, 0x440E
004404  21C6C0     MOV #0x1C6C, W0
004406  784090     MOV.B [W0], W1
004408  B3C010     MOV #0x1, W0
00440A  50CF80     SUB.B W1, W0, [W15]
00440C  3A0007     BRA NZ, 0x441C
400:                       LED_RED = 1;
00440E  A882CB     BSET 0x2CB, #4
401:                       wing_status.stopped = 1;
004410  21C6C1     MOV #0x1C6C, W1
004412  B3C010     MOV #0x1, W0
004414  784880     MOV.B W0, [W1]
402:                       output.thrust = 0.0;
004416  47016E     ADD W14, #0xE, W2
004418  B80060     MUL.UU W0, #0, W0
00441A  BE8900     MOV.D W0, [W2]
403:                   }
404:                   
405:               //    if (adcGetBEMFR() < 3) {
406:               //        LED_RED = 1;
407:               //    } else {
408:               //        LED_RED = 0;
409:               //    }
410:                   
411:                   applyOutputs(&output);        
00441C  47006E     ADD W14, #0xE, W0
00441E  070120     RCALL applyOutputs
412:                   
413:                   if(is_logging) {
004420  21B5F0     MOV #0x1B5F, W0
004422  784090     MOV.B [W0], W1
004424  EB4000     CLR.B W0
004426  50CF80     SUB.B W1, W0, [W15]
004428  320005     BRA Z, 0x4434
414:                       logTrace(&error, &output);
00442A  4700EE     ADD W14, #0xE, W1
00442C  E8800E     INC2 W14, W0
00442E  07036F     RCALL logTrace
004430  370001     BRA 0x4434
415:                   }
416:               }
004434  78044F     MOV [--W15], W8
004436  FA8000     ULNK
004438  060000     RETURN
417:               
418:               
419:               // =========== Private Functions ===============================================
420:               
421:               static float runYawControl(float yaw) {
00443A  FA0004     LNK #0x4
00443C  BE8F00     MOV.D W0, [W14]
422:               
423:                   /*float u;
424:               
425:                   u = yawPid.offset;
426:               
427:                   if (u > yawPid.umax) {
428:                       u = yawPid.umax;
429:                   } else if (u < yawPid.umin) {
430:                       u = yawPid.umin;
431:                   }
432:               
433:                   return u;*/
434:                   if(yaw_filter_ready) {
00443E  21B610     MOV #0x1B61, W0
004440  784090     MOV.B [W0], W1
004442  EB4000     CLR.B W0
004444  50CF80     SUB.B W1, W0, [W15]
004446  320006     BRA Z, 0x4454
435:                      return ctrlRunPid(&yawPid, yaw, &yawRateFilter);
004448  21A321     MOV #0x1A32, W1
00444A  BE011E     MOV.D [W14], W2
00444C  2199C0     MOV #0x199C, W0
00444E  02AEE4     CALL ctrlRunPid
004450  000000     NOP
004452  370005     BRA 0x445E
436:                   } else {
437:                       return ctrlRunPid(&yawPid, yaw, NULL);
004454  EB0080     CLR W1
004456  BE011E     MOV.D [W14], W2
004458  2199C0     MOV #0x199C, W0
00445A  02AEE4     CALL ctrlRunPid
00445C  000000     NOP
438:                   }
439:               }
00445E  FA8000     ULNK
004460  060000     RETURN
440:               
441:               
442:               static float runPitchControl(float pitch) {   
004462  FA0004     LNK #0x4
004464  BE8F00     MOV.D W0, [W14]
443:               
444:                   if(pitch_filter_ready) {
004466  21B620     MOV #0x1B62, W0
004468  784090     MOV.B [W0], W1
00446A  EB4000     CLR.B W0
00446C  50CF80     SUB.B W1, W0, [W15]
00446E  320006     BRA Z, 0x447C
445:                       return ctrlRunPid(&pitchPid, pitch, &pitchRateFilter);
004470  21A961     MOV #0x1A96, W1
004472  BE011E     MOV.D [W14], W2
004474  219CE0     MOV #0x19CE, W0
004476  02AEE4     CALL ctrlRunPid
004478  000000     NOP
00447A  370005     BRA 0x4486
446:                   } else {
447:                       return ctrlRunPid(&pitchPid, pitch, NULL);
00447C  EB0080     CLR W1
00447E  BE011E     MOV.D [W14], W2
004480  219CE0     MOV #0x19CE, W0
004482  02AEE4     CALL ctrlRunPid
004484  000000     NOP
448:                   }        
449:               
450:               }
004486  FA8000     ULNK
004488  060000     RETURN
451:               
452:               static float runRollControl(float roll) {
00448A  FA0004     LNK #0x4
00448C  BE8F00     MOV.D W0, [W14]
453:               
454:                   if(roll_filter_ready) {
00448E  21B630     MOV #0x1B63, W0
004490  784090     MOV.B [W0], W1
004492  EB4000     CLR.B W0
004494  50CF80     SUB.B W1, W0, [W15]
004496  320006     BRA Z, 0x44A4
455:                       return ctrlRunPid(&thrustPid, roll, &rollRateFilter);
004498  21AFA1     MOV #0x1AFA, W1
00449A  BE011E     MOV.D [W14], W2
00449C  21A000     MOV #0x1A00, W0
00449E  02AEE4     CALL ctrlRunPid
0044A0  000000     NOP
0044A2  370005     BRA 0x44AE
456:                   } else {
457:                       return ctrlRunPid(&thrustPid, roll, NULL);
0044A4  EB0080     CLR W1
0044A6  BE011E     MOV.D [W14], W2
0044A8  21A000     MOV #0x1A00, W0
0044AA  02AEE4     CALL ctrlRunPid
0044AC  000000     NOP
458:                   }
459:               
460:               }
0044AE  FA8000     ULNK
0044B0  060000     RETURN
461:               
462:               static void applyTempRot(Quaternion *input, Quaternion *output) {
0044B2  FA0004     LNK #0x4
0044B4  780F00     MOV W0, [W14]
0044B6  980711     MOV W1, [W14+2]
463:                   if (temp_rot_active == 1) {
0044B8  21B600     MOV #0x1B60, W0
0044BA  784090     MOV.B [W0], W1
0044BC  B3C010     MOV #0x1, W0
0044BE  50CF80     SUB.B W1, W0, [W15]
0044C0  3A0009     BRA NZ, 0x44D4
464:                       quatMult(&temp_rot, input, output);
0044C2  90011E     MOV [W14+2], W2
0044C4  78009E     MOV [W14], W1
0044C6  21BA20     MOV #0x1BA2, W0
0044C8  02A54E     CALL quatMult
0044CA  000000     NOP
465:                       quatNormalize(output);
0044CC  90001E     MOV [W14+2], W0
0044CE  02A72C     CALL quatNormalize
0044D0  000000     NOP
0044D2  370004     BRA 0x44DC
466:                   } else {
467:                       quatCopy(output, input);
0044D4  78009E     MOV [W14], W1
0044D6  90001E     MOV [W14+2], W0
0044D8  02A488     CALL quatCopy
0044DA  000000     NOP
468:                   }
469:               }
0044DC  FA8000     ULNK
0044DE  060000     RETURN
470:               
471:               static void calculateError(RegulatorError *error) {
0044E0  FA0028     LNK #0x28
0044E2  BE9F88     MOV.D W8, [W15++]
0044E4  981730     MOV W0, [W14+38]
472:               
473:                   Quaternion conj_quat, err_quat;
474:                   bams16_t a_2;
475:                   float scale;
476:                   
477:                   // qref = qpose*qerr
478:                   // qpose'*qref = qerr
479:                   quatConj(&pose, &conj_quat);
0044E6  470066     ADD W14, #0x6, W0
0044E8  780080     MOV W0, W1
0044EA  21B920     MOV #0x1B92, W0
0044EC  02A4FA     CALL quatConj
0044EE  000000     NOP
480:                   //quatMult(&limited_reference, &conj_quat, &err_quat);
481:                   quatMult(&conj_quat, &limited_reference, &err_quat);
0044F0  4700F6     ADD W14, #0x16, W1
0044F2  470066     ADD W14, #0x6, W0
0044F4  780101     MOV W1, W2
0044F6  21B821     MOV #0x1B82, W1
0044F8  02A54E     CALL quatMult
0044FA  000000     NOP
482:               
483:                   // q = [cos(a/2), sin(a/2)*[x, y, z]]
484:                   // d[x, y, z] = [q]*a/sin(a/2)        
485:                   if(err_quat.w == 1.0) { // a = 0 case
0044FC  470076     ADD W14, #0x16, W0
0044FE  BE0010     MOV.D [W0], W0
004500  200002     MOV #0x0, W2
004502  23F803     MOV #0x3F80, W3
004504  0225A4     CALL ___lesf2
004506  000000     NOP
004508  EB0080     CLR W1
00450A  500F81     SUB W0, W1, [W15]
00450C  3A000C     BRA NZ, 0x4526
486:                       error->yaw_err = 0.0;
00450E  90113E     MOV [W14+38], W2
004510  B80060     MUL.UU W0, #0, W0
004512  BE8900     MOV.D W0, [W2]
487:                       error->pitch_err = 0.0;
004514  90113E     MOV [W14+38], W2
004516  B80060     MUL.UU W0, #0, W0
004518  980120     MOV W0, [W2+4]
00451A  980131     MOV W1, [W2+6]
488:                       error->roll_err = 0.0;
00451C  90113E     MOV [W14+38], W2
00451E  B80060     MUL.UU W0, #0, W0
004520  980140     MOV W0, [W2+8]
004522  980151     MOV W1, [W2+10]
004524  370030     BRA 0x4586
489:                   } else {
490:                       a_2 = bams16Acos(err_quat.w); // w = cos(a/2)             
004526  470076     ADD W14, #0x16, W0
004528  BE0010     MOV.D [W0], W0
00452A  026F88     CALL bams16Acos
00452C  000000     NOP
00452E  780F00     MOV W0, [W14]
491:                       scale = bams16ToFloatRad(a_2*2)/bams16Sin(a_2); // a/sin(a/2)
004530  78001E     MOV [W14], W0
004532  400000     ADD W0, W0, W0
004534  026B50     CALL bams16ToFloatRad
004536  000000     NOP
004538  BE0400     MOV.D W0, W8
00453A  78001E     MOV [W14], W0
00453C  026D1C     CALL bams16Sin
00453E  000000     NOP
004540  BE0100     MOV.D W0, W2
004542  BE0008     MOV.D W8, W0
004544  022E80     CALL ___divsf3x
004546  000000     NOP
004548  980710     MOV W0, [W14+2]
00454A  980721     MOV W1, [W14+4]
492:                       error->yaw_err = err_quat.z*scale;
00454C  470076     ADD W14, #0x16, W0
00454E  9000F0     MOV [W0+14], W1
004550  900060     MOV [W0+12], W0
004552  90011E     MOV [W14+2], W2
004554  9001AE     MOV [W14+4], W3
004556  022C36     CALL ___mulsf3
004558  000000     NOP
00455A  90113E     MOV [W14+38], W2
00455C  BE8900     MOV.D W0, [W2]
493:                       error->pitch_err = err_quat.y*scale;
00455E  470076     ADD W14, #0x16, W0
004560  9000D0     MOV [W0+10], W1
004562  900040     MOV [W0+8], W0
004564  90011E     MOV [W14+2], W2
004566  9001AE     MOV [W14+4], W3
004568  022C36     CALL ___mulsf3
00456A  000000     NOP
00456C  90113E     MOV [W14+38], W2
00456E  980120     MOV W0, [W2+4]
004570  980131     MOV W1, [W2+6]
494:                       error->roll_err = err_quat.x*scale;
004572  470076     ADD W14, #0x16, W0
004574  9000B0     MOV [W0+6], W1
004576  900020     MOV [W0+4], W0
004578  90011E     MOV [W14+2], W2
00457A  9001AE     MOV [W14+4], W3
00457C  022C36     CALL ___mulsf3
00457E  000000     NOP
004580  90113E     MOV [W14+38], W2
004582  980140     MOV W0, [W2+8]
004584  980151     MOV W1, [W2+10]
495:                   }
496:                   
497:               }
004586  BE044F     MOV.D [--W15], W8
004588  FA8000     ULNK
00458A  060000     RETURN
498:               
499:               static void filterError(RegulatorError *error) {
00458C  FA0002     LNK #0x2
00458E  780F00     MOV W0, [W14]
500:               
501:                   if(yaw_filter_ready) {
004590  21B610     MOV #0x1B61, W0
004592  784090     MOV.B [W0], W1
004594  EB4000     CLR.B W0
004596  50CF80     SUB.B W1, W0, [W15]
004598  320008     BRA Z, 0x45AA
502:                       error->yaw_err = dfilterApply(&yawRateFilter, error->yaw_err);
00459A  78001E     MOV [W14], W0
00459C  BE0010     MOV.D [W0], W0
00459E  BE0100     MOV.D W0, W2
0045A0  21A320     MOV #0x1A32, W0
0045A2  02D3F6     CALL dfilterApply
0045A4  000000     NOP
0045A6  78011E     MOV [W14], W2
0045A8  BE8900     MOV.D W0, [W2]
503:                   }
504:                   if(pitch_filter_ready) {
0045AA  21B620     MOV #0x1B62, W0
0045AC  784090     MOV.B [W0], W1
0045AE  EB4000     CLR.B W0
0045B0  50CF80     SUB.B W1, W0, [W15]
0045B2  32000A     BRA Z, 0x45C8
505:                       error->pitch_err = dfilterApply(&pitchRateFilter, error->pitch_err);
0045B4  78001E     MOV [W14], W0
0045B6  9000B0     MOV [W0+6], W1
0045B8  900020     MOV [W0+4], W0
0045BA  BE0100     MOV.D W0, W2
0045BC  21A960     MOV #0x1A96, W0
0045BE  02D3F6     CALL dfilterApply
0045C0  000000     NOP
0045C2  78011E     MOV [W14], W2
0045C4  980120     MOV W0, [W2+4]
0045C6  980131     MOV W1, [W2+6]
506:                   }
507:                   if(roll_filter_ready) {
0045C8  21B630     MOV #0x1B63, W0
0045CA  784090     MOV.B [W0], W1
0045CC  EB4000     CLR.B W0
0045CE  50CF80     SUB.B W1, W0, [W15]
0045D0  32000A     BRA Z, 0x45E6
508:                       error->roll_err = dfilterApply(&rollRateFilter, error->roll_err);
0045D2  78001E     MOV [W14], W0
0045D4  9000D0     MOV [W0+10], W1
0045D6  900040     MOV [W0+8], W0
0045D8  BE0100     MOV.D W0, W2
0045DA  21AFA0     MOV #0x1AFA, W0
0045DC  02D3F6     CALL dfilterApply
0045DE  000000     NOP
0045E0  78011E     MOV [W14], W2
0045E2  980140     MOV W0, [W2+8]
0045E4  980151     MOV W1, [W2+10]
509:                   }
510:                   
511:               }
0045E6  FA8000     ULNK
0045E8  060000     RETURN
512:               
513:               static void calculateOutputs(RegulatorError *error, RegulatorOutput *output) {
0045EA  FA0004     LNK #0x4
0045EC  780F00     MOV W0, [W14]
0045EE  980711     MOV W1, [W14+2]
514:               
515:                   if(reg_mode == REG_REMOTE_CONTROL) {
0045F0  80DB21     MOV reg_mode, W1
0045F2  200020     MOV #0x2, W0
0045F4  508F80     SUB W1, W0, [W15]
0045F6  3A000F     BRA NZ, 0x4616
516:               
517:                       output->steer = rc_outputs.steer;
0045F8  80DB50     MOV 0x1B6A, W0
0045FA  80DB61     MOV 0x1B6C, W1
0045FC  90011E     MOV [W14+2], W2
0045FE  980120     MOV W0, [W2+4]
004600  980131     MOV W1, [W2+6]
518:                       output->thrust = rc_outputs.thrust;
004602  80DB30     MOV rc_outputs, W0
004604  80DB41     MOV 0x1B68, W1
004606  90011E     MOV [W14+2], W2
004608  BE8900     MOV.D W0, [W2]
519:                       output->elevator = rc_outputs.elevator;
00460A  80DB70     MOV 0x1B6E, W0
00460C  80DB81     MOV 0x1B70, W1
00460E  90011E     MOV [W14+2], W2
004610  980140     MOV W0, [W2+8]
004612  980151     MOV W1, [W2+10]
004614  370023     BRA 0x465C
520:               
521:                   } else if(reg_mode == REG_TRACK){
004616  80DB21     MOV reg_mode, W1
004618  200010     MOV #0x1, W0
00461A  508F80     SUB W1, W0, [W15]
00461C  3A0014     BRA NZ, 0x4646
522:               
523:                       output->steer = runYawControl(error->yaw_err);
00461E  78001E     MOV [W14], W0
004620  BE0010     MOV.D [W0], W0
004622  07FF0B     RCALL runYawControl
004624  90011E     MOV [W14+2], W2
004626  980120     MOV W0, [W2+4]
004628  980131     MOV W1, [W2+6]
524:                       output->elevator = runPitchControl(error->pitch_err);        
00462A  78001E     MOV [W14], W0
00462C  9000B0     MOV [W0+6], W1
00462E  900020     MOV [W0+4], W0
004630  07FF18     RCALL runPitchControl
004632  90011E     MOV [W14+2], W2
004634  980140     MOV W0, [W2+8]
004636  980151     MOV W1, [W2+10]
525:                       output->thrust = runRollControl(error->pitch_err);
004638  78001E     MOV [W14], W0
00463A  9000B0     MOV [W0+6], W1
00463C  900020     MOV [W0+4], W0
00463E  07FF25     RCALL runRollControl
004640  90011E     MOV [W14+2], W2
004642  BE8900     MOV.D W0, [W2]
004644  37000B     BRA 0x465C
526:               
527:                   } else {
528:               
529:                       output->steer = 0.0;
004646  90011E     MOV [W14+2], W2
004648  B80060     MUL.UU W0, #0, W0
00464A  980120     MOV W0, [W2+4]
00464C  980131     MOV W1, [W2+6]
530:                       output->thrust = 0.0;
00464E  90011E     MOV [W14+2], W2
004650  B80060     MUL.UU W0, #0, W0
004652  BE8900     MOV.D W0, [W2]
531:                       output->elevator = 0.0;
004654  90011E     MOV [W14+2], W2
004656  B80060     MUL.UU W0, #0, W0
004658  980140     MOV W0, [W2+8]
00465A  980151     MOV W1, [W2+10]
532:               
533:                   }
534:               
535:               }
00465C  FA8000     ULNK
00465E  060000     RETURN
536:               
537:               static void applyOutputs(RegulatorOutput *output) {
004660  FA0002     LNK #0x2
004662  780F00     MOV W0, [W14]
538:               
539:                   mcSteer(output->steer);
004664  78001E     MOV [W14], W0
004666  9000B0     MOV [W0+6], W1
004668  900020     MOV [W0+4], W0
00466A  02C7FA     CALL mcSteer
00466C  000000     NOP
540:                   mcThrust(output->thrust);
00466E  78001E     MOV [W14], W0
004670  BE0010     MOV.D [W0], W0
004672  02C7EC     CALL mcThrust
004674  000000     NOP
541:                   servoSet(output->elevator);
004676  78001E     MOV [W14], W0
004678  9000D0     MOV [W0+10], W1
00467A  900040     MOV [W0+8], W0
00467C  02D966     CALL servoSet
00467E  000000     NOP
542:               
543:               }
004680  FA8000     ULNK
004682  060000     RETURN
544:               
545:               //Poor implementation of a median filter for a 3-array of values
546:               
547:               int medianFilter3(int* a) {
004684  FA000A     LNK #0xA
004686  980740     MOV W0, [W14+8]
548:                   int b[3] = {a[0], a[1], a[2]};
004688  90004E     MOV [W14+8], W0
00468A  780190     MOV [W0], W3
00468C  90004E     MOV [W14+8], W0
00468E  E88000     INC2 W0, W0
004690  780110     MOV [W0], W2
004692  90004E     MOV [W14+8], W0
004694  400064     ADD W0, #0x4, W0
004696  780090     MOV [W0], W1
004698  E8800E     INC2 W14, W0
00469A  780803     MOV W3, [W0]
00469C  E8800E     INC2 W14, W0
00469E  980012     MOV W2, [W0+2]
0046A0  E8800E     INC2 W14, W0
0046A2  980021     MOV W1, [W0+4]
549:                   int temp;
550:               
551:                   //Implemented through 3 compare-exchange operations, increasing index
552:                   if (b[0] > b[1]) {
0046A4  E8800E     INC2 W14, W0
0046A6  780090     MOV [W0], W1
0046A8  E8800E     INC2 W14, W0
0046AA  900010     MOV [W0+2], W0
0046AC  508F80     SUB W1, W0, [W15]
0046AE  340009     BRA LE, 0x46C2
553:                       temp = b[1];
0046B0  E8800E     INC2 W14, W0
0046B2  900090     MOV [W0+2], W1
0046B4  780F01     MOV W1, [W14]
554:                       b[1] = b[0];
0046B6  E8800E     INC2 W14, W0
0046B8  780090     MOV [W0], W1
0046BA  E8800E     INC2 W14, W0
0046BC  980011     MOV W1, [W0+2]
555:                       b[0] = temp;
0046BE  E8800E     INC2 W14, W0
0046C0  78081E     MOV [W14], [W0]
556:                   }
557:                   if (a[0] > a[2]) {
0046C2  90004E     MOV [W14+8], W0
0046C4  780090     MOV [W0], W1
0046C6  90004E     MOV [W14+8], W0
0046C8  400064     ADD W0, #0x4, W0
0046CA  780010     MOV [W0], W0
0046CC  508F80     SUB W1, W0, [W15]
0046CE  340009     BRA LE, 0x46E2
558:                       temp = b[2];
0046D0  E8800E     INC2 W14, W0
0046D2  9000A0     MOV [W0+4], W1
0046D4  780F01     MOV W1, [W14]
559:                       b[2] = b[0];
0046D6  E8800E     INC2 W14, W0
0046D8  780090     MOV [W0], W1
0046DA  E8800E     INC2 W14, W0
0046DC  980021     MOV W1, [W0+4]
560:                       b[0] = temp;
0046DE  E8800E     INC2 W14, W0
0046E0  78081E     MOV [W14], [W0]
561:                   }
562:                   if (a[1] > a[2]) {
0046E2  90004E     MOV [W14+8], W0
0046E4  E88000     INC2 W0, W0
0046E6  780090     MOV [W0], W1
0046E8  90004E     MOV [W14+8], W0
0046EA  400064     ADD W0, #0x4, W0
0046EC  780010     MOV [W0], W0
0046EE  508F80     SUB W1, W0, [W15]
0046F0  34000A     BRA LE, 0x4706
563:                       temp = b[2];
0046F2  E8800E     INC2 W14, W0
0046F4  9000A0     MOV [W0+4], W1
0046F6  780F01     MOV W1, [W14]
564:                       b[2] = b[1];
0046F8  E8800E     INC2 W14, W0
0046FA  900090     MOV [W0+2], W1
0046FC  E8800E     INC2 W14, W0
0046FE  980021     MOV W1, [W0+4]
565:                       b[1] = temp;
004700  E8800E     INC2 W14, W0
004702  78009E     MOV [W14], W1
004704  980011     MOV W1, [W0+2]
566:                   }
567:               
568:                   return b[1];
004706  E8800E     INC2 W14, W0
004708  900010     MOV [W0+2], W0
569:               }
00470A  FA8000     ULNK
00470C  060000     RETURN
570:               
571:               int updateBEMF() {
00470E  FA0004     LNK #0x4
004710  781F88     MOV W8, [W15++]
572:                   int updated_bemf = 0;
004712  EB0000     CLR W0
004714  980710     MOV W0, [W14+2]
573:                   //Back EMF measurements are made automatically by coordination of the ADC, PWM, and DMA.
574:                   //Copy to local variables. Not strictly neccesary, just for clarity.
575:                   //This **REQUIRES** that the divider on the battery & BEMF circuits have the same ratio.
576:                   bemf[0] = adcGetVBatt() - adcGetBEMFL();
004716  02DDB6     CALL adcGetVBatt
004718  000000     NOP
00471A  780400     MOV W0, W8
00471C  02DDA6     CALL adcGetBEMFL
00471E  000000     NOP
004720  540000     SUB W8, W0, W0
004722  88E200     MOV W0, bemf
577:                   //bemf[0] = ADC1BUF0;
578:                   bemf[1] = adcGetVBatt() - adcGetBEMFR();
004724  02DDB6     CALL adcGetVBatt
004726  000000     NOP
004728  780400     MOV W0, W8
00472A  02DDAE     CALL adcGetBEMFR
00472C  000000     NOP
00472E  540000     SUB W8, W0, W0
004730  88E210     MOV W0, 0x1C42
579:                   //NOTE: at this point, we should have a proper correspondance between
580:                   //   the order of all the structured variable; bemf[i] associated with
581:                   //   pidObjs[i], bemfLast[i], etc.
582:                   //   Any "jumbling" of the inputs can be done in the above assignments.
583:               
584:                   //Negative ADC measures mean nothing and should never happen anyway
585:                   if (bemf[0] < 0) {
004732  80E201     MOV bemf, W1
004734  EB0000     CLR W0
004736  508F80     SUB W1, W0, [W15]
004738  3D0002     BRA GE, 0x473E
586:                       bemf[0] = 0;
00473A  EB0000     CLR W0
00473C  88E200     MOV W0, bemf
587:                   }
588:                   if (bemf[1] < 0) {
00473E  80E211     MOV 0x1C42, W1
004740  EB0000     CLR W0
004742  508F80     SUB W1, W0, [W15]
004744  3D0002     BRA GE, 0x474A
589:                       bemf[1] = 0;
004746  EB0000     CLR W0
004748  88E210     MOV W0, 0x1C42
590:                   }
591:               
592:               //    int i;
593:               //    for (i = 0; i < 1; i++) {
594:               //        if (bemfHist[i][0] != bemf[i]) {
595:               //            bemfHist[i][2] = bemfHist[i][1]; //rotate first
596:               //            bemfHist[i][1] = bemfHist[i][0];
597:               //            bemfHist[i][0] = bemf[i]; //include newest value
598:               //            updated_bemf = 1;
599:               //            prev_time = curr_time;
600:               //            curr_time = sclockGetLocalMillis();
601:               //        }
602:               //    }
603:                   
604:                   //Apply median filter
605:                   int i;
606:                   for (i = 0; i < 1; i++) {
00474A  EB0000     CLR W0
00474C  780F00     MOV W0, [W14]
00474E  370031     BRA 0x47B2
0047B0  E80F1E     INC [W14], [W14]
0047B2  78009E     MOV [W14], W1
0047B4  EB0000     CLR W0
0047B6  508F80     SUB W1, W0, [W15]
0047B8  34FFCB     BRA LE, 0x4750
607:                       bemfHist[i][2] = bemfHist[i][1]; //rotate first
004750  78001E     MOV [W14], W0
004752  B90066     MUL.SU W0, #6, W0
004754  780000     MOV W0, W0
004756  E88080     INC2 W0, W1
004758  21C480     MOV #0x1C48, W0
00475A  408000     ADD W1, W0, W0
00475C  780110     MOV [W0], W2
00475E  78001E     MOV [W14], W0
004760  B90066     MUL.SU W0, #6, W0
004762  780080     MOV W0, W1
004764  21C4C0     MOV #0x1C4C, W0
004766  408000     ADD W1, W0, W0
004768  780802     MOV W2, [W0]
608:                       bemfHist[i][1] = bemfHist[i][0];
00476A  78001E     MOV [W14], W0
00476C  B90066     MUL.SU W0, #6, W0
00476E  780080     MOV W0, W1
004770  21C480     MOV #0x1C48, W0
004772  408000     ADD W1, W0, W0
004774  780110     MOV [W0], W2
004776  78001E     MOV [W14], W0
004778  B90066     MUL.SU W0, #6, W0
00477A  780080     MOV W0, W1
00477C  21C4A0     MOV #0x1C4A, W0
00477E  408000     ADD W1, W0, W0
004780  780802     MOV W2, [W0]
609:                       bemfHist[i][0] = bemf[i]; //include newest value
004782  78001E     MOV [W14], W0
004784  400080     ADD W0, W0, W1
004786  21C400     MOV #0x1C40, W0
004788  408000     ADD W1, W0, W0
00478A  780110     MOV [W0], W2
00478C  78001E     MOV [W14], W0
00478E  B90066     MUL.SU W0, #6, W0
004790  780080     MOV W0, W1
004792  21C480     MOV #0x1C48, W0
004794  408000     ADD W1, W0, W0
004796  780802     MOV W2, [W0]
610:                       bemf[i] = medianFilter3(bemfHist[i]); //Apply median filter
004798  21C482     MOV #0x1C48, W2
00479A  78001E     MOV [W14], W0
00479C  B90066     MUL.SU W0, #6, W0
00479E  780000     MOV W0, W0
0047A0  410000     ADD W2, W0, W0
0047A2  07FF70     RCALL medianFilter3
0047A4  780080     MOV W0, W1
0047A6  78001E     MOV [W14], W0
0047A8  400100     ADD W0, W0, W2
0047AA  21C400     MOV #0x1C40, W0
0047AC  410000     ADD W2, W0, W0
0047AE  780801     MOV W1, [W0]
611:                   }
612:               
613:                   // IIR filter on BEMF: y[n] = 0.2 * y[n-1] + 0.8 * x[n]
614:                   bemf[0] = (2 * (long) bemfLast[0] / 10) + 8 * (long) bemf[0] / 10;
0047BA  80E220     MOV bemfLast, W0
0047BC  DE80CF     ASR W0, #15, W1
0047BE  400000     ADD W0, W0, W0
0047C0  488081     ADDC W1, W1, W1
0047C2  2000A2     MOV #0xA, W2
0047C4  200003     MOV #0x0, W3
0047C6  022586     CALL ___divsi3
0047C8  000000     NOP
0047CA  780400     MOV W0, W8
0047CC  80E200     MOV bemf, W0
0047CE  B90161     MUL.SU W0, #1, W2
0047D0  DD1843     SL W3, #3, W0
0047D2  DE10CD     LSR W2, #13, W1
0047D4  700081     IOR W0, W1, W1
0047D6  DD1043     SL W2, #3, W0
0047D8  2000A2     MOV #0xA, W2
0047DA  200003     MOV #0x0, W3
0047DC  022586     CALL ___divsi3
0047DE  000000     NOP
0047E0  780000     MOV W0, W0
0047E2  440000     ADD W8, W0, W0
0047E4  88E200     MOV W0, bemf
615:                   bemfLast[0] = bemf[0]; //bemfLast will not be used after here, OK to set
0047E6  80E200     MOV bemf, W0
0047E8  88E220     MOV W0, bemfLast
616:               
617:                   return updated_bemf;
0047EA  90001E     MOV [W14+2], W0
618:               //
619:               //    // IIR filter on BEMF: y[n] = 0.2 * y[n-1] + 0.8 * x[n]
620:               //    bemf[0] = (5 * (long) bemfLast[0] / 10) + 5 * (long) bemf[0] / 10;
621:               //    bemf[1] = (5 * (long) bemfLast[1] / 10) + 5 * (long) bemf[1] / 10;
622:               //    bemfLast[0] = bemf[0]; //bemfLast will not be used after here, OK to set
623:               //    bemfLast[1] = bemf[1];
624:               }
0047EC  78044F     MOV [--W15], W8
0047EE  FA8000     ULNK
0047F0  060000     RETURN
625:               
626:               void rgltrStopWings(unsigned char flag) {
0047F2  FA0002     LNK #0x2
0047F4  784F00     MOV.B W0, [W14]
627:                   if (flag == 0) {
0047F6  78409E     MOV.B [W14], W1
0047F8  EB4000     CLR.B W0
0047FA  50CF80     SUB.B W1, W0, [W15]
0047FC  3A0007     BRA NZ, 0x480C
628:                       wing_status.enabled = 0;
0047FE  21C6D1     MOV #0x1C6D, W1
004800  EB4000     CLR.B W0
004802  784880     MOV.B W0, [W1]
629:                       wing_status.stopped = 0;
004804  21C6C1     MOV #0x1C6C, W1
004806  EB4000     CLR.B W0
004808  784880     MOV.B W0, [W1]
00480A  37000F     BRA 0x482A
630:                   } else if (flag == 1) {
00480C  78409E     MOV.B [W14], W1
00480E  B3C010     MOV #0x1, W0
004810  50CF80     SUB.B W1, W0, [W15]
004812  3A0006     BRA NZ, 0x4820
631:                       wing_status.stopPos = 40 % 360;
004814  200280     MOV #0x28, W0
004816  88E370     MOV W0, 0x1C6E
632:                       wing_status.enabled = 1;
004818  21C6D1     MOV #0x1C6D, W1
00481A  B3C010     MOV #0x1, W0
00481C  784880     MOV.B W0, [W1]
00481E  370005     BRA 0x482A
633:                   } else {
634:                       wing_status.stopPos = 40 % 180;
004820  200280     MOV #0x28, W0
004822  88E370     MOV W0, 0x1C6E
635:                       wing_status.enabled = 1;
004824  21C6D1     MOV #0x1C6D, W1
004826  B3C010     MOV #0x1, W0
004828  784880     MOV.B W0, [W1]
636:                   }
637:               }
00482A  FA8000     ULNK
00482C  060000     RETURN
638:               
639:               void calibCrank() {
00482E  FA000A     LNK #0xA
640:                   LED_RED = 0;
004830  A982CB     BCLR 0x2CB, #4
641:                   int max_bemf_peak1 = 0;
004832  EB0000     CLR W0
004834  780F00     MOV W0, [W14]
642:                   int max_bemf_peak2 = 0;
004836  EB0000     CLR W0
004838  980710     MOV W0, [W14+2]
643:                   int min_bemf_peak1 = 0;
00483A  EB0000     CLR W0
00483C  980720     MOV W0, [W14+4]
644:                   int min_bemf_peak2 = 0;
00483E  EB0000     CLR W0
004840  980730     MOV W0, [W14+6]
645:                   int holder;
646:                   
647:                   while (max_bemf_peak1 == 0 || max_bemf_peak2 == 0) {
004842  37001A     BRA 0x4878
004878  78009E     MOV [W14], W1
00487A  EB0000     CLR W0
00487C  508F80     SUB W1, W0, [W15]
00487E  32FFE2     BRA Z, 0x4844
004880  90009E     MOV [W14+2], W1
004882  EB0000     CLR W0
004884  508F80     SUB W1, W0, [W15]
004886  32FFDE     BRA Z, 0x4844
648:                       if (bemfHist[0][0] < bemfHist[0][1] && bemfHist[0][1] > bemfHist[0][2]) {
004844  80E241     MOV bemfHist, W1
004846  80E250     MOV 0x1C4A, W0
004848  508F80     SUB W1, W0, [W15]
00484A  3D0015     BRA GE, 0x4876
00484C  80E251     MOV 0x1C4A, W1
00484E  80E260     MOV 0x1C4C, W0
004850  508F80     SUB W1, W0, [W15]
004852  340011     BRA LE, 0x4876
649:                           if (max_bemf_peak1 == 0) {
004854  78009E     MOV [W14], W1
004856  EB0000     CLR W0
004858  508F80     SUB W1, W0, [W15]
00485A  3A0003     BRA NZ, 0x4862
650:                               max_bemf_peak1 = bemfHist[0][1];
00485C  80E250     MOV 0x1C4A, W0
00485E  780F00     MOV W0, [W14]
004860  37000A     BRA 0x4876
651:                           } else if (bemfHist[0][1] != max_bemf_peak1 && max_bemf_peak2 == 0) {
004862  80E251     MOV 0x1C4A, W1
004864  78001E     MOV [W14], W0
004866  508F80     SUB W1, W0, [W15]
004868  320006     BRA Z, 0x4876
00486A  90009E     MOV [W14+2], W1
00486C  EB0000     CLR W0
00486E  508F80     SUB W1, W0, [W15]
004870  3A0002     BRA NZ, 0x4876
652:                               max_bemf_peak2 = bemfHist[0][1];
004872  80E251     MOV 0x1C4A, W1
004874  980711     MOV W1, [W14+2]
653:                           }
654:                       }
655:                       updateBEMF();
004876  07FF4B     RCALL updateBEMF
656:                   }
657:               
658:                   if (max_bemf_peak2 > max_bemf_peak1) {
004888  90009E     MOV [W14+2], W1
00488A  78001E     MOV [W14], W0
00488C  508F80     SUB W1, W0, [W15]
00488E  340004     BRA LE, 0x4898
659:                       crankAngle = 0;
004890  B80060     MUL.UU W0, #0, W0
004892  88E2A0     MOV W0, crankAngle
004894  88E2B1     MOV W1, 0x1C56
660:                   } else {
661:                       crankAngle = 180;
004898  200000     MOV #0x0, W0
00489A  243341     MOV #0x4334, W1
00489C  88E2A0     MOV W0, crankAngle
00489E  88E2B1     MOV W1, 0x1C56
662:                   }
663:               
664:                   while (min_bemf_peak1 == 0 || min_bemf_peak2 == 0) {
004896  37001F     BRA 0x48D6
0048A0  37001A     BRA 0x48D6
0048D6  9000AE     MOV [W14+4], W1
0048D8  EB0000     CLR W0
0048DA  508F80     SUB W1, W0, [W15]
0048DC  32FFE2     BRA Z, 0x48A2
0048DE  9000BE     MOV [W14+6], W1
0048E0  EB0000     CLR W0
0048E2  508F80     SUB W1, W0, [W15]
0048E4  32FFDE     BRA Z, 0x48A2
665:                       if (bemfHist[0][0] > bemfHist[0][1] && bemfHist[0][1] < bemfHist[0][2]) {
0048A2  80E241     MOV bemfHist, W1
0048A4  80E250     MOV 0x1C4A, W0
0048A6  508F80     SUB W1, W0, [W15]
0048A8  340015     BRA LE, 0x48D4
0048AA  80E251     MOV 0x1C4A, W1
0048AC  80E260     MOV 0x1C4C, W0
0048AE  508F80     SUB W1, W0, [W15]
0048B0  3D0011     BRA GE, 0x48D4
666:                           if (min_bemf_peak1 == 0) {
0048B2  9000AE     MOV [W14+4], W1
0048B4  EB0000     CLR W0
0048B6  508F80     SUB W1, W0, [W15]
0048B8  3A0003     BRA NZ, 0x48C0
667:                               min_bemf_peak1 = bemfHist[0][1];
0048BA  80E250     MOV 0x1C4A, W0
0048BC  980720     MOV W0, [W14+4]
0048BE  37000A     BRA 0x48D4
668:                           } else if (bemfHist[0][1] != min_bemf_peak1 && min_bemf_peak2 == 0) {
0048C0  80E251     MOV 0x1C4A, W1
0048C2  90002E     MOV [W14+4], W0
0048C4  508F80     SUB W1, W0, [W15]
0048C6  320006     BRA Z, 0x48D4
0048C8  9000BE     MOV [W14+6], W1
0048CA  EB0000     CLR W0
0048CC  508F80     SUB W1, W0, [W15]
0048CE  3A0002     BRA NZ, 0x48D4
669:                               min_bemf_peak2 = bemfHist[0][1];
0048D0  80E251     MOV 0x1C4A, W1
0048D2  980731     MOV W1, [W14+6]
670:                           }
671:                       }
672:                       updateBEMF();
0048D4  07FF1C     RCALL updateBEMF
673:                   }
674:               
675:                   if (crankAngle == 0) {
0048E6  80E2A0     MOV crankAngle, W0
0048E8  80E2B1     MOV 0x1C56, W1
0048EA  B81160     MUL.UU W2, #0, W2
0048EC  0225A4     CALL ___lesf2
0048EE  000000     NOP
0048F0  EB0080     CLR W1
0048F2  500F81     SUB W0, W1, [W15]
0048F4  3A0007     BRA NZ, 0x4904
676:                       holder = max_bemf_peak2;
0048F6  90001E     MOV [W14+2], W0
0048F8  980740     MOV W0, [W14+8]
677:                       max_bemf_peak2 = max_bemf_peak1;
0048FA  78009E     MOV [W14], W1
0048FC  980711     MOV W1, [W14+2]
678:                       max_bemf_peak1 = holder;
0048FE  90004E     MOV [W14+8], W0
004900  780F00     MOV W0, [W14]
004902  370006     BRA 0x4910
679:                   } else {
680:                       holder = min_bemf_peak2;
004904  9000BE     MOV [W14+6], W1
004906  980741     MOV W1, [W14+8]
681:                       min_bemf_peak2 = min_bemf_peak1;
004908  90002E     MOV [W14+4], W0
00490A  980730     MOV W0, [W14+6]
682:                       min_bemf_peak1 = holder;
00490C  9000CE     MOV [W14+8], W1
00490E  980721     MOV W1, [W14+4]
683:                   }
684:               
685:                   zone = 0;
004910  EB0000     CLR W0
004912  88E2C0     MOV W0, zone
686:                   if (crankAngle == 0) {
004914  80E2A0     MOV crankAngle, W0
004916  80E2B1     MOV 0x1C56, W1
004918  B81160     MUL.UU W2, #0, W2
00491A  0225A4     CALL ___lesf2
00491C  000000     NOP
00491E  EB0080     CLR W1
004920  500F81     SUB W0, W1, [W15]
004922  3A0007     BRA NZ, 0x4932
687:                       zone = 4;
004924  200040     MOV #0x4, W0
004926  88E2C0     MOV W0, zone
688:                       crankAngle = 270;
004928  200000     MOV #0x0, W0
00492A  243871     MOV #0x4387, W1
00492C  88E2A0     MOV W0, crankAngle
00492E  88E2B1     MOV W1, 0x1C56
004930  370006     BRA 0x493E
689:                   } else {
690:                       zone = 2;
004932  200020     MOV #0x2, W0
004934  88E2C0     MOV W0, zone
691:                       crankAngle = 90;
004936  200000     MOV #0x0, W0
004938  242B41     MOV #0x42B4, W1
00493A  88E2A0     MOV W0, crankAngle
00493C  88E2B1     MOV W1, 0x1C56
692:                   }
693:                   bemfVals[0] = max_bemf_peak1;
00493E  21C5A0     MOV #0x1C5A, W0
004940  78081E     MOV [W14], [W0]
694:                   bemfVals[1] = min_bemf_peak1;
004942  21C5A0     MOV #0x1C5A, W0
004944  9000AE     MOV [W14+4], W1
004946  980011     MOV W1, [W0+2]
695:                   bemfVals[2] = max_bemf_peak2;
004948  21C5A0     MOV #0x1C5A, W0
00494A  90009E     MOV [W14+2], W1
00494C  980021     MOV W1, [W0+4]
696:                   bemfVals[3] = min_bemf_peak2;
00494E  21C5A0     MOV #0x1C5A, W0
004950  9000BE     MOV [W14+6], W1
004952  980031     MOV W1, [W0+6]
697:               
698:                   crankCalibrated = 1;
004954  200010     MOV #0x1, W0
004956  88E310     MOV W0, crankCalibrated
699:               }
004958  FA8000     ULNK
00495A  060000     RETURN
700:               
701:               static void updateCrank() {
00495C  FA0010     LNK #0x10
702:                   int inter = 0;
00495E  EB0000     CLR W0
004960  980710     MOV W0, [W14+2]
703:                   unsigned long hold_time;
704:                   double time_diff;
705:                   float c = 26.0396;
004962  2511A0     MOV #0x511A, W0
004964  241D01     MOV #0x41D0, W1
004966  980720     MOV W0, [W14+4]
004968  980731     MOV W1, [W14+6]
706:               
707:                   unsigned char do_integ = 1;
00496A  B3C010     MOV #0x1, W0
00496C  784F00     MOV.B W0, [W14]
708:               
709:                   if (bemfHist[0][0] > bemfHist[0][1] && bemfHist[0][1] < bemfHist[0][2]) {
00496E  80E241     MOV bemfHist, W1
004970  80E250     MOV 0x1C4A, W0
004972  508F80     SUB W1, W0, [W15]
004974  34001A     BRA LE, 0x49AA
004976  80E251     MOV 0x1C4A, W1
004978  80E260     MOV 0x1C4C, W0
00497A  508F80     SUB W1, W0, [W15]
00497C  3D0016     BRA GE, 0x49AA
710:                       if (zone == 1) {
00497E  80E2C1     MOV zone, W1
004980  200010     MOV #0x1, W0
004982  508F80     SUB W1, W0, [W15]
004984  3A0009     BRA NZ, 0x4998
004996  370025     BRA 0x49E2
0049A8  37001C     BRA 0x49E2
711:                           zone = 2;
004986  200020     MOV #0x2, W0
004988  88E2C0     MOV W0, zone
712:                           crankAngle = 90;
00498A  200000     MOV #0x0, W0
00498C  242B41     MOV #0x42B4, W1
00498E  88E2A0     MOV W0, crankAngle
004990  88E2B1     MOV W1, 0x1C56
713:                           do_integ = 0;
004992  EB4000     CLR.B W0
004994  784F00     MOV.B W0, [W14]
714:                       } else {
715:                           zone = 4;
004998  200040     MOV #0x4, W0
00499A  88E2C0     MOV W0, zone
716:                           crankAngle = 270;
00499C  200000     MOV #0x0, W0
00499E  243871     MOV #0x4387, W1
0049A0  88E2A0     MOV W0, crankAngle
0049A2  88E2B1     MOV W1, 0x1C56
717:                           do_integ = 0;
0049A4  EB4000     CLR.B W0
0049A6  784F00     MOV.B W0, [W14]
718:                       }
719:                   } else if (bemfHist[0][0] < bemfHist[0][1] && bemfHist[0][1] > bemfHist[0][2]) {
0049AA  80E241     MOV bemfHist, W1
0049AC  80E250     MOV 0x1C4A, W0
0049AE  508F80     SUB W1, W0, [W15]
0049B0  3D0018     BRA GE, 0x49E2
0049B2  80E251     MOV 0x1C4A, W1
0049B4  80E260     MOV 0x1C4C, W0
0049B6  508F80     SUB W1, W0, [W15]
0049B8  340014     BRA LE, 0x49E2
720:                       if (zone == 4) {
0049BA  80E2C1     MOV zone, W1
0049BC  200040     MOV #0x4, W0
0049BE  508F80     SUB W1, W0, [W15]
0049C0  3A0008     BRA NZ, 0x49D2
721:                           zone = 1;
0049C2  200010     MOV #0x1, W0
0049C4  88E2C0     MOV W0, zone
722:                           crankAngle = 0;
0049C6  B80060     MUL.UU W0, #0, W0
0049C8  88E2A0     MOV W0, crankAngle
0049CA  88E2B1     MOV W1, 0x1C56
723:                           do_integ = 0;
0049CC  EB4000     CLR.B W0
0049CE  784F00     MOV.B W0, [W14]
0049D0  370008     BRA 0x49E2
724:                       } else {
725:                           zone = 3;
0049D2  200030     MOV #0x3, W0
0049D4  88E2C0     MOV W0, zone
726:                           crankAngle = 180;
0049D6  200000     MOV #0x0, W0
0049D8  243341     MOV #0x4334, W1
0049DA  88E2A0     MOV W0, crankAngle
0049DC  88E2B1     MOV W1, 0x1C56
727:                           do_integ = 0;
0049DE  EB4000     CLR.B W0
0049E0  784F00     MOV.B W0, [W14]
728:                       }
729:                   }
730:                   if (zone == 1) {
0049E2  80E2C1     MOV zone, W1
0049E4  200010     MOV #0x1, W0
0049E6  508F80     SUB W1, W0, [W15]
0049E8  3A0018     BRA NZ, 0x4A1A
731:                       inter = (bemf[0] - bemfVals[zone])/(bemfVals[zone-1] - bemfVals[zone]);
0049EA  80E201     MOV bemf, W1
0049EC  80E2C0     MOV zone, W0
0049EE  21C5A2     MOV #0x1C5A, W2
0049F0  400000     ADD W0, W0, W0
0049F2  410000     ADD W2, W0, W0
0049F4  780010     MOV [W0], W0
0049F6  508080     SUB W1, W0, W1
0049F8  80E2C0     MOV zone, W0
0049FA  E90000     DEC W0, W0
0049FC  21C5A2     MOV #0x1C5A, W2
0049FE  400000     ADD W0, W0, W0
004A00  410000     ADD W2, W0, W0
004A02  780110     MOV [W0], W2
004A04  80E2C0     MOV zone, W0
004A06  21C5A3     MOV #0x1C5A, W3
004A08  400000     ADD W0, W0, W0
004A0A  418000     ADD W3, W0, W0
004A0C  780010     MOV [W0], W0
004A0E  510000     SUB W2, W0, W0
004A10  780100     MOV W0, W2
004A12  090011     REPEAT #0x11
004A14  D80082     DIV.SW W1, W2
004A16  980710     MOV W0, [W14+2]
004A18  370049     BRA 0x4AAC
732:                   } else if (zone == 2) {
004A1A  80E2C1     MOV zone, W1
004A1C  200020     MOV #0x2, W0
004A1E  508F80     SUB W1, W0, [W15]
004A20  3A0018     BRA NZ, 0x4A52
733:                       inter = (bemf[0] - bemfVals[zone])/(bemfVals[zone-1] - bemfVals[zone]);
004A22  80E201     MOV bemf, W1
004A24  80E2C0     MOV zone, W0
004A26  21C5A2     MOV #0x1C5A, W2
004A28  400000     ADD W0, W0, W0
004A2A  410000     ADD W2, W0, W0
004A2C  780010     MOV [W0], W0
004A2E  508080     SUB W1, W0, W1
004A30  80E2C0     MOV zone, W0
004A32  E90000     DEC W0, W0
004A34  21C5A2     MOV #0x1C5A, W2
004A36  400000     ADD W0, W0, W0
004A38  410000     ADD W2, W0, W0
004A3A  780110     MOV [W0], W2
004A3C  80E2C0     MOV zone, W0
004A3E  21C5A3     MOV #0x1C5A, W3
004A40  400000     ADD W0, W0, W0
004A42  418000     ADD W3, W0, W0
004A44  780010     MOV [W0], W0
004A46  510000     SUB W2, W0, W0
004A48  780100     MOV W0, W2
004A4A  090011     REPEAT #0x11
004A4C  D80082     DIV.SW W1, W2
004A4E  980710     MOV W0, [W14+2]
004A50  37002D     BRA 0x4AAC
734:                   } else if (zone == 3) {
004A52  80E2C1     MOV zone, W1
004A54  200030     MOV #0x3, W0
004A56  508F80     SUB W1, W0, [W15]
004A58  3A0018     BRA NZ, 0x4A8A
735:                       inter = (bemf[0] - bemfVals[zone])/(bemfVals[zone-1] - bemfVals[zone]);
004A5A  80E201     MOV bemf, W1
004A5C  80E2C0     MOV zone, W0
004A5E  21C5A2     MOV #0x1C5A, W2
004A60  400000     ADD W0, W0, W0
004A62  410000     ADD W2, W0, W0
004A64  780010     MOV [W0], W0
004A66  508080     SUB W1, W0, W1
004A68  80E2C0     MOV zone, W0
004A6A  E90000     DEC W0, W0
004A6C  21C5A2     MOV #0x1C5A, W2
004A6E  400000     ADD W0, W0, W0
004A70  410000     ADD W2, W0, W0
004A72  780110     MOV [W0], W2
004A74  80E2C0     MOV zone, W0
004A76  21C5A3     MOV #0x1C5A, W3
004A78  400000     ADD W0, W0, W0
004A7A  418000     ADD W3, W0, W0
004A7C  780010     MOV [W0], W0
004A7E  510000     SUB W2, W0, W0
004A80  780100     MOV W0, W2
004A82  090011     REPEAT #0x11
004A84  D80082     DIV.SW W1, W2
004A86  980710     MOV W0, [W14+2]
004A88  370011     BRA 0x4AAC
736:                   } else {
737:                       inter = (bemf[0] - bemfVals[0])/(bemfVals[zone-1] - bemfVals[0]);
004A8A  80E201     MOV bemf, W1
004A8C  21C5A0     MOV #0x1C5A, W0
004A8E  780010     MOV [W0], W0
004A90  508080     SUB W1, W0, W1
004A92  80E2C0     MOV zone, W0
004A94  E90000     DEC W0, W0
004A96  21C5A2     MOV #0x1C5A, W2
004A98  400000     ADD W0, W0, W0
004A9A  410000     ADD W2, W0, W0
004A9C  780110     MOV [W0], W2
004A9E  21C5A0     MOV #0x1C5A, W0
004AA0  780010     MOV [W0], W0
004AA2  510000     SUB W2, W0, W0
004AA4  780100     MOV W0, W2
004AA6  090011     REPEAT #0x11
004AA8  D80082     DIV.SW W1, W2
004AAA  980710     MOV W0, [W14+2]
738:                   }
739:               
740:                   //crankAngle = 90 + 90*(zone - 1) - 90*inter;
741:                   if (do_integ) {
004AAC  78409E     MOV.B [W14], W1
004AAE  EB4000     CLR.B W0
004AB0  50CF80     SUB.B W1, W0, [W15]
004AB2  32002B     BRA Z, 0x4B0A
742:                       hold_time = curr_time - prev_time;
004AB4  80E322     MOV curr_time, W2
004AB6  80E333     MOV 0x1C66, W3
004AB8  80E340     MOV prev_time, W0
004ABA  80E351     MOV 0x1C6A, W1
004ABC  510000     SUB W2, W0, W0
004ABE  598081     SUBB W3, W1, W1
004AC0  980740     MOV W0, [W14+8]
004AC2  980751     MOV W1, [W14+10]
743:                       time_diff = ((double)hold_time)/1000.0;
004AC4  90004E     MOV [W14+8], W0
004AC6  9000DE     MOV [W14+10], W1
004AC8  022640     CALL ___floatunsisf
004ACA  000000     NOP
004ACC  200002     MOV #0x0, W2
004ACE  2447A3     MOV #0x447A, W3
004AD0  022E80     CALL ___divsf3x
004AD2  000000     NOP
004AD4  980760     MOV W0, [W14+12]
004AD6  980771     MOV W1, [W14+14]
744:                       crankAngle = (float)(fmod((crankAngle + c*bemfHist[0][0]*(time_diff)), 360.0));
004AD8  80E240     MOV bemfHist, W0
004ADA  DE80CF     ASR W0, #15, W1
004ADC  022624     CALL ___floatsisf
004ADE  000000     NOP
004AE0  90012E     MOV [W14+4], W2
004AE2  9001BE     MOV [W14+6], W3
004AE4  022C36     CALL ___mulsf3
004AE6  000000     NOP
004AE8  90016E     MOV [W14+12], W2
004AEA  9001FE     MOV [W14+14], W3
004AEC  022C36     CALL ___mulsf3
004AEE  000000     NOP
004AF0  BE0200     MOV.D W0, W4
004AF2  80E2A0     MOV crankAngle, W0
004AF4  80E2B1     MOV 0x1C56, W1
004AF6  BE0100     MOV.D W0, W2
004AF8  BE0004     MOV.D W4, W0
004AFA  022A6C     CALL ___addsf3
004AFC  000000     NOP
004AFE  200002     MOV #0x0, W2
004B00  243B43     MOV #0x43B4, W3
004B02  022680     CALL _fmodf
004B04  000000     NOP
004B06  88E2A0     MOV W0, crankAngle
004B08  88E2B1     MOV W1, 0x1C56
745:                   }
746:               }
004B0A  FA8000     ULNK
004B0C  060000     RETURN
747:               
748:               static void logTrace(RegulatorError *error, RegulatorOutput *output) {
004B0E  FA0014     LNK #0x14
004B10  980F00     MOV W0, [W14+16]
004B12  980F11     MOV W1, [W14+18]
749:               
750:                   int xldat[3];
751:                   int gyrodat[3];
752:                   long* motor_counts;
753:                   RegulatorStateStruct *storage;
754:                   
755:                   storage = ppbuffReadInactive(&reg_state_buff);
004B14  21C3A0     MOV #0x1C3A, W0
004B16  02C6C6     CALL ppbuffReadInactive
004B18  000000     NOP
004B1A  780F00     MOV W0, [W14]
756:                   
757:                   if(storage != NULL) {
004B1C  78009E     MOV [W14], W1
004B1E  EB0000     CLR W0
004B20  508F80     SUB W1, W0, [W15]
004B22  320046     BRA Z, 0x4BB0
758:                       quatCopy(&storage->ref, &limited_reference);
004B24  78001E     MOV [W14], W0
004B26  21B821     MOV #0x1B82, W1
004B28  02A488     CALL quatCopy
004B2A  000000     NOP
759:                       quatCopy(&storage->pose, &pose);        
004B2C  78009E     MOV [W14], W1
004B2E  408070     ADD W1, #0x10, W0
004B30  21B921     MOV #0x1B92, W1
004B32  02A488     CALL quatCopy
004B34  000000     NOP
760:                       //storage->error.w = 0.0;
761:                       //storage->error.x = error->roll_err;
762:                       //storage->error.y = error->pitch_err;
763:                       //storage->error.z = error->yaw_err;
764:                       gyroGetIntXYZ(gyrodat);
004B36  47006A     ADD W14, #0xA, W0
004B38  029638     CALL gyroGetIntXYZ
004B3A  000000     NOP
765:                       memcpy(&storage->gyro_data, gyrodat, 3*sizeof(int));
004B3C  200201     MOV #0x20, W1
004B3E  40801E     ADD W1, [W14], W0
004B40  4700EA     ADD W14, #0xA, W1
004B42  200062     MOV #0x6, W2
004B44  023582     CALL _memcpy
004B46  000000     NOP
766:                       xlGetXYZ(xldat);
004B48  470064     ADD W14, #0x4, W0
004B4A  02B4A8     CALL xlGetXYZ
004B4C  000000     NOP
767:                       memcpy(&storage->xl_data, xldat, 3*sizeof(int));
004B4E  200261     MOV #0x26, W1
004B50  40801E     ADD W1, [W14], W0
004B52  4700E4     ADD W14, #0x4, W1
004B54  200062     MOV #0x6, W2
004B56  023582     CALL _memcpy
004B58  000000     NOP
768:                       //storage->u[0] = output->thrust;
769:                       storage->u[0] = hallGetOutput();
004B5A  026A36     CALL hallGetOutput
004B5C  000000     NOP
004B5E  DE80CF     ASR W0, #15, W1
004B60  022624     CALL ___floatsisf
004B62  000000     NOP
004B64  78011E     MOV [W14], W2
004B66  981160     MOV W0, [W2+44]
004B68  981171     MOV W1, [W2+46]
770:                       storage->u[1] = output->steer;
004B6A  90081E     MOV [W14+18], W0
004B6C  9000B0     MOV [W0+6], W1
004B6E  900020     MOV [W0+4], W0
004B70  78011E     MOV [W14], W2
004B72  981900     MOV W0, [W2+48]
004B74  981911     MOV W1, [W2+50]
771:                       storage->u[2] = output->elevator;
004B76  90081E     MOV [W14+18], W0
004B78  9000D0     MOV [W0+10], W1
004B7A  900040     MOV [W0+8], W0
004B7C  78011E     MOV [W14], W2
004B7E  981920     MOV W0, [W2+52]
004B80  981931     MOV W1, [W2+54]
772:                       storage->bemf[0] = bemf[0];
004B82  80E201     MOV bemf, W1
004B84  78001E     MOV [W14], W0
004B86  981841     MOV W1, [W0+56]
773:                       motor_counts = hallGetMotorCounts();
004B88  026B48     CALL hallGetMotorCounts
004B8A  000000     NOP
004B8C  980710     MOV W0, [W14+2]
774:                       storage->bemf[1] = motor_counts[0];
004B8E  90001E     MOV [W14+2], W0
004B90  BE0010     MOV.D [W0], W0
004B92  780080     MOV W0, W1
004B94  78001E     MOV [W14], W0
004B96  981851     MOV W1, [W0+58]
775:                       //storage->bemf[1] = (int) (hallGetError()/1000);
776:                       //storage->crank = crankAngle;
777:                       storage->crank = (float) hallGetError();
004B98  026A3E     CALL hallGetError
004B9A  000000     NOP
004B9C  022624     CALL ___floatsisf
004B9E  000000     NOP
004BA0  78011E     MOV [W14], W2
004BA2  981960     MOV W0, [W2+60]
004BA4  981971     MOV W1, [W2+62]
778:                       storage->time = sclockGetLocalMillis();
004BA6  02DE60     CALL sclockGetLocalMillis
004BA8  000000     NOP
004BAA  78011E     MOV [W14], W2
004BAC  982100     MOV W0, [W2+64]
004BAE  982111     MOV W1, [W2+66]
779:                   }
780:                   ppbuffFlip(&reg_state_buff);
004BB0  21C3A0     MOV #0x1C3A, W0
004BB2  02C51A     CALL ppbuffFlip
004BB4  000000     NOP
781:               
782:               }
004BB6  FA8000     ULNK
004BB8  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/rate.c  ---------------------------------------------------
1:                 /*
2:                 * Copyright (c) 2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Rate-Based Reference Generator
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v.0.1
35:                *
36:                * Revisions: 
37:                *  Humphrey Hu		    2012-07-09       Initial implementation
38:                */
39:                
40:                #include "rate.h"
41:                #include "quat.h"
42:                #include "regulator.h"
43:                #include "bams.h"
44:                #include "attitude.h"
45:                
46:                #include <stdlib.h>
47:                #include <string.h>
48:                #include <math.h>
49:                
50:                // =========== Static Variables ================================================
51:                static unsigned char is_ready = 0, is_running = 0;
52:                static float period;
53:                
54:                static RateStruct global_rate, body_rate;
55:                static Quaternion global_displacement, body_displacement;
56:                
57:                // =========== Function Stubs ==================================================
58:                static void generateDisplacement(Rate rate, Quaternion *q);
59:                
60:                // =========== Public Methods ==================================================
61:                void rateSetup(float ts) {
00C068  FA0004     LNK #0x4
00C06A  BE8F00     MOV.D W0, [W14]
62:                
63:                    period = ts;
00C06C  BE001E     MOV.D [W14], W0
00C06E  890450     MOV W0, _period
00C070  890461     MOV W1, 0x208C
64:                    
65:                    global_rate.yaw_rate = 0.0;
00C072  B80060     MUL.UU W0, #0, W0
00C074  890470     MOV W0, _global_rate
00C076  890481     MOV W1, 0x2090
66:                    global_rate.pitch_rate = 0.0;
00C078  B80060     MUL.UU W0, #0, W0
00C07A  890490     MOV W0, 0x2092
00C07C  8904A1     MOV W1, 0x2094
67:                    global_rate.roll_rate = 0.0;   
00C07E  B80060     MUL.UU W0, #0, W0
00C080  8904B0     MOV W0, 0x2096
00C082  8904C1     MOV W1, 0x2098
68:                    generateDisplacement(&global_rate, &global_displacement);
00C084  220A61     MOV #0x20A6, W1
00C086  2208E0     MOV #0x208E, W0
00C088  07008C     RCALL generateDisplacement
69:                    
70:                    body_rate.yaw_rate = 0.0;
00C08A  B80060     MUL.UU W0, #0, W0
00C08C  8904D0     MOV W0, _body_rate
00C08E  8904E1     MOV W1, 0x209C
71:                    body_rate.pitch_rate = 0.0;
00C090  B80060     MUL.UU W0, #0, W0
00C092  8904F0     MOV W0, 0x209E
00C094  890501     MOV W1, 0x20A0
72:                    body_rate.roll_rate = 0.0;
00C096  B80060     MUL.UU W0, #0, W0
00C098  890510     MOV W0, 0x20A2
00C09A  890521     MOV W1, 0x20A4
73:                    generateDisplacement(&body_rate, &body_displacement);
00C09C  220B61     MOV #0x20B6, W1
00C09E  2209A0     MOV #0x209A, W0
00C0A0  070080     RCALL generateDisplacement
74:                    
75:                    is_running = 0;
00C0A2  220891     MOV #0x2089, W1
00C0A4  EB4000     CLR.B W0
00C0A6  784880     MOV.B W0, [W1]
76:                    is_ready = 1;
00C0A8  220881     MOV #0x2088, W1
00C0AA  B3C010     MOV #0x1, W0
00C0AC  784880     MOV.B W0, [W1]
77:                    
78:                }
00C0AE  FA8000     ULNK
00C0B0  060000     RETURN
79:                
80:                void rateSetGlobalSlew(Rate rate) {
00C0B2  FA0002     LNK #0x2
00C0B4  780F00     MOV W0, [W14]
81:                
82:                    if(rate == NULL) { return; }
00C0B6  78009E     MOV [W14], W1
00C0B8  EB0000     CLR W0
00C0BA  508F80     SUB W1, W0, [W15]
00C0BC  320009     BRA Z, 0xC0D0
00C0D0  000000     NOP
83:                    
84:                    memcpy(&global_rate, rate, sizeof(RateStruct));    
00C0BE  2000C2     MOV #0xC, W2
00C0C0  78009E     MOV [W14], W1
00C0C2  2208E0     MOV #0x208E, W0
00C0C4  023582     CALL _memcpy
00C0C6  000000     NOP
85:                    generateDisplacement(&global_rate, &global_displacement);
00C0C8  220A61     MOV #0x20A6, W1
00C0CA  2208E0     MOV #0x208E, W0
00C0CC  07006A     RCALL generateDisplacement
00C0CE  370001     BRA 0xC0D2
86:                    
87:                }
00C0D2  FA8000     ULNK
00C0D4  060000     RETURN
88:                
89:                void rateSetBodySlew(Rate rate) {
00C0D6  FA0002     LNK #0x2
00C0D8  780F00     MOV W0, [W14]
90:                
91:                    if(rate == NULL) { return; }
00C0DA  78009E     MOV [W14], W1
00C0DC  EB0000     CLR W0
00C0DE  508F80     SUB W1, W0, [W15]
00C0E0  320009     BRA Z, 0xC0F4
00C0F4  000000     NOP
92:                    
93:                    memcpy(&body_rate, rate, sizeof(RateStruct));
00C0E2  2000C2     MOV #0xC, W2
00C0E4  78009E     MOV [W14], W1
00C0E6  2209A0     MOV #0x209A, W0
00C0E8  023582     CALL _memcpy
00C0EA  000000     NOP
94:                    generateDisplacement(&body_rate, &body_displacement);
00C0EC  220B61     MOV #0x20B6, W1
00C0EE  2209A0     MOV #0x209A, W0
00C0F0  070058     RCALL generateDisplacement
00C0F2  370001     BRA 0xC0F6
95:                
96:                }
00C0F6  FA8000     ULNK
00C0F8  060000     RETURN
97:                
98:                void rateEnable(void) {
00C0FA  FA0000     LNK #0x0
99:                    is_running = 1;
00C0FC  220891     MOV #0x2089, W1
00C0FE  B3C010     MOV #0x1, W0
00C100  784880     MOV.B W0, [W1]
100:               }
00C102  FA8000     ULNK
00C104  060000     RETURN
101:               
102:               void rateDisable(void) {
00C106  FA0000     LNK #0x0
103:                   is_running = 0;
00C108  220891     MOV #0x2089, W1
00C10A  EB4000     CLR.B W0
00C10C  784880     MOV.B W0, [W1]
104:               }
00C10E  FA8000     ULNK
00C110  060000     RETURN
105:               
106:               void rateApplyGlobalRotation(Quaternion *rot) {
00C112  FA0012     LNK #0x12
00C114  980F00     MOV W0, [W14+16]
107:               
108:                   Quaternion current_ref;
109:                   
110:                   rgltrGetQuatRef(&current_ref);
00C116  78000E     MOV W14, W0
00C118  0242A0     CALL rgltrGetQuatRef
00C11A  000000     NOP
111:                   quatMult(rot, &current_ref, &current_ref);
00C11C  78010E     MOV W14, W2
00C11E  78008E     MOV W14, W1
00C120  90080E     MOV [W14+16], W0
00C122  02A54E     CALL quatMult
00C124  000000     NOP
112:                   quatNormalize(&current_ref);
00C126  78000E     MOV W14, W0
00C128  02A72C     CALL quatNormalize
00C12A  000000     NOP
113:                   rgltrSetQuatRef(&current_ref);
00C12C  78000E     MOV W14, W0
00C12E  0242BC     CALL rgltrSetQuatRef
00C130  000000     NOP
114:               
115:               }
00C132  FA8000     ULNK
00C134  060000     RETURN
116:               
117:               void rateApplyLocalRotation(Quaternion *rot) {
00C136  FA0012     LNK #0x12
00C138  980F00     MOV W0, [W14+16]
118:               
119:                   Quaternion current_ref;
120:                   
121:                   rgltrGetQuatRef(&current_ref);
00C13A  78000E     MOV W14, W0
00C13C  0242A0     CALL rgltrGetQuatRef
00C13E  000000     NOP
122:                   quatMult(&current_ref, rot, &current_ref);
00C140  78010E     MOV W14, W2
00C142  90088E     MOV [W14+16], W1
00C144  78000E     MOV W14, W0
00C146  02A54E     CALL quatMult
00C148  000000     NOP
123:                   quatNormalize(&current_ref);
00C14A  78000E     MOV W14, W0
00C14C  02A72C     CALL quatNormalize
00C14E  000000     NOP
124:                   rgltrSetQuatRef(&current_ref);
00C150  78000E     MOV W14, W0
00C152  0242BC     CALL rgltrSetQuatRef
00C154  000000     NOP
125:               
126:               }
00C156  FA8000     ULNK
00C158  060000     RETURN
127:               
128:               void rateProcess(void) {
00C15A  FA0010     LNK #0x10
129:               
130:                   Quaternion current_ref;
131:               
132:                   if(!is_ready || !is_running) { return; }
00C15C  220880     MOV #0x2088, W0
00C15E  784090     MOV.B [W0], W1
00C160  EB4000     CLR.B W0
00C162  50CF80     SUB.B W1, W0, [W15]
00C164  320019     BRA Z, 0xC198
00C166  220890     MOV #0x2089, W0
00C168  784090     MOV.B [W0], W1
00C16A  EB4000     CLR.B W0
00C16C  50CF80     SUB.B W1, W0, [W15]
00C16E  320016     BRA Z, 0xC19C
00C198  000000     NOP
00C19A  370001     BRA 0xC19E
00C19C  000000     NOP
133:                   
134:                   rgltrGetQuatRef(&current_ref);    
00C170  78000E     MOV W14, W0
00C172  0242A0     CALL rgltrGetQuatRef
00C174  000000     NOP
135:               
136:                   // q_body*q_current*q_global    
137:                   quatMult(&global_displacement, &current_ref, &current_ref);
00C176  78010E     MOV W14, W2
00C178  78008E     MOV W14, W1
00C17A  220A60     MOV #0x20A6, W0
00C17C  02A54E     CALL quatMult
00C17E  000000     NOP
138:                   quatMult(&current_ref, &body_displacement, &current_ref);
00C180  78010E     MOV W14, W2
00C182  220B61     MOV #0x20B6, W1
00C184  78000E     MOV W14, W0
00C186  02A54E     CALL quatMult
00C188  000000     NOP
139:               
140:                   quatNormalize(&current_ref);
00C18A  78000E     MOV W14, W0
00C18C  02A72C     CALL quatNormalize
00C18E  000000     NOP
141:               
142:                   rgltrSetQuatRef(&current_ref);
00C190  78000E     MOV W14, W0
00C192  0242BC     CALL rgltrSetQuatRef
00C194  000000     NOP
00C196  370003     BRA 0xC19E
143:               
144:               }
00C19E  FA8000     ULNK
00C1A0  060000     RETURN
145:               
146:               // =========== Private Methods =================================================
147:               
148:               void generateDisplacement(Rate rate, Quaternion *q) {
00C1A2  FA0010     LNK #0x10
00C1A4  BE9F88     MOV.D W8, [W15++]
00C1A6  980760     MOV W0, [W14+12]
00C1A8  980771     MOV W1, [W14+14]
149:                   
150:                   float norm, sina_2;
151:                   bams32_t a_2;
152:                   
153:                   norm = sqrtf(   rate->yaw_rate*rate->yaw_rate +
00C1AA  90006E     MOV [W14+12], W0
00C1AC  BE0210     MOV.D [W0], W4
00C1AE  90006E     MOV [W14+12], W0
00C1B0  BE0010     MOV.D [W0], W0
00C1B2  BE0100     MOV.D W0, W2
00C1B4  BE0004     MOV.D W4, W0
00C1B6  022C36     CALL ___mulsf3
00C1B8  000000     NOP
00C1BA  BE0400     MOV.D W0, W8
00C1D0  BE0100     MOV.D W0, W2
00C1D2  BE0008     MOV.D W8, W0
00C1D4  022A6C     CALL ___addsf3
00C1D6  000000     NOP
00C1D8  BE0400     MOV.D W0, W8
00C1EE  BE0100     MOV.D W0, W2
00C1F0  BE0008     MOV.D W8, W0
00C1F2  022A6C     CALL ___addsf3
00C1F4  000000     NOP
00C1F6  023050     CALL _sqrtfx
00C1F8  000000     NOP
00C1FA  BE8F00     MOV.D W0, [W14]
154:                                   rate->pitch_rate*rate->pitch_rate +
00C1BC  90006E     MOV [W14+12], W0
00C1BE  900220     MOV [W0+4], W4
00C1C0  9002B0     MOV [W0+6], W5
00C1C2  90006E     MOV [W14+12], W0
00C1C4  9000B0     MOV [W0+6], W1
00C1C6  900020     MOV [W0+4], W0
00C1C8  BE0100     MOV.D W0, W2
00C1CA  BE0004     MOV.D W4, W0
00C1CC  022C36     CALL ___mulsf3
00C1CE  000000     NOP
155:                                   rate->roll_rate*rate->roll_rate   );
00C1DA  90006E     MOV [W14+12], W0
00C1DC  900240     MOV [W0+8], W4
00C1DE  9002D0     MOV [W0+10], W5
00C1E0  90006E     MOV [W14+12], W0
00C1E2  9000D0     MOV [W0+10], W1
00C1E4  900040     MOV [W0+8], W0
00C1E6  BE0100     MOV.D W0, W2
00C1E8  BE0004     MOV.D W4, W0
00C1EA  022C36     CALL ___mulsf3
00C1EC  000000     NOP
156:               
157:                   if(norm == 0.0) {
00C1FC  B81160     MUL.UU W2, #0, W2
00C1FE  BE001E     MOV.D [W14], W0
00C200  0225A4     CALL ___lesf2
00C202  000000     NOP
00C204  EB0080     CLR W1
00C206  500F81     SUB W0, W1, [W15]
00C208  3A0011     BRA NZ, 0xC22C
158:                       q->w = 1.0;
00C20A  90017E     MOV [W14+14], W2
00C20C  200000     MOV #0x0, W0
00C20E  23F801     MOV #0x3F80, W1
00C210  BE8900     MOV.D W0, [W2]
159:                       q->x = 0.0;
00C212  90017E     MOV [W14+14], W2
00C214  B80060     MUL.UU W0, #0, W0
00C216  980120     MOV W0, [W2+4]
00C218  980131     MOV W1, [W2+6]
160:                       q->y = 0.0;
00C21A  90017E     MOV [W14+14], W2
00C21C  B80060     MUL.UU W0, #0, W0
00C21E  980140     MOV W0, [W2+8]
00C220  980151     MOV W1, [W2+10]
161:                       q->z = 0.0;
00C222  90017E     MOV [W14+14], W2
00C224  B80060     MUL.UU W0, #0, W0
00C226  980160     MOV W0, [W2+12]
00C228  980171     MOV W1, [W2+14]
00C22A  37003B     BRA 0xC2A2
162:                   } else {
163:                       a_2 = floatToBams32Rad(norm*period)/2;
00C22C  810450     MOV _period, W0
00C22E  810461     MOV 0x208C, W1
00C230  BE011E     MOV.D [W14], W2
00C232  022C36     CALL ___mulsf3
00C234  000000     NOP
00C236  026C4C     CALL floatToBams32Rad
00C238  000000     NOP
00C23A  DE094F     LSR W1, #15, W2
00C23C  200003     MOV #0x0, W3
00C23E  400002     ADD W0, W2, W0
00C240  488083     ADDC W1, W3, W1
00C242  D18081     ASR W1, W1
00C244  D38000     RRC W0, W0
00C246  980720     MOV W0, [W14+4]
00C248  980731     MOV W1, [W14+6]
164:                       sina_2 = bams32SinFine(a_2);
00C24A  90002E     MOV [W14+4], W0
00C24C  9000BE     MOV [W14+6], W1
00C24E  026E30     CALL bams32SinFine
00C250  000000     NOP
00C252  980740     MOV W0, [W14+8]
00C254  980751     MOV W1, [W14+10]
165:               
166:                       q->w = bams32CosFine(a_2)*norm;
00C256  90002E     MOV [W14+4], W0
00C258  9000BE     MOV [W14+6], W1
00C25A  026EDE     CALL bams32CosFine
00C25C  000000     NOP
00C25E  BE011E     MOV.D [W14], W2
00C260  022C36     CALL ___mulsf3
00C262  000000     NOP
00C264  90017E     MOV [W14+14], W2
00C266  BE8900     MOV.D W0, [W2]
167:                       q->x = sina_2*rate->roll_rate;
00C268  90006E     MOV [W14+12], W0
00C26A  9000D0     MOV [W0+10], W1
00C26C  900040     MOV [W0+8], W0
00C26E  90014E     MOV [W14+8], W2
00C270  9001DE     MOV [W14+10], W3
00C272  022C36     CALL ___mulsf3
00C274  000000     NOP
00C276  90017E     MOV [W14+14], W2
00C278  980120     MOV W0, [W2+4]
00C27A  980131     MOV W1, [W2+6]
168:                       q->y = sina_2*rate->pitch_rate;
00C27C  90006E     MOV [W14+12], W0
00C27E  9000B0     MOV [W0+6], W1
00C280  900020     MOV [W0+4], W0
00C282  90014E     MOV [W14+8], W2
00C284  9001DE     MOV [W14+10], W3
00C286  022C36     CALL ___mulsf3
00C288  000000     NOP
00C28A  90017E     MOV [W14+14], W2
00C28C  980140     MOV W0, [W2+8]
00C28E  980151     MOV W1, [W2+10]
169:                       q->z = sina_2*rate->yaw_rate;
00C290  90006E     MOV [W14+12], W0
00C292  BE0010     MOV.D [W0], W0
00C294  90014E     MOV [W14+8], W2
00C296  9001DE     MOV [W14+10], W3
00C298  022C36     CALL ___mulsf3
00C29A  000000     NOP
00C29C  90017E     MOV [W14+14], W2
00C29E  980160     MOV W0, [W2+12]
00C2A0  980171     MOV W1, [W2+14]
170:                   }
171:                   quatNormalize(q);    
00C2A2  90007E     MOV [W14+14], W0
00C2A4  02A72C     CALL quatNormalize
00C2A6  000000     NOP
172:                   
173:               }
00C2A8  BE044F     MOV.D [--W15], W8
00C2AA  FA8000     ULNK
00C2AC  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/ppbuff.c  -------------------------------------------------
1:                 /*
2:                 * Copyright (c) 2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Ping-Pong Buffer
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v.0.1
35:                *
36:                * Revisions:
37:                *  Humphrey Hu     2012-07-21      Initial release
38:                */
39:                
40:                #include "ppbuff.h"
41:                #include "utils.h"
42:                #include <stdlib.h>
43:                
44:                #define FLIP(x)            ((x) ^ 0x01)
45:                
46:                // =========== Public Methods =================================================
47:                void ppbuffInit(PingPongBuffer *ppbuff) {
00C4EE  FA0002     LNK #0x2
00C4F0  780F00     MOV W0, [W14]
48:                
49:                    if(ppbuff == NULL) { return; }
00C4F2  78009E     MOV [W14], W1
00C4F4  EB0000     CLR W0
00C4F6  508F80     SUB W1, W0, [W15]
00C4F8  32000D     BRA Z, 0xC514
00C514  000000     NOP
50:                    ppbuff->active_index = 0;
00C4FA  78009E     MOV [W14], W1
00C4FC  EB4000     CLR.B W0
00C4FE  984090     MOV.B W0, [W1+1]
51:                    ppbuff->items[0] = NULL;
00C500  78001E     MOV [W14], W0
00C502  EB0080     CLR W1
00C504  980011     MOV W1, [W0+2]
52:                    ppbuff->items[1] = NULL;
00C506  78001E     MOV [W14], W0
00C508  EB0080     CLR W1
00C50A  980021     MOV W1, [W0+4]
53:                    ppbuff->is_valid = 1;
00C50C  78009E     MOV [W14], W1
00C50E  B3C010     MOV #0x1, W0
00C510  784880     MOV.B W0, [W1]
00C512  370001     BRA 0xC516
54:                    
55:                }
00C516  FA8000     ULNK
00C518  060000     RETURN
56:                
57:                void ppbuffFlip(PingPongBuffer *ppbuff) {
00C51A  FA0008     LNK #0x8
00C51C  980730     MOV W0, [W14+6]
58:                
59:                    if(ppbuff == NULL) { return; }
00C51E  9000BE     MOV [W14+6], W1
00C520  EB0000     CLR W0
00C522  508F80     SUB W1, W0, [W15]
00C524  320024     BRA Z, 0xC56E
00C56E  000000     NOP
60:                    
61:                    CRITICAL_SECTION_START
00C526  800210     MOV SR, W0
00C528  DE0045     LSR W0, #5, W0
00C52A  604067     AND.B W0, #0x7, W0
00C52C  784F00     MOV.B W0, [W14]
00C52E  800290     MOV DISICNT, W0
00C530  980710     MOV W0, [W14+2]
00C532  FC3FFF     DISI #0x3FFF
00C534  800211     MOV SR, W1
00C536  200E00     MOV #0xE0, W0
00C538  708000     IOR W1, W0, W0
00C53A  880210     MOV W0, SR
00C53C  90001E     MOV [W14+2], W0
00C53E  880290     MOV W0, DISICNT
00C540  880000     MOV W0, WREG0
62:                    ppbuff->active_index = FLIP(ppbuff->active_index);
00C542  90003E     MOV [W14+6], W0
00C544  904010     MOV.B [W0+1], W0
00C546  A20400     BTG.B W0, #0
00C548  9000BE     MOV [W14+6], W1
00C54A  984090     MOV.B W0, [W1+1]
63:                    CRITICAL_SECTION_END
00C54C  800290     MOV DISICNT, W0
00C54E  980720     MOV W0, [W14+4]
00C550  FC3FFF     DISI #0x3FFF
00C552  78401E     MOV.B [W14], W0
00C554  604067     AND.B W0, #0x7, W0
00C556  FB8000     ZE W0, W0
00C558  600067     AND W0, #0x7, W0
00C55A  DD0045     SL W0, #5, W0
00C55C  800212     MOV SR, W2
00C55E  2FF1F1     MOV #0xFF1F, W1
00C560  610081     AND W2, W1, W1
00C562  708000     IOR W1, W0, W0
00C564  880210     MOV W0, SR
00C566  90002E     MOV [W14+4], W0
00C568  880290     MOV W0, DISICNT
00C56A  880000     MOV W0, WREG0
00C56C  370001     BRA 0xC570
64:                
65:                }
00C570  FA8000     ULNK
00C572  060000     RETURN
66:                
67:                PingPongItem ppbuffWriteActive(PingPongBuffer *ppbuff, PingPongItem item) {
00C574  FA000C     LNK #0xC
00C576  980740     MOV W0, [W14+8]
00C578  980751     MOV W1, [W14+10]
68:                
69:                    PingPongItem old;
70:                
71:                    if(ppbuff == NULL) { return NULL; }
00C57A  9000CE     MOV [W14+8], W1
00C57C  EB0000     CLR W0
00C57E  508F80     SUB W1, W0, [W15]
00C580  3A0002     BRA NZ, 0xC586
00C582  EB0000     CLR W0
00C584  370030     BRA 0xC5E6
72:                    
73:                    CRITICAL_SECTION_START
00C586  800210     MOV SR, W0
00C588  DE0045     LSR W0, #5, W0
00C58A  604067     AND.B W0, #0x7, W0
00C58C  784F00     MOV.B W0, [W14]
00C58E  800290     MOV DISICNT, W0
00C590  980710     MOV W0, [W14+2]
00C592  FC3FFF     DISI #0x3FFF
00C594  800211     MOV SR, W1
00C596  200E00     MOV #0xE0, W0
00C598  708000     IOR W1, W0, W0
00C59A  880210     MOV W0, SR
00C59C  90001E     MOV [W14+2], W0
00C59E  880290     MOV W0, DISICNT
00C5A0  880000     MOV W0, WREG0
74:                    old = ppbuff->items[ppbuff->active_index];
00C5A2  90004E     MOV [W14+8], W0
00C5A4  904010     MOV.B [W0+1], W0
00C5A6  FB8000     ZE W0, W0
00C5A8  9000CE     MOV [W14+8], W1
00C5AA  E80000     INC W0, W0
00C5AC  400000     ADD W0, W0, W0
00C5AE  780161     MOV [W1+W0], W2
00C5B0  980722     MOV W2, [W14+4]
75:                    ppbuff->items[ppbuff->active_index] = item;
00C5B2  90004E     MOV [W14+8], W0
00C5B4  904010     MOV.B [W0+1], W0
00C5B6  FB8000     ZE W0, W0
00C5B8  9000CE     MOV [W14+8], W1
00C5BA  E80000     INC W0, W0
00C5BC  400000     ADD W0, W0, W0
00C5BE  408000     ADD W1, W0, W0
00C5C0  9000DE     MOV [W14+10], W1
00C5C2  780801     MOV W1, [W0]
76:                    CRITICAL_SECTION_END    
00C5C4  800290     MOV DISICNT, W0
00C5C6  980730     MOV W0, [W14+6]
00C5C8  FC3FFF     DISI #0x3FFF
00C5CA  78401E     MOV.B [W14], W0
00C5CC  604067     AND.B W0, #0x7, W0
00C5CE  FB8000     ZE W0, W0
00C5D0  600067     AND W0, #0x7, W0
00C5D2  DD0045     SL W0, #5, W0
00C5D4  800212     MOV SR, W2
00C5D6  2FF1F1     MOV #0xFF1F, W1
00C5D8  610081     AND W2, W1, W1
00C5DA  708000     IOR W1, W0, W0
00C5DC  880210     MOV W0, SR
00C5DE  90003E     MOV [W14+6], W0
00C5E0  880290     MOV W0, DISICNT
00C5E2  880000     MOV W0, WREG0
77:                    
78:                    return old;
00C5E4  90002E     MOV [W14+4], W0
79:                
80:                }
00C5E6  FA8000     ULNK
00C5E8  060000     RETURN
81:                
82:                PingPongItem ppbuffWriteInactive(PingPongBuffer *ppbuff, PingPongItem item) {
00C5EA  FA000C     LNK #0xC
00C5EC  980740     MOV W0, [W14+8]
00C5EE  980751     MOV W1, [W14+10]
83:                
84:                    PingPongItem old;
85:                
86:                    if(ppbuff == NULL) { return NULL; }
00C5F0  9000CE     MOV [W14+8], W1
00C5F2  EB0000     CLR W0
00C5F4  508F80     SUB W1, W0, [W15]
00C5F6  3A0002     BRA NZ, 0xC5FC
00C5F8  EB0000     CLR W0
00C5FA  370032     BRA 0xC660
87:                    
88:                    CRITICAL_SECTION_START
00C5FC  800210     MOV SR, W0
00C5FE  DE0045     LSR W0, #5, W0
00C600  604067     AND.B W0, #0x7, W0
00C602  784F00     MOV.B W0, [W14]
00C604  800290     MOV DISICNT, W0
00C606  980710     MOV W0, [W14+2]
00C608  FC3FFF     DISI #0x3FFF
00C60A  800211     MOV SR, W1
00C60C  200E00     MOV #0xE0, W0
00C60E  708000     IOR W1, W0, W0
00C610  880210     MOV W0, SR
00C612  90001E     MOV [W14+2], W0
00C614  880290     MOV W0, DISICNT
00C616  880000     MOV W0, WREG0
89:                    old = ppbuff->items[FLIP(ppbuff->active_index)];
00C618  90004E     MOV [W14+8], W0
00C61A  904010     MOV.B [W0+1], W0
00C61C  A20400     BTG.B W0, #0
00C61E  FB8000     ZE W0, W0
00C620  9000CE     MOV [W14+8], W1
00C622  E80000     INC W0, W0
00C624  400000     ADD W0, W0, W0
00C626  780161     MOV [W1+W0], W2
00C628  980722     MOV W2, [W14+4]
90:                    ppbuff->items[FLIP(ppbuff->active_index)] = item;
00C62A  90004E     MOV [W14+8], W0
00C62C  904010     MOV.B [W0+1], W0
00C62E  A20400     BTG.B W0, #0
00C630  FB8000     ZE W0, W0
00C632  9000CE     MOV [W14+8], W1
00C634  E80000     INC W0, W0
00C636  400000     ADD W0, W0, W0
00C638  408000     ADD W1, W0, W0
00C63A  9000DE     MOV [W14+10], W1
00C63C  780801     MOV W1, [W0]
91:                    CRITICAL_SECTION_END    
00C63E  800290     MOV DISICNT, W0
00C640  980730     MOV W0, [W14+6]
00C642  FC3FFF     DISI #0x3FFF
00C644  78401E     MOV.B [W14], W0
00C646  604067     AND.B W0, #0x7, W0
00C648  FB8000     ZE W0, W0
00C64A  600067     AND W0, #0x7, W0
00C64C  DD0045     SL W0, #5, W0
00C64E  800212     MOV SR, W2
00C650  2FF1F1     MOV #0xFF1F, W1
00C652  610081     AND W2, W1, W1
00C654  708000     IOR W1, W0, W0
00C656  880210     MOV W0, SR
00C658  90003E     MOV [W14+6], W0
00C65A  880290     MOV W0, DISICNT
00C65C  880000     MOV W0, WREG0
92:                    
93:                    return old;
00C65E  90002E     MOV [W14+4], W0
94:                    
95:                }
00C660  FA8000     ULNK
00C662  060000     RETURN
96:                
97:                PingPongItem ppbuffReadActive(PingPongBuffer *ppbuff) {
00C664  FA000A     LNK #0xA
00C666  980740     MOV W0, [W14+8]
98:                
99:                    PingPongItem old;
100:               
101:                   if(ppbuff == NULL) { return NULL; }
00C668  9000CE     MOV [W14+8], W1
00C66A  EB0000     CLR W0
00C66C  508F80     SUB W1, W0, [W15]
00C66E  3A0002     BRA NZ, 0xC674
00C670  EB0000     CLR W0
00C672  370027     BRA 0xC6C2
102:               
103:                   CRITICAL_SECTION_START
00C674  800210     MOV SR, W0
00C676  DE0045     LSR W0, #5, W0
00C678  604067     AND.B W0, #0x7, W0
00C67A  784F00     MOV.B W0, [W14]
00C67C  800290     MOV DISICNT, W0
00C67E  980710     MOV W0, [W14+2]
00C680  FC3FFF     DISI #0x3FFF
00C682  800211     MOV SR, W1
00C684  200E00     MOV #0xE0, W0
00C686  708000     IOR W1, W0, W0
00C688  880210     MOV W0, SR
00C68A  90001E     MOV [W14+2], W0
00C68C  880290     MOV W0, DISICNT
00C68E  880000     MOV W0, WREG0
104:                   old = ppbuff->items[ppbuff->active_index];    
00C690  90004E     MOV [W14+8], W0
00C692  904010     MOV.B [W0+1], W0
00C694  FB8000     ZE W0, W0
00C696  9000CE     MOV [W14+8], W1
00C698  E80000     INC W0, W0
00C69A  400000     ADD W0, W0, W0
00C69C  780161     MOV [W1+W0], W2
00C69E  980722     MOV W2, [W14+4]
105:                   CRITICAL_SECTION_END    
00C6A0  800290     MOV DISICNT, W0
00C6A2  980730     MOV W0, [W14+6]
00C6A4  FC3FFF     DISI #0x3FFF
00C6A6  78401E     MOV.B [W14], W0
00C6A8  604067     AND.B W0, #0x7, W0
00C6AA  FB8000     ZE W0, W0
00C6AC  600067     AND W0, #0x7, W0
00C6AE  DD0045     SL W0, #5, W0
00C6B0  800212     MOV SR, W2
00C6B2  2FF1F1     MOV #0xFF1F, W1
00C6B4  610081     AND W2, W1, W1
00C6B6  708000     IOR W1, W0, W0
00C6B8  880210     MOV W0, SR
00C6BA  90003E     MOV [W14+6], W0
00C6BC  880290     MOV W0, DISICNT
00C6BE  880000     MOV W0, WREG0
106:                   
107:                   return old;       
00C6C0  90002E     MOV [W14+4], W0
108:                   
109:               }
00C6C2  FA8000     ULNK
00C6C4  060000     RETURN
110:               
111:               PingPongItem ppbuffReadInactive(PingPongBuffer *ppbuff) {
00C6C6  FA000A     LNK #0xA
00C6C8  980740     MOV W0, [W14+8]
112:               
113:                   PingPongItem old;
114:               
115:                   if(ppbuff == NULL) { return NULL; }
00C6CA  9000CE     MOV [W14+8], W1
00C6CC  EB0000     CLR W0
00C6CE  508F80     SUB W1, W0, [W15]
00C6D0  3A0002     BRA NZ, 0xC6D6
00C6D2  EB0000     CLR W0
00C6D4  370028     BRA 0xC726
116:               
117:                   CRITICAL_SECTION_START
00C6D6  800210     MOV SR, W0
00C6D8  DE0045     LSR W0, #5, W0
00C6DA  604067     AND.B W0, #0x7, W0
00C6DC  784F00     MOV.B W0, [W14]
00C6DE  800290     MOV DISICNT, W0
00C6E0  980710     MOV W0, [W14+2]
00C6E2  FC3FFF     DISI #0x3FFF
00C6E4  800211     MOV SR, W1
00C6E6  200E00     MOV #0xE0, W0
00C6E8  708000     IOR W1, W0, W0
00C6EA  880210     MOV W0, SR
00C6EC  90001E     MOV [W14+2], W0
00C6EE  880290     MOV W0, DISICNT
00C6F0  880000     MOV W0, WREG0
118:                   old = ppbuff->items[FLIP(ppbuff->active_index)];    
00C6F2  90004E     MOV [W14+8], W0
00C6F4  904010     MOV.B [W0+1], W0
00C6F6  A20400     BTG.B W0, #0
00C6F8  FB8000     ZE W0, W0
00C6FA  9000CE     MOV [W14+8], W1
00C6FC  E80000     INC W0, W0
00C6FE  400000     ADD W0, W0, W0
00C700  780161     MOV [W1+W0], W2
00C702  980722     MOV W2, [W14+4]
119:                   CRITICAL_SECTION_END    
00C704  800290     MOV DISICNT, W0
00C706  980730     MOV W0, [W14+6]
00C708  FC3FFF     DISI #0x3FFF
00C70A  78401E     MOV.B [W14], W0
00C70C  604067     AND.B W0, #0x7, W0
00C70E  FB8000     ZE W0, W0
00C710  600067     AND W0, #0x7, W0
00C712  DD0045     SL W0, #5, W0
00C714  800212     MOV SR, W2
00C716  2FF1F1     MOV #0xFF1F, W1
00C718  610081     AND W2, W1, W1
00C71A  708000     IOR W1, W0, W0
00C71C  880210     MOV W0, SR
00C71E  90003E     MOV [W14+6], W0
00C720  880290     MOV W0, DISICNT
00C722  880000     MOV W0, WREG0
120:                   
121:                   return old;       
00C724  90002E     MOV [W14+4], W0
122:                   
123:               }
00C726  FA8000     ULNK
00C728  060000     RETURN
124:               
---  C:/Users/Cameron/Documents/Git/ibird-lib/pbuff.c  --------------------------------------------------
1:                 /**
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Pooled Buffer
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v alpha
35:                 *
36:                 */
37:                 
38:                 #include "pbuff.h"
39:                 #include "carray.h"
40:                #include <stdlib.h>
41:                
42:                 void pbuffInit(PoolBuff pbuff, unsigned int size, PoolBuffItem *items) {
00D25A  FA0008     LNK #0x8
00D25C  980710     MOV W0, [W14+2]
00D25E  980721     MOV W1, [W14+4]
00D260  980732     MOV W2, [W14+6]
43:                 
44:                    unsigned int i;
45:                 
46:                    pbuff->valid = 0;
00D262  90009E     MOV [W14+2], W1
00D264  EB4000     CLR.B W0
00D266  784880     MOV.B W0, [W1]
47:                    
48:                    pbuff->active = carrayCreate(size);
00D268  90002E     MOV [W14+4], W0
00D26A  028F1C     CALL carrayCreate
00D26C  000000     NOP
00D26E  90009E     MOV [W14+2], W1
00D270  980090     MOV W0, [W1+2]
49:                    if(pbuff->active == NULL) { return; }
00D272  90001E     MOV [W14+2], W0
00D274  900090     MOV [W0+2], W1
00D276  EB0000     CLR W0
00D278  508F80     SUB W1, W0, [W15]
00D27A  320023     BRA Z, 0xD2C2
00D2C2  000000     NOP
50:                    
51:                    pbuff->idle = carrayCreate(size);
00D27C  90002E     MOV [W14+4], W0
00D27E  028F1C     CALL carrayCreate
00D280  000000     NOP
00D282  90009E     MOV [W14+2], W1
00D284  9800A0     MOV W0, [W1+4]
52:                    if(pbuff->idle == NULL) { 
00D286  90001E     MOV [W14+2], W0
00D288  9000A0     MOV [W0+4], W1
00D28A  EB0000     CLR W0
00D28C  508F80     SUB W1, W0, [W15]
00D28E  3A0005     BRA NZ, 0xD29A
53:                        carrayDelete(pbuff->active);
00D290  90001E     MOV [W14+2], W0
00D292  900010     MOV [W0+2], W0
00D294  028F72     CALL carrayDelete
00D296  000000     NOP
54:                        return;
00D298  370015     BRA 0xD2C4
55:                    }
56:                    
57:                    pbuff->valid = 1;
00D29A  90009E     MOV [W14+2], W1
00D29C  B3C010     MOV #0x1, W0
00D29E  784880     MOV.B W0, [W1]
58:                    
59:                    for(i = 0; i < size; i++) {   
00D2A0  EB0000     CLR W0
00D2A2  780F00     MOV W0, [W14]
00D2A4  370009     BRA 0xD2B8
00D2B6  E80F1E     INC [W14], [W14]
00D2B8  90002E     MOV [W14+4], W0
00D2BA  78009E     MOV [W14], W1
00D2BC  508F80     SUB W1, W0, [W15]
00D2BE  39FFF3     BRA NC, 0xD2A6
00D2C0  370001     BRA 0xD2C4
60:                        pbuffReturn(pbuff, items[i]);    
00D2A6  78001E     MOV [W14], W0
00D2A8  400000     ADD W0, W0, W0
00D2AA  9000BE     MOV [W14+6], W1
00D2AC  408000     ADD W1, W0, W0
00D2AE  780010     MOV [W0], W0
00D2B0  780080     MOV W0, W1
00D2B2  90001E     MOV [W14+2], W0
00D2B4  07008F     RCALL pbuffReturn
61:                    }
62:                    
63:                 }
00D2C4  FA8000     ULNK
00D2C6  060000     RETURN
64:                 
65:                 unsigned int pbuffHasActive(PoolBuff pbuff) {
00D2C8  FA0002     LNK #0x2
00D2CA  780F00     MOV W0, [W14]
66:                 
67:                    if(!pbuff->valid) { return 0; }
00D2CC  78001E     MOV [W14], W0
00D2CE  784090     MOV.B [W0], W1
00D2D0  EB4000     CLR.B W0
00D2D2  50CF80     SUB.B W1, W0, [W15]
00D2D4  3A0002     BRA NZ, 0xD2DA
00D2D6  EB0000     CLR W0
00D2D8  37000A     BRA 0xD2EE
68:                    
69:                    return !carrayIsEmpty(pbuff->active);
00D2DA  78001E     MOV [W14], W0
00D2DC  900010     MOV [W0+2], W0
00D2DE  02937A     CALL carrayIsEmpty
00D2E0  000000     NOP
00D2E2  780080     MOV W0, W1
00D2E4  200010     MOV #0x1, W0
00D2E6  EB0100     CLR W2
00D2E8  508F82     SUB W1, W2, [W15]
00D2EA  320001     BRA Z, 0xD2EE
00D2EC  EB0000     CLR W0
70:                 
71:                 }
00D2EE  FA8000     ULNK
00D2F0  060000     RETURN
72:                 
73:                 void pbuffAddActive(PoolBuff pbuff, PoolBuffItem item) {
00D2F2  FA0004     LNK #0x4
00D2F4  780F00     MOV W0, [W14]
00D2F6  980711     MOV W1, [W14+2]
74:                 
75:                    if(!pbuff->valid) { return; }
00D2F8  78001E     MOV [W14], W0
00D2FA  784090     MOV.B [W0], W1
00D2FC  EB4000     CLR.B W0
00D2FE  50CF80     SUB.B W1, W0, [W15]
00D300  320006     BRA Z, 0xD30E
00D30E  000000     NOP
76:                    
77:                    carrayAddTail(pbuff->active, item);
00D302  78001E     MOV [W14], W0
00D304  900010     MOV [W0+2], W0
00D306  90009E     MOV [W14+2], W1
00D308  028F9A     CALL carrayAddTail
00D30A  000000     NOP
00D30C  370001     BRA 0xD310
78:                 
79:                 }
00D310  FA8000     ULNK
00D312  060000     RETURN
80:                 
81:                 PoolBuffItem pbuffGetNewestActive(PoolBuff pbuff) {
00D314  FA0002     LNK #0x2
00D316  780F00     MOV W0, [W14]
82:                 
83:                    if(!pbuff->valid) { return NULL; }
00D318  78001E     MOV [W14], W0
00D31A  784090     MOV.B [W0], W1
00D31C  EB4000     CLR.B W0
00D31E  50CF80     SUB.B W1, W0, [W15]
00D320  3A0002     BRA NZ, 0xD326
00D322  EB0000     CLR W0
00D324  370004     BRA 0xD32E
84:                    
85:                    return carrayPopTail(pbuff->active);
00D326  78001E     MOV [W14], W0
00D328  900010     MOV [W0+2], W0
00D32A  029102     CALL carrayPopTail
00D32C  000000     NOP
86:                 
87:                 }
00D32E  FA8000     ULNK
00D330  060000     RETURN
88:                 
89:                 PoolBuffItem pbuffGetOldestActive(PoolBuff pbuff) {
00D332  FA0002     LNK #0x2
00D334  780F00     MOV W0, [W14]
90:                 
91:                    if(!pbuff->valid) { return NULL; }
00D336  78001E     MOV [W14], W0
00D338  784090     MOV.B [W0], W1
00D33A  EB4000     CLR.B W0
00D33C  50CF80     SUB.B W1, W0, [W15]
00D33E  3A0002     BRA NZ, 0xD344
00D340  EB0000     CLR W0
00D342  370004     BRA 0xD34C
92:                    
93:                    return carrayPopHead(pbuff->active);
00D344  78001E     MOV [W14], W0
00D346  900010     MOV [W0+2], W0
00D348  0291BA     CALL carrayPopHead
00D34A  000000     NOP
94:                 
95:                 }
00D34C  FA8000     ULNK
00D34E  060000     RETURN
96:                 
97:                 unsigned int pbuffHasIdle(PoolBuff pbuff) {
00D350  FA0002     LNK #0x2
00D352  780F00     MOV W0, [W14]
98:                 
99:                    if(!pbuff->valid) { return 0; }
00D354  78001E     MOV [W14], W0
00D356  784090     MOV.B [W0], W1
00D358  EB4000     CLR.B W0
00D35A  50CF80     SUB.B W1, W0, [W15]
00D35C  3A0002     BRA NZ, 0xD362
00D35E  EB0000     CLR W0
00D360  37000A     BRA 0xD376
100:                   
101:                   return !carrayIsEmpty(pbuff->idle);
00D362  78001E     MOV [W14], W0
00D364  900020     MOV [W0+4], W0
00D366  02937A     CALL carrayIsEmpty
00D368  000000     NOP
00D36A  780080     MOV W0, W1
00D36C  200010     MOV #0x1, W0
00D36E  EB0100     CLR W2
00D370  508F82     SUB W1, W2, [W15]
00D372  320001     BRA Z, 0xD376
00D374  EB0000     CLR W0
102:                
103:                }
00D376  FA8000     ULNK
00D378  060000     RETURN
104:                
105:                PoolBuffItem pbuffGetIdle(PoolBuff pbuff) {
00D37A  FA0002     LNK #0x2
00D37C  780F00     MOV W0, [W14]
106:                
107:                   if(!pbuff->valid) { return NULL; }
00D37E  78001E     MOV [W14], W0
00D380  784090     MOV.B [W0], W1
00D382  EB4000     CLR.B W0
00D384  50CF80     SUB.B W1, W0, [W15]
00D386  3A0002     BRA NZ, 0xD38C
00D388  EB0000     CLR W0
00D38A  370004     BRA 0xD394
108:                   
109:                   return carrayPopHead(pbuff->idle);
00D38C  78001E     MOV [W14], W0
00D38E  900020     MOV [W0+4], W0
00D390  0291BA     CALL carrayPopHead
00D392  000000     NOP
110:                
111:                }
00D394  FA8000     ULNK
00D396  060000     RETURN
112:                
113:               PoolBuffItem pbuffForceGetIdleNewest(PoolBuff pbuff) {
00D398  FA0004     LNK #0x4
00D39A  980710     MOV W0, [W14+2]
114:               
115:                   PoolBuffItem item;
116:                   
117:                   item = pbuffGetIdle(pbuff);
00D39C  90001E     MOV [W14+2], W0
00D39E  07FFED     RCALL pbuffGetIdle
00D3A0  780F00     MOV W0, [W14]
118:                   if(item == NULL) {
00D3A2  78009E     MOV [W14], W1
00D3A4  EB0000     CLR W0
00D3A6  508F80     SUB W1, W0, [W15]
00D3A8  3A0003     BRA NZ, 0xD3B0
119:                       item = pbuffGetNewestActive(pbuff);
00D3AA  90001E     MOV [W14+2], W0
00D3AC  07FFB3     RCALL pbuffGetNewestActive
00D3AE  780F00     MOV W0, [W14]
120:                   }
121:                   
122:                   return item;
00D3B0  78001E     MOV [W14], W0
123:               
124:               }
00D3B2  FA8000     ULNK
00D3B4  060000     RETURN
125:               
126:                
127:               PoolBuffItem pbuffForceGetIdleOldest(PoolBuff pbuff) {
00D3B6  FA0004     LNK #0x4
00D3B8  980710     MOV W0, [W14+2]
128:               
129:                   PoolBuffItem item;
130:                   
131:                   item = pbuffGetIdle(pbuff);
00D3BA  90001E     MOV [W14+2], W0
00D3BC  07FFDE     RCALL pbuffGetIdle
00D3BE  780F00     MOV W0, [W14]
132:                   if(item == NULL) {
00D3C0  78009E     MOV [W14], W1
00D3C2  EB0000     CLR W0
00D3C4  508F80     SUB W1, W0, [W15]
00D3C6  3A0003     BRA NZ, 0xD3CE
133:                       item = pbuffGetOldestActive(pbuff);
00D3C8  90001E     MOV [W14+2], W0
00D3CA  07FFB3     RCALL pbuffGetOldestActive
00D3CC  780F00     MOV W0, [W14]
134:                   }
135:                   
136:                   return item;
00D3CE  78001E     MOV [W14], W0
137:               
138:               }
00D3D0  FA8000     ULNK
00D3D2  060000     RETURN
139:                
140:               void pbuffReturn(PoolBuff pbuff, PoolBuffItem item) {
00D3D4  FA0004     LNK #0x4
00D3D6  780F00     MOV W0, [W14]
00D3D8  980711     MOV W1, [W14+2]
141:                
142:                   if(!pbuff->valid) { return; }
00D3DA  78001E     MOV [W14], W0
00D3DC  784090     MOV.B [W0], W1
00D3DE  EB4000     CLR.B W0
00D3E0  50CF80     SUB.B W1, W0, [W15]
00D3E2  320006     BRA Z, 0xD3F0
00D3F0  000000     NOP
143:                   
144:                   carrayAddTail(pbuff->idle, item);
00D3E4  78001E     MOV [W14], W0
00D3E6  900020     MOV [W0+4], W0
00D3E8  90009E     MOV [W14+2], W1
00D3EA  028F9A     CALL carrayAddTail
00D3EC  000000     NOP
00D3EE  370001     BRA 0xD3F2
145:                
146:               }
00D3F2  FA8000     ULNK
00D3F4  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/net.c  ----------------------------------------------------
1:                 /**
2:                 * Copyright (c) 2011-2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Network addressing module
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v.beta
35:                *
36:                * Revisions:
37:                *   Humphrey Hu         2011-07-27      Initial implementation
38:                *   Humphrey Hu         2011-09-03      Moved directory to separate module
39:                *                      
40:                * Notes:
41:                *
42:                * TODO:
43:                *	Implement robust multi-hop networking
44:                */
45:                
46:                // ==== REFERENCES ==========================================
47:                #include "net.h"
48:                #include "directory.h"
49:                #include "radio.h"
50:                #include "telemetry.h"
51:                
52:                #include "cmd_const.h"
53:                #include "utils.h"
54:                #include "counter.h"
55:                #include "sys_clock.h" 
56:                
57:                #include <stdlib.h>
58:                
59:                // ==== CONSTANTS =========================================== 
60:                #define MAX_REQUEST_ATTEMPTS        (10)
61:                
62:                #define DEFAULT_LOCAL_ADDR          (0x1021)
63:                #define DEFAULT_LOCAL_PAN           (0x1005)
64:                #define DEFAULT_LOCAL_CHANNEL       (0x12)
65:                
66:                #define DEFAULT_BASE_ADDR           (0x1020)
67:                #define DEFAULT_BASE_PAN            (0x1005)
68:                #define DEFAULT_BASE_CHANNEL        (0x12)
69:                
70:                // ==== STATIC VARIABLES ====================================
71:                // Local assigned parameters
72:                static unsigned int localAddress;
73:                static unsigned int localPanID;
74:                static unsigned char localChannel;
75:                static unsigned long long local_UUID;
76:                
77:                // Network assigned parameters
78:                static unsigned int baseStationAddress;
79:                static unsigned int baseStationPanID;
80:                static unsigned int baseStationChannel;
81:                
82:                static unsigned int request_attempts;
83:                static unsigned char attempts_exceeded, address_received;
84:                
85:                // ==== FUNCTION STUBS ======================================
86:                // Send methods
87:                void netSendRequest(void);
88:                void netSendAccept(long);
89:                
90:                // ==== FUNCTION BODIES =====================================
91:                // Setup the network module
92:                // Note that this method blocks until an address is assigned!
93:                void netSetup(unsigned int dir_size) {
00C2AE  FA000A     LNK #0xA
00C2B0  BE9F88     MOV.D W8, [W15++]
00C2B2  BE9F8A     MOV.D W10, [W15++]
00C2B4  980740     MOV W0, [W14+8]
94:                
95:                    localAddress = DEFAULT_LOCAL_ADDR;
00C2B6  210210     MOV #0x1021, W0
00C2B8  890C80     MOV W0, localAddress
96:                    localPanID = DEFAULT_LOCAL_PAN;
00C2BA  210050     MOV #0x1005, W0
00C2BC  890C90     MOV W0, localPanID
97:                    localChannel = DEFAULT_LOCAL_CHANNEL;
00C2BE  221941     MOV #0x2194, W1
00C2C0  B3C120     MOV #0x12, W0
00C2C2  784880     MOV.B W0, [W1]
98:                
99:                    baseStationAddress = DEFAULT_BASE_ADDR;
00C2C4  210200     MOV #0x1020, W0
00C2C6  890CF0     MOV W0, baseStationAddress
100:                   baseStationPanID = DEFAULT_BASE_PAN;
00C2C8  210050     MOV #0x1005, W0
00C2CA  890D00     MOV W0, baseStationPanID
101:                   baseStationChannel = DEFAULT_BASE_CHANNEL;
00C2CC  200120     MOV #0x12, W0
00C2CE  890D10     MOV W0, baseStationChannel
102:               
103:                   // Generate 64-bit UUID
104:                   unsigned long a, b;
105:                   a = (unsigned long) rand();
00C2D0  0235D0     CALL _rand
00C2D2  000000     NOP
00C2D4  DE80CF     ASR W0, #15, W1
00C2D6  BE8F00     MOV.D W0, [W14]
106:                   b = ((unsigned long) rand()) << 16;
00C2D8  0235D0     CALL _rand
00C2DA  000000     NOP
00C2DC  DE80CF     ASR W0, #15, W1
00C2DE  DD00C0     SL W0, #0, W1
00C2E0  200000     MOV #0x0, W0
00C2E2  980720     MOV W0, [W14+4]
00C2E4  980731     MOV W1, [W14+6]
107:                   local_UUID = a|b;
00C2E6  90002E     MOV [W14+4], W0
00C2E8  9000BE     MOV [W14+6], W1
00C2EA  70013E     IOR W0, [W14++], W2
00C2EC  7081AE     IOR W1, [W14--], W3
00C2EE  BE0002     MOV.D W2, W0
00C2F0  BE0400     MOV.D W0, W8
00C2F2  EB0500     CLR W10
00C2F4  EB0580     CLR W11
00C2F6  221960     MOV #0x2196, W0
00C2F8  BE9808     MOV.D W8, [W0++]
00C2FA  BE900A     MOV.D W10, [W0--]
108:                   
109:                   attempts_exceeded = 0;
00C2FC  221A61     MOV #0x21A6, W1
00C2FE  EB4000     CLR.B W0
00C300  784880     MOV.B W0, [W1]
110:                   address_received = 0;
00C302  221A71     MOV #0x21A7, W1
00C304  EB4000     CLR.B W0
00C306  784880     MOV.B W0, [W1]
111:                   
112:                   dirInit(dir_size);
00C308  90004E     MOV [W14+8], W0
00C30A  02CB38     CALL dirInit
00C30C  000000     NOP
113:                   
114:               }
00C30E  BE054F     MOV.D [--W15], W10
00C310  BE044F     MOV.D [--W15], W8
00C312  FA8000     ULNK
00C314  060000     RETURN
115:               
116:               // Retrieve local address
117:               unsigned int netGetLocalAddress(void) {
00C316  FA0000     LNK #0x0
118:               
119:                   return localAddress;
00C318  810C80     MOV localAddress, W0
120:               
121:               }
00C31A  FA8000     ULNK
00C31C  060000     RETURN
122:               
123:               // Retrieve local PAN ID
124:               unsigned int netGetLocalPanID(void) {
00C31E  FA0000     LNK #0x0
125:               
126:                   return localPanID;
00C320  810C90     MOV localPanID, W0
127:                   
128:               }
00C322  FA8000     ULNK
00C324  060000     RETURN
129:               
130:               unsigned int netGetBaseAddress(void) {
00C326  FA0000     LNK #0x0
131:               
132:                   return baseStationAddress;
00C328  810CF0     MOV baseStationAddress, W0
133:                   
134:               }
00C32A  FA8000     ULNK
00C32C  060000     RETURN
135:               
136:               unsigned int netGetBasePanID(void) {
00C32E  FA0000     LNK #0x0
137:               
138:                   return baseStationPanID;
00C330  810D00     MOV baseStationPanID, W0
139:                   
140:               }
00C332  FA8000     ULNK
00C334  060000     RETURN
141:               
142:               unsigned char netAddressReceived(void) {
00C336  FA0000     LNK #0x0
143:               
144:                   return address_received || attempts_exceeded;
00C338  221A70     MOV #0x21A7, W0
00C33A  784090     MOV.B [W0], W1
00C33C  EB4000     CLR.B W0
00C33E  50CF80     SUB.B W1, W0, [W15]
00C340  3A0005     BRA NZ, 0xC34C
00C342  221A60     MOV #0x21A6, W0
00C344  784090     MOV.B [W0], W1
00C346  EB4000     CLR.B W0
00C348  50CF80     SUB.B W1, W0, [W15]
00C34A  320002     BRA Z, 0xC350
00C34C  200010     MOV #0x1, W0
00C34E  370001     BRA 0xC352
00C350  EB0000     CLR W0
00C352  784000     MOV.B W0, W0
145:               
146:               }
00C354  FA8000     ULNK
00C356  060000     RETURN
147:               
148:               // Request an address
149:               void netRequestAddress(void) {
00C358  FA0000     LNK #0x0
150:                   
151:                   if(netAddressReceived()) { return; }
00C35A  07FFED     RCALL netAddressReceived
00C35C  EB4080     CLR.B W1
00C35E  504F81     SUB.B W0, W1, [W15]
00C360  3A000C     BRA NZ, 0xC37A
00C37A  000000     NOP
152:                   
153:                   netSendRequest();
00C362  070064     RCALL netSendRequest
154:                   
155:                   request_attempts++;    
00C364  810D20     MOV request_attempts, W0
00C366  E80000     INC W0, W0
00C368  890D20     MOV W0, request_attempts
156:                   if(request_attempts > MAX_REQUEST_ATTEMPTS) {    
00C36A  810D21     MOV request_attempts, W1
00C36C  2000A0     MOV #0xA, W0
00C36E  508F80     SUB W1, W0, [W15]
00C370  360005     BRA LEU, 0xC37C
157:                       attempts_exceeded = 1;
00C372  221A61     MOV #0x21A6, W1
00C374  B3C010     MOV #0x1, W0
00C376  784880     MOV.B W0, [W1]
00C378  370001     BRA 0xC37C
158:                   }
159:                   
160:               }
00C37C  FA8000     ULNK
00C37E  060000     RETURN
161:               
162:               void netHandleOffer(MacPacket packet) {
00C380  FA0016     LNK #0x16
00C382  980F20     MOV W0, [W14+20]
163:                   
164:                   Payload pld;    
165:                   unsigned long long uuidKey;
166:                   unsigned long offerID, timestamp;
167:                   unsigned char* data;    
168:               
169:                   pld = macGetPayload(packet);
00C384  90082E     MOV [W14+20], W0
00C386  0286E6     CALL macGetPayload
00C388  000000     NOP
00C38A  780F00     MOV W0, [W14]
170:                   uuidKey = *((unsigned long long*) payGetData(pld));
00C38C  78001E     MOV [W14], W0
00C38E  02CAA0     CALL payGetData
00C390  000000     NOP
00C392  BE0230     MOV.D [W0++], W4
00C394  BE0320     MOV.D [W0--], W6
00C396  980714     MOV W4, [W14+2]
00C398  980725     MOV W5, [W14+4]
00C39A  980736     MOV W6, [W14+6]
00C39C  980747     MOV W7, [W14+8]
171:               
172:                   // If offer is addressed to us, decode offer and send acceptance
173:                   if(uuidKey == local_UUID) {
00C39E  221960     MOV #0x2196, W0
00C3A0  BE0150     MOV.D [++W0], W2
00C3A2  BE0040     MOV.D [--W0], W0
00C3A4  90021E     MOV [W14+2], W4
00C3A6  9002AE     MOV [W14+4], W5
00C3A8  90033E     MOV [W14+6], W6
00C3AA  9003CE     MOV [W14+8], W7
00C3AC  E12000     CP W4, W0
00C3AE  E1A801     CPB W5, W1
00C3B0  E1B002     CPB W6, W2
00C3B2  E1B803     CPB W7, W3
00C3B4  3A0031     BRA NZ, 0xC418
174:                       data = payGetData(pld);
00C3B6  78001E     MOV [W14], W0
00C3B8  02CAA0     CALL payGetData
00C3BA  000000     NOP
00C3BC  980750     MOV W0, [W14+10]
175:                       offerID = *((unsigned long*) (data + 8));
00C3BE  90005E     MOV [W14+10], W0
00C3C0  400068     ADD W0, #0x8, W0
00C3C2  BE0310     MOV.D [W0], W6
00C3C4  980766     MOV W6, [W14+12]
00C3C6  980777     MOV W7, [W14+14]
176:                       localAddress = *((unsigned int*) (data + 12));
00C3C8  90005E     MOV [W14+10], W0
00C3CA  40006C     ADD W0, #0xC, W0
00C3CC  780010     MOV [W0], W0
00C3CE  890C80     MOV W0, localAddress
177:                       localPanID = *((unsigned int*) (data + 14));
00C3D0  90005E     MOV [W14+10], W0
00C3D2  40006E     ADD W0, #0xE, W0
00C3D4  780010     MOV [W0], W0
00C3D6  890C90     MOV W0, localPanID
178:                       localChannel = (unsigned char)*((unsigned int*) (data + 16));
00C3D8  90005E     MOV [W14+10], W0
00C3DA  400070     ADD W0, #0x10, W0
00C3DC  780010     MOV [W0], W0
00C3DE  784000     MOV.B W0, W0
00C3E0  221941     MOV #0x2194, W1
00C3E2  784880     MOV.B W0, [W1]
179:               
180:                       baseStationAddress = *((unsigned int*) (data + 18));
00C3E4  90005E     MOV [W14+10], W0
00C3E6  400072     ADD W0, #0x12, W0
00C3E8  780010     MOV [W0], W0
00C3EA  890CF0     MOV W0, baseStationAddress
181:                       baseStationPanID = *((unsigned int*) (data + 20));
00C3EC  90005E     MOV [W14+10], W0
00C3EE  400074     ADD W0, #0x14, W0
00C3F0  780010     MOV [W0], W0
00C3F2  890D00     MOV W0, baseStationPanID
182:                       baseStationChannel = (unsigned char)*((unsigned int*) (data + 22));
00C3F4  90005E     MOV [W14+10], W0
00C3F6  400076     ADD W0, #0x16, W0
00C3F8  780010     MOV [W0], W0
00C3FA  784000     MOV.B W0, W0
00C3FC  FB8000     ZE W0, W0
00C3FE  890D10     MOV W0, baseStationChannel
183:               
184:                       timestamp = *((unsigned long *) data + 24);
00C400  90005E     MOV [W14+10], W0
00C402  B00600     ADD #0x60, W0
00C404  BE0110     MOV.D [W0], W2
00C406  980F02     MOV W2, [W14+16]
00C408  980F13     MOV W3, [W14+18]
185:               
186:                       netSendAccept(offerID);
00C40A  90006E     MOV [W14+12], W0
00C40C  9000FE     MOV [W14+14], W1
00C40E  070038     RCALL netSendAccept
187:                       address_received = 1;
00C410  221A71     MOV #0x21A7, W1
00C412  B3C010     MOV #0x1, W0
00C414  784880     MOV.B W0, [W1]
188:                       return;
00C416  000000     NOP
189:                   }        
190:               
191:               }
00C418  FA8000     ULNK
00C41A  060000     RETURN
192:               
193:               void netHandleRequest(MacPacket packet) {
00C41C  FA0002     LNK #0x2
00C41E  780F00     MOV W0, [W14]
194:               
195:                   return;
196:               
197:               }
00C420  FA8000     ULNK
00C422  060000     RETURN
198:               
199:               void netHandleAccept(MacPacket packet) {
00C424  FA0002     LNK #0x2
00C426  780F00     MOV W0, [W14]
200:               
201:                   return;
202:               
203:               }
00C428  FA8000     ULNK
00C42A  060000     RETURN
204:               
205:               // =========== Private Functions ==============================================
206:               
207:               // Broadcast a request for an address
208:               // Note that the radio needs to be set to the appropriate PAN
209:               // TODO: Have network setup set radio to appropriate PAN!
210:               void netSendRequest(void) {
00C42C  FA0004     LNK #0x4
211:                   
212:                   MacPacket request_packet;
213:                   Payload pld;    
214:               
215:                   // Create request packet
216:                   request_packet = radioRequestPacket(8);
00C42E  200080     MOV #0x8, W0
00C430  0281B2     CALL radioRequestPacket
00C432  000000     NOP
00C434  780F00     MOV W0, [W14]
217:                   if(request_packet == NULL) { return; }
00C436  78009E     MOV [W14], W1
00C438  EB0000     CLR W0
00C43A  508F80     SUB W1, W0, [W15]
00C43C  32001E     BRA Z, 0xC47A
00C47A  000000     NOP
218:                   macSetDestAddr(request_packet, NETWORK_BROADCAST_ADDR);
00C43E  EB8080     SETM W1
00C440  78001E     MOV [W14], W0
00C442  02863C     CALL macSetDestAddr
00C444  000000     NOP
219:                   pld = macGetPayload(request_packet);
00C446  78001E     MOV [W14], W0
00C448  0286E6     CALL macGetPayload
00C44A  000000     NOP
00C44C  980710     MOV W0, [W14+2]
220:                   paySetData(pld, 8, (unsigned char *) &local_UUID);
00C44E  221960     MOV #0x2196, W0
00C450  780100     MOV W0, W2
00C452  B3C081     MOV #0x8, W1
00C454  90001E     MOV [W14+2], W0
00C456  02CAAE     CALL paySetData
00C458  000000     NOP
221:                   paySetStatus(pld, 0);
00C45A  EB4080     CLR.B W1
00C45C  90001E     MOV [W14+2], W0
00C45E  02CB02     CALL paySetStatus
00C460  000000     NOP
222:                   paySetType(pld, CMD_ADDRESS_REQUEST);
00C462  B3C301     MOV #0x30, W1
00C464  90001E     MOV [W14+2], W0
00C466  02CADE     CALL paySetType
00C468  000000     NOP
223:               
224:                   while(!radioEnqueueTxPacket(request_packet));
00C46A  000000     NOP
00C46C  78001E     MOV [W14], W0
00C46E  028128     CALL radioEnqueueTxPacket
00C470  000000     NOP
00C472  EB0080     CLR W1
00C474  500F81     SUB W0, W1, [W15]
00C476  32FFFA     BRA Z, 0xC46C
00C478  370001     BRA 0xC47C
225:               
226:               }
00C47C  FA8000     ULNK
00C47E  060000     RETURN
227:               
228:               // Broadcasts acceptance of an address
229:               void netSendAccept(long offerID) {
00C480  FA000C     LNK #0xC
00C482  980740     MOV W0, [W14+8]
00C484  980751     MOV W1, [W14+10]
230:                   
231:                   MacPacket accept_packet;
232:                   Payload pld;
233:                   long offer = offerID;
00C486  90004E     MOV [W14+8], W0
00C488  9000DE     MOV [W14+10], W1
00C48A  980720     MOV W0, [W14+4]
00C48C  980731     MOV W1, [W14+6]
234:                   
235:                   // Broadcast acceptance to inform other coordinators
236:                   accept_packet = radioRequestPacket(12);
00C48E  2000C0     MOV #0xC, W0
00C490  0281B2     CALL radioRequestPacket
00C492  000000     NOP
00C494  780F00     MOV W0, [W14]
237:                   if(accept_packet == NULL) { return; }
00C496  78009E     MOV [W14], W1
00C498  EB0000     CLR W0
00C49A  508F80     SUB W1, W0, [W15]
00C49C  320025     BRA Z, 0xC4E8
00C4E8  000000     NOP
238:                   macSetDestAddr(accept_packet, NETWORK_BROADCAST_ADDR);
00C49E  EB8080     SETM W1
00C4A0  78001E     MOV [W14], W0
00C4A2  02863C     CALL macSetDestAddr
00C4A4  000000     NOP
239:                   
240:                   pld = macGetPayload(accept_packet);
00C4A6  78001E     MOV [W14], W0
00C4A8  0286E6     CALL macGetPayload
00C4AA  000000     NOP
00C4AC  980710     MOV W0, [W14+2]
241:                   paySetData(pld, 8, (unsigned char *) &local_UUID);
00C4AE  221960     MOV #0x2196, W0
00C4B0  780100     MOV W0, W2
00C4B2  B3C081     MOV #0x8, W1
00C4B4  90001E     MOV [W14+2], W0
00C4B6  02CAAE     CALL paySetData
00C4B8  000000     NOP
242:                   payAppendData(pld, 8, 4, (unsigned char *) & offer);
00C4BA  470064     ADD W14, #0x4, W0
00C4BC  780180     MOV W0, W3
00C4BE  B3C042     MOV #0x4, W2
00C4C0  B3C081     MOV #0x8, W1
00C4C2  90001E     MOV [W14+2], W0
00C4C4  02CA40     CALL payAppendData
00C4C6  000000     NOP
243:                   paySetStatus(pld, 0);
00C4C8  EB4080     CLR.B W1
00C4CA  90001E     MOV [W14+2], W0
00C4CC  02CB02     CALL paySetStatus
00C4CE  000000     NOP
244:                   paySetType(pld, CMD_ADDRESS_ACCEPT);
00C4D0  B3C321     MOV #0x32, W1
00C4D2  90001E     MOV [W14+2], W0
00C4D4  02CADE     CALL paySetType
00C4D6  000000     NOP
245:               
246:                   while(!radioEnqueueTxPacket(accept_packet));
00C4D8  000000     NOP
00C4DA  78001E     MOV [W14], W0
00C4DC  028128     CALL radioEnqueueTxPacket
00C4DE  000000     NOP
00C4E0  EB0080     CLR W1
00C4E2  500F81     SUB W0, W1, [W15]
00C4E4  32FFFA     BRA Z, 0xC4DA
00C4E6  370001     BRA 0xC4EA
247:               
248:               }
00C4EA  FA8000     ULNK
00C4EC  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/motor_ctrl.c  ---------------------------------------------
1:                 /*
2:                 * Copyright (c) 2010 - 2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * PWM Motor Controller Drive
31:                *
32:                * by Stanley S. Baek
33:                *
34:                * v 0.2
35:                *
36:                * Revisions:
37:                *   Stanley S. Baek     2010-05-30      Initial release
38:                *   Humphrey Hu         2012-06-30      Switched to +- 1.0 scale
39:                */
40:                
41:                #include "motor_ctrl.h"
42:                #include "pwm.h"
43:                #include "ports.h"
44:                #include "led.h"
45:                
46:                #define LEFT_TURN           _LATE2 = 1; _LATE4 = 0;
47:                #define RIGHT_TURN          _LATE2 = 0; _LATE4 = 1;
48:                #define NO_TURN             _LATE2 = 0; _LATE4 = 0;
49:                
50:                #define LEFT_TURN_CHANNEL   (2)
51:                #define RIGHT_TURN_CHANNEL  (3)
52:                
53:                #define DC_UPPER_LIMIT      (1.0)
54:                #define DC_LOWER_LIMIT      (0.0)
55:                
56:                // =========== Static Variables ================================================
57:                static unsigned char is_ready = 0;
58:                static unsigned int pwmPeriod;
59:                static McSteerMode steerMode = MC_STEER_MODE_CONT;
60:                
61:                // =========== Function Stubs ==================================================
62:                static void mcSetupPeripheral(void);
63:                
64:                // =========== Public Functions ================================================
65:                void mcSetup(void) {
00C72A  FA0000     LNK #0x0
66:                    
67:                    pwmPeriod = 624;    // For 1KHz at MIPS == 40    
00C72C  202700     MOV #0x270, W0
00C72E  891100     MOV W0, _pwmPeriod
68:                    mcSetupPeripheral();
00C730  0700D0     RCALL mcSetupPeripheral
69:                    is_ready = 1;
00C732  2221E1     MOV #0x221E, W1
00C734  B3C010     MOV #0x1, W0
00C736  784880     MOV.B W0, [W1]
70:                    
71:                }
00C738  FA8000     ULNK
00C73A  060000     RETURN
72:                
73:                void mcStop(void) {   
00C73C  FA0000     LNK #0x0
74:                    
75:                    mcSetDutyCycle(MC_CHANNEL_PWM1, 0.0);
00C73E  B81160     MUL.UU W2, #0, W2
00C740  B3C010     MOV #0x1, W0
00C742  07000B     RCALL mcSetDutyCycle
76:                    mcSetDutyCycle(MC_CHANNEL_PWM2, 0.0);
00C744  B81160     MUL.UU W2, #0, W2
00C746  B3C020     MOV #0x2, W0
00C748  070008     RCALL mcSetDutyCycle
77:                    mcSetDutyCycle(MC_CHANNEL_PWM3, 0.0);
00C74A  B81160     MUL.UU W2, #0, W2
00C74C  B3C030     MOV #0x3, W0
00C74E  070005     RCALL mcSetDutyCycle
78:                    mcSetDutyCycle(MC_CHANNEL_PWM4, 0.0);
00C750  B81160     MUL.UU W2, #0, W2
00C752  B3C040     MOV #0x4, W0
00C754  070002     RCALL mcSetDutyCycle
79:                
80:                }
00C756  FA8000     ULNK
00C758  060000     RETURN
81:                
82:                void mcSetDutyCycle(unsigned char channel, float duty_cycle) {
00C75A  FA0008     LNK #0x8
00C75C  BE9F88     MOV.D W8, [W15++]
00C75E  984720     MOV.B W0, [W14+2]
00C760  980722     MOV W2, [W14+4]
00C762  980733     MOV W3, [W14+6]
83:                
84:                    unsigned int pdc_value;
85:                
86:                    if(!is_ready) { return; }
00C764  2221E0     MOV #0x221E, W0
00C766  784090     MOV.B [W0], W1
00C768  EB4000     CLR.B W0
00C76A  50CF80     SUB.B W1, W0, [W15]
00C76C  32003B     BRA Z, 0xC7E4
00C7E4  000000     NOP
87:                
88:                    // Check input range
89:                    if(duty_cycle > DC_UPPER_LIMIT) {
00C76E  B3C018     MOV #0x1, W8
00C770  200002     MOV #0x0, W2
00C772  23F803     MOV #0x3F80, W3
00C774  90002E     MOV [W14+4], W0
00C776  9000BE     MOV [W14+6], W1
00C778  0225A8     CALL ___gtsf2
00C77A  000000     NOP
00C77C  EB0080     CLR W1
00C77E  500F81     SUB W0, W1, [W15]
00C780  3C0001     BRA GT, 0xC784
00C782  EB4400     CLR.B W8
00C784  EB4000     CLR.B W0
00C786  544F80     SUB.B W8, W0, [W15]
00C788  320005     BRA Z, 0xC794
90:                        duty_cycle = DC_UPPER_LIMIT;
00C78A  200000     MOV #0x0, W0
00C78C  23F801     MOV #0x3F80, W1
00C78E  980720     MOV W0, [W14+4]
00C790  980731     MOV W1, [W14+6]
00C792  370010     BRA 0xC7B4
91:                    } else if(duty_cycle < DC_LOWER_LIMIT) {
00C794  B3C018     MOV #0x1, W8
00C796  B81160     MUL.UU W2, #0, W2
00C798  90002E     MOV [W14+4], W0
00C79A  9000BE     MOV [W14+6], W1
00C79C  0225A4     CALL ___lesf2
00C79E  000000     NOP
00C7A0  EB0080     CLR W1
00C7A2  500F81     SUB W0, W1, [W15]
00C7A4  350001     BRA LT, 0xC7A8
00C7A6  EB4400     CLR.B W8
00C7A8  EB4000     CLR.B W0
00C7AA  544F80     SUB.B W8, W0, [W15]
00C7AC  320003     BRA Z, 0xC7B4
92:                        duty_cycle = DC_LOWER_LIMIT;
00C7AE  B80060     MUL.UU W0, #0, W0
00C7B0  980720     MOV W0, [W14+4]
00C7B2  980731     MOV W1, [W14+6]
93:                    }
94:                    
95:                    pdc_value = (unsigned int)(2*duty_cycle*pwmPeriod);
00C7B4  90002E     MOV [W14+4], W0
00C7B6  9000BE     MOV [W14+6], W1
00C7B8  BE0100     MOV.D W0, W2
00C7BA  022A6C     CALL ___addsf3
00C7BC  000000     NOP
00C7BE  BE0400     MOV.D W0, W8
00C7C0  811100     MOV _pwmPeriod, W0
00C7C2  200001     MOV #0x0, W1
00C7C4  022640     CALL ___floatunsisf
00C7C6  000000     NOP
00C7C8  BE0100     MOV.D W0, W2
00C7CA  BE0008     MOV.D W8, W0
00C7CC  022C36     CALL ___mulsf3
00C7CE  000000     NOP
00C7D0  0225EE     CALL ___fixunssfsi
00C7D2  000000     NOP
00C7D4  780F00     MOV W0, [W14]
96:                    SetDCMCPWM(channel, pdc_value, 0);
00C7D6  90402E     MOV.B [W14+2], W0
00C7D8  FB8000     ZE W0, W0
00C7DA  EB4100     CLR.B W2
00C7DC  78009E     MOV [W14], W1
00C7DE  022436     CALL _SetDCMCPWM
00C7E0  000000     NOP
00C7E2  370001     BRA 0xC7E6
97:                
98:                }
00C7E6  BE044F     MOV.D [--W15], W8
00C7E8  FA8000     ULNK
00C7EA  060000     RETURN
99:                
100:               void mcThrust(float value) {
00C7EC  FA0004     LNK #0x4
00C7EE  BE8F00     MOV.D W0, [W14]
101:               
102:                   mcSetDutyCycle(MC_CHANNEL_PWM1, value);
00C7F0  BE011E     MOV.D [W14], W2
00C7F2  B3C010     MOV #0x1, W0
00C7F4  07FFB2     RCALL mcSetDutyCycle
103:               
104:               }
00C7F6  FA8000     ULNK
00C7F8  060000     RETURN
105:               
106:               void mcSteer(float value) {
00C7FA  FA0004     LNK #0x4
00C7FC  781F88     MOV W8, [W15++]
00C7FE  BE8F00     MOV.D W0, [W14]
107:               
108:                   if (steerMode == MC_STEER_MODE_CONT) {
00C800  811151     MOV 0x222A, W1
00C802  200010     MOV #0x1, W0
00C804  508F80     SUB W1, W0, [W15]
00C806  3A002D     BRA NZ, 0xC862
109:                       if (value > 0) {
00C808  B3C018     MOV #0x1, W8
00C80A  B81160     MUL.UU W2, #0, W2
00C80C  BE001E     MOV.D [W14], W0
00C80E  0225A8     CALL ___gtsf2
00C810  000000     NOP
00C812  EB0080     CLR W1
00C814  500F81     SUB W0, W1, [W15]
00C816  3C0001     BRA GT, 0xC81A
00C818  EB4400     CLR.B W8
00C81A  EB4000     CLR.B W0
00C81C  544F80     SUB.B W8, W0, [W15]
00C81E  320007     BRA Z, 0xC82E
110:                           mcSetDutyCycle(RIGHT_TURN_CHANNEL, 0);
00C820  B81160     MUL.UU W2, #0, W2
00C822  B3C030     MOV #0x3, W0
00C824  07FF9A     RCALL mcSetDutyCycle
111:                           mcSetDutyCycle(LEFT_TURN_CHANNEL, value);
00C826  BE011E     MOV.D [W14], W2
00C828  B3C020     MOV #0x2, W0
00C82A  07FF97     RCALL mcSetDutyCycle
00C82C  37003E     BRA 0xC8AA
112:                       } else if (value < 0) {
00C82E  B3C018     MOV #0x1, W8
00C830  B81160     MUL.UU W2, #0, W2
00C832  BE001E     MOV.D [W14], W0
00C834  0225A4     CALL ___lesf2
00C836  000000     NOP
00C838  EB0080     CLR W1
00C83A  500F81     SUB W0, W1, [W15]
00C83C  350001     BRA LT, 0xC840
00C83E  EB4400     CLR.B W8
00C840  EB4000     CLR.B W0
00C842  544F80     SUB.B W8, W0, [W15]
00C844  320009     BRA Z, 0xC858
113:                           mcSetDutyCycle(LEFT_TURN_CHANNEL, 0);
00C846  B81160     MUL.UU W2, #0, W2
00C848  B3C020     MOV #0x2, W0
00C84A  07FF87     RCALL mcSetDutyCycle
114:                           mcSetDutyCycle(RIGHT_TURN_CHANNEL, -value);
00C84C  BE001E     MOV.D [W14], W0
00C84E  A2F001     BTG W1, #15
00C850  BE0100     MOV.D W0, W2
00C852  B3C030     MOV #0x3, W0
00C854  07FF82     RCALL mcSetDutyCycle
00C856  370029     BRA 0xC8AA
115:                       } else {
116:                           PDC2 = 0;
00C858  EB0000     CLR W0
00C85A  880EC0     MOV W0, PDC2
117:                           PDC3 = 0;
00C85C  EB0000     CLR W0
00C85E  880ED0     MOV W0, PDC3
00C860  370024     BRA 0xC8AA
118:                       }
119:               
120:                   } else {
121:                       if (value > 0) { 
00C862  B3C018     MOV #0x1, W8
00C864  B81160     MUL.UU W2, #0, W2
00C866  BE001E     MOV.D [W14], W0
00C868  0225A8     CALL ___gtsf2
00C86A  000000     NOP
00C86C  EB0080     CLR W1
00C86E  500F81     SUB W0, W1, [W15]
00C870  3C0001     BRA GT, 0xC874
00C872  EB4400     CLR.B W8
00C874  EB4000     CLR.B W0
00C876  544F80     SUB.B W8, W0, [W15]
00C878  320005     BRA Z, 0xC884
122:                           NO_TURN;
00C87A  A942DC     BCLR LATE, #2
00C87C  A982DC     BCLR LATE, #4
123:                           RIGHT_TURN;
00C87E  A942DC     BCLR LATE, #2
00C880  A882DC     BSET LATE, #4
00C882  370013     BRA 0xC8AA
124:                       } else if (value < 0) { 
00C884  B3C018     MOV #0x1, W8
00C886  B81160     MUL.UU W2, #0, W2
00C888  BE001E     MOV.D [W14], W0
00C88A  0225A4     CALL ___lesf2
00C88C  000000     NOP
00C88E  EB0080     CLR W1
00C890  500F81     SUB W0, W1, [W15]
00C892  350001     BRA LT, 0xC896
00C894  EB4400     CLR.B W8
00C896  EB4000     CLR.B W0
00C898  544F80     SUB.B W8, W0, [W15]
00C89A  320005     BRA Z, 0xC8A6
125:                           NO_TURN;
00C89C  A942DC     BCLR LATE, #2
00C89E  A982DC     BCLR LATE, #4
126:                           LEFT_TURN;
00C8A0  A842DC     BSET LATE, #2
00C8A2  A982DC     BCLR LATE, #4
00C8A4  370002     BRA 0xC8AA
127:                       } else { 
128:                           NO_TURN;
00C8A6  A942DC     BCLR LATE, #2
00C8A8  A982DC     BCLR LATE, #4
129:                       }
130:                   }
131:               
132:               }
00C8AA  78044F     MOV [--W15], W8
00C8AC  FA8000     ULNK
00C8AE  060000     RETURN
133:               
134:               
135:               void mcSetSteerMode(McSteerMode mode) {
00C8B0  FA0002     LNK #0x2
00C8B2  780F00     MOV W0, [W14]
136:               
137:                   if (mode == MC_STEER_DISC) {
00C8B4  78009E     MOV [W14], W1
00C8B6  EB0000     CLR W0
00C8B8  508F80     SUB W1, W0, [W15]
00C8BA  3A0005     BRA NZ, 0xC8C6
138:                       steerMode = MC_STEER_DISC;
00C8BC  EB0000     CLR W0
00C8BE  891150     MOV W0, 0x222A
139:                       // PWM2L & PWM3L pins are general I/O
140:                       PWMCON1bits.PEN2L = 0;
00C8C0  A921C8     BCLR PWMCON1, #1
141:                       PWMCON1bits.PEN3L = 0;
00C8C2  A941C8     BCLR PWMCON1, #2
00C8C4  370004     BRA 0xC8CE
142:                   } else {
143:                       steerMode = MC_STEER_CONT;
00C8C6  200010     MOV #0x1, W0
00C8C8  891150     MOV W0, 0x222A
144:                       // PWM2L & PWM3L pins are enabled for PWM output
145:                       PWMCON1bits.PEN2L = 1;
00C8CA  A821C8     BSET PWMCON1, #1
146:                       PWMCON1bits.PEN3L = 1;
00C8CC  A841C8     BSET PWMCON1, #2
147:                   }
148:               
149:               }
00C8CE  FA8000     ULNK
00C8D0  060000     RETURN
150:               
151:               static void mcSetupPeripheral(void) {    
00C8D2  FA0000     LNK #0x0
152:                   
153:                   ConfigIntMCPWM(PWM_INT_DIS & PWM_FLTA_DIS_INT & PWM_FLTB_DIS_INT);
00C8D4  2F7770     MOV #0xF777, W0
00C8D6  0223D4     CALL _ConfigIntMCPWM
00C8D8  000000     NOP
154:                   
155:                   PDC1 = 0;   // duty cycle = 0
00C8DA  EB0000     CLR W0
00C8DC  880EB0     MOV W0, PDC1
156:                   PDC2 = 0;   // duty cycle = 0
00C8DE  EB0000     CLR W0
00C8E0  880EC0     MOV W0, PDC2
157:                   PDC3 = 0;   // duty cycle = 0
00C8E2  EB0000     CLR W0
00C8E4  880ED0     MOV W0, PDC3
158:                   PDC4 = 0;   // duty cycle = 0
00C8E6  EB0000     CLR W0
00C8E8  880EE0     MOV W0, PDC4
159:                   
160:                   PTPER = pwmPeriod;
00C8EA  811100     MOV _pwmPeriod, W0
00C8EC  880E20     MOV W0, PTPER
161:               
162:                   SEVTCMP = 620; // Special Event Trigger Compare Value for ADC in phase with PWM
00C8EE  2026C0     MOV #0x26C, W0
00C8F0  880E30     MOV W0, SEVTCMP
163:               
164:                   PWMCON1bits.PMOD1 = 1;
00C8F2  A801C9     BSET 0x1C9, #0
165:                   PWMCON1bits.PMOD2 = 1;
00C8F4  A821C9     BSET 0x1C9, #1
166:                   PWMCON1bits.PMOD3 = 1;
00C8F6  A841C9     BSET 0x1C9, #2
167:                   PWMCON1bits.PMOD4 = 0;
00C8F8  A961C9     BCLR 0x1C9, #3
168:               
169:                   PWMCON1bits.PEN1H = 0;
00C8FA  A981C8     BCLR PWMCON1, #4
170:                   PWMCON1bits.PEN2H = 0;
00C8FC  A9A1C8     BCLR PWMCON1, #5
171:                   PWMCON1bits.PEN3H = 0;
00C8FE  A9C1C8     BCLR PWMCON1, #6
172:                   PWMCON1bits.PEN4H = 0;
00C900  A9E1C8     BCLR PWMCON1, #7
173:                   PWMCON1bits.PEN1L = 1;
00C902  A801C8     BSET PWMCON1, #0
174:                   PWMCON1bits.PEN2L = 1;
00C904  A821C8     BSET PWMCON1, #1
175:                   PWMCON1bits.PEN3L = 1;
00C906  A841C8     BSET PWMCON1, #2
176:                   PWMCON1bits.PEN4L = 0;
00C908  A961C8     BCLR PWMCON1, #3
177:               
178:                   PWMCON2bits.SEVOPS = 0; // postscale 1:1
00C90A  800E51     MOV PWMCON2, W1
00C90C  2F0FF0     MOV #0xF0FF, W0
00C90E  608000     AND W1, W0, W0
00C910  880E50     MOV W0, PWMCON2
179:                   PWMCON2bits.OSYNC = 0;
00C912  A921CA     BCLR PWMCON2, #1
180:                   PWMCON2bits.IUE = 0;
00C914  A941CA     BCLR PWMCON2, #2
181:               
182:                   PTCONbits.PTMOD = 0; // Free running mode
00C916  800E01     MOV PTCON, W1
00C918  2FFFC0     MOV #0xFFFC, W0
00C91A  608000     AND W1, W0, W0
00C91C  880E00     MOV W0, PTCON
183:                   PTCONbits.PTOPS = 0; // postscale 1:1
00C91E  800E01     MOV PTCON, W1
00C920  2FF0F0     MOV #0xFF0F, W0
00C922  608000     AND W1, W0, W0
00C924  880E00     MOV W0, PTCON
184:                   PTCONbits.PTCKPS = 0b11; // postscale 1:64
00C926  800E00     MOV PTCON, W0
00C928  B300C0     IOR #0xC, W0
00C92A  880E00     MOV W0, PTCON
185:                   PTCONbits.PTSIDL = 0; // runs in CPU idle mode
00C92C  A9A1C1     BCLR 0x1C1, #5
186:                   PTCONbits.PTEN = 1;
00C92E  A8E1C1     BSET 0x1C1, #7
187:               
188:               }
00C930  FA8000     ULNK
00C932  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/main.c  ---------------------------------------------------
1:                 /*
2:                  * Copyright (c) 2010-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * iBird Main Loop
31:                 *
32:                 * by Stan Baek
33:                 * 
34:                 * Description:
35:                 *    Main processing loop for iBird ornithopter platform
36:                 *
37:                 * v.0.4
38:                 *
39:                 * Revisions:
40:                 *  Stan Baek           2010-07-08      Initial implementation
41:                 *  Humphrey Hu         2011-06-12      Changed to interleaved controller
42:                 *  Humphrey Hu         2011-10-26      Changed to asynchronous camera capture                    
43:                 *  Humphrey Hu         2012-07-01      Background/foreground processes
44:                 */
45:                
46:                // TODO: Slotted LED strobing
47:                // TODO: Obstacle avoidance
48:                // TODO: Directories and telemetry broadcasts
49:                
50:                // ==== REFERENCES =============================================
51:                // Utils
52:                #include "counter.h"
53:                #include "directory.h"
54:                #include "utils.h"
55:                #include "telemetry.h"
56:                #include "sys_clock.h"
57:                #include "battery.h"
58:                #include "carray.h"
59:                #include "ppool.h"
60:                
61:                // Software Modules
62:                #include "cmd.h"
63:                #include "cv.h"
64:                #include "regulator.h"
65:                #include "attitude.h"
66:                #include "net.h"
67:                #include "clock_sync.h"
68:                
69:                // Device Drivers
70:                #include "init_default.h"
71:                #include "led.h"
72:                #include "timer.h"
73:                #include "cam.h"
74:                #include "xl.h"
75:                #include "gyro.h"
76:                #include "dfmem.h"
77:                #include "radio.h"
78:                #include "spi_controller.h"
79:                #include "adc_pid.h"
80:                #include "hall.h"
81:                
82:                // Other utilities
83:                #include "larray.h"
84:                #include "bams.h"
85:                #include "ports.h"
86:                #include <math.h>
87:                #include <stdlib.h>
88:                #include <string.h>
89:                
90:                // ==== CONSTANTS =============================================
91:                #define FCY                         (40000000)  // 40 MIPS   
92:                #define REGULATOR_FCY               (500)       // 300 Hz
93:                #define RADIO_FCY                   (200)       // 200 Hz
94:                #define RADIO_TX_QUEUE_SIZE         (40)        // 40 Outgoing
95:                #define RADIO_RX_QUEUE_SIZE         (40)        // 40 Incoming
96:                
97:                #define DIRECTORY_SIZE              (20)        // Network size
98:                #define NUM_CAM_FRAMES              (1)         // Camera driver frames
99:                #define TELEM_SUBSAMPLE             (1)         // Telemetry subsample default
100:               
101:               // ==== FUNCTION STUBS =========================================
102:               static void processRadioBuffer(void);
103:               
104:               static void setupAll(void);
105:               static void setRandomSeed(void);
106:               static void attemptNetworkConfig(void);
107:               static void attemptClockSync(void);
108:               
109:               static void batteryLowCallback(void);
110:               
111:               static void setupTimer5(unsigned int per);
112:               static void setupTimer6(unsigned int per);
113:               void _T5Interrupt(void);
114:               void _T6Interrupt(void);
115:               
116:               // ==== STATIC VARIABLES =======================================
117:               static CamFrameStruct cam_frames[NUM_CAM_FRAMES];
118:               
119:               // ==== FUNCTION BODIES ========================================
120:               int main(void) {
00BDEA  FA000C     LNK #0xC
121:                
122:                   unsigned long prev_millis, now;
123:                   unsigned int phase;
124:                   unsigned char led_state;    
125:               
126:                   prev_millis = 0;
00BDEC  B80060     MUL.UU W0, #0, W0
00BDEE  980710     MOV W0, [W14+2]
00BDF0  980721     MOV W1, [W14+4]
127:                   led_state = 0;    
00BDF2  EB4000     CLR.B W0
00BDF4  784F00     MOV.B W0, [W14]
128:               
129:                   setupAll();    
00BDF6  07003F     RCALL setupAll
00BDF8  370003     BRA 0xBE00
130:               
131:                   // Non-time-critical background tasks
132:                   while(1) {
133:                   
134:                       processRadioBuffer();
00BE00  070025     RCALL processRadioBuffer
135:                       cmdProcessBuffer();            
00BE02  024CC0     CALL cmdProcessBuffer
00BE04  000000     NOP
136:               
137:                       now = sclockGetGlobalMillis();
00BE06  02DE40     CALL sclockGetGlobalMillis
00BE08  000000     NOP
00BE0A  980730     MOV W0, [W14+6]
00BE0C  980741     MOV W1, [W14+8]
138:                       phase = now % 2000;
00BE0E  90003E     MOV [W14+6], W0
00BE10  9000CE     MOV [W14+8], W1
00BE12  207D02     MOV #0x7D0, W2
00BE14  200003     MOV #0x0, W3
00BE16  022E1C     CALL ___umodsi3
00BE18  000000     NOP
00BE1A  980750     MOV W0, [W14+10]
139:               
140:                       // Blink LED at 1 Hz
141:                       if(phase > 1000 && led_state == 0) {
00BE1C  9000DE     MOV [W14+10], W1
00BE1E  203E80     MOV #0x3E8, W0
00BE20  508F80     SUB W1, W0, [W15]
00BE22  360008     BRA LEU, 0xBE34
00BE24  78409E     MOV.B [W14], W1
00BE26  EB4000     CLR.B W0
00BE28  50CF80     SUB.B W1, W0, [W15]
00BE2A  3A0004     BRA NZ, 0xBE34
142:                           LED_GREEN = 1;            
00BE2C  A8A2CB     BSET 0x2CB, #5
143:                           led_state = 1;
00BE2E  B3C010     MOV #0x1, W0
00BE30  784F00     MOV.B W0, [W14]
144:                       } else if(phase < 1000 && led_state == 1) {
00BE34  9000DE     MOV [W14+10], W1
00BE36  203E70     MOV #0x3E7, W0
00BE38  508F80     SUB W1, W0, [W15]
00BE3A  3EFFDF     BRA GTU, 0xBDFA
00BE3C  78409E     MOV.B [W14], W1
00BE3E  B3C010     MOV #0x1, W0
00BE40  50CF80     SUB.B W1, W0, [W15]
00BE42  3AFFDD     BRA NZ, 0xBDFE
145:                           LED_GREEN = 0;            
00BE44  A9A2CB     BCLR 0x2CB, #5
146:                           led_state = 0;
00BE46  EB4000     CLR.B W0
00BE48  784F00     MOV.B W0, [W14]
147:                       }
148:               
149:                   }
00BDFA  000000     NOP
00BDFC  370001     BRA 0xBE00
00BDFE  000000     NOP
00BE32  37FFE6     BRA 0xBE00
00BE4A  37FFDA     BRA 0xBE00
150:               
151:               } // End main
152:               
153:               void processRadioBuffer(void) {
00BE4C  FA0002     LNK #0x2
154:               
155:                   MacPacket packet;
156:                   
157:                   packet = radioDequeueRxPacket();
00BE4E  02811C     CALL radioDequeueRxPacket
00BE50  000000     NOP
00BE52  780F00     MOV W0, [W14]
158:                   if(packet == NULL) { return; }
00BE54  78009E     MOV [W14], W1
00BE56  EB0000     CLR W0
00BE58  508F80     SUB W1, W0, [W15]
00BE5A  32000A     BRA Z, 0xBE70
00BE70  000000     NOP
159:               
160:                   // If enqueue fails, clean up packet
161:                   if(cmdQueuePacket(packet) == 0) {
00BE5C  78001E     MOV [W14], W0
00BE5E  024CB0     CALL cmdQueuePacket
00BE60  000000     NOP
00BE62  EB0080     CLR W1
00BE64  500F81     SUB W0, W1, [W15]
00BE66  3A0005     BRA NZ, 0xBE72
162:                       radioReturnPacket(packet);
00BE68  78001E     MOV [W14], W0
00BE6A  028240     CALL radioReturnPacket
00BE6C  000000     NOP
00BE6E  370001     BRA 0xBE72
163:                   }
164:               
165:               }
00BE72  FA8000     ULNK
00BE74  060000     RETURN
166:               
167:               // Set up hardware and software
168:               void setupAll(void) {
00BE76  FA0000     LNK #0x0
169:               
170:                   unsigned int i;    
171:               
172:                   SetupClock();   // Setup clock and ports
00BE78  02E118     CALL SetupClock
00BE7A  000000     NOP
173:                   SwitchClocks();
00BE7C  02E138     CALL SwitchClocks
00BE7E  000000     NOP
174:                   SetupPorts();
00BE80  02E14C     CALL SetupPorts
00BE82  000000     NOP
175:               
176:                   sclockSetup();                          // System clock
00BE84  02DE0A     CALL sclockSetup
00BE86  000000     NOP
177:                   batSetup();                             // Battery monitor
00BE88  02DB68     CALL batSetup
00BE8A  000000     NOP
178:                   batSetCallback(&batteryLowCallback);    // Set battery event callback
00BE8C  2BFBA0     MOV #0xBFBA, W0
00BE8E  02DB74     CALL batSetCallback
00BE90  000000     NOP
179:                   ppoolInit();
00BE92  02B83C     CALL ppoolInit
00BE94  000000     NOP
180:                   // Set up peripherals
181:                   // Note: OV7660 I2C operates at 100 kHz on the same bus
182:                   // as the accelerometer. Make sure to set up camera module first!
183:                   dfmemSetup();                           // Flash memory device
00BE96  027988     CALL dfmemSetup
00BE98  000000     NOP
184:                   //camSetup(cam_frames, NUM_CAM_FRAMES);   // Camera device
185:                   
186:                   // Accelerometer setup
187:                   //xlSetup();
188:                   //xlSetRange(16);                         // +- 16 g range
189:                   //xlSetOutputRate(0, 0x0c);               // 800 Hz
190:                   
191:                   gyroSetup();
00BE9A  0293F0     CALL gyroSetup
00BE9C  000000     NOP
192:                   gyroSetDeadZone(25);
00BE9E  200190     MOV #0x19, W0
00BEA0  02942A     CALL gyroSetDeadZone
00BEA2  000000     NOP
193:               
194:                   
195:                   LED_GREEN = 1; // CPU, sensors initialization clear
00BEA4  A8A2CB     BSET 0x2CB, #5
196:                   
197:                   setRandomSeed();                // Seeds random number generation using IMU sensors
00BEA6  07003D     RCALL setRandomSeed
198:                   cmdSetup(RADIO_RX_QUEUE_SIZE);  // Command packet processing module
00BEA8  200280     MOV #0x28, W0
00BEAA  024BBA     CALL cmdSetup
00BEAC  000000     NOP
199:                   radioInit(RADIO_TX_QUEUE_SIZE, RADIO_RX_QUEUE_SIZE);    
00BEAE  200281     MOV #0x28, W1
00BEB0  200280     MOV #0x28, W0
00BEB2  02801A     CALL radioInit
00BEB4  000000     NOP
200:                   setupTimer6(RADIO_FCY); // Radio and buffer loop timer
00BEB6  200C80     MOV #0xC8, W0
00BEB8  0700C1     RCALL setupTimer6
201:                   netSetup(DIRECTORY_SIZE); // Networking module
00BEBA  200140     MOV #0x14, W0
00BEBC  02C2AE     CALL netSetup
00BEBE  000000     NOP
202:                   attemptNetworkConfig();
00BEC0  07004E     RCALL attemptNetworkConfig
203:                   radioSetSrcAddr(netGetLocalAddress());
00BEC2  02C316     CALL netGetLocalAddress
00BEC4  000000     NOP
00BEC6  02808E     CALL radioSetSrcAddr
00BEC8  000000     NOP
204:                   radioSetSrcPanID(netGetLocalPanID());    
00BECA  02C31E     CALL netGetLocalPanID
00BECC  000000     NOP
00BECE  0280A8     CALL radioSetSrcPanID
00BED0  000000     NOP
205:               
206:                   //clksyncSetup();
207:                   //clksyncSetMasterAddr(DEFAULT_SYNC_ADDR, DEFAULT_SYNC_PAN);
208:                   //attemptClockSync();
209:                   
210:                   LED_ORANGE = 1; // Communications initialization clear
00BED2  A8C2CB     BSET 0x2CB, #6
211:                   
212:                   adcSetup();
00BED4  02DD36     CALL adcSetup
00BED6  000000     NOP
213:                   hallSetup();
00BED8  026482     CALL hallSetup
00BEDA  000000     NOP
214:                   telemSetup();                   // Telemetry logger
00BEDC  02B53C     CALL telemSetup
00BEDE  000000     NOP
215:                   telemSetSubsampleRate(TELEM_SUBSAMPLE);
00BEE0  200010     MOV #0x1, W0
00BEE2  02B5A8     CALL telemSetSubsampleRate
00BEE4  000000     NOP
216:                   rgltrSetup(1.0/REGULATOR_FCY);  // Control module
00BEE6  2126F0     MOV #0x126F, W0
00BEE8  23B031     MOV #0x3B03, W1
00BEEA  023ECE     CALL rgltrSetup
00BEEC  000000     NOP
217:                   rgltrSetOff();
00BEEE  024038     CALL rgltrSetOff
00BEF0  000000     NOP
218:                   rgltrStartLogging();    
00BEF2  024320     CALL rgltrStartLogging
00BEF4  000000     NOP
219:                   setupTimer5(REGULATOR_FCY);     // Control loop timer
00BEF6  201F40     MOV #0x1F4, W0
00BEF8  07008B     RCALL setupTimer5
220:                   //cvSetup();                      // Vision module
221:               
222:                   LED_RED = 1; // Third stage initialization clear
00BEFA  A882CB     BSET 0x2CB, #4
223:               
224:                   delay_ms(500);
00BEFC  201F40     MOV #0x1F4, W0
00BEFE  02E270     CALL msELAPSED
00BF00  000000     NOP
225:               
226:                   LED_RED = 0;
00BF02  A982CB     BCLR 0x2CB, #4
227:                   LED_GREEN = 0;
00BF04  A9A2CB     BCLR 0x2CB, #5
228:                   LED_ORANGE = 0;
00BF06  A9C2CB     BCLR 0x2CB, #6
229:               
230:                   DisableIntT6;
00BF08  A9E099     BCLR 0x99, #7
231:                   //camStart();     // Start camera capture
232:                   attStart();     // Start attitude estimation 
00BF0A  028B2A     CALL attStart
00BF0C  000000     NOP
233:                   EnableIntT5;    // Start control loop
00BF0E  A88097     BSET 0x97, #4
234:                   EnableIntT6;
00BF10  A8E099     BSET 0x99, #7
235:               
236:                   radioSetWatchdogState(1);
00BF12  B3C010     MOV #0x1, W0
00BF14  0280FE     CALL radioSetWatchdogState
00BF16  000000     NOP
237:                   radioSetWatchdogTime(400);
00BF18  201900     MOV #0x190, W0
00BF1A  02810E     CALL radioSetWatchdogTime
00BF1C  000000     NOP
238:                   
239:               }
00BF1E  FA8000     ULNK
00BF20  060000     RETURN
240:               
241:               /**
242:                * Seeds the system pseudo-random number generator using the IMU sensors
243:                */
244:               static void setRandomSeed(void) {
00BF22  FA000E     LNK #0xE
245:               
246:                   unsigned int seed;
247:                   int xlData[3], gyroData[3];
248:               
249:                   xlGetXYZ((unsigned char*) xlData);
00BF24  E8800E     INC2 W14, W0
00BF26  02B4A8     CALL xlGetXYZ
00BF28  000000     NOP
250:                   gyroGetXYZ((unsigned char*) gyroData);
00BF2A  470068     ADD W14, #0x8, W0
00BF2C  0297B4     CALL gyroGetXYZ
00BF2E  000000     NOP
251:                   seed = xlData[0] ^ xlData[1] ^ xlData[2] ^ gyroData[0] ^ gyroData[1]
00BF30  E8800E     INC2 W14, W0
00BF32  780090     MOV [W0], W1
00BF34  E8800E     INC2 W14, W0
00BF36  900010     MOV [W0+2], W0
00BF38  688080     XOR W1, W0, W1
00BF3A  E8800E     INC2 W14, W0
00BF3C  900020     MOV [W0+4], W0
00BF3E  688080     XOR W1, W0, W1
00BF40  470068     ADD W14, #0x8, W0
00BF42  780010     MOV [W0], W0
00BF44  688080     XOR W1, W0, W1
00BF46  470068     ADD W14, #0x8, W0
00BF48  900010     MOV [W0+2], W0
00BF4A  688080     XOR W1, W0, W1
00BF52  780F00     MOV W0, [W14]
252:                           ^ gyroData[2];
00BF4C  470068     ADD W14, #0x8, W0
00BF4E  900020     MOV [W0+4], W0
00BF50  688000     XOR W1, W0, W0
253:                   srand(seed);
00BF54  78001E     MOV [W14], W0
00BF56  0235C2     CALL _srand
00BF58  000000     NOP
254:                   
255:               }
00BF5A  FA8000     ULNK
00BF5C  060000     RETURN
256:               
257:               static void attemptNetworkConfig(void) {
00BF5E  FA0000     LNK #0x0
258:               
259:                   radioSetWatchdogState(1);
00BF60  B3C010     MOV #0x1, W0
00BF62  0280FE     CALL radioSetWatchdogState
00BF64  000000     NOP
260:                   radioSetWatchdogTime(2000);
00BF66  207D00     MOV #0x7D0, W0
00BF68  02810E     CALL radioSetWatchdogTime
00BF6A  000000     NOP
261:                   
262:                   while(!netAddressReceived()) {
00BF6C  370008     BRA 0xBF7E
00BF7E  02C336     CALL netAddressReceived
00BF80  000000     NOP
00BF82  EB4080     CLR.B W1
00BF84  504F81     SUB.B W0, W1, [W15]
00BF86  32FFF3     BRA Z, 0xBF6E
263:                       netRequestAddress();        
00BF6E  02C358     CALL netRequestAddress
00BF70  000000     NOP
264:                       delay_ms(300);
00BF72  2012C0     MOV #0x12C, W0
00BF74  02E270     CALL msELAPSED
00BF76  000000     NOP
265:                       processRadioBuffer();
00BF78  07FF69     RCALL processRadioBuffer
266:                       cmdProcessBuffer();
00BF7A  024CC0     CALL cmdProcessBuffer
00BF7C  000000     NOP
267:               
268:                   }
269:                   
270:               }
00BF88  FA8000     ULNK
00BF8A  060000     RETURN
271:               
272:               static void attemptClockSync(void) {
00BF8C  FA0000     LNK #0x0
273:               
274:                   radioSetWatchdogState(1);
00BF8E  B3C010     MOV #0x1, W0
00BF90  0280FE     CALL radioSetWatchdogState
00BF92  000000     NOP
275:                   radioSetWatchdogTime(300);
00BF94  2012C0     MOV #0x12C, W0
00BF96  02810E     CALL radioSetWatchdogTime
00BF98  000000     NOP
276:                   
277:                   while(!clksyncIsDone()) {
00BF9A  370008     BRA 0xBFAC
00BFAC  02A8A2     CALL clksyncIsDone
00BFAE  000000     NOP
00BFB0  EB4080     CLR.B W1
00BFB2  504F81     SUB.B W0, W1, [W15]
00BFB4  32FFF3     BRA Z, 0xBF9C
278:                       clksyncSync();        
00BF9C  02A88C     CALL clksyncSync
00BF9E  000000     NOP
279:                       delay_ms(50);
00BFA0  200320     MOV #0x32, W0
00BFA2  02E270     CALL msELAPSED
00BFA4  000000     NOP
280:                       processRadioBuffer();
00BFA6  07FF52     RCALL processRadioBuffer
281:                       cmdProcessBuffer();
00BFA8  024CC0     CALL cmdProcessBuffer
00BFAA  000000     NOP
282:               
283:                   }
284:               
285:               }
00BFB6  FA8000     ULNK
00BFB8  060000     RETURN
286:               
287:               static void batteryLowCallback(void) {
00BFBA  FA0000     LNK #0x0
288:               
289:                   //rgltrSetOff();
290:               
291:               }
00BFBC  FA8000     ULNK
00BFBE  060000     RETURN
292:               
293:               /**
294:                * Interrupt handler for Timer 5
295:                * Polls sensors, estimates attitude, and runs controller at
296:                * regular interval. This timer is the lowest priority with
297:                * the highest execution time. (20000 cycles)
298:                */
299:               void __attribute__((interrupt, no_auto_psv)) _T5Interrupt(void) {
00BFC0  F80036     PUSH RCOUNT
00BFC2  BE9F80     MOV.D W0, [W15++]
00BFC4  BE9F82     MOV.D W2, [W15++]
00BFC6  BE9F84     MOV.D W4, [W15++]
00BFC8  BE9F86     MOV.D W6, [W15++]
00BFCA  FA0000     LNK #0x0
300:                   
301:                   gyroReadXYZ();    
00BFCC  02976C     CALL gyroReadXYZ
00BFCE  000000     NOP
302:                   rgltrRunController();    
00BFD0  024366     CALL rgltrRunController
00BFD2  000000     NOP
303:                   telemLog();
00BFD4  02B61A     CALL telemLog
00BFD6  000000     NOP
304:                   telemProcess();    
00BFD8  02B6BE     CALL telemProcess
00BFDA  000000     NOP
305:                   telemStream();
00BFDC  02B67A     CALL telemStream
00BFDE  000000     NOP
306:                   
307:                   _T5IF = 0;
00BFE0  A98087     BCLR 0x87, #4
308:               
309:               }
00BFE2  FA8000     ULNK
00BFE4  BE034F     MOV.D [--W15], W6
00BFE6  BE024F     MOV.D [--W15], W4
00BFE8  BE014F     MOV.D [--W15], W2
00BFEA  BE004F     MOV.D [--W15], W0
00BFEC  F90036     POP RCOUNT
00BFEE  064000     RETFIE
310:               
311:               void __attribute__((interrupt, no_auto_psv)) _T6Interrupt(void) {
00BFF0  F80036     PUSH RCOUNT
00BFF2  BE9F80     MOV.D W0, [W15++]
00BFF4  BE9F82     MOV.D W2, [W15++]
00BFF6  BE9F84     MOV.D W4, [W15++]
00BFF8  BE9F86     MOV.D W6, [W15++]
00BFFA  FA0000     LNK #0x0
312:               
313:                   radioProcess();        
00BFFC  028276     CALL radioProcess
00BFFE  000000     NOP
314:                   _T6IF = 0;
00C000  A9E089     BCLR 0x89, #7
315:               
316:               }
00C002  FA8000     ULNK
00C004  BE034F     MOV.D [--W15], W6
00C006  BE024F     MOV.D [--W15], W4
00C008  BE014F     MOV.D [--W15], W2
00C00A  BE004F     MOV.D [--W15], W0
00C00C  F90036     POP RCOUNT
00C00E  064000     RETFIE
317:               
318:               /**
319:                * Control loop timer setup
320:                */
321:               static void setupTimer5(unsigned int fs) {
00C010  FA0006     LNK #0x6
00C012  980720     MOV W0, [W14+4]
322:               
323:                   unsigned int con_reg, period;
324:                   
325:                   con_reg =   T5_ON &         // Timer on
00C014  2FF9D0     MOV #0xFF9D, W0
00C016  780F00     MOV W0, [W14]
326:                               T5_IDLE_STOP &  // Stop timer when idle
327:                               T5_GATE_OFF &   // Gated mode off
328:                               T5_PS_1_8 &     // Prescale 1:8
329:                               T5_SOURCE_INT;  // Internal clock source
330:               
331:                   // period value = Fcy/(prescale*Ftimer)
332:                   period = FCY/(8*fs); 
00C018  90002E     MOV [W14+4], W0
00C01A  DD0043     SL W0, #3, W0
00C01C  200001     MOV #0x0, W1
00C01E  BE0100     MOV.D W0, W2
00C020  25A000     MOV #0x5A00, W0
00C022  202621     MOV #0x262, W1
00C024  022586     CALL ___divsi3
00C026  000000     NOP
00C028  980710     MOV W0, [W14+2]
333:               
334:                   OpenTimer5(con_reg, period);
00C02A  90009E     MOV [W14+2], W1
00C02C  78001E     MOV [W14], W0
00C02E  02254E     CALL _OpenTimer5
00C030  000000     NOP
335:                   ConfigIntTimer5(T5_INT_PRIOR_4 & T5_INT_OFF);
00C032  2FFF40     MOV #0xFFF4, W0
00C034  0224CA     CALL _ConfigIntTimer5
00C036  000000     NOP
336:               
337:               }
00C038  FA8000     ULNK
00C03A  060000     RETURN
338:               
339:               static void setupTimer6(unsigned int fs) {
00C03C  FA0006     LNK #0x6
00C03E  980720     MOV W0, [W14+4]
340:               
341:                   unsigned int con_reg, period;
342:               
343:                   con_reg =   T6_ON &         // Timer on
00C040  2FF950     MOV #0xFF95, W0
00C042  780F00     MOV W0, [W14]
344:                               T6_IDLE_STOP &  // Stop timer when idle
345:                               T6_GATE_OFF &   // Gated mode off
346:                               T6_PS_1_8 &     // Prescale 1:8
347:                               T6_SOURCE_INT &  // Internal clock source
348:                               T6_32BIT_MODE_OFF; // 16 bit mode
349:                   
350:                   // period value = Fcy/(prescale*Ftimer)
351:                   period = FCY/(8*fs);
00C044  90002E     MOV [W14+4], W0
00C046  DD0043     SL W0, #3, W0
00C048  200001     MOV #0x0, W1
00C04A  BE0100     MOV.D W0, W2
00C04C  25A000     MOV #0x5A00, W0
00C04E  202621     MOV #0x262, W1
00C050  022586     CALL ___divsi3
00C052  000000     NOP
00C054  980710     MOV W0, [W14+2]
352:               
353:                   OpenTimer6(con_reg, period);
00C056  90009E     MOV [W14+2], W1
00C058  78001E     MOV [W14], W0
00C05A  022556     CALL _OpenTimer6
00C05C  000000     NOP
354:                   ConfigIntTimer6(T6_INT_PRIOR_3 & T6_INT_ON);
00C05E  2FFFB0     MOV #0xFFFB, W0
00C060  0224EA     CALL _ConfigIntTimer6
00C062  000000     NOP
355:               
356:               }
00C064  FA8000     ULNK
00C066  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/lstrobe.c  ------------------------------------------------
1:                 /**
2:                  * Copyright (c) 2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * LED Strobe Timer
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu		2012-04-25		Initial implementation 
38:                 *                      
39:                 */
40:                
41:                #include "lstrobe.h"
42:                #include "led.h"
43:                #include "timer.h"
44:                #include "sys_clock.h"
45:                #include "cam.h"
46:                
47:                #define DEFAULT_ON_TIME         (0)
48:                #define DEFAULT_OFF_TIME        (0)
49:                 
50:                #define STROBE_ON               (1)
51:                #define STROBE_OFF              (0)
52:                #define STROBE                  (LED_IR)
53:                
54:                #define RUNS_BEFORE_CALIB       (50)
55:                
56:                typedef enum {
57:                    LT_ON = 0,
58:                    LT_OFF,
59:                    LT_PL,
60:                }LTimerState; 
61:                 
62:                static LTimerState state;
63:                static unsigned char is_ready = 0;
64:                static LStrobeParamStruct target;
65:                static unsigned int runs;
66:                
67:                static void phaseLock(LStrobeParam param);
68:                static void setupTimer3(void);
69:                
70:                void lstrobeSetup(void) {
00D82C  FA0000     LNK #0x0
71:                
72:                    setupTimer3();
00D82E  07007D     RCALL setupTimer3
73:                
74:                    STROBE = STROBE_ON;
00D830  A822DC     BSET LATE, #1
75:                    state = LT_OFF;
00D832  200010     MOV #0x1, W0
00D834  890E50     MOV W0, _state
76:                
77:                    runs = 0;
00D836  EB0000     CLR W0
00D838  890EB0     MOV W0, _runs
78:                    is_ready = 1;
00D83A  221CC1     MOV #0x21CC, W1
00D83C  B3C010     MOV #0x1, W0
00D83E  784880     MOV.B W0, [W1]
79:                    
80:                } 
00D840  FA8000     ULNK
00D842  060000     RETURN
81:                 
82:                void lstrobeSetParam(LStrobeParam param) {
00D844  FA0002     LNK #0x2
00D846  780F00     MOV W0, [W14]
83:                
84:                    target.period = param->period;
00D848  78001E     MOV [W14], W0
00D84A  780090     MOV [W0], W1
00D84C  221CE0     MOV #0x21CE, W0
00D84E  780801     MOV W1, [W0]
85:                    target.period_offset = param->period_offset;
00D850  78001E     MOV [W14], W0
00D852  900090     MOV [W0+2], W1
00D854  221CE0     MOV #0x21CE, W0
00D856  980011     MOV W1, [W0+2]
86:                    target.on_time = param->on_time;
00D858  78001E     MOV [W14], W0
00D85A  9000A0     MOV [W0+4], W1
00D85C  221CE0     MOV #0x21CE, W0
00D85E  980021     MOV W1, [W0+4]
87:                    target.off_time = param->off_time;
00D860  78001E     MOV [W14], W0
00D862  9000B0     MOV [W0+6], W1
00D864  221CE0     MOV #0x21CE, W0
00D866  980031     MOV W1, [W0+6]
88:                
89:                }
00D868  FA8000     ULNK
00D86A  060000     RETURN
90:                
91:                void lstrobeGetParam(LStrobeParam param) {
00D86C  FA0002     LNK #0x2
00D86E  780F00     MOV W0, [W14]
92:                
93:                    param->period = target.period;
00D870  221CE0     MOV #0x21CE, W0
00D872  780090     MOV [W0], W1
00D874  78001E     MOV [W14], W0
00D876  780801     MOV W1, [W0]
94:                    param->period_offset = target.period_offset;
00D878  221CE0     MOV #0x21CE, W0
00D87A  900090     MOV [W0+2], W1
00D87C  78001E     MOV [W14], W0
00D87E  980011     MOV W1, [W0+2]
95:                    param->on_time = target.on_time;
00D880  221CE0     MOV #0x21CE, W0
00D882  9000A0     MOV [W0+4], W1
00D884  78001E     MOV [W14], W0
00D886  980021     MOV W1, [W0+4]
96:                    param->off_time = param->off_time;
00D888  78001E     MOV [W14], W0
00D88A  9000B0     MOV [W0+6], W1
00D88C  78001E     MOV [W14], W0
00D88E  980031     MOV W1, [W0+6]
97:                
98:                }
00D890  FA8000     ULNK
00D892  060000     RETURN
99:                
100:               void lstrobeStart(void) {
00D894  FA0000     LNK #0x0
101:               
102:                   if(!is_ready) { return; }
00D896  221CC0     MOV #0x21CC, W0
00D898  784090     MOV.B [W0], W1
00D89A  EB4000     CLR.B W0
00D89C  50CF80     SUB.B W1, W0, [W15]
00D89E  320003     BRA Z, 0xD8A6
00D8A6  000000     NOP
103:                   phaseLock(&target);
00D8A0  221CE0     MOV #0x21CE, W0
00D8A2  070027     RCALL phaseLock
00D8A4  370001     BRA 0xD8A8
104:                   
105:                   
106:               }
00D8A8  FA8000     ULNK
00D8AA  060000     RETURN
107:                
108:               // ====== Private Functions ===================================================
109:                
110:               void __attribute__((interrupt, no_auto_psv)) _T3Interrupt(void) {
00D8AC  BE9F80     MOV.D W0, [W15++]
00D8AE  FA0000     LNK #0x0
111:               
112:                   if(state == LT_PL) {
00D8B0  810E51     MOV _state, W1
00D8B2  200020     MOV #0x2, W0
00D8B4  508F80     SUB W1, W0, [W15]
00D8B6  3A0002     BRA NZ, 0xD8BC
113:                       state = LT_OFF; // Once synchronized, proceed to OFF state immediately
00D8B8  200010     MOV #0x1, W0
00D8BA  890E50     MOV W0, _state
114:                   }
115:               
116:                   if(state == LT_ON) {
00D8BC  810E51     MOV _state, W1
00D8BE  EB0000     CLR W0
00D8C0  508F80     SUB W1, W0, [W15]
00D8C2  3A0008     BRA NZ, 0xD8D4
117:                       STROBE = STROBE_OFF;
00D8C4  A922DC     BCLR LATE, #1
118:                       LED_RED = 0;
00D8C6  A982CB     BCLR 0x2CB, #4
119:                       PR3 = target.off_time;
00D8C8  221CE0     MOV #0x21CE, W0
00D8CA  900030     MOV [W0+6], W0
00D8CC  880870     MOV W0, PR3
120:                       state = LT_OFF;
00D8CE  200010     MOV #0x1, W0
00D8D0  890E50     MOV W0, _state
00D8D2  37000B     BRA 0xD8EA
121:               
122:                   } else if(state == LT_OFF) {
00D8D4  810E51     MOV _state, W1
00D8D6  200010     MOV #0x1, W0
00D8D8  508F80     SUB W1, W0, [W15]
00D8DA  3A0007     BRA NZ, 0xD8EA
123:                       STROBE = STROBE_ON;
00D8DC  A822DC     BSET LATE, #1
124:                       LED_RED = 1;
00D8DE  A882CB     BSET 0x2CB, #4
125:                       PR3 = target.on_time;
00D8E0  221CE0     MOV #0x21CE, W0
00D8E2  900020     MOV [W0+4], W0
00D8E4  880870     MOV W0, PR3
126:                       state = LT_ON;
00D8E6  EB0000     CLR W0
00D8E8  890E50     MOV W0, _state
127:                   } 
128:               
129:                   _T3IF = 0;
00D8EA  A90085     BCLR 0x85, #0
130:               
131:               }
00D8EC  FA8000     ULNK
00D8EE  BE004F     MOV.D [--W15], W0
00D8F0  064000     RETFIE
132:                
133:               static void phaseLock(LStrobeParam params) {      
00D8F2  FA0002     LNK #0x2
00D8F4  781F88     MOV W8, [W15++]
00D8F6  780F00     MOV W0, [W14]
134:                   
135:                   DisableIntT3;
00D8F8  A90095     BCLR 0x95, #0
136:                   
137:                   PR3 = params->period + params->period_offset - 
00D8FA  78001E     MOV [W14], W0
00D8FC  780090     MOV [W0], W1
00D8FE  78001E     MOV [W14], W0
00D900  900010     MOV [W0+2], W0
00D902  408400     ADD W1, W0, W8
00D918  780000     MOV W0, W0
00D91A  540000     SUB W8, W0, W0
00D91C  880870     MOV W0, PR3
138:                           sclockGetGlobalTicks() % params->period;
00D904  02DE28     CALL sclockGetGlobalTicks
00D906  000000     NOP
00D908  BE0200     MOV.D W0, W4
00D90A  78001E     MOV [W14], W0
00D90C  780010     MOV [W0], W0
00D90E  200001     MOV #0x0, W1
00D910  BE0100     MOV.D W0, W2
00D912  BE0004     MOV.D W4, W0
00D914  022E1C     CALL ___umodsi3
00D916  000000     NOP
139:                   state = LT_PL;
00D91E  200020     MOV #0x2, W0
00D920  890E50     MOV W0, _state
140:               
141:                   EnableIntT3;   
00D922  A80095     BSET 0x95, #0
142:                   
143:               }
00D924  78044F     MOV [--W15], W8
00D926  FA8000     ULNK
00D928  060000     RETURN
144:                
145:               /**
146:                * LED strobe timer setup
147:                */
148:               static void setupTimer3(void) {
00D92A  FA0002     LNK #0x2
149:               
150:                   unsigned int con_reg;
151:               
152:                   con_reg =   T3_OFF &            // Disable module until setup complete
00D92C  25FBD0     MOV #0x5FBD, W0
00D92E  780F00     MOV W0, [W14]
153:                               T3_IDLE_CON &       // Continue running when idle
154:                               T3_GATE_OFF &       // Time accumulation disable
155:                               T3_PS_1_256 &        // Prescale 1:64
156:                               T3_SOURCE_INT;      // Internal clock
157:               
158:                   _T3IF = 0;
00D930  A90085     BCLR 0x85, #0
159:                   OpenTimer3(con_reg, 0);         // Configure timer
00D932  EB0080     CLR W1
00D934  78001E     MOV [W14], W0
00D936  02253C     CALL _OpenTimer3
00D938  000000     NOP
160:                   ConfigIntTimer3(T3_INT_PRIOR_6 & T3_INT_OFF);
00D93A  2FFF60     MOV #0xFFF6, W0
00D93C  022488     CALL _ConfigIntTimer3
00D93E  000000     NOP
161:                   T3CONbits.TON = 1;              // Enable module
00D940  A8E113     BSET 0x113, #7
162:               
163:               }
00D942  FA8000     ULNK
00D944  060000     RETURN
164:               
165:               
---  C:/Users/Cameron/Documents/Git/ibird-lib/hall.c  ---------------------------------------------------
1:                 // Modifications and additions to this file made by Andrew Pullin are copyright, 2013
2:                 // Copyrights are acknowledged for portions of this code extant before modifications by Andrew Pullin 
3:                 // Any application of BSD or other license to copyright content without the authors express approval
4:                 // is invalid and void.
5:                 
6:                 // July 14, 2011
7:                 // authors: rfearing, apullin
8:                 // code for position feedback using hall sensors on left and right motor
9:                 
10:                #include "p33Fxxxx.h"
11:                #include "led.h"
12:                #include "pid.h"
13:                #include "hall.h"
14:                #include "gyro.h"
15:                #include "motor_ctrl.h"
16:                #include "timer.h"
17:                #include "adc_pid.h"
18:                #include "pwm.h"
19:                #include "hall.h"
20:                #include "p33Fxxxx.h"
21:                #include "incap.h" // input capture
22:                #include <stdlib.h> // for malloc
23:                
24:                //Private Functions
25:                static void SetupTimer1(void);
26:                static void SetupTimer2(void);
27:                static void SetupInputCapture(void);
28:                static void hallUpdateBEMF(void);
29:                static void hallUpdatePID(pidPos *pid);
30:                int medianFilter3(int*);
31:                
32:                //Function to be installed into T1, and setup function
33:                //static void hallServiceRoutine(void);
34:                
35:                ///////////////////////////////////
36:                /////// Local variables ///////////
37:                //////////////////////////////////
38:                int t2_ticks;
39:                // unsigned long tic, toc;
40:                long old_wing_time, wing_time, wing_delta; // time of last event
41:                long motor_count[1]; // 0 = left 1 = right counts on sensor
42:                
43:                //MoveQueue hallMoveq;
44:                //moveCmdT hallCurrentMove, hallIdleMove, hallManualMove;
45:                
46:                int hallbemf[NUM_HALL_PIDS]; //used to store the true, unfiltered speed
47:                int hallbemfLast[NUM_HALL_PIDS]; // Last post-median-filter value
48:                int hallbemfHist[NUM_HALL_PIDS][3]; //This is ONLY for applying the median filter to
49:                
50:                //This is an array to map legCtrl controller to PWM output channels
51:                int hallOutputChannels[NUM_HALL_PIDS];
52:                
53:                // PID control structure
54:                pidPos hallPIDObjs;
55:                //pidObj hallPIDObjs[NUM_HALL_PIDS];
56:                
57:                // structure for reference velocity for leg
58:                hallVelLUT hallPIDVel;
59:                
60:                // may be glitch in longer missions at rollover
61:                unsigned long lastMoveTime;
62:                int seqIndex;
63:                
64:                static void hallGetSetpoint();
65:                static void hallSetControl();
66:                
67:                //////////// 1khz timer //////////
68:                //extern volatile unsigned long t1_ticks;
69:                volatile unsigned long hall_t1_ticks;
70:                
71:                ///////////////////////////////////
72:                /////// Private Functions /////////
73:                ///////////////////////////////////
74:                
75:                //Hall effect sensor has ~ 3 kHz rate max, so choose clock high enough
76:                // choose clock period = 6.4 us, divide FCY by 256
77:                
78:                // highest interrupt priority. runs at 1 kHZ
79:                static void SetupTimer1(void)
80:                {
0063AC  FA0004     LNK #0x4
81:                    unsigned int T1CON1value, T1PERvalue;
82:                    T1CON1value = T1_ON & T1_SOURCE_INT & T1_PS_1_1 & T1_GATE_OFF &
0063AE  2DF890     MOV #0xDF89, W0
0063B0  780F00     MOV W0, [W14]
83:                            T1_SYNC_EXT_OFF & T1_IDLE_CON;
84:                
85:                    T1PERvalue = 0x9C40; //clock period = 0.001s = (T1PERvalue/FCY) (1KHz)
0063B2  29C400     MOV #0x9C40, W0
0063B4  980710     MOV W0, [W14+2]
86:                    //T1PERvalue = 0x9C40/2;
87:                    //getT1_ticks() = 0;
88:                    OpenTimer1(T1CON1value, T1PERvalue);
0063B6  90009E     MOV [W14+2], W1
0063B8  78001E     MOV [W14], W0
0063BA  02252A     CALL _OpenTimer1
0063BC  000000     NOP
89:                    ConfigIntTimer1(T1_INT_PRIOR_6 & T1_INT_ON);
0063BE  2FFFE0     MOV #0xFFFE, W0
0063C0  02244A     CALL _ConfigIntTimer1
0063C2  000000     NOP
90:                    //int retval;
91:                    //retval = sysServiceConfigT1(T1CON1value, T1PERvalue, T1_INT_PRIOR_6 & T1_INT_ON);
92:                    //TODO: Put a soft trap here, conditional on retval
93:                }
0063C4  FA8000     ULNK
0063C6  060000     RETURN
94:                 
95:                //Timer 2 counts
96:                // Set up just to provide a tick counter at 400 Hz
97:                static void SetupTimer2(void) {
0063C8  FA0004     LNK #0x4
98:                    unsigned int T2CON1value, T2PERvalue;
99:                    t2_ticks = 0;
0063CA  EB0000     CLR W0
0063CC  88FB80     MOV W0, t2_ticks
100:                   T2CON1value = T2_ON & T2_SOURCE_INT & T2_PS_1_256 & T2_GATE_OFF;
0063CE  2FFBD0     MOV #0xFFBD, W0
0063D0  780F00     MOV W0, [W14]
101:                   T2PERvalue = 0xffff; // max period
0063D2  EB8000     SETM W0
0063D4  980710     MOV W0, [W14+2]
102:                   OpenTimer2(T2CON1value, T2PERvalue);
0063D6  90009E     MOV [W14+2], W1
0063D8  78001E     MOV [W14], W0
0063DA  022532     CALL _OpenTimer2
0063DC  000000     NOP
103:                   ConfigIntTimer2(T2_INT_PRIOR_5 & T2_INT_ON);
0063DE  2FFFD0     MOV #0xFFFD, W0
0063E0  022466     CALL _ConfigIntTimer2
0063E2  000000     NOP
104:                   //int retval;
105:                   //retval = sysServiceConfigT2(T2CON1value, T2PERvalue, T2_INT_PRIOR_5 & T2_INT_ON);
106:                   //TODO: Put a soft trap here, conditional on retval
107:               }
0063E4  FA8000     ULNK
0063E6  060000     RETURN
108:               
109:               
110:               static void SetupInputCapture() {
0063E8  FA0000     LNK #0x0
111:                   // RB4 and RB5 will be used for inputs
112:                   _TRISB4 = 1; // set for input
0063EA  A882C6     BSET TRISB, #4
113:                   //_TRISB5 = 1; // set for input
114:               
115:                   // left leg
116:                   motor_count[0] = 0;
0063EC  B80060     MUL.UU W0, #0, W0
0063EE  88FBF0     MOV W0, motor_count
0063F0  88FC01     MOV W1, 0x1F80
117:                   old_wing_time = 0;
0063F2  B80060     MUL.UU W0, #0, W0
0063F4  88FB90     MOV W0, old_wing_time
0063F6  88FBA1     MOV W1, 0x1F74
118:                   ConfigIntCapture7(IC_INT_ON & IC_INT_PRIOR_2);
0063F8  2FFFA0     MOV #0xFFFA, W0
0063FA  0222EE     CALL _ConfigIntCapture7
0063FC  000000     NOP
119:                   EnableIntIC7;
0063FE  A8C096     BSET IEC1, #6
120:                   /* In Edge Detection Mode (ICM = 001), the interrupt is generated on every capture
121:                   event and the Input Capture Interrupt (ICI<1:0>) bits are ignored. */
122:                   OpenCapture7(IC_IDLE_STOP & IC_TIMER2_SRC &
006400  2FF990     MOV #0xFF99, W0
006402  022310     CALL _OpenCapture7
006404  000000     NOP
123:                           IC_INT_1CAPTURE & IC_EVERY_EDGE);
124:               }
006406  FA8000     ULNK
006408  060000     RETURN
125:               
126:               //unsigned long toc;
127:               
128:               
129:               /////////////////////////
130:               ///////   ISR's  /////////
131:               /////////////////////////
132:               
133:               // Input Capture 7: wings
134:               
135:               //handler for wings
136:               void __attribute__((__interrupt__, no_auto_psv)) _IC7Interrupt(void) {
00640A  BE9F80     MOV.D W0, [W15++]
00640C  BE9F82     MOV.D W2, [W15++]
00640E  FA0000     LNK #0x0
137:                   // Insert ISR code here
138:                   motor_count[0]++; // increment count for right side - neglect overflow/wrap around
006410  80FBF2     MOV motor_count, W2
006412  80FC03     MOV 0x1F80, W3
006414  200010     MOV #0x1, W0
006416  200001     MOV #0x0, W1
006418  400002     ADD W0, W2, W0
00641A  488083     ADDC W1, W3, W1
00641C  88FBF0     MOV W0, motor_count
00641E  88FC01     MOV W1, 0x1F80
139:               
140:                   wing_time = (long) IC7BUF + ((long) (t2_ticks) << 16);
006420  800AC0     MOV IC7BUF, W0
006422  B80161     MUL.UU W0, #1, W2
006424  80FB80     MOV t2_ticks, W0
006426  DE80CF     ASR W0, #15, W1
006428  DD00C0     SL W0, #0, W1
00642A  200000     MOV #0x0, W0
00642C  400002     ADD W0, W2, W0
00642E  488083     ADDC W1, W3, W1
006430  88FBB0     MOV W0, wing_time
006432  88FBC1     MOV W1, 0x1F78
141:                   //left_time = (long) IC7BUF + (getT2_ticks() << 16);
142:                   wing_delta = wing_time - old_wing_time;
006434  80FBB2     MOV wing_time, W2
006436  80FBC3     MOV 0x1F78, W3
006438  80FB90     MOV old_wing_time, W0
00643A  80FBA1     MOV 0x1F74, W1
00643C  510000     SUB W2, W0, W0
00643E  598081     SUBB W3, W1, W1
006440  88FBD0     MOV W0, wing_delta
006442  88FBE1     MOV W1, 0x1F7C
143:                   old_wing_time = wing_time;
006444  80FBB0     MOV wing_time, W0
006446  80FBC1     MOV 0x1F78, W1
006448  88FB90     MOV W0, old_wing_time
00644A  88FBA1     MOV W1, 0x1F74
144:               
145:                   LED_RED = ~LED_RED;
00644C  801650     MOV LATB, W0
00644E  DE004C     LSR W0, #12, W0
006450  604061     AND.B W0, #0x1, W0
006452  EAC000     COM.B W0, W0
006454  604061     AND.B W0, #0x1, W0
006456  FB8000     ZE W0, W0
006458  600061     AND W0, #0x1, W0
00645A  DD004C     SL W0, #12, W0
00645C  801652     MOV LATB, W2
00645E  2EFFF1     MOV #0xEFFF, W1
006460  610081     AND W2, W1, W1
006462  708000     IOR W1, W0, W0
006464  881650     MOV W0, LATB
146:               
147:                   IFS1bits.IC7IF = 0; // Clear CN interrupt
006466  A9C086     BCLR IFS1, #6
148:               }
006468  FA8000     ULNK
00646A  BE014F     MOV.D [--W15], W2
00646C  BE004F     MOV.D [--W15], W0
00646E  064000     RETFIE
149:               
150:               /// Replaced by sys_service module
151:               void __attribute__((interrupt, no_auto_psv)) _T2Interrupt(void) {
006470  781F80     MOV W0, [W15++]
006472  FA0000     LNK #0x0
152:               
153:                   t2_ticks++; // updates about every 400 ms
006474  80FB80     MOV t2_ticks, W0
006476  E80000     INC W0, W0
006478  88FB80     MOV W0, t2_ticks
154:               
155:                   //Clear Timer2 interrupt flag
156:                   _T2IF = 0;
00647A  A9E084     BCLR IFS0, #7
157:               }
00647C  FA8000     ULNK
00647E  78004F     MOV [--W15], W0
006480  064000     RETFIE
158:               
159:               
160:               
161:               
162:               //////////////////////////////////
163:               /////// Public Functions /////////
164:               //////////////////////////////////
165:               
166:               
167:               //Main hall effect sensor setup, called from main()
168:               void hallSetup() {
006482  FA0004     LNK #0x4
169:                   //Init of PID controller objects
170:                   int i;
171:                   int temp_in = 0;
006484  EB0000     CLR W0
006486  980710     MOV W0, [W14+2]
172:                   for (i = 0; i < NUM_HALL_PIDS; i++) {
006488  EB0000     CLR W0
00648A  780F00     MOV W0, [W14]
00648C  370010     BRA 0x64AE
0064AC  E80F1E     INC [W14], [W14]
0064AE  78009E     MOV [W14], W1
0064B0  EB0000     CLR W0
0064B2  508F80     SUB W1, W0, [W15]
0064B4  34FFEC     BRA LE, 0x648E
173:                       hallInitPIDObjPos(&(hallPIDObjs), DEFAULT_HALL_KP, DEFAULT_HALL_KI,
00648E  EB0280     CLR W5
006490  EB0200     CLR W4
006492  EB0180     CLR W3
006494  EB0100     CLR W2
006496  EB0080     CLR W1
006498  21F8E0     MOV #0x1F8E, W0
00649A  0702DC     RCALL hallInitPIDObjPos
174:                               DEFAULT_HALL_KD, DEFAULT_HALL_KAW, DEFAULT_HALL_FF);
175:                       hallPIDObjs.minVal = 0;
00649C  EB0000     CLR W0
00649E  88FE90     MOV W0, 0x1FD2
176:                       hallPIDObjs.satValNeg = 0;
0064A0  EB0000     CLR W0
0064A2  88FEB0     MOV W0, 0x1FD6
177:                       hallPIDObjs.maxVal = FULLTHROT;
0064A4  204E00     MOV #0x4E0, W0
0064A6  88FE80     MOV W0, 0x1FD0
178:                       hallPIDObjs.satValPos = SATTHROT;
0064A8  204D80     MOV #0x4D8, W0
0064AA  88FEA0     MOV W0, 0x1FD4
179:                   }
180:               
181:                   // Controller to PWM channel correspondance
182:                   hallOutputChannels[0] = MC_CHANNEL_PWM1;
0064B6  200010     MOV #0x1, W0
0064B8  88FC60     MOV W0, hallOutputChannels
183:               
184:                   //Init for velocity profile objects
185:                   hallInitPIDVelProfile();
0064BA  070030     RCALL hallInitPIDVelProfile
186:               
187:                   lastMoveTime = 0;
0064BC  B80060     MUL.UU W0, #0, W0
0064BE  88FFD0     MOV W0, lastMoveTime
0064C0  88FFE1     MOV W1, 0x1FFC
188:                   //  initialize PID structures before starting Timer1
189:                   hallPIDSetInput(temp_in, lastMoveTime);
0064C2  80FFD0     MOV lastMoveTime, W0
0064C4  80FFE1     MOV 0x1FFC, W1
0064C6  780080     MOV W0, W1
0064C8  90001E     MOV [W14+2], W0
0064CA  070099     RCALL hallPIDSetInput
190:               
191:                   for (i = 0; i < NUM_HALL_PIDS; i++) {
0064CC  EB0000     CLR W0
0064CE  780F00     MOV W0, [W14]
0064D0  37001C     BRA 0x650A
006508  E80F1E     INC [W14], [W14]
00650A  78009E     MOV [W14], W1
00650C  EB0000     CLR W0
00650E  508F80     SUB W1, W0, [W15]
006510  34FFE0     BRA LE, 0x64D2
192:                       hallbemfLast[i] = 0;
0064D2  78001E     MOV [W14], W0
0064D4  400080     ADD W0, W0, W1
0064D6  21F840     MOV #0x1F84, W0
0064D8  408000     ADD W1, W0, W0
0064DA  EB0080     CLR W1
0064DC  780801     MOV W1, [W0]
193:                       hallbemfHist[i][0] = 0;
0064DE  78001E     MOV [W14], W0
0064E0  B90066     MUL.SU W0, #6, W0
0064E2  780080     MOV W0, W1
0064E4  21F860     MOV #0x1F86, W0
0064E6  408000     ADD W1, W0, W0
0064E8  EB0080     CLR W1
0064EA  780801     MOV W1, [W0]
194:                       hallbemfHist[i][1] = 0;
0064EC  78001E     MOV [W14], W0
0064EE  B90066     MUL.SU W0, #6, W0
0064F0  780080     MOV W0, W1
0064F2  21F880     MOV #0x1F88, W0
0064F4  408000     ADD W1, W0, W0
0064F6  EB0080     CLR W1
0064F8  780801     MOV W1, [W0]
195:                       hallbemfHist[i][2] = 0;
0064FA  78001E     MOV [W14], W0
0064FC  B90066     MUL.SU W0, #6, W0
0064FE  780080     MOV W0, W1
006500  21F8A0     MOV #0x1F8A, W0
006502  408000     ADD W1, W0, W0
006504  EB0080     CLR W1
006506  780801     MOV W1, [W0]
196:                   }
197:                   
198:                   //System setup
199:                   SetupTimer1();
006512  07FF4C     RCALL SetupTimer1
200:                   SetupTimer2(); // used for leg hall effect sensors
006514  07FF59     RCALL SetupTimer2
201:                   SetupInputCapture(); // setup input capture for hall effect sensors
006516  07FF68     RCALL SetupInputCapture
202:               
203:               
204:                   //int retval;
205:                   //retval = sysServiceInstallT1(hallServiceRoutine);
206:               
207:                   // returns pointer to queue with 8 move entries
208:               //    hallMoveq = mqInit(8);
209:               //    hallIdleMove = malloc(sizeof (moveCmdStruct));
210:               //    hallIdleMove->inputL = 0;
211:               //    hallIdleMove->inputR = 0;
212:               //    hallIdleMove->duration = 0;
213:               //    hallCurrentMove = hallIdleMove;
214:               //
215:               //    hallManualMove = malloc(sizeof (moveCmdStruct));
216:               //    hallManualMove->inputL = 0;
217:               //    hallManualMove->inputR = 0;
218:               //    hallManualMove->duration = 0;
219:               
220:               }
006518  FA8000     ULNK
00651A  060000     RETURN
221:               
222:               // ----------   all the initializations  -------------------------
223:               // set expire time for first segment in pidSetInput - use start time from MoveClosedLoop
224:               // set points and velocities for one revolution of leg
225:               // called from pidSetup()
226:               
227:               void hallInitPIDVelProfile() {
00651C  FA0004     LNK #0x4
228:                   int i, j;
229:                   for (j = 0; j < NUM_PIDS; j++) {
00651E  EB0000     CLR W0
006520  980710     MOV W0, [W14+2]
006522  37003B     BRA 0x659A
006594  90001E     MOV [W14+2], W0
006596  E80000     INC W0, W0
006598  980710     MOV W0, [W14+2]
00659A  90009E     MOV [W14+2], W1
00659C  EB0000     CLR W0
00659E  508F80     SUB W1, W0, [W15]
0065A0  34FFC1     BRA LE, 0x6524
230:                       hallPIDVel.index = 0; // point to first velocity
006524  EB0000     CLR W0
006526  88FEF0     MOV W0, 0x1FDE
231:                       hallPIDVel.interpolate = 0;
006528  EB0000     CLR W0
00652A  88FEC0     MOV W0, hallPIDVel
232:                       hallPIDVel.wing_strokes = 0; // set initial leg count
00652C  EB0000     CLR W0
00652E  88FFC0     MOV W0, 0x1FF8
233:                       // set control intervals during stride - try to get close to 21.3 ratio (use 42 counts)
234:                       hallPIDVel.interval[0] = (3 * STRIDE_TICKS / NUM_VELS / 3);
006530  200B40     MOV #0xB4, W0
006532  88FF00     MOV W0, 0x1FE0
235:                       hallPIDVel.delta[0] = 11;
006534  2000B0     MOV #0xB, W0
006536  88FF40     MOV W0, 0x1FE8
236:                       hallPIDVel.interval[1] = (3 * STRIDE_TICKS / NUM_VELS / 3);
006538  200B40     MOV #0xB4, W0
00653A  88FF10     MOV W0, 0x1FE2
237:                       hallPIDVel.delta[1] = 11;
00653C  2000B0     MOV #0xB, W0
00653E  88FF50     MOV W0, 0x1FEA
238:                       hallPIDVel.interval[2] = (3 * STRIDE_TICKS / NUM_VELS / 3);
006540  200B40     MOV #0xB4, W0
006542  88FF20     MOV W0, 0x1FE4
239:                       hallPIDVel.delta[2] = 11;
006544  2000B0     MOV #0xB, W0
006546  88FF60     MOV W0, 0x1FEC
240:                       hallPIDVel.interval[3] = (3 * STRIDE_TICKS / NUM_VELS / 3);
006548  200B40     MOV #0xB4, W0
00654A  88FF30     MOV W0, 0x1FE6
241:                       hallPIDVel.delta[3] = 12;
00654C  2000C0     MOV #0xC, W0
00654E  88FF70     MOV W0, 0x1FEE
242:                       for (i = 0; i < NUM_VELS; i++) { // interpolate values between setpoints, <<4 for resolution
006550  EB0000     CLR W0
006552  780F00     MOV W0, [W14]
006554  370018     BRA 0x6586
006584  E80F1E     INC [W14], [W14]
006586  78009E     MOV [W14], W1
006588  200030     MOV #0x3, W0
00658A  508F80     SUB W1, W0, [W15]
00658C  34FFE4     BRA LE, 0x6556
243:                           hallPIDVel.vel[i] = (hallPIDVel.delta[i] << 8) / hallPIDVel.interval[i];
006556  78009E     MOV [W14], W1
006558  408068     ADD W1, #0x8, W0
00655A  400080     ADD W0, W0, W1
00655C  21FD80     MOV #0x1FD8, W0
00655E  408000     ADD W1, W0, W0
006560  780010     MOV [W0], W0
006562  DD00C8     SL W0, #8, W1
006564  78011E     MOV [W14], W2
006566  410064     ADD W2, #0x4, W0
006568  400100     ADD W0, W0, W2
00656A  21FD80     MOV #0x1FD8, W0
00656C  410000     ADD W2, W0, W0
00656E  780010     MOV [W0], W0
006570  780100     MOV W0, W2
006572  090011     REPEAT #0x11
006574  D80082     DIV.SW W1, W2
006576  780080     MOV W0, W1
006578  78011E     MOV [W14], W2
00657A  41006C     ADD W2, #0xC, W0
00657C  400100     ADD W0, W0, W2
00657E  21FD80     MOV #0x1FD8, W0
006580  410000     ADD W2, W0, W0
006582  780801     MOV W1, [W0]
244:                       }
245:                       hallPIDObjs.p_input = 0; // initialize first set point
00658E  B80060     MUL.UU W0, #0, W0
006590  88FC70     MOV W0, hallPIDObjs
006592  88FC81     MOV W1, 0x1F90
246:                   }
247:               }
0065A2  FA8000     ULNK
0065A4  060000     RETURN
248:               
249:               // set values from packet - leave previous motor_count, p_input, etc.
250:               // called from cmd.c
251:               
252:               void hallSetVelProfile(hallVelCmdParams params) {
0065A6  FA0004     LNK #0x4
0065A8  980710     MOV W0, [W14+2]
253:                   int i;
254:                   for (i = 0; i < NUM_VELS; i++) {
0065AA  EB0000     CLR W0
0065AC  780F00     MOV W0, [W14]
0065AE  370021     BRA 0x65F2
0065F0  E80F1E     INC [W14], [W14]
0065F2  78009E     MOV [W14], W1
0065F4  200030     MOV #0x3, W0
0065F6  508F80     SUB W1, W0, [W15]
0065F8  34FFDB     BRA LE, 0x65B0
255:                       hallPIDVel.interval[i] = params->interval[i];
0065B0  90009E     MOV [W14+2], W1
0065B2  78011E     MOV [W14], W2
0065B4  410064     ADD W2, #0x4, W0
0065B6  400000     ADD W0, W0, W0
0065B8  7800E1     MOV [W1+W0], W1
0065BA  78011E     MOV [W14], W2
0065BC  410064     ADD W2, #0x4, W0
0065BE  400100     ADD W0, W0, W2
0065C0  21FD80     MOV #0x1FD8, W0
0065C2  410000     ADD W2, W0, W0
0065C4  780801     MOV W1, [W0]
256:                       hallPIDVel.delta[i] = params->delta[i];
0065C6  90009E     MOV [W14+2], W1
0065C8  78001E     MOV [W14], W0
0065CA  400000     ADD W0, W0, W0
0065CC  7800E1     MOV [W1+W0], W1
0065CE  78011E     MOV [W14], W2
0065D0  410068     ADD W2, #0x8, W0
0065D2  400100     ADD W0, W0, W2
0065D4  21FD80     MOV #0x1FD8, W0
0065D6  410000     ADD W2, W0, W0
0065D8  780801     MOV W1, [W0]
257:                       hallPIDVel.vel[i] = params->vel[i];
0065DA  90009E     MOV [W14+2], W1
0065DC  78011E     MOV [W14], W2
0065DE  410068     ADD W2, #0x8, W0
0065E0  400000     ADD W0, W0, W0
0065E2  7800E1     MOV [W1+W0], W1
0065E4  78011E     MOV [W14], W2
0065E6  41006C     ADD W2, #0xC, W0
0065E8  400100     ADD W0, W0, W2
0065EA  21FD80     MOV #0x1FD8, W0
0065EC  410000     ADD W2, W0, W0
0065EE  780801     MOV W1, [W0]
258:                   }
259:               }
0065FA  FA8000     ULNK
0065FC  060000     RETURN
260:               
261:               
262:               // called from set thrust closed loop, etc. Thrust
263:               
264:               void hallPIDSetInput(unsigned int input, unsigned int run_time) {
0065FE  FA0008     LNK #0x8
006600  980720     MOV W0, [W14+4]
006602  980731     MOV W1, [W14+6]
265:                   unsigned long temp;
266:                   hallPIDObjs.v_input = input;
006604  90002E     MOV [W14+4], W0
006606  88FC90     MOV W0, 0x1F92
267:                   hallPIDObjs.run_time = run_time;
006608  90003E     MOV [W14+6], W0
00660A  200001     MOV #0x0, W1
00660C  88FDF0     MOV W0, 0x1FBE
00660E  88FE01     MOV W1, 0x1FC0
268:                   hallPIDObjs.start_time = hall_t1_ticks;
006610  810000     MOV hall_t1_ticks, W0
006612  810011     MOV 0x2002, W1
006614  88FE10     MOV W0, 0x1FC2
006616  88FE21     MOV W1, 0x1FC4
269:                   //zero out running PID values
270:                   hallPIDObjs.i_error = 0;
006618  B80060     MUL.UU W0, #0, W0
00661A  88FDD0     MOV W0, 0x1FBA
00661C  88FDE1     MOV W1, 0x1FBC
271:                   hallPIDObjs.p = 0;
00661E  B80060     MUL.UU W0, #0, W0
006620  88FCE0     MOV W0, 0x1F9C
006622  88FCF1     MOV W1, 0x1F9E
272:                   hallPIDObjs.i = 0;
006624  B80060     MUL.UU W0, #0, W0
006626  88FD00     MOV W0, 0x1FA0
006628  88FD11     MOV W1, 0x1FA2
273:                   hallPIDObjs.d = 0;
00662A  B80060     MUL.UU W0, #0, W0
00662C  88FD20     MOV W0, 0x1FA4
00662E  88FD31     MOV W1, 0x1FA6
274:                   //Seed the median filter
275:               
276:                   temp = hall_t1_ticks; // need atomic read due to interrupt
006630  810000     MOV hall_t1_ticks, W0
006632  810011     MOV 0x2002, W1
006634  BE8F00     MOV.D W0, [W14]
277:                   lastMoveTime = temp + (unsigned long) run_time; // only one run time for both sides
006636  90003E     MOV [W14+6], W0
006638  200001     MOV #0x0, W1
00663A  40013E     ADD W0, [W14++], W2
00663C  4881AE     ADDC W1, [W14--], W3
00663E  BE0002     MOV.D W2, W0
006640  88FFD0     MOV W0, lastMoveTime
006642  88FFE1     MOV W1, 0x1FFC
278:                   // set initial time for next move set point
279:               
280:                   /*   need to set index =0 initial values */
281:                   /* position setpoints start at 0 (index=0), then interpolate until setpoint 1 (index =1), etc */
282:                   hallPIDVel.expire = temp + (long) hallPIDVel.interval[0]; // end of first interval
006644  80FF00     MOV 0x1FE0, W0
006646  DE80CF     ASR W0, #15, W1
006648  40013E     ADD W0, [W14++], W2
00664A  4881AE     ADDC W1, [W14--], W3
00664C  BE0002     MOV.D W2, W0
00664E  88FED0     MOV W0, 0x1FDA
006650  88FEE1     MOV W1, 0x1FDC
283:                   hallPIDVel.interpolate = 0;
006652  EB0000     CLR W0
006654  88FEC0     MOV W0, hallPIDVel
284:                   /*        pidObjs[pid_num].p_input += pidVel[pid_num].delta[0];        //update to first set point
285:                    ***  this should be set only after first .expire time to avoid initial transients */
286:                   hallPIDVel.index = 0; // reset setpoint index
006656  EB0000     CLR W0
006658  88FEF0     MOV W0, 0x1FDE
287:                   // set first move at t = 0
288:                   //        pidVel[0].expire = temp;   // right side
289:                   //        pidVel[1].expire = temp;   // left side
290:               
291:               }
00665A  FA8000     ULNK
00665C  060000     RETURN
292:               
293:               void hallSetGains(hallGainParams params) {
00665E  FA0002     LNK #0x2
006660  780F00     MOV W0, [W14]
294:                   hallPIDObjs.Kp = params->Kp;
006662  78001E     MOV [W14], W0
006664  780010     MOV [W0], W0
006666  88FD40     MOV W0, 0x1FA8
295:                   hallPIDObjs.Ki = params->Ki;
006668  78001E     MOV [W14], W0
00666A  900010     MOV [W0+2], W0
00666C  88FD50     MOV W0, 0x1FAA
296:                   hallPIDObjs.Kd = params->Kd;
00666E  78001E     MOV [W14], W0
006670  900020     MOV [W0+4], W0
006672  88FD60     MOV W0, 0x1FAC
297:                   hallPIDObjs.Kaw = params->Kaw;
006674  78001E     MOV [W14], W0
006676  900030     MOV [W0+6], W0
006678  88FD70     MOV W0, 0x1FAE
298:                   hallPIDObjs.Kff = params->Kff;
00667A  78001E     MOV [W14], W0
00667C  900040     MOV [W0+8], W0
00667E  88FE40     MOV W0, 0x1FC8
299:               }
006680  FA8000     ULNK
006682  060000     RETURN
300:               
301:               void hallPIDOn() {
006684  FA0000     LNK #0x0
302:                   hallZeroPos();
006686  07000B     RCALL hallZeroPos
303:                   hallPIDObjs.onoff = 1;
006688  21FB31     MOV #0x1FB3, W1
00668A  B3C010     MOV #0x1, W0
00668C  784880     MOV.B W0, [W1]
304:               }
00668E  FA8000     ULNK
006690  060000     RETURN
305:               
306:               void hallPIDOff() {
006692  FA0000     LNK #0x0
307:                   hallPIDObjs.onoff = 0;
006694  21FB31     MOV #0x1FB3, W1
006696  EB4000     CLR.B W0
006698  784880     MOV.B W0, [W1]
308:               }
00669A  FA8000     ULNK
00669C  060000     RETURN
309:               
310:               // zero position setpoint for both motors (avoids big offset errors)
311:               
312:               void hallZeroPos() {
00669E  FA0000     LNK #0x0
313:                   // disable interrupts to reset both motor_counts
314:                   DisableIntIC7;
0066A0  A9C096     BCLR IEC1, #6
315:                   motor_count[0] = 0;
0066A2  B80060     MUL.UU W0, #0, W0
0066A4  88FBF0     MOV W0, motor_count
0066A6  88FC01     MOV W1, 0x1F80
316:                   EnableIntIC7;
0066A8  A8C096     BSET IEC1, #6
317:                   // reset position setpoint as well
318:                   hallPIDObjs.p_input = 0;
0066AA  B80060     MUL.UU W0, #0, W0
0066AC  88FC70     MOV W0, hallPIDObjs
0066AE  88FC81     MOV W1, 0x1F90
319:                   hallPIDVel.wing_strokes = 0; // strides also reset
0066B0  EB0000     CLR W0
0066B2  88FFC0     MOV W0, 0x1FF8
320:               }
0066B4  FA8000     ULNK
0066B6  060000     RETURN
321:               
322:               
323:               /*********************** Motor Control Interrupt *********************************************/
324:               /*****************************************************************************************/
325:               
326:               /*****************************************************************************************/
327:               
328:               
329:               /////////        Hall Control ISR       ////////
330:               /////////  Installed to Timer1 @ 1Khz  ////////
331:               void __attribute__((interrupt, no_auto_psv)) _T1Interrupt(void)
332:               //static void hallServiceRoutine(void)
333:               {
0066B8  F80036     PUSH RCOUNT
0066BA  BE9F80     MOV.D W0, [W15++]
0066BC  BE9F82     MOV.D W2, [W15++]
0066BE  BE9F84     MOV.D W4, [W15++]
0066C0  BE9F86     MOV.D W6, [W15++]
0066C2  FA0000     LNK #0x0
334:                   // debug Hall effect sensors //
335:                   LED_RED = _RB4;
0066C4  801640     MOV PORTB, W0
0066C6  DE0044     LSR W0, #4, W0
0066C8  604061     AND.B W0, #0x1, W0
0066CA  FB8000     ZE W0, W0
0066CC  600061     AND W0, #0x1, W0
0066CE  DD004C     SL W0, #12, W0
0066D0  801652     MOV LATB, W2
0066D2  2EFFF1     MOV #0xEFFF, W1
0066D4  610081     AND W2, W1, W1
0066D6  708000     IOR W1, W0, W0
0066D8  881650     MOV W0, LATB
336:                   //LED_RED = _RB5;
337:               
338:                   hall_t1_ticks++;
0066DA  810002     MOV hall_t1_ticks, W2
0066DC  810013     MOV 0x2002, W3
0066DE  200010     MOV #0x1, W0
0066E0  200001     MOV #0x0, W1
0066E2  400002     ADD W0, W2, W0
0066E4  488083     ADDC W1, W3, W1
0066E6  890000     MOV W0, hall_t1_ticks
0066E8  890011     MOV W1, 0x2002
339:               
340:                   if (hall_t1_ticks > lastMoveTime) // turn off if done running
0066EA  810002     MOV hall_t1_ticks, W2
0066EC  810013     MOV 0x2002, W3
0066EE  80FFD0     MOV lastMoveTime, W0
0066F0  80FFE1     MOV 0x1FFC, W1
0066F2  510F80     SUB W2, W0, [W15]
0066F4  598F81     SUBB W3, W1, [W15]
0066F6  36000B     BRA LEU, 0x670E
341:                   { //        hallPIDSetInput(0, 0, 0);    don't reset state when done run, keep for recording telemetry
342:                       hallPIDObjs.onoff = 0;
0066F8  21FB31     MOV #0x1FB3, W1
0066FA  EB4000     CLR.B W0
0066FC  784880     MOV.B W0, [W1]
343:                       if (lastMoveTime > 0) {
0066FE  80FFD2     MOV lastMoveTime, W2
006700  80FFE3     MOV 0x1FFC, W3
006702  B80060     MUL.UU W0, #0, W0
006704  510F80     SUB W2, W0, [W15]
006706  598F81     SUBB W3, W1, [W15]
006708  320003     BRA Z, 0x6710
344:                           Nop();
00670A  000000     NOP
00670C  370001     BRA 0x6710
345:                       }
346:                       //hallGetSetpoint();
347:                       //        hallPIDSetInput(1, 0, 0);
348:                   } else // update velocity setpoints if needed - only when running
349:                   {
350:                       hallGetSetpoint();
00670E  07000A     RCALL hallGetSetpoint
351:                   }
352:               
353:                   hallUpdateBEMF();
006710  07012F     RCALL hallUpdateBEMF
354:                   hallSetControl();
006712  07005C     RCALL hallSetControl
355:                   _T1IF = 0;
006714  A96084     BCLR IFS0, #3
356:               }
006716  FA8000     ULNK
006718  BE034F     MOV.D [--W15], W6
00671A  BE024F     MOV.D [--W15], W4
00671C  BE014F     MOV.D [--W15], W2
00671E  BE004F     MOV.D [--W15], W0
006720  F90036     POP RCOUNT
006722  064000     RETFIE
357:               
358:               static void hallGetSetpoint() {
006724  FA0002     LNK #0x2
359:                   int j, index;
360:                   index = hallPIDVel.index;
006726  80FEF0     MOV 0x1FDE, W0
006728  780F00     MOV W0, [W14]
361:                   // update desired position between setpoints, scaled by 256
362:                   hallPIDVel.interpolate += hallPIDVel.vel[index];
00672A  80FEC1     MOV hallPIDVel, W1
00672C  78011E     MOV [W14], W2
00672E  41006C     ADD W2, #0xC, W0
006730  400100     ADD W0, W0, W2
006732  21FD80     MOV #0x1FD8, W0
006734  410000     ADD W2, W0, W0
006736  780010     MOV [W0], W0
006738  408000     ADD W1, W0, W0
00673A  88FEC0     MOV W0, hallPIDVel
363:               
364:                   if (hall_t1_ticks >= hallPIDVel.expire) // time to reach previous setpoint has passed
00673C  80FED2     MOV 0x1FDA, W2
00673E  80FEE3     MOV 0x1FDC, W3
006740  810000     MOV hall_t1_ticks, W0
006742  810011     MOV 0x2002, W1
006744  510F80     SUB W2, W0, [W15]
006746  598F81     SUBB W3, W1, [W15]
006748  3E003F     BRA GTU, 0x67C8
365:                   {
366:                       hallPIDVel.interpolate = 0;
00674A  EB0000     CLR W0
00674C  88FEC0     MOV W0, hallPIDVel
367:                       hallPIDObjs.p_input += hallPIDVel.delta[index]; //update to next set point
00674E  80FC72     MOV hallPIDObjs, W2
006750  80FC83     MOV 0x1F90, W3
006752  78021E     MOV [W14], W4
006754  420068     ADD W4, #0x8, W0
006756  400080     ADD W0, W0, W1
006758  21FD80     MOV #0x1FD8, W0
00675A  408000     ADD W1, W0, W0
00675C  780010     MOV [W0], W0
00675E  DE80CF     ASR W0, #15, W1
006760  400002     ADD W0, W2, W0
006762  488083     ADDC W1, W3, W1
006764  88FC70     MOV W0, hallPIDObjs
006766  88FC81     MOV W1, 0x1F90
368:                       hallPIDVel.expire += hallPIDVel.interval[(index + 1) % NUM_VELS]; // expire time for next interval
006768  80FED2     MOV 0x1FDA, W2
00676A  80FEE3     MOV 0x1FDC, W3
00676C  E8009E     INC [W14], W1
00676E  200040     MOV #0x4, W0
006770  780200     MOV W0, W4
006772  090011     REPEAT #0x11
006774  D80084     DIV.SW W1, W4
006776  FD0080     EXCH W0, W1
006778  400064     ADD W0, #0x4, W0
00677A  400080     ADD W0, W0, W1
00677C  21FD80     MOV #0x1FD8, W0
00677E  408000     ADD W1, W0, W0
006780  780010     MOV [W0], W0
006782  DE80CF     ASR W0, #15, W1
006784  400002     ADD W0, W2, W0
006786  488083     ADDC W1, W3, W1
006788  88FED0     MOV W0, 0x1FDA
00678A  88FEE1     MOV W1, 0x1FDC
369:                       // got to next index point
370:                       hallPIDVel.index++;
00678C  80FEF0     MOV 0x1FDE, W0
00678E  E80000     INC W0, W0
006790  88FEF0     MOV W0, 0x1FDE
371:               
372:                       if (hallPIDVel.index >= NUM_VELS) {
006792  80FEF1     MOV 0x1FDE, W1
006794  200030     MOV #0x3, W0
006796  508F80     SUB W1, W0, [W15]
006798  340017     BRA LE, 0x67C8
373:                           hallPIDVel.index = 0;
00679A  EB0000     CLR W0
00679C  88FEF0     MOV W0, 0x1FDE
374:                           hallPIDVel.wing_strokes++; // one full leg revolution
00679E  80FFC0     MOV 0x1FF8, W0
0067A0  E80000     INC W0, W0
0067A2  88FFC0     MOV W0, 0x1FF8
375:                           // need to correct for 426 counts per leg stride
376:                           // 5 rev @ 42 counts/rev = 210, actual set point 5 rev @ 42.6 counts, so add 3 to p_input
377:                               if ((hallPIDVel.wing_strokes % 5) == 0) {
0067A4  80FFC1     MOV 0x1FF8, W1
0067A6  200050     MOV #0x5, W0
0067A8  780100     MOV W0, W2
0067AA  090011     REPEAT #0x11
0067AC  D80082     DIV.SW W1, W2
0067AE  FD0080     EXCH W0, W1
0067B0  780080     MOV W0, W1
0067B2  EB0000     CLR W0
0067B4  508F80     SUB W1, W0, [W15]
0067B6  3A0008     BRA NZ, 0x67C8
378:                                   hallPIDObjs.p_input += 3;
0067B8  80FC72     MOV hallPIDObjs, W2
0067BA  80FC83     MOV 0x1F90, W3
0067BC  200030     MOV #0x3, W0
0067BE  200001     MOV #0x0, W1
0067C0  400002     ADD W0, W2, W0
0067C2  488083     ADDC W1, W3, W1
0067C4  88FC70     MOV W0, hallPIDObjs
0067C6  88FC81     MOV W1, 0x1F90
379:                               }
380:                       } // loop on index
381:                   }
382:               }
0067C8  FA8000     ULNK
0067CA  060000     RETURN
383:               
384:               static void hallSetControl() {
0067CC  FA0008     LNK #0x8
385:                   long j;
386:                   long k;
387:                   // 0 = right side
388:                  
389:                   hallPIDObjs.p_error = hallPIDObjs.p_input + (hallPIDVel.interpolate >> 8) - motor_count[0];
0067CE  80FC72     MOV hallPIDObjs, W2
0067D0  80FC83     MOV 0x1F90, W3
0067D2  80FEC0     MOV hallPIDVel, W0
0067D4  DE8048     ASR W0, #8, W0
0067D6  DE80CF     ASR W0, #15, W1
0067D8  400102     ADD W0, W2, W2
0067DA  488183     ADDC W1, W3, W3
0067DC  80FBF0     MOV motor_count, W0
0067DE  80FC01     MOV 0x1F80, W1
0067E0  510000     SUB W2, W0, W0
0067E2  598081     SUBB W3, W1, W1
0067E4  88FDA0     MOV W0, 0x1FB4
0067E6  88FDB1     MOV W1, 0x1FB6
390:                   //hallPIDObjs.p_error = hallPIDObjs.p_input - motor_count[0];
391:                   //hallPIDObjs[j].v_error = hallPIDObjs[j].v_input - measurements[j];
392:                   hallPIDObjs.v_error = hallPIDObjs.v_input - hallbemf[0];
0067E8  80FC91     MOV 0x1F92, W1
0067EA  80FC10     MOV hallbemf, W0
0067EC  508000     SUB W1, W0, W0
0067EE  88FDC0     MOV W0, 0x1FB8
393:                   //Update values
394:               
395:                   if (hallPIDObjs.p_error < -100) {
0067F0  80FDA2     MOV 0x1FB4, W2
0067F2  80FDB3     MOV 0x1FB6, W3
0067F4  2FF9C0     MOV #0xFF9C, W0
0067F6  2FFFF1     MOV #0xFFFF, W1
0067F8  510F80     SUB W2, W0, [W15]
0067FA  598F81     SUBB W3, W1, [W15]
0067FC  3D0008     BRA GE, 0x680E
396:                       k = hallPIDObjs.p_input;
0067FE  80FC70     MOV hallPIDObjs, W0
006800  80FC81     MOV 0x1F90, W1
006802  BE8F00     MOV.D W0, [W14]
397:                       j = motor_count[0];
006804  80FBF0     MOV motor_count, W0
006806  80FC01     MOV 0x1F80, W1
006808  980720     MOV W0, [W14+4]
00680A  980731     MOV W1, [W14+6]
398:                       Nop();
00680C  000000     NOP
399:                   }
400:               
401:                   hallUpdatePID(&(hallPIDObjs));
00680E  21F8E0     MOV #0x1F8E, W0
006810  070013     RCALL hallUpdatePID
402:                   if (hallPIDObjs.onoff) {
006812  21FB30     MOV #0x1FB3, W0
006814  784090     MOV.B [W0], W1
006816  EB4000     CLR.B W0
006818  50CF80     SUB.B W1, W0, [W15]
00681A  320007     BRA Z, 0x682A
403:                       //Might want to change this in the future, if we want to track error
404:                       //even when the motor is off.
405:                       //Set PWM duty cycle
406:                       SetDCMCPWM(MC_CHANNEL_PWM1, hallPIDObjs.output, 0); //PWM1.L
00681C  80FE70     MOV 0x1FCE, W0
00681E  EB4100     CLR.B W2
006820  780080     MOV W0, W1
006822  200010     MOV #0x1, W0
006824  022436     CALL _SetDCMCPWM
006826  000000     NOP
006828  370005     BRA 0x6834
407:                   }//end of if (on / off)
408:                   else { //if PID loop is off
409:                       SetDCMCPWM(MC_CHANNEL_PWM1, 0, 0);
00682A  EB4100     CLR.B W2
00682C  EB0080     CLR W1
00682E  200010     MOV #0x1, W0
006830  022436     CALL _SetDCMCPWM
006832  000000     NOP
410:                   }
411:               }
006834  FA8000     ULNK
006836  060000     RETURN
412:               
413:               static void hallUpdatePID(pidPos *pid) {
006838  FA0002     LNK #0x2
00683A  BE9F88     MOV.D W8, [W15++]
00683C  780F00     MOV W0, [W14]
414:                   pid->p = (long) pid->Kp * pid->p_error;
00683E  78001E     MOV [W14], W0
006840  900850     MOV [W0+26], W0
006842  B90161     MUL.SU W0, #1, W2
006844  78001E     MOV [W14], W0
006846  9010C0     MOV [W0+40], W1
006848  901030     MOV [W0+38], W0
00684A  B99A00     MUL.SS W3, W0, W4
00684C  780204     MOV W4, W4
00684E  B98B02     MUL.SS W1, W2, W6
006850  780286     MOV W6, W5
006852  420205     ADD W4, W5, W4
006854  B81000     MUL.UU W2, W0, W0
006856  420201     ADD W4, W1, W4
006858  780084     MOV W4, W1
00685A  78011E     MOV [W14], W2
00685C  980170     MOV W0, [W2+14]
00685E  980901     MOV W1, [W2+16]
415:                   pid->i = (long) pid->Ki * pid->i_error;
006860  78001E     MOV [W14], W0
006862  900860     MOV [W0+28], W0
006864  B90161     MUL.SU W0, #1, W2
006866  78001E     MOV [W14], W0
006868  9010F0     MOV [W0+46], W1
00686A  901060     MOV [W0+44], W0
00686C  B99A00     MUL.SS W3, W0, W4
00686E  780204     MOV W4, W4
006870  B98B02     MUL.SS W1, W2, W6
006872  780286     MOV W6, W5
006874  420205     ADD W4, W5, W4
006876  B81000     MUL.UU W2, W0, W0
006878  420201     ADD W4, W1, W4
00687A  780084     MOV W4, W1
00687C  78011E     MOV [W14], W2
00687E  980910     MOV W0, [W2+18]
006880  980921     MOV W1, [W2+20]
416:                   pid->d = (long) pid->Kd * (long) pid->v_error;
006882  78001E     MOV [W14], W0
006884  900870     MOV [W0+30], W0
006886  B90161     MUL.SU W0, #1, W2
006888  78001E     MOV [W14], W0
00688A  901050     MOV [W0+42], W0
00688C  DE80CF     ASR W0, #15, W1
00688E  B99A00     MUL.SS W3, W0, W4
006890  780204     MOV W4, W4
006892  B98B02     MUL.SS W1, W2, W6
006894  780286     MOV W6, W5
006896  420205     ADD W4, W5, W4
006898  B81000     MUL.UU W2, W0, W0
00689A  420201     ADD W4, W1, W4
00689C  780084     MOV W4, W1
00689E  78011E     MOV [W14], W2
0068A0  980930     MOV W0, [W2+22]
0068A2  980941     MOV W1, [W2+24]
417:                   // better check scale factors
418:                   /* just use simpled PID, offset is already subtracted in PID GetState */
419:                   // scale so doesn't over flow
420:                   pid->preSat = pid->Kff + pid->p +
0068A4  78001E     MOV [W14], W0
0068A6  901850     MOV [W0+58], W0
0068A8  B90161     MUL.SU W0, #1, W2
0068AA  78001E     MOV [W14], W0
0068AC  900880     MOV [W0+16], W1
0068AE  900070     MOV [W0+14], W0
0068B0  400102     ADD W0, W2, W2
0068B2  488183     ADDC W1, W3, W3
0068CC  400002     ADD W0, W2, W0
0068CE  488083     ADDC W1, W3, W1
0068D0  78011E     MOV [W14], W2
0068D2  981960     MOV W0, [W2+60]
0068D4  981971     MOV W1, [W2+62]
421:                           ((pid->i + pid->d) >> 4); // divide by 16
0068B4  78001E     MOV [W14], W0
0068B6  900A10     MOV [W0+18], W4
0068B8  900AA0     MOV [W0+20], W5
0068BA  78001E     MOV [W14], W0
0068BC  9008C0     MOV [W0+24], W1
0068BE  900830     MOV [W0+22], W0
0068C0  400004     ADD W0, W4, W0
0068C2  488085     ADDC W1, W5, W1
0068C4  DD0A4C     SL W1, #12, W4
0068C6  DE0044     LSR W0, #4, W0
0068C8  720000     IOR W4, W0, W0
0068CA  DE88C4     ASR W1, #4, W1
422:                   pid->output = pid->preSat;
0068D6  78001E     MOV [W14], W0
0068D8  9018F0     MOV [W0+62], W1
0068DA  901860     MOV [W0+60], W0
0068DC  780080     MOV W0, W1
0068DE  78001E     MOV [W14], W0
0068E0  982001     MOV W1, [W0+64]
423:                   //Clamp output above 0 since don't have H bridge
424:                   if (pid->preSat < pid->minVal) {
0068E2  78001E     MOV [W14], W0
0068E4  901960     MOV [W0+60], W2
0068E6  9019F0     MOV [W0+62], W3
0068E8  78001E     MOV [W14], W0
0068EA  902020     MOV [W0+68], W0
0068EC  DE80CF     ASR W0, #15, W1
0068EE  510F80     SUB W2, W0, [W15]
0068F0  598F81     SUBB W3, W1, [W15]
0068F2  3D0004     BRA GE, 0x68FC
425:                       pid->output = pid->minVal;
0068F4  78001E     MOV [W14], W0
0068F6  9020A0     MOV [W0+68], W1
0068F8  78001E     MOV [W14], W0
0068FA  982001     MOV W1, [W0+64]
426:                   }
427:               
428:                   pid-> i_error = (long) pid-> i_error + (long) pid->p_error; // integrate error
0068FC  78001E     MOV [W14], W0
0068FE  901160     MOV [W0+44], W2
006900  9011F0     MOV [W0+46], W3
006902  78001E     MOV [W14], W0
006904  9010C0     MOV [W0+40], W1
006906  901030     MOV [W0+38], W0
006908  400002     ADD W0, W2, W0
00690A  488083     ADDC W1, W3, W1
00690C  78011E     MOV [W14], W2
00690E  981160     MOV W0, [W2+44]
006910  981171     MOV W1, [W2+46]
429:                   // saturate output - assume only worry about >0 for now
430:                   // apply anti-windup to integrator
431:                   if (pid->preSat > pid->satValPos) {
006912  78001E     MOV [W14], W0
006914  901960     MOV [W0+60], W2
006916  9019F0     MOV [W0+62], W3
006918  78001E     MOV [W14], W0
00691A  902030     MOV [W0+70], W0
00691C  DE80CF     ASR W0, #15, W1
00691E  510F80     SUB W2, W0, [W15]
006920  598F81     SUBB W3, W1, [W15]
006922  340023     BRA LE, 0x696A
432:                       pid->output = pid->satValPos;
006924  78001E     MOV [W14], W0
006926  9020B0     MOV [W0+70], W1
006928  78001E     MOV [W14], W0
00692A  982001     MOV W1, [W0+64]
433:                       pid->i_error = (long) pid->i_error + (long) (pid->Kaw) * ((long) (pid->satValPos) - (long) (pid->preSat)) / ((long) GAIN_SCALER);
00692C  78001E     MOV [W14], W0
00692E  901460     MOV [W0+44], W8
006930  9014F0     MOV [W0+46], W9
006932  78001E     MOV [W14], W0
006934  901000     MOV [W0+32], W0
006936  B90161     MUL.SU W0, #1, W2
006938  78001E     MOV [W14], W0
00693A  902030     MOV [W0+70], W0
00693C  B90261     MUL.SU W0, #1, W4
00693E  78001E     MOV [W14], W0
006940  9018F0     MOV [W0+62], W1
006942  901860     MOV [W0+60], W0
006944  520000     SUB W4, W0, W0
006946  5A8081     SUBB W5, W1, W1
006948  B99A00     MUL.SS W3, W0, W4
00694A  780204     MOV W4, W4
00694C  B98B02     MUL.SS W1, W2, W6
00694E  780286     MOV W6, W5
006950  420205     ADD W4, W5, W4
006952  B81000     MUL.UU W2, W0, W0
006954  420201     ADD W4, W1, W4
006956  780084     MOV W4, W1
006958  200642     MOV #0x64, W2
00695A  200003     MOV #0x0, W3
00695C  022586     CALL ___divsi3
00695E  000000     NOP
006960  400008     ADD W0, W8, W0
006962  488089     ADDC W1, W9, W1
006964  78011E     MOV [W14], W2
006966  981160     MOV W0, [W2+44]
006968  981171     MOV W1, [W2+46]
434:                   }
435:               
436:               }
00696A  BE044F     MOV.D [--W15], W8
00696C  FA8000     ULNK
00696E  060000     RETURN
437:               
438:               //This duplicates functionalist in leg_ctrl
439:               static void hallUpdateBEMF() {
006970  FA0002     LNK #0x2
006972  781F88     MOV W8, [W15++]
440:                   //Back EMF measurements are made automatically by coordination of the ADC, PWM, and DMA.
441:                   //Copy to local variables. Not strictly neccesary, just for clarity.
442:                   //This **REQUIRES** that the divider on the battery & BEMF circuits have the same ratio.
443:                   hallbemf[0] = adcGetVBatt() - adcGetBEMFL();
006974  02DDB6     CALL adcGetVBatt
006976  000000     NOP
006978  780400     MOV W0, W8
00697A  02DDA6     CALL adcGetBEMFL
00697C  000000     NOP
00697E  540000     SUB W8, W0, W0
006980  88FC10     MOV W0, hallbemf
444:                   //NOTE: at this point, we should have a proper correspondance between
445:                   //   the order of all the structured variable; bemf[i] associated with
446:                   //   pidObjs[i], bemfLast[i], etc.
447:                   //   Any "jumbling" of the inputs can be done in the above assignments.
448:               
449:                   //Negative ADC measures mean nothing and should never happen anyway
450:                   if (hallbemf[0] < 0) {
006982  80FC11     MOV hallbemf, W1
006984  EB0000     CLR W0
006986  508F80     SUB W1, W0, [W15]
006988  3D0002     BRA GE, 0x698E
451:                       hallbemf[0] = 0;
00698A  EB0000     CLR W0
00698C  88FC10     MOV W0, hallbemf
452:                   }
453:               
454:                   //Apply median filter
455:                   int i;
456:                   for (i = 0; i < NUM_HALL_PIDS; i++) {
00698E  EB0000     CLR W0
006990  780F00     MOV W0, [W14]
006992  370032     BRA 0x69F8
0069F6  E80F1E     INC [W14], [W14]
0069F8  78009E     MOV [W14], W1
0069FA  EB0000     CLR W0
0069FC  508F80     SUB W1, W0, [W15]
0069FE  34FFCA     BRA LE, 0x6994
457:                       hallbemfHist[i][2] = hallbemfHist[i][1]; //rotate first
006994  78001E     MOV [W14], W0
006996  B90066     MUL.SU W0, #6, W0
006998  780000     MOV W0, W0
00699A  E88080     INC2 W0, W1
00699C  21F860     MOV #0x1F86, W0
00699E  408000     ADD W1, W0, W0
0069A0  780110     MOV [W0], W2
0069A2  78001E     MOV [W14], W0
0069A4  B90066     MUL.SU W0, #6, W0
0069A6  780080     MOV W0, W1
0069A8  21F8A0     MOV #0x1F8A, W0
0069AA  408000     ADD W1, W0, W0
0069AC  780802     MOV W2, [W0]
458:                       hallbemfHist[i][1] = hallbemfHist[i][0];
0069AE  78001E     MOV [W14], W0
0069B0  B90066     MUL.SU W0, #6, W0
0069B2  780080     MOV W0, W1
0069B4  21F860     MOV #0x1F86, W0
0069B6  408000     ADD W1, W0, W0
0069B8  780110     MOV [W0], W2
0069BA  78001E     MOV [W14], W0
0069BC  B90066     MUL.SU W0, #6, W0
0069BE  780080     MOV W0, W1
0069C0  21F880     MOV #0x1F88, W0
0069C2  408000     ADD W1, W0, W0
0069C4  780802     MOV W2, [W0]
459:                       hallbemfHist[i][0] = hallbemf[i]; //include newest value
0069C6  78001E     MOV [W14], W0
0069C8  400080     ADD W0, W0, W1
0069CA  21F820     MOV #0x1F82, W0
0069CC  408000     ADD W1, W0, W0
0069CE  780110     MOV [W0], W2
0069D0  78001E     MOV [W14], W0
0069D2  B90066     MUL.SU W0, #6, W0
0069D4  780080     MOV W0, W1
0069D6  21F860     MOV #0x1F86, W0
0069D8  408000     ADD W1, W0, W0
0069DA  780802     MOV W2, [W0]
460:                       hallbemf[i] = medianFilter3(hallbemfHist[i]); //Apply median filter
0069DC  21F862     MOV #0x1F86, W2
0069DE  78001E     MOV [W14], W0
0069E0  B90066     MUL.SU W0, #6, W0
0069E2  780000     MOV W0, W0
0069E4  410000     ADD W2, W0, W0
0069E6  024684     CALL medianFilter3
0069E8  000000     NOP
0069EA  780080     MOV W0, W1
0069EC  78001E     MOV [W14], W0
0069EE  400100     ADD W0, W0, W2
0069F0  21F820     MOV #0x1F82, W0
0069F2  410000     ADD W2, W0, W0
0069F4  780801     MOV W1, [W0]
461:                   }
462:               
463:                   // IIR filter on BEMF: y[n] = 0.2 * y[n-1] + 0.8 * x[n]
464:                   hallbemf[0] = (2 * (long) hallbemfLast[0] / 10) + 8 * (long) hallbemf[0] / 10;
006A00  80FC20     MOV hallbemfLast, W0
006A02  DE80CF     ASR W0, #15, W1
006A04  400000     ADD W0, W0, W0
006A06  488081     ADDC W1, W1, W1
006A08  2000A2     MOV #0xA, W2
006A0A  200003     MOV #0x0, W3
006A0C  022586     CALL ___divsi3
006A0E  000000     NOP
006A10  780400     MOV W0, W8
006A12  80FC10     MOV hallbemf, W0
006A14  B90161     MUL.SU W0, #1, W2
006A16  DD1843     SL W3, #3, W0
006A18  DE10CD     LSR W2, #13, W1
006A1A  700081     IOR W0, W1, W1
006A1C  DD1043     SL W2, #3, W0
006A1E  2000A2     MOV #0xA, W2
006A20  200003     MOV #0x0, W3
006A22  022586     CALL ___divsi3
006A24  000000     NOP
006A26  780000     MOV W0, W0
006A28  440000     ADD W8, W0, W0
006A2A  88FC10     MOV W0, hallbemf
465:                   hallbemfLast[0] = hallbemf[0]; //bemfLast will not be used after here, OK to set
006A2C  80FC10     MOV hallbemf, W0
006A2E  88FC20     MOV W0, hallbemfLast
466:               }
006A30  78044F     MOV [--W15], W8
006A32  FA8000     ULNK
006A34  060000     RETURN
467:               
468:               
469:               ////   Public functions
470:               ////////////////////////
471:               
472:               int hallGetOutput() {
006A36  FA0000     LNK #0x0
473:                   return hallPIDObjs.output;
006A38  80FE70     MOV 0x1FCE, W0
474:               }
006A3A  FA8000     ULNK
006A3C  060000     RETURN
475:               
476:               long hallGetError() {
006A3E  FA0002     LNK #0x2
477:                   int r = (int) hallPIDObjs.p_input + (hallPIDVel.interpolate >> 8);
006A40  80FC70     MOV hallPIDObjs, W0
006A42  80FC81     MOV 0x1F90, W1
006A44  780080     MOV W0, W1
006A46  80FEC0     MOV hallPIDVel, W0
006A48  DE8048     ASR W0, #8, W0
006A4A  408F00     ADD W1, W0, [W14]
478:                   return r;
006A4C  78001E     MOV [W14], W0
006A4E  DE80CF     ASR W0, #15, W1
479:               }
006A50  FA8000     ULNK
006A52  060000     RETURN
480:               
481:               void hallInitPIDObjPos(pidPos *pid, int Kp, int Ki, int Kd, int Kaw, int Kff) {
006A54  FA000C     LNK #0xC
006A56  780F00     MOV W0, [W14]
006A58  980711     MOV W1, [W14+2]
006A5A  980722     MOV W2, [W14+4]
006A5C  980733     MOV W3, [W14+6]
006A5E  980744     MOV W4, [W14+8]
006A60  980755     MOV W5, [W14+10]
482:                   pid->p_input = 0;
006A62  78011E     MOV [W14], W2
006A64  B80060     MUL.UU W0, #0, W0
006A66  BE8900     MOV.D W0, [W2]
483:                   pid->v_input = 0;
006A68  78001E     MOV [W14], W0
006A6A  EB0080     CLR W1
006A6C  980021     MOV W1, [W0+4]
484:                   pid->p = 0;
006A6E  78011E     MOV [W14], W2
006A70  B80060     MUL.UU W0, #0, W0
006A72  980170     MOV W0, [W2+14]
006A74  980901     MOV W1, [W2+16]
485:                   pid->i = 0;
006A76  78011E     MOV [W14], W2
006A78  B80060     MUL.UU W0, #0, W0
006A7A  980910     MOV W0, [W2+18]
006A7C  980921     MOV W1, [W2+20]
486:                   pid->d = 0;
006A7E  78011E     MOV [W14], W2
006A80  B80060     MUL.UU W0, #0, W0
006A82  980930     MOV W0, [W2+22]
006A84  980941     MOV W1, [W2+24]
487:                   pid->Kp = Kp;
006A86  78001E     MOV [W14], W0
006A88  90009E     MOV [W14+2], W1
006A8A  980851     MOV W1, [W0+26]
488:                   pid->Ki = Ki;
006A8C  78001E     MOV [W14], W0
006A8E  9000AE     MOV [W14+4], W1
006A90  980861     MOV W1, [W0+28]
489:                   pid->Kd = Kd;
006A92  78001E     MOV [W14], W0
006A94  9000BE     MOV [W14+6], W1
006A96  980871     MOV W1, [W0+30]
490:                   pid->Kaw = Kaw;
006A98  78001E     MOV [W14], W0
006A9A  9000CE     MOV [W14+8], W1
006A9C  981001     MOV W1, [W0+32]
491:                   pid->Kff = Kff;
006A9E  78001E     MOV [W14], W0
006AA0  9000DE     MOV [W14+10], W1
006AA2  981851     MOV W1, [W0+58]
492:                   pid->output = 0;
006AA4  78001E     MOV [W14], W0
006AA6  EB0080     CLR W1
006AA8  982001     MOV W1, [W0+64]
493:                   pid->onoff = 0;
006AAA  78009E     MOV [W14], W1
006AAC  EB4000     CLR.B W0
006AAE  9860D0     MOV.B W0, [W1+37]
494:                   pid->p_error = 0;
006AB0  78011E     MOV [W14], W2
006AB2  B80060     MUL.UU W0, #0, W0
006AB4  981130     MOV W0, [W2+38]
006AB6  981141     MOV W1, [W2+40]
495:                   pid->v_error = 0;
006AB8  78001E     MOV [W14], W0
006ABA  EB0080     CLR W1
006ABC  981051     MOV W1, [W0+42]
496:                   pid->i_error = 0;
006ABE  78011E     MOV [W14], W2
006AC0  B80060     MUL.UU W0, #0, W0
006AC2  981160     MOV W0, [W2+44]
006AC4  981171     MOV W1, [W2+46]
497:               }
006AC6  FA8000     ULNK
006AC8  060000     RETURN
498:               
499:               // called from steeringSetup()
500:               
501:               void hallInitPIDObj(pidObj *pid, int Kp, int Ki, int Kd, int Kaw, int Kff) {
006ACA  FA000C     LNK #0xC
006ACC  780F00     MOV W0, [W14]
006ACE  980711     MOV W1, [W14+2]
006AD0  980722     MOV W2, [W14+4]
006AD2  980733     MOV W3, [W14+6]
006AD4  980744     MOV W4, [W14+8]
006AD6  980755     MOV W5, [W14+10]
502:                   pid->input = 0;
006AD8  78001E     MOV [W14], W0
006ADA  EB0080     CLR W1
006ADC  780801     MOV W1, [W0]
503:                   pid->dState = 0;
006ADE  78011E     MOV [W14], W2
006AE0  B80060     MUL.UU W0, #0, W0
006AE2  980110     MOV W0, [W2+2]
006AE4  980121     MOV W1, [W2+4]
504:                   pid->iState = 0;
006AE6  78011E     MOV [W14], W2
006AE8  B80060     MUL.UU W0, #0, W0
006AEA  980130     MOV W0, [W2+6]
006AEC  980141     MOV W1, [W2+8]
505:                   pid->output = 0;
006AEE  78001E     MOV [W14], W0
006AF0  EB0080     CLR W1
006AF2  981021     MOV W1, [W0+36]
506:                   pid->y_old = 0;
006AF4  78001E     MOV [W14], W0
006AF6  EB0080     CLR W1
006AF8  981011     MOV W1, [W0+34]
507:                   pid->p = 0;
006AFA  78011E     MOV [W14], W2
006AFC  B80060     MUL.UU W0, #0, W0
006AFE  980170     MOV W0, [W2+14]
006B00  980901     MOV W1, [W2+16]
508:                   pid->i = 0;
006B02  78011E     MOV [W14], W2
006B04  B80060     MUL.UU W0, #0, W0
006B06  980910     MOV W0, [W2+18]
006B08  980921     MOV W1, [W2+20]
509:                   pid->d = 0;
006B0A  78011E     MOV [W14], W2
006B0C  B80060     MUL.UU W0, #0, W0
006B0E  980930     MOV W0, [W2+22]
006B10  980941     MOV W1, [W2+24]
510:                   //This is just a guess for the derivative filter time constant
511:                   pid->N = 5;
006B12  78009E     MOV [W14], W1
006B14  B3C050     MOV #0x5, W0
006B16  9860E0     MOV.B W0, [W1+38]
512:                   pid->Kp = Kp;
006B18  78001E     MOV [W14], W0
006B1A  90009E     MOV [W14+2], W1
006B1C  980851     MOV W1, [W0+26]
513:                   pid->Ki = Ki;
006B1E  78001E     MOV [W14], W0
006B20  9000AE     MOV [W14+4], W1
006B22  980861     MOV W1, [W0+28]
514:                   pid->Kd = Kd;
006B24  78001E     MOV [W14], W0
006B26  9000BE     MOV [W14+6], W1
006B28  980871     MOV W1, [W0+30]
515:                   pid->Kaw = Kaw;
006B2A  78001E     MOV [W14], W0
006B2C  9000CE     MOV [W14+8], W1
006B2E  981001     MOV W1, [W0+32]
516:                   pid->Kff = 0;
006B30  78001E     MOV [W14], W0
006B32  EB0080     CLR W1
006B34  981831     MOV W1, [W0+54]
517:                   pid->onoff = 0;
006B36  78009E     MOV [W14], W1
006B38  EB4000     CLR.B W0
006B3A  9860F0     MOV.B W0, [W1+39]
518:                   pid->error = 0;
006B3C  78011E     MOV [W14], W2
006B3E  B80060     MUL.UU W0, #0, W0
006B40  981140     MOV W0, [W2+40]
006B42  981151     MOV W1, [W2+42]
519:               }
006B44  FA8000     ULNK
006B46  060000     RETURN
520:               
521:               //todo: a getter should not return a pointer; this is unsafe behavior.
522:               long* hallGetMotorCounts() {
006B48  FA0000     LNK #0x0
523:                   return motor_count;
006B4A  21F7E0     MOV #0x1F7E, W0
524:               }
006B4C  FA8000     ULNK
006B4E  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/directory.c  ----------------------------------------------
1:                 /**
2:                  * Copyright (c) 2011-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Network Directory
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu         2011-09-03    Initial implementation
38:                 *                      
39:                 * Notes:
40:                 */
41:                
42:                #include "directory.h"
43:                #include "larray.h"
44:                #include <stdlib.h>
45:                
46:                // ==== Static Variables =======================================================
47:                static unsigned char is_ready = 0;
48:                static LinArray dir;
49:                
50:                // ==== Function Stubs =========================================================
51:                DirEntry dirCreateEntry(void);
52:                void dirDeleteEntry(DirEntry entry);
53:                unsigned int searchAddress(DirEntry entry, void* args);
54:                unsigned int searchID(DirEntry entry, void* args);
55:                unsigned int searchValid(DirEntry entry, void* args);
56:                
57:                // ==== Function Bodies ========================================================
58:                void dirInit(unsigned int size) {
00CB38  FA0002     LNK #0x2
00CB3A  780F00     MOV W0, [W14]
59:                
60:                    dir = larrayCreate(size);    
00CB3C  78001E     MOV [W14], W0
00CB3E  02CEEA     CALL larrayCreate
00CB40  000000     NOP
00CB42  8910E0     MOV W0, dir
61:                    is_ready = 1;
00CB44  2221A1     MOV #0x221A, W1
00CB46  B3C010     MOV #0x1, W0
00CB48  784880     MOV.B W0, [W1]
62:                    
63:                 }
00CB4A  FA8000     ULNK
00CB4C  060000     RETURN
64:                
65:                unsigned int dirQuery(DirEntryTest comp, void *args, DirEntry *entry) {
00CB4E  FA0008     LNK #0x8
00CB50  980710     MOV W0, [W14+2]
00CB52  980721     MOV W1, [W14+4]
00CB54  980732     MOV W2, [W14+6]
66:                
67:                    unsigned int i;    
68:                
69:                    return larrayFindFirst(dir, (LinArrayItemTest)comp, args,
00CB56  90013E     MOV [W14+6], W2
00CB58  90009E     MOV [W14+2], W1
00CB5A  8110E0     MOV dir, W0
00CB5C  780202     MOV W2, W4
00CB5E  78018E     MOV W14, W3
00CB60  90012E     MOV [W14+4], W2
00CB62  02CFB4     CALL larrayFindFirst
00CB64  000000     NOP
70:                                &i, (LinArrayItem*) entry);
71:                
72:                }
00CB66  FA8000     ULNK
00CB68  060000     RETURN
73:                
74:                unsigned int dirQueryN(DirEntryTest comp, void *args, DirEntry *entries,
75:                                        unsigned int N) {
00CB6A  FA000C     LNK #0xC
00CB6C  BE9F88     MOV.D W8, [W15++]
00CB6E  980720     MOV W0, [W14+4]
00CB70  980731     MOV W1, [W14+6]
00CB72  980742     MOV W2, [W14+8]
00CB74  980753     MOV W3, [W14+10]
00CB78  78000F     MOV W15, W0
00CB7A  780480     MOV W0, W9
76:                
77:                    unsigned int i[N];
00CB7C  90005E     MOV [W14+10], W0
00CB7E  780080     MOV W0, W1
00CB80  E90081     DEC W1, W1
00CB82  780F01     MOV W1, [W14]
00CB84  400000     ADD W0, W0, W0
00CB86  E80000     INC W0, W0
00CB88  E80000     INC W0, W0
00CB8A  D10000     LSR W0, W0
00CB8C  400080     ADD W0, W0, W1
00CB8E  78000F     MOV W15, W0
00CB90  478781     ADD W15, W1, W15
00CB92  E80000     INC W0, W0
00CB94  D10000     LSR W0, W0
00CB96  400000     ADD W0, W0, W0
00CB98  980710     MOV W0, [W14+2]
78:                
79:                    return larrayFindN(dir, (LinArrayItemTest)comp, args, i,
00CB9A  9001CE     MOV [W14+8], W3
00CB9C  90011E     MOV [W14+2], W2
00CB9E  9000AE     MOV [W14+4], W1
00CBA0  8110E0     MOV dir, W0
00CBA2  9002DE     MOV [W14+10], W5
00CBA4  780203     MOV W3, W4
00CBA6  780182     MOV W2, W3
00CBA8  90013E     MOV [W14+6], W2
00CBAA  02CFD2     CALL larrayFindN
00CBAC  000000     NOP
00CBAE  780789     MOV W9, W15
80:                                            (LinArrayItem*) entries, N);
81:                
82:                }
00CB76  78040F     MOV W15, W8
00CBB0  780788     MOV W8, W15
00CBB2  BE044F     MOV.D [--W15], W8
00CBB4  FA8000     ULNK
00CBB6  060000     RETURN
83:                
84:                DirEntry dirQueryAddress(unsigned int addr, unsigned int pan) {
00CBB8  FA000A     LNK #0xA
00CBBA  980730     MOV W0, [W14+6]
00CBBC  980741     MOV W1, [W14+8]
85:                
86:                    unsigned int args[2];
87:                    DirEntry entry;
88:                
89:                    args[0] = addr;
00CBBE  90003E     MOV [W14+6], W0
00CBC0  780F00     MOV W0, [W14]
90:                    args[1] = pan;
00CBC2  90004E     MOV [W14+8], W0
00CBC4  980710     MOV W0, [W14+2]
91:                
92:                    // If search successful, return item
93:                    if(dirQuery(&searchAddress, args, &entry)) {
00CBC6  470064     ADD W14, #0x4, W0
00CBC8  780100     MOV W0, W2
00CBCA  78008E     MOV W14, W1
00CBCC  2CC600     MOV #0xCC60, W0
00CBCE  07FFBF     RCALL dirQuery
00CBD0  EB0080     CLR W1
00CBD2  500F81     SUB W0, W1, [W15]
00CBD4  320002     BRA Z, 0xCBDA
94:                        return entry;
00CBD6  90002E     MOV [W14+4], W0
00CBD8  370001     BRA 0xCBDC
95:                    }
96:                    return NULL;
00CBDA  EB0000     CLR W0
97:                
98:                }
00CBDC  FA8000     ULNK
00CBDE  060000     RETURN
99:                
100:               DirEntry dirQueryID(unsigned long long id) {
00CBE0  FA000A     LNK #0xA
00CBE2  980710     MOV W0, [W14+2]
00CBE4  980721     MOV W1, [W14+4]
00CBE6  980732     MOV W2, [W14+6]
00CBE8  980743     MOV W3, [W14+8]
101:               
102:                   DirEntry entry;
103:               
104:                   // If search successful, return item
105:                   if(dirQuery(&searchID, &id, &entry)) {
00CBEA  E8800E     INC2 W14, W0
00CBEC  78010E     MOV W14, W2
00CBEE  780080     MOV W0, W1
00CBF0  2CC960     MOV #0xCC96, W0
00CBF2  07FFAD     RCALL dirQuery
00CBF4  EB0080     CLR W1
00CBF6  500F81     SUB W0, W1, [W15]
00CBF8  320002     BRA Z, 0xCBFE
106:                       return entry;
00CBFA  78001E     MOV [W14], W0
00CBFC  370001     BRA 0xCC00
107:                   }
108:                   return NULL;
00CBFE  EB0000     CLR W0
109:               
110:               }
00CC00  FA8000     ULNK
00CC02  060000     RETURN
111:               
112:               DirEntry dirAddNew(void) {
00CC04  FA0004     LNK #0x4
113:               
114:                   DirEntry entry;
115:                   unsigned int i;
116:               
117:                   // Allocate new entry
118:                   entry = dirCreateEntry();
00CC06  07006A     RCALL dirCreateEntry
00CC08  780F00     MOV W0, [W14]
119:                   if(entry == NULL) { return NULL; }
00CC0A  78009E     MOV [W14], W1
00CC0C  EB0000     CLR W0
00CC0E  508F80     SUB W1, W0, [W15]
00CC10  3A0002     BRA NZ, 0xCC16
00CC12  EB0000     CLR W0
00CC14  370011     BRA 0xCC38
120:               
121:                   // Find space
122:                   if(larrayFindEmpty(dir, &i) == 0) { 
00CC16  8110E0     MOV dir, W0
00CC18  E8808E     INC2 W14, W1
00CC1A  02D040     CALL larrayFindEmpty
00CC1C  000000     NOP
00CC1E  EB0080     CLR W1
00CC20  500F81     SUB W0, W1, [W15]
00CC22  3A0004     BRA NZ, 0xCC2C
123:                       dirDeleteEntry(entry);
00CC24  78001E     MOV [W14], W0
00CC26  070069     RCALL dirDeleteEntry
124:                       return NULL;
00CC28  EB0000     CLR W0
00CC2A  370006     BRA 0xCC38
125:                   }
126:               
127:                   larrayReplace(dir, i, entry);
00CC2C  90009E     MOV [W14+2], W1
00CC2E  8110E0     MOV dir, W0
00CC30  78011E     MOV [W14], W2
00CC32  02CF36     CALL larrayReplace
00CC34  000000     NOP
128:                   return entry;
00CC36  78001E     MOV [W14], W0
129:               
130:               }
00CC38  FA8000     ULNK
00CC3A  060000     RETURN
131:               
132:               unsigned int dirGetSize(void) {
00CC3C  FA0000     LNK #0x0
133:               
134:                   return larrayGetSize(dir);
00CC3E  8110E0     MOV dir, W0
00CC40  02D084     CALL larrayGetSize
00CC42  000000     NOP
135:               
136:               }
00CC44  FA8000     ULNK
00CC46  060000     RETURN
137:               
138:               unsigned int dirGetEntries(DirEntry *entries) {
00CC48  FA0002     LNK #0x2
00CC4A  780F00     MOV W0, [W14]
139:                   
140:                   return dirQueryN(&searchValid, NULL, entries, larrayGetMaxSize(dir));
00CC4C  8110E0     MOV dir, W0
00CC4E  02D090     CALL larrayGetMaxSize
00CC50  000000     NOP
00CC52  780180     MOV W0, W3
00CC54  78011E     MOV [W14], W2
00CC56  EB0080     CLR W1
00CC58  2CCCC0     MOV #0xCCCC, W0
00CC5A  07FF87     RCALL dirQueryN
141:               
142:               }
00CC5C  FA8000     ULNK
00CC5E  060000     RETURN
143:               
144:               // ==== Private Functions ======================================================
145:               
146:               unsigned int searchAddress(DirEntry entry, void *args) {
00CC60  FA0004     LNK #0x4
00CC62  780F00     MOV W0, [W14]
00CC64  980711     MOV W1, [W14+2]
147:               
148:                   if(entry == NULL) { return 0; }
00CC66  78009E     MOV [W14], W1
00CC68  EB0000     CLR W0
00CC6A  508F80     SUB W1, W0, [W15]
00CC6C  3A0002     BRA NZ, 0xCC72
00CC6E  EB0000     CLR W0
00CC70  370010     BRA 0xCC92
149:                   return entry->address == ((unsigned int*)args)[0] &&
00CC72  78001E     MOV [W14], W0
00CC74  9008C0     MOV [W0+24], W1
00CC76  90001E     MOV [W14+2], W0
00CC78  780010     MOV [W0], W0
00CC7A  508F80     SUB W1, W0, [W15]
00CC7C  3A0009     BRA NZ, 0xCC90
00CC88  508F80     SUB W1, W0, [W15]
00CC8A  3A0002     BRA NZ, 0xCC90
00CC8C  200010     MOV #0x1, W0
00CC8E  370001     BRA 0xCC92
00CC90  EB0000     CLR W0
150:                           entry->pan_id == ((unsigned int*)args)[1];
00CC7E  78001E     MOV [W14], W0
00CC80  9008D0     MOV [W0+26], W1
00CC82  90001E     MOV [W14+2], W0
00CC84  E88000     INC2 W0, W0
00CC86  780010     MOV [W0], W0
151:               
152:               }
00CC92  FA8000     ULNK
00CC94  060000     RETURN
153:               
154:               unsigned int searchID(DirEntry entry, void *args) {
00CC96  FA0004     LNK #0x4
00CC98  781F88     MOV W8, [W15++]
00CC9A  780F00     MOV W0, [W14]
00CC9C  980711     MOV W1, [W14+2]
155:               
156:                   if(entry == NULL) { return 0; }
00CC9E  78009E     MOV [W14], W1
00CCA0  EB0000     CLR W0
00CCA2  508F80     SUB W1, W0, [W15]
00CCA4  3A0002     BRA NZ, 0xCCAA
00CCA6  EB0400     CLR W8
00CCA8  37000D     BRA 0xCCC4
157:                   return entry->uuid == *((unsigned long long *)args);
00CCAA  78001E     MOV [W14], W0
00CCAC  BE0230     MOV.D [W0++], W4
00CCAE  BE0320     MOV.D [W0--], W6
00CCB0  90001E     MOV [W14+2], W0
00CCB2  BE0150     MOV.D [++W0], W2
00CCB4  BE0040     MOV.D [--W0], W0
00CCB6  200018     MOV #0x1, W8
00CCB8  E12000     CP W4, W0
00CCBA  E1A801     CPB W5, W1
00CCBC  E1B002     CPB W6, W2
00CCBE  E1B803     CPB W7, W3
00CCC0  320001     BRA Z, 0xCCC4
00CCC2  EB0400     CLR W8
00CCC4  780008     MOV W8, W0
158:               
159:               }
00CCC6  78044F     MOV [--W15], W8
00CCC8  FA8000     ULNK
00CCCA  060000     RETURN
160:               
161:               unsigned int searchValid(DirEntry entry, void *args) {
00CCCC  FA0004     LNK #0x4
00CCCE  780F00     MOV W0, [W14]
00CCD0  980711     MOV W1, [W14+2]
162:               
163:                   return entry != NULL;
00CCD2  EA001E     NEG [W14], W0
00CCD4  70001E     IOR W0, [W14], W0
00CCD6  DE004F     LSR W0, #15, W0
164:               
165:               }
00CCD8  FA8000     ULNK
00CCDA  060000     RETURN
166:               
167:               DirEntry dirCreateEntry(void) {
00CCDC  FA0002     LNK #0x2
168:               
169:                   DirEntry entry;
170:               
171:                   entry = (DirEntry) calloc(sizeof(DirEntryStruct), 1);
00CCDE  200011     MOV #0x1, W1
00CCE0  2001C0     MOV #0x1C, W0
00CCE2  023556     CALL _calloc
00CCE4  000000     NOP
00CCE6  780F00     MOV W0, [W14]
172:                   if(entry == NULL) { return NULL; }
00CCE8  78009E     MOV [W14], W1
00CCEA  EB0000     CLR W0
00CCEC  508F80     SUB W1, W0, [W15]
00CCEE  3A0002     BRA NZ, 0xCCF4
00CCF0  EB0000     CLR W0
00CCF2  370001     BRA 0xCCF6
173:               
174:                   return entry;
00CCF4  78001E     MOV [W14], W0
175:               
176:               }
00CCF6  FA8000     ULNK
00CCF8  060000     RETURN
177:               
178:               void dirDeleteEntry(DirEntry entry) {
00CCFA  FA0002     LNK #0x2
00CCFC  780F00     MOV W0, [W14]
179:               
180:                   if(entry == NULL) { return; }
00CCFE  78009E     MOV [W14], W1
00CD00  EB0000     CLR W0
00CD02  508F80     SUB W1, W0, [W15]
00CD04  320004     BRA Z, 0xCD0E
00CD0E  000000     NOP
181:                   free(entry);
00CD06  78001E     MOV [W14], W0
00CD08  0234EC     CALL _free
00CD0A  000000     NOP
00CD0C  370001     BRA 0xCD10
182:                   
183:               }
00CD10  FA8000     ULNK
00CD12  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/cv.c  -----------------------------------------------------
1:                 /**
2:                 * Copyright (c) 2011-2012, Regents of the University of California
3:                 * All rights reserved.
4:                 *
5:                 * Redistribution and use in source and binary forms, with or without
6:                 * modification, are permitted provided that the following conditions are met:
7:                 *
8:                 * - Redistributions of source code must retain the above copyright notice,
9:                 *   this list of conditions and the following disclaimer.
10:                * - Redistributions in binary form must reproduce the above copyright notice,
11:                *   this list of conditions and the following disclaimer in the documentation
12:                *   and/or other materials provided with the distribution.
13:                * - Neither the name of the University of California, Berkeley nor the names
14:                *   of its contributors may be used to endorse or promote products derived
15:                *   from this software without specific prior written permission.
16:                *
17:                * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                * POSSIBILITY OF SUCH DAMAGE.
28:                *
29:                *
30:                * Online computer vision module
31:                *
32:                * by Humphrey Hu
33:                *
34:                * v. beta
35:                *
36:                * Revisions:
37:                *  Humphrey Hu      2011-07-01      Initial implementation
38:                *  Humphrey Hu      2012-02-16      Complete rewrite to use camera driver
39:                */
40:                
41:                #include "attitude.h"
42:                #include "cv.h"
43:                #include "cam.h"
44:                #include "counter.h"
45:                #include "utils.h"
46:                #include "bams.h" // For fast trig
47:                #include "sqrti.h" // For fast integer square root
48:                
49:                #include <math.h>
50:                #include <stdlib.h>
51:                #include <string.h>
52:                
53:                // =========== Static Variables ================================================
54:                
55:                // State info
56:                static unsigned char is_ready, high_pass_on;
57:                
58:                static CamFrame background_frame;
59:                
60:                // =========== Function Stubs ==================================================
61:                
62:                // Shifting and setting helpers
63:                static void shiftFrameHorizontal(CamFrame frame, int num);
64:                static void shiftFrameVertical(CamFrame frame, int num);
65:                static void shiftColumn(CamFrame frame, unsigned int col, 
66:                                    unsigned int row_dst, unsigned int row_src, unsigned int num);
67:                static void setColumn(CamFrame frame, unsigned int col, unsigned int row_dst,
68:                                    unsigned char val, unsigned int num);
69:                                    
70:                // =========== Public Methods ==================================================                    
71:                                    
72:                void cvSetup(void) {        
00581E  FA0000     LNK #0x0
73:                    
74:                    is_ready = 0;    
005820  222161     MOV #0x2216, W1
005822  EB4000     CLR.B W0
005824  784880     MOV.B W0, [W1]
75:                       
76:                    background_frame = NULL;
005826  EB0000     CLR W0
005828  8910C0     MOV W0, background_frame
77:                    high_pass_on = 0;
00582A  222171     MOV #0x2217, W1
00582C  EB4000     CLR.B W0
00582E  784880     MOV.B W0, [W1]
78:                    
79:                    is_ready = 1;
005830  222161     MOV #0x2216, W1
005832  B3C010     MOV #0x1, W0
005834  784880     MOV.B W0, [W1]
80:                
81:                }
005836  FA8000     ULNK
005838  060000     RETURN
82:                
83:                void cvSetHP() {
00583A  FA0000     LNK #0x0
84:                
85:                    high_pass_on = ~high_pass_on;
00583C  222170     MOV #0x2217, W0
00583E  784010     MOV.B [W0], W0
005840  EAC000     COM.B W0, W0
005842  222171     MOV #0x2217, W1
005844  784880     MOV.B W0, [W1]
86:                
87:                }
005846  FA8000     ULNK
005848  060000     RETURN
88:                
89:                void cvProcessFrame(CamFrame frame, CvResult info) {    
00584A  FA0004     LNK #0x4
00584C  780F00     MOV W0, [W14]
00584E  980711     MOV W1, [W14+2]
90:                
91:                    if(!is_ready) { return; } // Module readiness quick fail       
005850  222160     MOV #0x2216, W0
005852  784090     MOV.B [W0], W1
005854  EB4000     CLR.B W0
005856  50CF80     SUB.B W1, W0, [W15]
005858  32000C     BRA Z, 0x5872
005872  000000     NOP
92:                
93:                    cvReadFrameParams(frame, info);     
00585A  90009E     MOV [W14+2], W1
00585C  78001E     MOV [W14], W0
00585E  070015     RCALL cvReadFrameParams
94:                    //cvRotateFrame(frame, -attGetYawBAMS());
95:                    
96:                    if(high_pass_on) {
005860  222170     MOV #0x2217, W0
005862  784090     MOV.B [W0], W1
005864  EB4000     CLR.B W0
005866  50CF80     SUB.B W1, W0, [W15]
005868  320005     BRA Z, 0x5874
97:                        cvSobel(frame, info);
00586A  90009E     MOV [W14+2], W1
00586C  78001E     MOV [W14], W0
00586E  070216     RCALL cvSobel
005870  370001     BRA 0x5874
98:                        //cvBinary(frame, info);
99:                    }
100:                       
101:                   
102:               }
005874  FA8000     ULNK
005876  060000     RETURN
103:               
104:               CamFrame cvSetBackgroundFrame(CamFrame frame) {
005878  FA0004     LNK #0x4
00587A  980710     MOV W0, [W14+2]
105:               
106:                   CamFrame old;
107:               
108:                   old = background_frame;
00587C  8110C0     MOV background_frame, W0
00587E  780F00     MOV W0, [W14]
109:                   background_frame = frame;
005880  90001E     MOV [W14+2], W0
005882  8910C0     MOV W0, background_frame
110:               
111:                   return old;
005884  78001E     MOV [W14], W0
112:                   
113:               }
005886  FA8000     ULNK
005888  060000     RETURN
114:               
115:               void cvReadFrameParams(CamFrame frame, CvResult info) {
00588A  FA0004     LNK #0x4
00588C  780F00     MOV W0, [W14]
00588E  980711     MOV W1, [W14+2]
116:               
117:                   if(frame == NULL || info == NULL) { return; };
005890  78009E     MOV [W14], W1
005892  EB0000     CLR W0
005894  508F80     SUB W1, W0, [W15]
005896  320014     BRA Z, 0x58C0
005898  90009E     MOV [W14+2], W1
00589A  EB0000     CLR W0
00589C  508F80     SUB W1, W0, [W15]
00589E  320012     BRA Z, 0x58C4
0058C0  000000     NOP
0058C2  370001     BRA 0x58C6
0058C4  000000     NOP
118:                   
119:                   memset(info, 0, sizeof(CvResultStruct)); // Reset fields
0058A0  200A02     MOV #0xA0, W2
0058A2  EB0080     CLR W1
0058A4  90001E     MOV [W14+2], W0
0058A6  0235B4     CALL _memset
0058A8  000000     NOP
120:                   
121:                   info->offset[0] = 0;
0058AA  90001E     MOV [W14+2], W0
0058AC  EB0080     CLR W1
0058AE  980031     MOV W1, [W0+6]
122:                   info->offset[1] = 0;       
0058B0  90001E     MOV [W14+2], W0
0058B2  EB0080     CLR W1
0058B4  980041     MOV W1, [W0+8]
123:                   info->frame_num = frame->frame_num;    
0058B6  78001E     MOV [W14], W0
0058B8  9000A0     MOV [W0+4], W1
0058BA  90001E     MOV [W14+2], W0
0058BC  780801     MOV W1, [W0]
0058BE  370003     BRA 0x58C6
124:               
125:               }
0058C6  FA8000     ULNK
0058C8  060000     RETURN
126:               
127:               /**
128:                * Subtract the set background frame from the input frame.
129:                *
130:                * @param frame - Input frame
131:                * @param info - Info struct to populate
132:                */
133:               void cvBackgroundSubtractFrame(CamFrame frame, CvResult info) {
0058CA  FA000A     LNK #0xA
0058CC  980730     MOV W0, [W14+6]
0058CE  980741     MOV W1, [W14+8]
134:               
135:                   unsigned char cap_val, bg_val;
136:                   unsigned int i, j; 
137:               
138:                   if(frame == NULL || info == NULL) { return; }
0058D0  9000BE     MOV [W14+6], W1
0058D2  EB0000     CLR W0
0058D4  508F80     SUB W1, W0, [W15]
0058D6  32004E     BRA Z, 0x5974
0058D8  9000CE     MOV [W14+8], W1
0058DA  EB0000     CLR W0
0058DC  508F80     SUB W1, W0, [W15]
0058DE  32004C     BRA Z, 0x5978
005974  000000     NOP
005976  370003     BRA 0x597E
005978  000000     NOP
00597A  370001     BRA 0x597E
139:                   if(background_frame == NULL) { return; }
0058E0  8110C1     MOV background_frame, W1
0058E2  EB0000     CLR W0
0058E4  508F80     SUB W1, W0, [W15]
0058E6  32004A     BRA Z, 0x597C
00597C  000000     NOP
140:               
141:                   for(i = 0; i < DS_IMAGE_ROWS; i++) {        
0058E8  EB0000     CLR W0
0058EA  780F00     MOV W0, [W14]
0058EC  37003E     BRA 0x596A
005968  E80F1E     INC [W14], [W14]
00596A  2003B0     MOV #0x3B, W0
00596C  78009E     MOV [W14], W1
00596E  508F80     SUB W1, W0, [W15]
005970  36FFBE     BRA LEU, 0x58EE
005972  370005     BRA 0x597E
142:                       for(j = 0; j < DS_IMAGE_COLS; j++) {        
0058EE  EB0000     CLR W0
0058F0  980710     MOV W0, [W14+2]
0058F2  370036     BRA 0x5960
00595A  90001E     MOV [W14+2], W0
00595C  E80000     INC W0, W0
00595E  980710     MOV W0, [W14+2]
005960  90009E     MOV [W14+2], W1
005962  2004A0     MOV #0x4A, W0
005964  508F80     SUB W1, W0, [W15]
005966  36FFC6     BRA LEU, 0x58F4
143:                           cap_val = frame->pixels[i][j];
0058F4  90013E     MOV [W14+6], W2
0058F6  78009E     MOV [W14], W1
0058F8  2004B0     MOV #0x4B, W0
0058FA  B98800     MUL.SS W1, W0, W0
0058FC  780080     MOV W0, W1
0058FE  90001E     MOV [W14+2], W0
005900  408000     ADD W1, W0, W0
005902  400066     ADD W0, #0x6, W0
005904  410000     ADD W2, W0, W0
005906  784090     MOV.B [W0], W1
005908  984741     MOV.B W1, [W14+4]
144:                           bg_val = background_frame->pixels[i][j];
00590A  8110C2     MOV background_frame, W2
00590C  78009E     MOV [W14], W1
00590E  2004B0     MOV #0x4B, W0
005910  B98800     MUL.SS W1, W0, W0
005912  780080     MOV W0, W1
005914  90001E     MOV [W14+2], W0
005916  408000     ADD W1, W0, W0
005918  400066     ADD W0, #0x6, W0
00591A  410000     ADD W2, W0, W0
00591C  784090     MOV.B [W0], W1
00591E  984751     MOV.B W1, [W14+5]
145:                           
146:                           if(cap_val > bg_val) {
005920  9040CE     MOV.B [W14+4], W1
005922  90405E     MOV.B [W14+5], W0
005924  50CF80     SUB.B W1, W0, [W15]
005926  36000E     BRA LEU, 0x5944
147:                               frame->pixels[i][j] = cap_val - bg_val;
005928  9040CE     MOV.B [W14+4], W1
00592A  90405E     MOV.B [W14+5], W0
00592C  50C100     SUB.B W1, W0, W2
00592E  9001BE     MOV [W14+6], W3
005930  78009E     MOV [W14], W1
005932  2004B0     MOV #0x4B, W0
005934  B98800     MUL.SS W1, W0, W0
005936  780000     MOV W0, W0
005938  418080     ADD W3, W0, W1
00593A  90001E     MOV [W14+2], W0
00593C  408000     ADD W1, W0, W0
00593E  400066     ADD W0, #0x6, W0
005940  784802     MOV.B W2, [W0]
005942  37000B     BRA 0x595A
148:                           } else {
149:                               frame->pixels[i][j] = 0;
005944  90013E     MOV [W14+6], W2
005946  78009E     MOV [W14], W1
005948  2004B0     MOV #0x4B, W0
00594A  B98800     MUL.SS W1, W0, W0
00594C  780000     MOV W0, W0
00594E  410080     ADD W2, W0, W1
005950  90001E     MOV [W14+2], W0
005952  408000     ADD W1, W0, W0
005954  4000E6     ADD W0, #0x6, W1
005956  EB4000     CLR.B W0
005958  784880     MOV.B W0, [W1]
150:                           }            
151:                       }
152:                   }
153:               
154:               }
00597E  FA8000     ULNK
005980  060000     RETURN
155:               
156:               /**
157:                * Find the maximum luminosity pixel in the input frame.
158:                *
159:                * @param frame - Input frame
160:                * @param info - Info struct to populate
161:                */
162:               void cvMaxPixelFrame(CamFrame frame, CvResult info) {
005982  FA0010     LNK #0x10
005984  980760     MOV W0, [W14+12]
005986  980771     MOV W1, [W14+14]
163:                   
164:                   unsigned int i, j, max_val, max_loc[2];
165:                   unsigned char val;    
166:                   
167:                   max_val = 0;    
005988  EB0000     CLR W0
00598A  980720     MOV W0, [W14+4]
168:                   max_loc[0] = 0;
00598C  EB0000     CLR W0
00598E  980740     MOV W0, [W14+8]
169:                   max_loc[1] = 1;
005990  200010     MOV #0x1, W0
005992  980750     MOV W0, [W14+10]
170:               
171:                   for(i = 0; i < DS_IMAGE_ROWS; i++) {        
005994  EB0000     CLR W0
005996  780F00     MOV W0, [W14]
005998  370022     BRA 0x59DE
0059DC  E80F1E     INC [W14], [W14]
0059DE  2003B0     MOV #0x3B, W0
0059E0  78009E     MOV [W14], W1
0059E2  508F80     SUB W1, W0, [W15]
0059E4  36FFDA     BRA LEU, 0x599A
172:                       for(j = 0; j < DS_IMAGE_COLS; j++) {
00599A  EB0000     CLR W0
00599C  980710     MOV W0, [W14+2]
00599E  37001A     BRA 0x59D4
0059CE  90001E     MOV [W14+2], W0
0059D0  E80000     INC W0, W0
0059D2  980710     MOV W0, [W14+2]
0059D4  90009E     MOV [W14+2], W1
0059D6  2004A0     MOV #0x4A, W0
0059D8  508F80     SUB W1, W0, [W15]
0059DA  36FFE2     BRA LEU, 0x59A0
173:                           val = frame->pixels[i][j];
0059A0  90016E     MOV [W14+12], W2
0059A2  78009E     MOV [W14], W1
0059A4  2004B0     MOV #0x4B, W0
0059A6  B98800     MUL.SS W1, W0, W0
0059A8  780080     MOV W0, W1
0059AA  90001E     MOV [W14+2], W0
0059AC  408000     ADD W1, W0, W0
0059AE  400066     ADD W0, #0x6, W0
0059B0  410000     ADD W2, W0, W0
0059B2  784090     MOV.B [W0], W1
0059B4  984761     MOV.B W1, [W14+6]
174:                           if(val > max_val) {
0059B6  90406E     MOV.B [W14+6], W0
0059B8  FB8080     ZE W0, W1
0059BA  90002E     MOV [W14+4], W0
0059BC  508F80     SUB W1, W0, [W15]
0059BE  360007     BRA LEU, 0x59CE
175:                               max_val = val;
0059C0  90406E     MOV.B [W14+6], W0
0059C2  FB8000     ZE W0, W0
0059C4  980720     MOV W0, [W14+4]
176:                               max_loc[0] = j;
0059C6  90001E     MOV [W14+2], W0
0059C8  980740     MOV W0, [W14+8]
177:                               max_loc[1] = i;
0059CA  78009E     MOV [W14], W1
0059CC  980751     MOV W1, [W14+10]
178:                           }
179:                       }
180:                   }
181:               
182:                   info->max[0] = max_loc[0];
0059E6  9000CE     MOV [W14+8], W1
0059E8  90007E     MOV [W14+14], W0
0059EA  988851     MOV W1, [W0+154]
183:                   info->max[1] = max_loc[1];
0059EC  9000DE     MOV [W14+10], W1
0059EE  90007E     MOV [W14+14], W0
0059F0  988861     MOV W1, [W0+156]
184:                   info->max_lum = max_val;
0059F2  90002E     MOV [W14+4], W0
0059F4  784000     MOV.B W0, W0
0059F6  9000FE     MOV [W14+14], W1
0059F8  9958E0     MOV.B W0, [W1+158]
185:               
186:               }
0059FA  FA8000     ULNK
0059FC  060000     RETURN
187:               
188:               void cvCalculateMeans(CamFrame frame, CvResult info) {
0059FE  FA013C     LNK #0x13C
005A00  781F88     MOV W8, [W15++]
005A02  991F40     MOV W0, [W14+312]
005A04  991F51     MOV W1, [W14+314]
189:               
190:                   unsigned char i, j, val;
191:                   unsigned long row_acc, col_acc[DS_IMAGE_COLS];
192:                   unsigned long l_acc;
193:                   
194:                   l_acc = 0;
005A06  B80060     MUL.UU W0, #0, W0
005A08  980730     MOV W0, [W14+6]
005A0A  980741     MOV W1, [W14+8]
195:                   memset(col_acc, 0, 4*DS_IMAGE_COLS);
005A0C  47006C     ADD W14, #0xC, W0
005A0E  2012C2     MOV #0x12C, W2
005A10  EB0080     CLR W1
005A12  0235B4     CALL _memset
005A14  000000     NOP
196:                   
197:                   for(i = 0; i < DS_IMAGE_ROWS; i++) {
005A16  EB4000     CLR.B W0
005A18  784F00     MOV.B W0, [W14]
005A1A  37004B     BRA 0x5AB2
005AB0  E84F1E     INC.B [W14], [W14]
005AB2  B3C3B0     MOV #0x3B, W0
005AB4  78409E     MOV.B [W14], W1
005AB6  50CF80     SUB.B W1, W0, [W15]
005AB8  36FFB1     BRA LEU, 0x5A1C
198:                       row_acc = 0;
005A1C  B80060     MUL.UU W0, #0, W0
005A1E  980710     MOV W0, [W14+2]
005A20  980721     MOV W1, [W14+4]
199:                       for(j = 0; j < DS_IMAGE_COLS; j++) {
005A22  EB4000     CLR.B W0
005A24  984710     MOV.B W0, [W14+1]
005A26  370033     BRA 0x5A8E
005A88  90401E     MOV.B [W14+1], W0
005A8A  E84000     INC.B W0, W0
005A8C  984710     MOV.B W0, [W14+1]
005A8E  90409E     MOV.B [W14+1], W1
005A90  B3C4A0     MOV #0x4A, W0
005A92  50CF80     SUB.B W1, W0, [W15]
005A94  36FFC9     BRA LEU, 0x5A28
200:                           val = frame->pixels[i][j];
005A28  78401E     MOV.B [W14], W0
005A2A  FB8080     ZE W0, W1
005A2C  90401E     MOV.B [W14+1], W0
005A2E  FB8180     ZE W0, W3
005A30  91194E     MOV [W14+312], W2
005A32  2004B0     MOV #0x4B, W0
005A34  B98800     MUL.SS W1, W0, W0
005A36  780000     MOV W0, W0
005A38  400003     ADD W0, W3, W0
005A3A  400066     ADD W0, #0x6, W0
005A3C  410000     ADD W2, W0, W0
005A3E  784090     MOV.B [W0], W1
005A40  984F21     MOV.B W1, [W14+10]
201:                           l_acc += val;
005A42  90482E     MOV.B [W14+10], W0
005A44  FB8000     ZE W0, W0
005A46  200001     MOV #0x0, W1
005A48  90013E     MOV [W14+6], W2
005A4A  9001CE     MOV [W14+8], W3
005A4C  400002     ADD W0, W2, W0
005A4E  488083     ADDC W1, W3, W1
005A50  980730     MOV W0, [W14+6]
005A52  980741     MOV W1, [W14+8]
202:                           row_acc += val;
005A54  90482E     MOV.B [W14+10], W0
005A56  FB8000     ZE W0, W0
005A58  200001     MOV #0x0, W1
005A5A  90011E     MOV [W14+2], W2
005A5C  9001AE     MOV [W14+4], W3
005A5E  400002     ADD W0, W2, W0
005A60  488083     ADDC W1, W3, W1
005A62  980710     MOV W0, [W14+2]
005A64  980721     MOV W1, [W14+4]
203:                           col_acc[j] += val;
005A66  90401E     MOV.B [W14+1], W0
005A68  FB8200     ZE W0, W4
005A6A  90401E     MOV.B [W14+1], W0
005A6C  FB8000     ZE W0, W0
005A6E  4700EC     ADD W14, #0xC, W1
005A70  DD0042     SL W0, #2, W0
005A72  408000     ADD W1, W0, W0
005A74  BE0110     MOV.D [W0], W2
005A76  90482E     MOV.B [W14+10], W0
005A78  FB8000     ZE W0, W0
005A7A  200001     MOV #0x0, W1
005A7C  400002     ADD W0, W2, W0
005A7E  488083     ADDC W1, W3, W1
005A80  4701EC     ADD W14, #0xC, W3
005A82  DD2142     SL W4, #2, W2
005A84  418102     ADD W3, W2, W2
005A86  BE8900     MOV.D W0, [W2]
204:                       }
205:                       info->row_means[i] = (unsigned char) (row_acc/DS_IMAGE_COLS);
005A96  78411E     MOV.B [W14], W2
005A98  FB8402     ZE W2, W8
005A9A  90001E     MOV [W14+2], W0
005A9C  9000AE     MOV [W14+4], W1
005A9E  2004B2     MOV #0x4B, W2
005AA0  200003     MOV #0x0, W3
005AA2  022D42     CALL ___udivsi3x
005AA4  000000     NOP
005AA6  784000     MOV.B W0, W0
005AA8  9118DE     MOV [W14+314], W1
005AAA  408088     ADD W1, W8, W1
005AAC  4080EE     ADD W1, #0xE, W1
005AAE  984090     MOV.B W0, [W1+1]
206:                   }
207:               
208:                   for(j = 0; j < DS_IMAGE_COLS; j++) {
005ABA  EB4000     CLR.B W0
005ABC  984710     MOV.B W0, [W14+1]
005ABE  370014     BRA 0x5AE8
005AE2  90401E     MOV.B [W14+1], W0
005AE4  E84000     INC.B W0, W0
005AE6  984710     MOV.B W0, [W14+1]
005AE8  90409E     MOV.B [W14+1], W1
005AEA  B3C4A0     MOV #0x4A, W0
005AEC  50CF80     SUB.B W1, W0, [W15]
005AEE  36FFE8     BRA LEU, 0x5AC0
209:                       info->col_means[j] = (unsigned char) (col_acc[j]/DS_IMAGE_ROWS);
005AC0  90401E     MOV.B [W14+1], W0
005AC2  FB8400     ZE W0, W8
005AC4  90401E     MOV.B [W14+1], W0
005AC6  FB8000     ZE W0, W0
005AC8  4700EC     ADD W14, #0xC, W1
005ACA  DD0042     SL W0, #2, W0
005ACC  408000     ADD W1, W0, W0
005ACE  BE0010     MOV.D [W0], W0
005AD0  2003C2     MOV #0x3C, W2
005AD2  200003     MOV #0x0, W3
005AD4  022D42     CALL ___udivsi3x
005AD6  000000     NOP
005AD8  784000     MOV.B W0, W0
005ADA  9118DE     MOV [W14+314], W1
005ADC  408088     ADD W1, W8, W1
005ADE  B004A1     ADD #0x4A, W1
005AE0  984090     MOV.B W0, [W1+1]
210:                   }
211:               
212:                   info->mass = l_acc;
005AF0  91185E     MOV [W14+314], W0
005AF2  90013E     MOV [W14+6], W2
005AF4  9001CE     MOV [W14+8], W3
005AF6  980052     MOV W2, [W0+10]
005AF8  980063     MOV W3, [W0+12]
213:                   info->avg_lum = l_acc/(DS_IMAGE_ROWS*DS_IMAGE_COLS);
005AFA  90003E     MOV [W14+6], W0
005AFC  9000CE     MOV [W14+8], W1
005AFE  211942     MOV #0x1194, W2
005B00  200003     MOV #0x0, W3
005B02  022D42     CALL ___udivsi3x
005B04  000000     NOP
005B06  784000     MOV.B W0, W0
005B08  9118DE     MOV [W14+314], W1
005B0A  9848E0     MOV.B W0, [W1+14]
214:                   
215:               }
005B0C  78044F     MOV [--W15], W8
005B0E  FA8000     ULNK
005B10  060000     RETURN
216:               
217:               /**
218:                * Find the frame luminosity centroid of the input frame.
219:                *
220:                * @param frame - Input frame
221:                * @param info - Info struct to populate
222:                */
223:               void cvCentroidFrame(CamFrame frame, CvResult info) {
005B12  FA0012     LNK #0x12
005B14  980770     MOV W0, [W14+14]
005B16  980F01     MOV W1, [W14+16]
224:                   
225:                   unsigned long x_acc, y_acc, temp;
226:                   unsigned int i;
227:               
228:                   // Check for completely blank case
229:                   if(info->avg_lum == 0) {
005B18  90080E     MOV [W14+16], W0
005B1A  9048E0     MOV.B [W0+14], W1
005B1C  EB4000     CLR.B W0
005B1E  50CF80     SUB.B W1, W0, [W15]
005B20  3A0009     BRA NZ, 0x5B34
230:                       info->centroid[0] = info->offset[0];
005B22  90080E     MOV [W14+16], W0
005B24  9000B0     MOV [W0+6], W1
005B26  90080E     MOV [W14+16], W0
005B28  988831     MOV W1, [W0+150]
231:                       info->centroid[1] = info->offset[1];
005B2A  90080E     MOV [W14+16], W0
005B2C  9000C0     MOV [W0+8], W1
005B2E  90080E     MOV [W14+16], W0
005B30  988841     MOV W1, [W0+152]
232:                       return;
005B32  37006E     BRA 0x5C10
233:                   }
234:                   
235:                   // Else calculate centroid
236:                   x_acc = 0;
005B34  B80060     MUL.UU W0, #0, W0
005B36  BE8F00     MOV.D W0, [W14]
237:                   y_acc = 0;
005B38  B80060     MUL.UU W0, #0, W0
005B3A  980720     MOV W0, [W14+4]
005B3C  980731     MOV W1, [W14+6]
238:                   
239:                   for(i = 0; i < DS_IMAGE_ROWS; i++) {            
005B3E  EB0000     CLR W0
005B40  980740     MOV W0, [W14+8]
005B42  370013     BRA 0x5B6A
005B64  90004E     MOV [W14+8], W0
005B66  E80000     INC W0, W0
005B68  980740     MOV W0, [W14+8]
005B6A  9000CE     MOV [W14+8], W1
005B6C  2003B0     MOV #0x3B, W0
005B6E  508F80     SUB W1, W0, [W15]
005B70  36FFE9     BRA LEU, 0x5B44
240:                       y_acc += i*info->row_means[i];
005B44  90088E     MOV [W14+16], W1
005B46  90004E     MOV [W14+8], W0
005B48  40006E     ADD W0, #0xE, W0
005B4A  408000     ADD W1, W0, W0
005B4C  904010     MOV.B [W0+1], W0
005B4E  FB8080     ZE W0, W1
005B50  90004E     MOV [W14+8], W0
005B52  B98800     MUL.SS W1, W0, W0
005B54  780000     MOV W0, W0
005B56  200001     MOV #0x0, W1
005B58  90012E     MOV [W14+4], W2
005B5A  9001BE     MOV [W14+6], W3
005B5C  400002     ADD W0, W2, W0
005B5E  488083     ADDC W1, W3, W1
005B60  980720     MOV W0, [W14+4]
005B62  980731     MOV W1, [W14+6]
241:                   }   
242:                   for(i = 0; i < DS_IMAGE_COLS; i++) {
005B72  EB0000     CLR W0
005B74  980740     MOV W0, [W14+8]
005B76  37000F     BRA 0x5B96
005B90  90004E     MOV [W14+8], W0
005B92  E80000     INC W0, W0
005B94  980740     MOV W0, [W14+8]
005B96  9000CE     MOV [W14+8], W1
005B98  2004A0     MOV #0x4A, W0
005B9A  508F80     SUB W1, W0, [W15]
005B9C  36FFED     BRA LEU, 0x5B78
243:                       x_acc += i*info->col_means[i];
005B78  90088E     MOV [W14+16], W1
005B7A  90004E     MOV [W14+8], W0
005B7C  B004A0     ADD #0x4A, W0
005B7E  408000     ADD W1, W0, W0
005B80  904010     MOV.B [W0+1], W0
005B82  FB8080     ZE W0, W1
005B84  90004E     MOV [W14+8], W0
005B86  B98800     MUL.SS W1, W0, W0
005B88  780000     MOV W0, W0
005B8A  200001     MOV #0x0, W1
005B8C  400F1E     ADD W0, [W14], [W14]
005B8E  48975E     ADDC W1, [++W14], [W14--]
244:                   }
245:                   y_acc = y_acc*DS_IMAGE_COLS;
005B9E  9000BE     MOV [W14+6], W1
005BA0  2004B0     MOV #0x4B, W0
005BA2  B98800     MUL.SS W1, W0, W0
005BA4  780100     MOV W0, W2
005BA6  90002E     MOV [W14+4], W0
005BA8  B90060     MUL.SU W0, #0, W0
005BAA  780000     MOV W0, W0
005BAC  410100     ADD W2, W0, W2
005BAE  9000AE     MOV [W14+4], W1
005BB0  2004B0     MOV #0x4B, W0
005BB2  B80800     MUL.UU W1, W0, W0
005BB4  410101     ADD W2, W1, W2
005BB6  780082     MOV W2, W1
005BB8  980720     MOV W0, [W14+4]
005BBA  980731     MOV W1, [W14+6]
005BBC  980720     MOV W0, [W14+4]
005BBE  980731     MOV W1, [W14+6]
246:                   x_acc = x_acc*DS_IMAGE_ROWS;
005BC0  90009E     MOV [W14+2], W1
005BC2  2003C0     MOV #0x3C, W0
005BC4  B98800     MUL.SS W1, W0, W0
005BC6  780100     MOV W0, W2
005BC8  78001E     MOV [W14], W0
005BCA  B90060     MUL.SU W0, #0, W0
005BCC  780000     MOV W0, W0
005BCE  410100     ADD W2, W0, W2
005BD0  78009E     MOV [W14], W1
005BD2  2003C0     MOV #0x3C, W0
005BD4  B80800     MUL.UU W1, W0, W0
005BD6  410101     ADD W2, W1, W2
005BD8  780082     MOV W2, W1
005BDA  BE8F00     MOV.D W0, [W14]
005BDC  BE8F00     MOV.D W0, [W14]
247:               
248:                   temp = x_acc/info->mass;
005BDE  90080E     MOV [W14+16], W0
005BE0  9000E0     MOV [W0+12], W1
005BE2  900050     MOV [W0+10], W0
005BE4  BE0100     MOV.D W0, W2
005BE6  BE001E     MOV.D [W14], W0
005BE8  022D42     CALL ___udivsi3x
005BEA  000000     NOP
005BEC  980750     MOV W0, [W14+10]
005BEE  980761     MOV W1, [W14+12]
249:                   info->centroid[0] = (unsigned int) temp;
005BF0  9000DE     MOV [W14+10], W1
005BF2  90080E     MOV [W14+16], W0
005BF4  988831     MOV W1, [W0+150]
250:                   temp = y_acc/info->mass;
005BF6  90080E     MOV [W14+16], W0
005BF8  9000E0     MOV [W0+12], W1
005BFA  900050     MOV [W0+10], W0
005BFC  BE0100     MOV.D W0, W2
005BFE  90002E     MOV [W14+4], W0
005C00  9000BE     MOV [W14+6], W1
005C02  022D42     CALL ___udivsi3x
005C04  000000     NOP
005C06  980750     MOV W0, [W14+10]
005C08  980761     MOV W1, [W14+12]
251:                   info->centroid[1] = (unsigned int) temp;
005C0A  9000DE     MOV [W14+10], W1
005C0C  90080E     MOV [W14+16], W0
005C0E  988841     MOV W1, [W0+152]
252:                   
253:               
254:               }
005C10  FA8000     ULNK
005C12  060000     RETURN
255:               
256:               void cvRotateFrame(CamFrame frame, bams16_t theta) {
005C14  FA0010     LNK #0x10
005C16  980760     MOV W0, [W14+12]
005C18  980771     MOV W1, [W14+14]
257:               
258:                   float alpha, beta;
259:                   int horiz_shift, vert_shift;
260:                   
261:                   alpha = bams16Tan(theta/2);
005C1A  9000FE     MOV [W14+14], W1
005C1C  200020     MOV #0x2, W0
005C1E  780100     MOV W0, W2
005C20  090011     REPEAT #0x11
005C22  D80082     DIV.SW W1, W2
005C24  026DD8     CALL bams16Tan
005C26  000000     NOP
005C28  BE8F00     MOV.D W0, [W14]
262:                   beta = bams16Sin(theta);
005C2A  90007E     MOV [W14+14], W0
005C2C  026D1C     CALL bams16Sin
005C2E  000000     NOP
005C30  980720     MOV W0, [W14+4]
005C32  980731     MOV W1, [W14+6]
263:               
264:                   // Calculate total horizontal shift of upper row
265:                   horiz_shift = (int) (alpha*(DS_IMAGE_ROWS/2));
005C34  200002     MOV #0x0, W2
005C36  241F03     MOV #0x41F0, W3
005C38  BE001E     MOV.D [W14], W0
005C3A  022C36     CALL ___mulsf3
005C3C  000000     NOP
005C3E  0225AC     CALL ___fixsfsi
005C40  000000     NOP
005C42  980740     MOV W0, [W14+8]
266:                   // Calculate total horizontal shift of right column
267:                   vert_shift = (int) (beta*(DS_IMAGE_COLS/2));
005C44  200002     MOV #0x0, W2
005C46  242143     MOV #0x4214, W3
005C48  90002E     MOV [W14+4], W0
005C4A  9000BE     MOV [W14+6], W1
005C4C  022C36     CALL ___mulsf3
005C4E  000000     NOP
005C50  0225AC     CALL ___fixsfsi
005C52  000000     NOP
005C54  980750     MOV W0, [W14+10]
268:                   
269:                   shiftFrameHorizontal(frame, horiz_shift);    
005C56  9000CE     MOV [W14+8], W1
005C58  90006E     MOV [W14+12], W0
005C5A  07022D     RCALL shiftFrameHorizontal
270:                   shiftFrameVertical(frame, vert_shift);
005C5C  9000DE     MOV [W14+10], W1
005C5E  90006E     MOV [W14+12], W0
005C60  070289     RCALL shiftFrameVertical
271:                   shiftFrameHorizontal(frame, horiz_shift);
005C62  9000CE     MOV [W14+8], W1
005C64  90006E     MOV [W14+12], W0
005C66  070227     RCALL shiftFrameHorizontal
272:               
273:               }
005C68  FA8000     ULNK
005C6A  060000     RETURN
274:               
275:               typedef int CannyRow[DS_IMAGE_COLS];
276:               
277:               // Pseudocode
278:               static void modifiedCanny(CamFrame frame) {
005C6C  FA0420     LNK #0x420
005C6E  2041E1     MOV #0x41E, W1
005C70  470081     ADD W14, W1, W1
005C72  780880     MOV W0, [W1]
279:               
280:                   // Set up
281:                   // For set of 5 rows:
282:                   //      Convolve to get x, y gradients
283:                   //      Run non-maximum suppression on middle row
284:                   //      Store suppressed gradient magnitudes
285:                   //      Shift rows
286:               
287:                   unsigned int i, j;
288:                   CannyRow row, x_gradients[3], y_gradients[3];
289:                   
290:                   for(i = 0; i < DS_IMAGE_ROWS; i++) {
005C74  EB0000     CLR W0
005C76  780F00     MOV W0, [W14]
005C78  37000B     BRA 0x5C90
005C8E  E80F1E     INC [W14], [W14]
005C90  2003B0     MOV #0x3B, W0
005C92  78009E     MOV [W14], W1
005C94  508F80     SUB W1, W0, [W15]
005C96  36FFF1     BRA LEU, 0x5C7A
291:                       for(j = 0; j < DS_IMAGE_COLS; j++) {
005C7A  EB0000     CLR W0
005C7C  980710     MOV W0, [W14+2]
005C7E  370003     BRA 0x5C86
005C80  90001E     MOV [W14+2], W0
005C82  E80000     INC W0, W0
005C84  980710     MOV W0, [W14+2]
005C86  90009E     MOV [W14+2], W1
005C88  2004A0     MOV #0x4A, W0
005C8A  508F80     SUB W1, W0, [W15]
005C8C  36FFF9     BRA LEU, 0x5C80
292:                           
293:                       }
294:                   }
295:                   
296:               }
005C98  FA8000     ULNK
005C9A  060000     RETURN
297:               
298:               const char sobel_hor_kernel[3] = {-1, 0, 1};
299:               const char sobel_ver_kernel[3] = {1, 2, 1};
300:               #define SOBEL_HOR_SCALE         (1)
301:               #define SOBEL_VER_SCALE         (4)
302:               #define SOBEL_IMAGE_COLS       (DS_IMAGE_COLS - 2)
303:               #define SOBEL_IMAGE_ROWS       (DS_IMAGE_ROWS - 2)
304:               
305:               void cvSobel(CamFrame frame, CvResult info) {
005C9C  FA02EC     LNK #0x2EC
005C9E  9AB740     MOV W0, [W14+744]
005CA0  9AB751     MOV W1, [W14+746]
306:               
307:                   unsigned int i, j, k;
308:                   int h_acc, v_acc, h_grad[SOBEL_IMAGE_COLS], v_grad[SOBEL_IMAGE_COLS];
309:                   unsigned char val, temp;
310:                   unsigned char h_buffs[3][SOBEL_IMAGE_COLS],
311:                                   v_buffs[3][SOBEL_IMAGE_COLS];
312:                   unsigned char indices[3] = {2, 0, 1};
005CA2  202E41     MOV #0x2E4, W1
005CA4  40808E     ADD W1, W14, W1
005CA6  B3C020     MOV #0x2, W0
005CA8  784880     MOV.B W0, [W1]
005CAA  202E41     MOV #0x2E4, W1
005CAC  40808E     ADD W1, W14, W1
005CAE  EB4000     CLR.B W0
005CB0  984090     MOV.B W0, [W1+1]
005CB2  202E41     MOV #0x2E4, W1
005CB4  40808E     ADD W1, W14, W1
005CB6  B3C010     MOV #0x1, W0
005CB8  9840A0     MOV.B W0, [W1+2]
313:               
314:                   for(j = 0; j < SOBEL_IMAGE_COLS; j++) {
005CBA  EB0000     CLR W0
005CBC  980710     MOV W0, [W14+2]
005CBE  370081     BRA 0x5DC2
005DBC  90001E     MOV [W14+2], W0
005DBE  E80000     INC W0, W0
005DC0  980710     MOV W0, [W14+2]
005DC2  90009E     MOV [W14+2], W1
005DC4  200480     MOV #0x48, W0
005DC6  508F80     SUB W1, W0, [W15]
005DC8  36FF7B     BRA LEU, 0x5CC0
315:               
316:                       h_acc = (-frame->pixels[0][j] + frame->pixels[0][j + 2])/SOBEL_HOR_SCALE;
005CC0  90001E     MOV [W14+2], W0
005CC2  E88000     INC2 W0, W0
005CC4  92B0CE     MOV [W14+744], W1
005CC6  400066     ADD W0, #0x6, W0
005CC8  408000     ADD W1, W0, W0
005CCA  784010     MOV.B [W0], W0
005CCC  FB8080     ZE W0, W1
005CCE  92B14E     MOV [W14+744], W2
005CD0  90001E     MOV [W14+2], W0
005CD2  400066     ADD W0, #0x6, W0
005CD4  410000     ADD W2, W0, W0
005CD6  784010     MOV.B [W0], W0
005CD8  FB8000     ZE W0, W0
005CDA  508000     SUB W1, W0, W0
005CDC  980720     MOV W0, [W14+4]
317:                       if(h_acc < 0) { h_acc = -h_acc; }
005CDE  9000AE     MOV [W14+4], W1
005CE0  EB0000     CLR W0
005CE2  508F80     SUB W1, W0, [W15]
005CE4  3D0003     BRA GE, 0x5CEC
005CE6  90002E     MOV [W14+4], W0
005CE8  EA0000     NEG W0, W0
005CEA  980720     MOV W0, [W14+4]
318:                       h_buffs[0][j] = h_acc;
005CEC  90002E     MOV [W14+4], W0
005CEE  784000     MOV.B W0, W0
005CF0  2012E2     MOV #0x12E, W2
005CF2  41010E     ADD W2, W14, W2
005CF4  90009E     MOV [W14+2], W1
005CF6  410081     ADD W2, W1, W1
005CF8  784880     MOV.B W0, [W1]
319:                       h_acc = (-frame->pixels[1][j] + frame->pixels[1][j + 2])/SOBEL_HOR_SCALE;
005CFA  90001E     MOV [W14+2], W0
005CFC  E88000     INC2 W0, W0
005CFE  92B0CE     MOV [W14+744], W1
005D00  B00510     ADD #0x51, W0
005D02  408000     ADD W1, W0, W0
005D04  784010     MOV.B [W0], W0
005D06  FB8080     ZE W0, W1
005D08  92B14E     MOV [W14+744], W2
005D0A  90001E     MOV [W14+2], W0
005D0C  B00510     ADD #0x51, W0
005D0E  410000     ADD W2, W0, W0
005D10  784010     MOV.B [W0], W0
005D12  FB8000     ZE W0, W0
005D14  508000     SUB W1, W0, W0
005D16  980720     MOV W0, [W14+4]
320:                       if(h_acc < 0) { h_acc = -h_acc; }
005D18  9000AE     MOV [W14+4], W1
005D1A  EB0000     CLR W0
005D1C  508F80     SUB W1, W0, [W15]
005D1E  3D0003     BRA GE, 0x5D26
005D20  90002E     MOV [W14+4], W0
005D22  EA0000     NEG W0, W0
005D24  980720     MOV W0, [W14+4]
321:                       h_buffs[1][j] = h_acc;
005D26  90002E     MOV [W14+4], W0
005D28  784000     MOV.B W0, W0
005D2A  2012E2     MOV #0x12E, W2
005D2C  41010E     ADD W2, W14, W2
005D2E  90009E     MOV [W14+2], W1
005D30  410081     ADD W2, W1, W1
005D32  B00491     ADD #0x49, W1
005D34  784880     MOV.B W0, [W1]
322:               
323:                       v_buffs[0][j] = (frame->pixels[0][j] + 2*frame->pixels[0][j + 1] +
005D36  92B0CE     MOV [W14+744], W1
005D38  90001E     MOV [W14+2], W0
005D3A  400066     ADD W0, #0x6, W0
005D3C  408000     ADD W1, W0, W0
005D3E  784010     MOV.B [W0], W0
005D40  FB8080     ZE W0, W1
005D42  90001E     MOV [W14+2], W0
005D44  E80000     INC W0, W0
005D46  92B14E     MOV [W14+744], W2
005D48  400066     ADD W0, #0x6, W0
005D4A  410000     ADD W2, W0, W0
005D4C  784010     MOV.B [W0], W0
005D4E  FB8000     ZE W0, W0
005D50  400000     ADD W0, W0, W0
005D52  408080     ADD W1, W0, W1
005D60  FB8000     ZE W0, W0
005D62  408080     ADD W1, W0, W1
005D6C  784000     MOV.B W0, W0
005D6E  202092     MOV #0x209, W2
005D70  41010E     ADD W2, W14, W2
005D72  90009E     MOV [W14+2], W1
005D74  410081     ADD W2, W1, W1
005D76  784880     MOV.B W0, [W1]
324:                               frame->pixels[0][j + 2])/SOBEL_VER_SCALE;
005D54  90001E     MOV [W14+2], W0
005D56  E88000     INC2 W0, W0
005D58  92B14E     MOV [W14+744], W2
005D5A  400066     ADD W0, #0x6, W0
005D5C  410000     ADD W2, W0, W0
005D5E  784010     MOV.B [W0], W0
005D64  200040     MOV #0x4, W0
005D66  780100     MOV W0, W2
005D68  090011     REPEAT #0x11
005D6A  D80082     DIV.SW W1, W2
325:                       v_buffs[1][j] = (frame->pixels[1][j] + 2*frame->pixels[1][j + 1] +
005D78  92B0CE     MOV [W14+744], W1
005D7A  90001E     MOV [W14+2], W0
005D7C  B00510     ADD #0x51, W0
005D7E  408000     ADD W1, W0, W0
005D80  784010     MOV.B [W0], W0
005D82  FB8080     ZE W0, W1
005D84  90001E     MOV [W14+2], W0
005D86  E80000     INC W0, W0
005D88  92B14E     MOV [W14+744], W2
005D8A  B00510     ADD #0x51, W0
005D8C  410000     ADD W2, W0, W0
005D8E  784010     MOV.B [W0], W0
005D90  FB8000     ZE W0, W0
005D92  400000     ADD W0, W0, W0
005D94  408080     ADD W1, W0, W1
005DA2  FB8000     ZE W0, W0
005DA4  408080     ADD W1, W0, W1
005DAE  784000     MOV.B W0, W0
005DB0  202092     MOV #0x209, W2
005DB2  41010E     ADD W2, W14, W2
005DB4  90009E     MOV [W14+2], W1
005DB6  410081     ADD W2, W1, W1
005DB8  B00491     ADD #0x49, W1
005DBA  784880     MOV.B W0, [W1]
326:                               frame->pixels[1][j + 2])/SOBEL_VER_SCALE;
005D96  90001E     MOV [W14+2], W0
005D98  E88000     INC2 W0, W0
005D9A  92B14E     MOV [W14+744], W2
005D9C  B00510     ADD #0x51, W0
005D9E  410000     ADD W2, W0, W0
005DA0  784010     MOV.B [W0], W0
005DA6  200040     MOV #0x4, W0
005DA8  780180     MOV W0, W3
005DAA  090011     REPEAT #0x11
005DAC  D80083     DIV.SW W1, W3
327:                   }
328:               
329:                   for(i = 2; i < DS_IMAGE_ROWS; i++) {
005DCA  200020     MOV #0x2, W0
005DCC  780F00     MOV W0, [W14]
005DCE  370130     BRA 0x6030
00602E  E80F1E     INC [W14], [W14]
006030  2003B0     MOV #0x3B, W0
006032  78009E     MOV [W14], W1
006034  508F80     SUB W1, W0, [W15]
006036  36FECC     BRA LEU, 0x5DD0
330:                       for(j = 0; j < SOBEL_IMAGE_COLS; j++) {            
005DD0  EB0000     CLR W0
005DD2  980710     MOV W0, [W14+2]
005DD4  37006C     BRA 0x5EAE
005EA8  90001E     MOV [W14+2], W0
005EAA  E80000     INC W0, W0
005EAC  980710     MOV W0, [W14+2]
005EAE  90009E     MOV [W14+2], W1
005EB0  200480     MOV #0x48, W0
005EB2  508F80     SUB W1, W0, [W15]
005EB4  36FF90     BRA LEU, 0x5DD6
331:                           h_acc = (-frame->pixels[i][j] + frame->pixels[i][j + 2])/SOBEL_HOR_SCALE;
005DD6  90001E     MOV [W14+2], W0
005DD8  E88180     INC2 W0, W3
005DDA  92B14E     MOV [W14+744], W2
005DDC  78009E     MOV [W14], W1
005DDE  2004B0     MOV #0x4B, W0
005DE0  B98800     MUL.SS W1, W0, W0
005DE2  780000     MOV W0, W0
005DE4  400003     ADD W0, W3, W0
005DE6  400066     ADD W0, #0x6, W0
005DE8  410000     ADD W2, W0, W0
005DEA  784010     MOV.B [W0], W0
005DEC  FB8100     ZE W0, W2
005DEE  92B1CE     MOV [W14+744], W3
005DF0  78009E     MOV [W14], W1
005DF2  2004B0     MOV #0x4B, W0
005DF4  B98800     MUL.SS W1, W0, W0
005DF6  780080     MOV W0, W1
005DF8  90001E     MOV [W14+2], W0
005DFA  408000     ADD W1, W0, W0
005DFC  400066     ADD W0, #0x6, W0
005DFE  418000     ADD W3, W0, W0
005E00  784010     MOV.B [W0], W0
005E02  FB8000     ZE W0, W0
005E04  510000     SUB W2, W0, W0
005E06  980720     MOV W0, [W14+4]
332:                           v_acc = (frame->pixels[i][j] + 2*frame->pixels[i][j + 1] +
005E08  92B14E     MOV [W14+744], W2
005E0A  78009E     MOV [W14], W1
005E0C  2004B0     MOV #0x4B, W0
005E0E  B98800     MUL.SS W1, W0, W0
005E10  780080     MOV W0, W1
005E12  90001E     MOV [W14+2], W0
005E14  408000     ADD W1, W0, W0
005E16  400066     ADD W0, #0x6, W0
005E18  410000     ADD W2, W0, W0
005E1A  784010     MOV.B [W0], W0
005E1C  FB8100     ZE W0, W2
005E1E  90001E     MOV [W14+2], W0
005E20  E80200     INC W0, W4
005E22  92B1CE     MOV [W14+744], W3
005E24  78009E     MOV [W14], W1
005E26  2004B0     MOV #0x4B, W0
005E28  B98800     MUL.SS W1, W0, W0
005E2A  780000     MOV W0, W0
005E2C  400004     ADD W0, W4, W0
005E2E  400066     ADD W0, #0x6, W0
005E30  418000     ADD W3, W0, W0
005E32  784010     MOV.B [W0], W0
005E34  FB8000     ZE W0, W0
005E36  400000     ADD W0, W0, W0
005E38  410100     ADD W2, W0, W2
005E50  FB8000     ZE W0, W0
005E52  410080     ADD W2, W0, W1
005E54  200040     MOV #0x4, W0
005E56  780100     MOV W0, W2
005E58  090011     REPEAT #0x11
005E5A  D80082     DIV.SW W1, W2
005E5C  980730     MOV W0, [W14+6]
333:                                   frame->pixels[i][j + 2])/SOBEL_VER_SCALE;
005E3A  90001E     MOV [W14+2], W0
005E3C  E88200     INC2 W0, W4
005E3E  92B1CE     MOV [W14+744], W3
005E40  78009E     MOV [W14], W1
005E42  2004B0     MOV #0x4B, W0
005E44  B98800     MUL.SS W1, W0, W0
005E46  780000     MOV W0, W0
005E48  400004     ADD W0, W4, W0
005E4A  400066     ADD W0, #0x6, W0
005E4C  418000     ADD W3, W0, W0
005E4E  784010     MOV.B [W0], W0
334:               
335:                           if(h_acc < 0) { h_acc = -h_acc; } // Accumulators range [-255, 255]           
005E5E  9000AE     MOV [W14+4], W1
005E60  EB0000     CLR W0
005E62  508F80     SUB W1, W0, [W15]
005E64  3D0003     BRA GE, 0x5E6C
005E66  90002E     MOV [W14+4], W0
005E68  EA0000     NEG W0, W0
005E6A  980720     MOV W0, [W14+4]
336:               
337:                           h_buffs[indices[0]][j] = (unsigned char) h_acc;
005E6C  202E40     MOV #0x2E4, W0
005E6E  40000E     ADD W0, W14, W0
005E70  784010     MOV.B [W0], W0
005E72  FB8080     ZE W0, W1
005E74  90002E     MOV [W14+4], W0
005E76  784100     MOV.B W0, W2
005E78  2012E3     MOV #0x12E, W3
005E7A  41818E     ADD W3, W14, W3
005E7C  200490     MOV #0x49, W0
005E7E  B98800     MUL.SS W1, W0, W0
005E80  780080     MOV W0, W1
005E82  90001E     MOV [W14+2], W0
005E84  408000     ADD W1, W0, W0
005E86  418000     ADD W3, W0, W0
005E88  784802     MOV.B W2, [W0]
338:                           v_buffs[indices[0]][j] = (unsigned char) v_acc;
005E8A  202E40     MOV #0x2E4, W0
005E8C  40000E     ADD W0, W14, W0
005E8E  784010     MOV.B [W0], W0
005E90  FB8080     ZE W0, W1
005E92  90003E     MOV [W14+6], W0
005E94  784100     MOV.B W0, W2
005E96  202093     MOV #0x209, W3
005E98  41818E     ADD W3, W14, W3
005E9A  200490     MOV #0x49, W0
005E9C  B98800     MUL.SS W1, W0, W0
005E9E  780080     MOV W0, W1
005EA0  90001E     MOV [W14+2], W0
005EA2  408000     ADD W1, W0, W0
005EA4  418000     ADD W3, W0, W0
005EA6  784802     MOV.B W2, [W0]
339:                       
340:                       } // Row complete
341:                       
342:                       temp = indices[0];          // Rotate the indices left
005EB6  202E40     MOV #0x2E4, W0
005EB8  40000E     ADD W0, W14, W0
005EBA  784190     MOV.B [W0], W3
005EBC  984F03     MOV.B W3, [W14+8]
343:                       indices[0] = indices[1];
005EBE  202E40     MOV #0x2E4, W0
005EC0  40000E     ADD W0, W14, W0
005EC2  904010     MOV.B [W0+1], W0
005EC4  202E41     MOV #0x2E4, W1
005EC6  40808E     ADD W1, W14, W1
005EC8  784880     MOV.B W0, [W1]
344:                       indices[1] = indices[2];
005ECA  202E40     MOV #0x2E4, W0
005ECC  40000E     ADD W0, W14, W0
005ECE  904020     MOV.B [W0+2], W0
005ED0  202E41     MOV #0x2E4, W1
005ED2  40808E     ADD W1, W14, W1
005ED4  984090     MOV.B W0, [W1+1]
345:                       indices[2] = temp;                
005ED6  202E40     MOV #0x2E4, W0
005ED8  40000E     ADD W0, W14, W0
005EDA  90488E     MOV.B [W14+8], W1
005EDC  984021     MOV.B W1, [W0+2]
346:               
347:                       memset(h_grad, 0, 2*SOBEL_IMAGE_COLS);
005EDE  47006A     ADD W14, #0xA, W0
005EE0  200922     MOV #0x92, W2
005EE2  EB0080     CLR W1
005EE4  0235B4     CALL _memset
005EE6  000000     NOP
348:                       memset(v_grad, 0, 2*SOBEL_IMAGE_COLS);
005EE8  2009C0     MOV #0x9C, W0
005EEA  40000E     ADD W0, W14, W0
005EEC  200922     MOV #0x92, W2
005EEE  EB0080     CLR W1
005EF0  0235B4     CALL _memset
005EF2  000000     NOP
349:               
350:                       for(j = 0; j< SOBEL_IMAGE_COLS; j++) {
005EF4  EB0000     CLR W0
005EF6  980710     MOV W0, [W14+2]
005EF8  370061     BRA 0x5FBC
005FB6  90001E     MOV [W14+2], W0
005FB8  E80000     INC W0, W0
005FBA  980710     MOV W0, [W14+2]
005FBC  90009E     MOV [W14+2], W1
005FBE  200480     MOV #0x48, W0
005FC0  508F80     SUB W1, W0, [W15]
005FC2  36FF9B     BRA LEU, 0x5EFA
351:                           h_grad[j] += h_buffs[indices[0]][j] + 2*h_buffs[indices[1]][j] +
005EFA  4700EA     ADD W14, #0xA, W1
005EFC  90001E     MOV [W14+2], W0
005EFE  400000     ADD W0, W0, W0
005F00  780161     MOV [W1+W0], W2
005F02  202E40     MOV #0x2E4, W0
005F04  40000E     ADD W0, W14, W0
005F06  784010     MOV.B [W0], W0
005F08  FB8080     ZE W0, W1
005F0A  2012E3     MOV #0x12E, W3
005F0C  41818E     ADD W3, W14, W3
005F0E  200490     MOV #0x49, W0
005F10  B98800     MUL.SS W1, W0, W0
005F12  780080     MOV W0, W1
005F14  90001E     MOV [W14+2], W0
005F16  408000     ADD W1, W0, W0
005F18  418000     ADD W3, W0, W0
005F1A  784010     MOV.B [W0], W0
005F1C  FB8180     ZE W0, W3
005F1E  202E40     MOV #0x2E4, W0
005F20  40000E     ADD W0, W14, W0
005F22  904010     MOV.B [W0+1], W0
005F24  FB8080     ZE W0, W1
005F26  2012E4     MOV #0x12E, W4
005F28  42020E     ADD W4, W14, W4
005F2A  200490     MOV #0x49, W0
005F2C  B98800     MUL.SS W1, W0, W0
005F2E  780080     MOV W0, W1
005F30  90001E     MOV [W14+2], W0
005F32  408000     ADD W1, W0, W0
005F34  420000     ADD W4, W0, W0
005F36  784010     MOV.B [W0], W0
005F38  FB8000     ZE W0, W0
005F3A  400000     ADD W0, W0, W0
005F3C  418180     ADD W3, W0, W3
005F58  FB8000     ZE W0, W0
005F5A  418000     ADD W3, W0, W0
005F5C  410080     ADD W2, W0, W1
005F5E  47016A     ADD W14, #0xA, W2
005F60  90001E     MOV [W14+2], W0
005F62  400000     ADD W0, W0, W0
005F64  410000     ADD W2, W0, W0
005F66  780801     MOV W1, [W0]
352:                                       h_buffs[indices[2]][j];
005F3E  202E40     MOV #0x2E4, W0
005F40  40000E     ADD W0, W14, W0
005F42  904020     MOV.B [W0+2], W0
005F44  FB8080     ZE W0, W1
005F46  2012E4     MOV #0x12E, W4
005F48  42020E     ADD W4, W14, W4
005F4A  200490     MOV #0x49, W0
005F4C  B98800     MUL.SS W1, W0, W0
005F4E  780080     MOV W0, W1
005F50  90001E     MOV [W14+2], W0
005F52  408000     ADD W1, W0, W0
005F54  420000     ADD W4, W0, W0
005F56  784010     MOV.B [W0], W0
353:                           v_grad[j] += v_buffs[indices[0]][j] - v_buffs[indices[2]][j];
005F68  2009C1     MOV #0x9C, W1
005F6A  40808E     ADD W1, W14, W1
005F6C  90001E     MOV [W14+2], W0
005F6E  400000     ADD W0, W0, W0
005F70  780161     MOV [W1+W0], W2
005F72  202E40     MOV #0x2E4, W0
005F74  40000E     ADD W0, W14, W0
005F76  784010     MOV.B [W0], W0
005F78  FB8080     ZE W0, W1
005F7A  202093     MOV #0x209, W3
005F7C  41818E     ADD W3, W14, W3
005F7E  200490     MOV #0x49, W0
005F80  B98800     MUL.SS W1, W0, W0
005F82  780080     MOV W0, W1
005F84  90001E     MOV [W14+2], W0
005F86  408000     ADD W1, W0, W0
005F88  784063     MOV.B [W3+W0], W0
005F8A  FB8180     ZE W0, W3
005F8C  202E40     MOV #0x2E4, W0
005F8E  40000E     ADD W0, W14, W0
005F90  904020     MOV.B [W0+2], W0
005F92  FB8080     ZE W0, W1
005F94  202094     MOV #0x209, W4
005F96  42020E     ADD W4, W14, W4
005F98  200490     MOV #0x49, W0
005F9A  B98800     MUL.SS W1, W0, W0
005F9C  780080     MOV W0, W1
005F9E  90001E     MOV [W14+2], W0
005FA0  408000     ADD W1, W0, W0
005FA2  784064     MOV.B [W4+W0], W0
005FA4  FB8000     ZE W0, W0
005FA6  518000     SUB W3, W0, W0
005FA8  410080     ADD W2, W0, W1
005FAA  2009C2     MOV #0x9C, W2
005FAC  41010E     ADD W2, W14, W2
005FAE  90001E     MOV [W14+2], W0
005FB0  400000     ADD W0, W0, W0
005FB2  410000     ADD W2, W0, W0
005FB4  780801     MOV W1, [W0]
354:                       }
355:               
356:                       for(j = 0; j < SOBEL_IMAGE_COLS; j++) {
005FC4  EB0000     CLR W0
005FC6  980710     MOV W0, [W14+2]
005FC8  37002E     BRA 0x6026
006020  90001E     MOV [W14+2], W0
006022  E80000     INC W0, W0
006024  980710     MOV W0, [W14+2]
006026  90009E     MOV [W14+2], W1
006028  200480     MOV #0x48, W0
00602A  508F80     SUB W1, W0, [W15]
00602C  36FFCE     BRA LEU, 0x5FCA
357:                           v_acc = v_grad[j]/SOBEL_HOR_SCALE;
005FCA  2009C1     MOV #0x9C, W1
005FCC  40808E     ADD W1, W14, W1
005FCE  90001E     MOV [W14+2], W0
005FD0  400000     ADD W0, W0, W0
005FD2  780161     MOV [W1+W0], W2
005FD4  980732     MOV W2, [W14+6]
358:                           h_acc = h_grad[j]/SOBEL_VER_SCALE;
005FD6  4700EA     ADD W14, #0xA, W1
005FD8  90001E     MOV [W14+2], W0
005FDA  400000     ADD W0, W0, W0
005FDC  7800E1     MOV [W1+W0], W1
005FDE  200040     MOV #0x4, W0
005FE0  780180     MOV W0, W3
005FE2  090011     REPEAT #0x11
005FE4  D80083     DIV.SW W1, W3
005FE6  980720     MOV W0, [W14+4]
359:                           if(v_acc < 0) { v_acc = -v_acc; }
005FE8  9000BE     MOV [W14+6], W1
005FEA  EB0000     CLR W0
005FEC  508F80     SUB W1, W0, [W15]
005FEE  3D0003     BRA GE, 0x5FF6
005FF0  90003E     MOV [W14+6], W0
005FF2  EA0000     NEG W0, W0
005FF4  980730     MOV W0, [W14+6]
360:                           frame->pixels[i - 2][j] = (v_acc + h_acc)/2;
005FF6  E9809E     DEC2 [W14], W1
005FF8  90013E     MOV [W14+6], W2
005FFA  90002E     MOV [W14+4], W0
005FFC  410100     ADD W2, W0, W2
005FFE  200020     MOV #0x2, W0
006000  780180     MOV W0, W3
006002  781F81     MOV W1, [W15++]
006004  090011     REPEAT #0x11
006006  D80103     DIV.SW W2, W3
006008  780101     MOV W1, W2
00600A  7800CF     MOV [--W15], W1
00600C  784100     MOV.B W0, W2
00600E  92B1CE     MOV [W14+744], W3
006010  2004B0     MOV #0x4B, W0
006012  B98800     MUL.SS W1, W0, W0
006014  780000     MOV W0, W0
006016  418080     ADD W3, W0, W1
006018  90001E     MOV [W14+2], W0
00601A  408000     ADD W1, W0, W0
00601C  400066     ADD W0, #0x6, W0
00601E  784802     MOV.B W2, [W0]
361:                       }
362:               
363:                   }
364:                   
365:               }
006038  FA8000     ULNK
00603A  060000     RETURN
366:               
367:               #define BIN_THRESHOLD       (30)
368:               
369:               void cvBinary(CamFrame frame, CvResult info) {
00603C  FA000A     LNK #0xA
00603E  980730     MOV W0, [W14+6]
006040  980741     MOV W1, [W14+8]
370:               
371:                   unsigned int i, j;
372:                   unsigned char val;    
373:               
374:                   for(i = 0; i < DS_IMAGE_ROWS; i++) {
006042  EB0000     CLR W0
006044  780F00     MOV W0, [W14]
006046  370031     BRA 0x60AA
0060A8  E80F1E     INC [W14], [W14]
0060AA  2003B0     MOV #0x3B, W0
0060AC  78009E     MOV [W14], W1
0060AE  508F80     SUB W1, W0, [W15]
0060B0  36FFCB     BRA LEU, 0x6048
375:                       for(j = 0; j < DS_IMAGE_COLS; j++) {
006048  EB0000     CLR W0
00604A  980710     MOV W0, [W14+2]
00604C  370029     BRA 0x60A0
00609A  90001E     MOV [W14+2], W0
00609C  E80000     INC W0, W0
00609E  980710     MOV W0, [W14+2]
0060A0  90009E     MOV [W14+2], W1
0060A2  2004A0     MOV #0x4A, W0
0060A4  508F80     SUB W1, W0, [W15]
0060A6  36FFD3     BRA LEU, 0x604E
376:                           val = frame->pixels[i][j];
00604E  90013E     MOV [W14+6], W2
006050  78009E     MOV [W14], W1
006052  2004B0     MOV #0x4B, W0
006054  B98800     MUL.SS W1, W0, W0
006056  780080     MOV W0, W1
006058  90001E     MOV [W14+2], W0
00605A  408000     ADD W1, W0, W0
00605C  400066     ADD W0, #0x6, W0
00605E  410000     ADD W2, W0, W0
006060  784090     MOV.B [W0], W1
006062  984741     MOV.B W1, [W14+4]
377:                           if(val > BIN_THRESHOLD) {
006064  9040CE     MOV.B [W14+4], W1
006066  B3C1E0     MOV #0x1E, W0
006068  50CF80     SUB.B W1, W0, [W15]
00606A  36000C     BRA LEU, 0x6084
378:                               frame->pixels[i][j] = 0xFF;
00606C  90013E     MOV [W14+6], W2
00606E  78009E     MOV [W14], W1
006070  2004B0     MOV #0x4B, W0
006072  B98800     MUL.SS W1, W0, W0
006074  780000     MOV W0, W0
006076  410080     ADD W2, W0, W1
006078  90001E     MOV [W14+2], W0
00607A  408000     ADD W1, W0, W0
00607C  4000E6     ADD W0, #0x6, W1
00607E  EBC000     SETM.B W0
006080  784880     MOV.B W0, [W1]
006082  37000B     BRA 0x609A
379:                           } else {
380:                               frame->pixels[i][j] = 0;
006084  90013E     MOV [W14+6], W2
006086  78009E     MOV [W14], W1
006088  2004B0     MOV #0x4B, W0
00608A  B98800     MUL.SS W1, W0, W0
00608C  780000     MOV W0, W0
00608E  410080     ADD W2, W0, W1
006090  90001E     MOV [W14+2], W0
006092  408000     ADD W1, W0, W0
006094  4000E6     ADD W0, #0x6, W1
006096  EB4000     CLR.B W0
006098  784880     MOV.B W0, [W1]
381:                           }
382:                       }
383:                   }
384:               
385:               }
0060B2  FA8000     ULNK
0060B4  060000     RETURN
386:               
387:               // =========== Private Functions ===============================================
388:               
389:               // Frame is pointer to CamFrame object
390:               // num is number of pixels top row (row 0) is shifted to the right
391:               static void shiftFrameHorizontal(CamFrame frame, int num) {
0060B6  FA0012     LNK #0x12
0060B8  980770     MOV W0, [W14+14]
0060BA  980F01     MOV W1, [W14+16]
392:               
393:                   int shift, half_height, i, width, height;    
394:                   unsigned char *row;
395:                   
396:                   height = (int) DS_IMAGE_ROWS; // frame->num_rows;
0060BC  2003C0     MOV #0x3C, W0
0060BE  980710     MOV W0, [W14+2]
397:                   width = (int) DS_IMAGE_COLS; // frame->num_cols;
0060C0  2004B0     MOV #0x4B, W0
0060C2  980720     MOV W0, [W14+4]
398:                   half_height = (int) height/2;
0060C4  90009E     MOV [W14+2], W1
0060C6  200020     MOV #0x2, W0
0060C8  780100     MOV W0, W2
0060CA  090011     REPEAT #0x11
0060CC  D80082     DIV.SW W1, W2
0060CE  980730     MOV W0, [W14+6]
399:                   
400:                   for(i = 0; i < height; i++) {
0060D0  EB0000     CLR W0
0060D2  780F00     MOV W0, [W14]
0060D4  370049     BRA 0x6168
006166  E80F1E     INC [W14], [W14]
006168  90001E     MOV [W14+2], W0
00616A  78009E     MOV [W14], W1
00616C  508F80     SUB W1, W0, [W15]
00616E  35FFB3     BRA LT, 0x60D6
401:                           
402:                       row = frame->pixels[i];
0060D6  90007E     MOV [W14+14], W0
0060D8  400066     ADD W0, #0x6, W0
0060DA  780100     MOV W0, W2
0060DC  78009E     MOV [W14], W1
0060DE  2004B0     MOV #0x4B, W0
0060E0  B98800     MUL.SS W1, W0, W0
0060E2  780000     MOV W0, W0
0060E4  410000     ADD W2, W0, W0
0060E6  980740     MOV W0, [W14+8]
403:                       shift = ((i - half_height)*num)/half_height;
0060E8  90003E     MOV [W14+6], W0
0060EA  10009E     SUBR W0, [W14], W1
0060EC  90080E     MOV [W14+16], W0
0060EE  B98800     MUL.SS W1, W0, W0
0060F0  780080     MOV W0, W1
0060F2  90003E     MOV [W14+6], W0
0060F4  780100     MOV W0, W2
0060F6  090011     REPEAT #0x11
0060F8  D80082     DIV.SW W1, W2
0060FA  980750     MOV W0, [W14+10]
404:                       
405:                       if(shift == 0) {
0060FC  9000DE     MOV [W14+10], W1
0060FE  EB0000     CLR W0
006100  508F80     SUB W1, W0, [W15]
006102  32002F     BRA Z, 0x6162
406:                           // Do nothing
407:                       } else if(shift > 0) {
006104  9000DE     MOV [W14+10], W1
006106  EB0000     CLR W0
006108  508F80     SUB W1, W0, [W15]
00610A  340012     BRA LE, 0x6130
408:                           
409:                           memmove(row + shift, row, width - shift);
00610C  9000AE     MOV [W14+4], W1
00610E  90005E     MOV [W14+10], W0
006110  508000     SUB W1, W0, W0
006112  780080     MOV W0, W1
006114  90005E     MOV [W14+10], W0
006116  90014E     MOV [W14+8], W2
006118  410000     ADD W2, W0, W0
00611A  780101     MOV W1, W2
00611C  9000CE     MOV [W14+8], W1
00611E  023590     CALL _memmove
006120  000000     NOP
410:                           memset(row, 0, shift);
006122  90005E     MOV [W14+10], W0
006124  780100     MOV W0, W2
006126  EB0080     CLR W1
006128  90004E     MOV [W14+8], W0
00612A  0235B4     CALL _memset
00612C  000000     NOP
00612E  370019     BRA 0x6162
411:                       
412:                       } else { // shift < 0
413:                       
414:                           shift = -shift;
006130  90005E     MOV [W14+10], W0
006132  EA0000     NEG W0, W0
006134  980750     MOV W0, [W14+10]
415:                           memmove(row, row + shift, width - shift);
006136  9000AE     MOV [W14+4], W1
006138  90005E     MOV [W14+10], W0
00613A  508000     SUB W1, W0, W0
00613C  780080     MOV W0, W1
00613E  90005E     MOV [W14+10], W0
006140  90014E     MOV [W14+8], W2
006142  410000     ADD W2, W0, W0
006144  780101     MOV W1, W2
006146  780080     MOV W0, W1
006148  90004E     MOV [W14+8], W0
00614A  023590     CALL _memmove
00614C  000000     NOP
416:                           memset(row + width - shift, 0, shift);
00614E  9000DE     MOV [W14+10], W1
006150  90012E     MOV [W14+4], W2
006152  90005E     MOV [W14+10], W0
006154  510000     SUB W2, W0, W0
006156  90014E     MOV [W14+8], W2
006158  410000     ADD W2, W0, W0
00615A  780101     MOV W1, W2
00615C  EB0080     CLR W1
00615E  0235B4     CALL _memset
006160  000000     NOP
417:                           
418:                       }
419:               
420:                       int j;
421:                       j = 0;
006162  EB0000     CLR W0
006164  980760     MOV W0, [W14+12]
422:               
423:                   }
424:               
425:               }
006170  FA8000     ULNK
006172  060000     RETURN
426:               
427:               // Num is number of pixels leftmost column (col 0) is shifted down
428:               static void shiftFrameVertical(CamFrame frame, int num) {
006174  FA0010     LNK #0x10
006176  980760     MOV W0, [W14+12]
006178  980771     MOV W1, [W14+14]
429:               
430:                   int shift, half_width, i, width, height;        
431:                   
432:                   height = (int) DS_IMAGE_ROWS; // frame->num_rows;
00617A  2003C0     MOV #0x3C, W0
00617C  980710     MOV W0, [W14+2]
433:                   width = (int) DS_IMAGE_COLS; // frame->num_cols;
00617E  2004B0     MOV #0x4B, W0
006180  980720     MOV W0, [W14+4]
434:                   half_width = (int) width/2;
006182  9000AE     MOV [W14+4], W1
006184  200020     MOV #0x2, W0
006186  780100     MOV W0, W2
006188  090011     REPEAT #0x11
00618A  D80082     DIV.SW W1, W2
00618C  980730     MOV W0, [W14+6]
435:                   
436:                   for(i = 0; i < width; i++) {
00618E  EB0000     CLR W0
006190  780F00     MOV W0, [W14]
006192  370045     BRA 0x621E
00621C  E80F1E     INC [W14], [W14]
00621E  90002E     MOV [W14+4], W0
006220  78009E     MOV [W14], W1
006222  508F80     SUB W1, W0, [W15]
006224  35FFB7     BRA LT, 0x6194
437:                                   
438:                       shift = ((i - half_width)*num)/half_width;
006194  90003E     MOV [W14+6], W0
006196  10009E     SUBR W0, [W14], W1
006198  90007E     MOV [W14+14], W0
00619A  B98800     MUL.SS W1, W0, W0
00619C  780080     MOV W0, W1
00619E  90003E     MOV [W14+6], W0
0061A0  780100     MOV W0, W2
0061A2  090011     REPEAT #0x11
0061A4  D80082     DIV.SW W1, W2
0061A6  980740     MOV W0, [W14+8]
439:                       
440:                       if(shift == 0) {
0061A8  9000CE     MOV [W14+8], W1
0061AA  EB0000     CLR W0
0061AC  508F80     SUB W1, W0, [W15]
0061AE  320034     BRA Z, 0x6218
441:                           // Do nothing
442:                       } else if(shift > 0) {
0061B0  9000CE     MOV [W14+8], W1
0061B2  EB0000     CLR W0
0061B4  508F80     SUB W1, W0, [W15]
0061B6  340019     BRA LE, 0x61EA
443:                           
444:                           shiftColumn(frame, i, 0, shift, height - shift);
0061B8  90009E     MOV [W14+2], W1
0061BA  90004E     MOV [W14+8], W0
0061BC  508000     SUB W1, W0, W0
0061BE  780100     MOV W0, W2
0061C0  9000CE     MOV [W14+8], W1
0061C2  78001E     MOV [W14], W0
0061C4  780202     MOV W2, W4
0061C6  780181     MOV W1, W3
0061C8  EB0100     CLR W2
0061CA  780080     MOV W0, W1
0061CC  90006E     MOV [W14+12], W0
0061CE  07002D     RCALL shiftColumn
445:                           setColumn(frame, i, height - shift, 0, shift); 
0061D0  90014E     MOV [W14+8], W2
0061D2  90009E     MOV [W14+2], W1
0061D4  90004E     MOV [W14+8], W0
0061D6  508000     SUB W1, W0, W0
0061D8  780080     MOV W0, W1
0061DA  78001E     MOV [W14], W0
0061DC  780202     MOV W2, W4
0061DE  EB4180     CLR.B W3
0061E0  780101     MOV W1, W2
0061E2  780080     MOV W0, W1
0061E4  90006E     MOV [W14+12], W0
0061E6  07006A     RCALL setColumn
0061E8  370017     BRA 0x6218
446:                           
447:                       } else { // shift < 0
448:                       
449:                           shift = -shift;
0061EA  90004E     MOV [W14+8], W0
0061EC  EA0000     NEG W0, W0
0061EE  980740     MOV W0, [W14+8]
450:                           shiftColumn(frame, i, shift, 0, height - shift); 
0061F0  90009E     MOV [W14+2], W1
0061F2  90004E     MOV [W14+8], W0
0061F4  508000     SUB W1, W0, W0
0061F6  780100     MOV W0, W2
0061F8  9000CE     MOV [W14+8], W1
0061FA  78001E     MOV [W14], W0
0061FC  780202     MOV W2, W4
0061FE  EB0180     CLR W3
006200  780101     MOV W1, W2
006202  780080     MOV W0, W1
006204  90006E     MOV [W14+12], W0
006206  070011     RCALL shiftColumn
451:                           setColumn(frame, i, 0, 0, shift);
006208  9000CE     MOV [W14+8], W1
00620A  78001E     MOV [W14], W0
00620C  780201     MOV W1, W4
00620E  EB4180     CLR.B W3
006210  EB0100     CLR W2
006212  780080     MOV W0, W1
006214  90006E     MOV [W14+12], W0
006216  070052     RCALL setColumn
452:                           
453:                       }
454:               
455:                       int j;
456:                       j = 0;
006218  EB0000     CLR W0
00621A  980750     MOV W0, [W14+10]
457:               
458:                   }
459:               
460:               }
006226  FA8000     ULNK
006228  060000     RETURN
461:               
462:               static void shiftColumn(CamFrame frame, unsigned int col,
463:                                   unsigned int row_dst, unsigned int row_src, unsigned int num) {
00622A  FA0012     LNK #0x12
00622C  980740     MOV W0, [W14+8]
00622E  980751     MOV W1, [W14+10]
006230  980762     MOV W2, [W14+12]
006232  980773     MOV W3, [W14+14]
006234  980F04     MOV W4, [W14+16]
464:               
465:                   int i, shift, step;
466:                   unsigned int cnt;    
467:                       
468:                   shift = row_dst - row_src;
006236  9000EE     MOV [W14+12], W1
006238  90007E     MOV [W14+14], W0
00623A  508000     SUB W1, W0, W0
00623C  980730     MOV W0, [W14+6]
469:                   
470:                   if(shift == 0) {
00623E  9000BE     MOV [W14+6], W1
006240  EB0000     CLR W0
006242  508F80     SUB W1, W0, [W15]
006244  320038     BRA Z, 0x62B6
471:                       return;
0062B6  000000     NOP
472:                   } else if(shift > 0) { // Start from tail
006246  9000BE     MOV [W14+6], W1
006248  EB0000     CLR W0
00624A  508F80     SUB W1, W0, [W15]
00624C  340006     BRA LE, 0x625A
473:                       step = -1;
00624E  EB8000     SETM W0
006250  980710     MOV W0, [W14+2]
474:                       i = num - 1;
006252  90080E     MOV [W14+16], W0
006254  E90000     DEC W0, W0
006256  780F00     MOV W0, [W14]
006258  370004     BRA 0x6262
475:                   } else { // shift < 0, start from head
476:                       step = 1;
00625A  200010     MOV #0x1, W0
00625C  980710     MOV W0, [W14+2]
477:                       i = 0;
00625E  EB0000     CLR W0
006260  780F00     MOV W0, [W14]
478:                   }
479:                   
480:                   cnt = num;
006262  90080E     MOV [W14+16], W0
006264  980720     MOV W0, [W14+4]
481:                   while(cnt--) {
006266  37001A     BRA 0x629C
00629C  90002E     MOV [W14+4], W0
00629E  EA0080     NEG W0, W1
0062A0  90002E     MOV [W14+4], W0
0062A2  708000     IOR W1, W0, W0
0062A4  DE004F     LSR W0, #15, W0
0062A6  784080     MOV.B W0, W1
0062A8  90002E     MOV [W14+4], W0
0062AA  E90000     DEC W0, W0
0062AC  980720     MOV W0, [W14+4]
0062AE  EB4000     CLR.B W0
0062B0  50CF80     SUB.B W1, W0, [W15]
0062B2  3AFFDA     BRA NZ, 0x6268
0062B4  370001     BRA 0x62B8
482:                       frame->pixels[row_dst + i][col] = 
006268  78009E     MOV [W14], W1
00626A  90006E     MOV [W14+12], W0
00626C  408200     ADD W1, W0, W4
006286  9001CE     MOV [W14+8], W3
006288  2004B0     MOV #0x4B, W0
00628A  B9A000     MUL.SS W4, W0, W0
00628C  780000     MOV W0, W0
00628E  418080     ADD W3, W0, W1
006290  90005E     MOV [W14+10], W0
006292  408000     ADD W1, W0, W0
006294  400066     ADD W0, #0x6, W0
006296  784802     MOV.B W2, [W0]
483:                           frame->pixels[row_src + i][col];
00626E  78009E     MOV [W14], W1
006270  90007E     MOV [W14+14], W0
006272  408080     ADD W1, W0, W1
006274  90014E     MOV [W14+8], W2
006276  2004B0     MOV #0x4B, W0
006278  B98800     MUL.SS W1, W0, W0
00627A  780080     MOV W0, W1
00627C  90005E     MOV [W14+10], W0
00627E  408000     ADD W1, W0, W0
006280  400066     ADD W0, #0x6, W0
006282  410000     ADD W2, W0, W0
006284  784110     MOV.B [W0], W2
484:                       i = i + step;
006298  90001E     MOV [W14+2], W0
00629A  400F1E     ADD W0, [W14], [W14]
485:                   }
486:                   
487:               }
0062B8  FA8000     ULNK
0062BA  060000     RETURN
488:               
489:               static void setColumn(CamFrame frame, unsigned int col, unsigned int start_row,
490:                               unsigned char val, unsigned int num) {
0062BC  FA000E     LNK #0xE
0062BE  980720     MOV W0, [W14+4]
0062C0  980731     MOV W1, [W14+6]
0062C2  980742     MOV W2, [W14+8]
0062C4  984F23     MOV.B W3, [W14+10]
0062C6  980764     MOV W4, [W14+12]
491:               
492:                   unsigned int cnt, i;
493:                   
494:                   cnt = num;
0062C8  90006E     MOV [W14+12], W0
0062CA  780F00     MOV W0, [W14]
495:                   i = 0;
0062CC  EB0000     CLR W0
0062CE  980710     MOV W0, [W14+2]
496:                   
497:                   while(cnt--) {
0062D0  370010     BRA 0x62F2
0062F2  EA001E     NEG [W14], W0
0062F4  70001E     IOR W0, [W14], W0
0062F6  DE004F     LSR W0, #15, W0
0062F8  784080     MOV.B W0, W1
0062FA  E90F1E     DEC [W14], [W14]
0062FC  EB4000     CLR.B W0
0062FE  50CF80     SUB.B W1, W0, [W15]
006300  3AFFE8     BRA NZ, 0x62D2
498:                       frame->pixels[start_row + i][col] = val;
0062D2  9000CE     MOV [W14+8], W1
0062D4  90001E     MOV [W14+2], W0
0062D6  408080     ADD W1, W0, W1
0062D8  90012E     MOV [W14+4], W2
0062DA  2004B0     MOV #0x4B, W0
0062DC  B98800     MUL.SS W1, W0, W0
0062DE  780000     MOV W0, W0
0062E0  410080     ADD W2, W0, W1
0062E2  90003E     MOV [W14+6], W0
0062E4  408000     ADD W1, W0, W0
0062E6  400066     ADD W0, #0x6, W0
0062E8  9048AE     MOV.B [W14+10], W1
0062EA  784801     MOV.B W1, [W0]
499:                       i++;
0062EC  90001E     MOV [W14+2], W0
0062EE  E80000     INC W0, W0
0062F0  980710     MOV W0, [W14+2]
500:                   }
501:                               
502:               }
006302  FA8000     ULNK
006304  060000     RETURN
503:               
504:               static void cvNonMaximumElimination(CamFrame frame) {
006306  FA0008     LNK #0x8
006308  980730     MOV W0, [W14+6]
505:               
506:                   unsigned int i, j, atan_result;
507:                   unsigned char val;
508:                   
509:                   // Set outside border to 0
510:                   memset(frame->pixels[0], 0x00, DS_IMAGE_COLS);
00630A  90003E     MOV [W14+6], W0
00630C  400066     ADD W0, #0x6, W0
00630E  2004B2     MOV #0x4B, W2
006310  EB0080     CLR W1
006312  0235B4     CALL _memset
006314  000000     NOP
511:                   memset(frame->pixels[DS_IMAGE_ROWS - 1], 0x00, DS_IMAGE_COLS);
006316  90003E     MOV [W14+6], W0
006318  4000E6     ADD W0, #0x6, W1
00631A  211490     MOV #0x1149, W0
00631C  408000     ADD W1, W0, W0
00631E  2004B2     MOV #0x4B, W2
006320  EB0080     CLR W1
006322  0235B4     CALL _memset
006324  000000     NOP
512:                   setColumn(frame, 0, 0, 0x00, DS_IMAGE_ROWS);
006326  2003C4     MOV #0x3C, W4
006328  EB4180     CLR.B W3
00632A  EB0100     CLR W2
00632C  EB0080     CLR W1
00632E  90003E     MOV [W14+6], W0
006330  07FFC5     RCALL setColumn
513:                   setColumn(frame, DS_IMAGE_COLS - 1, 0, 0x00, DS_IMAGE_ROWS);
006332  2003C4     MOV #0x3C, W4
006334  EB4180     CLR.B W3
006336  EB0100     CLR W2
006338  2004A1     MOV #0x4A, W1
00633A  90003E     MOV [W14+6], W0
00633C  07FFBF     RCALL setColumn
514:                   
515:                   for(i = 1; i < DS_IMAGE_ROWS - 1; i++) {
00633E  200010     MOV #0x1, W0
006340  780F00     MOV W0, [W14]
006342  370016     BRA 0x6370
00636E  E80F1E     INC [W14], [W14]
006370  2003A0     MOV #0x3A, W0
006372  78009E     MOV [W14], W1
006374  508F80     SUB W1, W0, [W15]
006376  36FFE6     BRA LEU, 0x6344
516:                       for(j = 1; j < DS_IMAGE_COLS - 1; j++) {
006344  200010     MOV #0x1, W0
006346  980710     MOV W0, [W14+2]
006348  37000E     BRA 0x6366
006360  90001E     MOV [W14+2], W0
006362  E80000     INC W0, W0
006364  980710     MOV W0, [W14+2]
006366  90009E     MOV [W14+2], W1
006368  200490     MOV #0x49, W0
00636A  508F80     SUB W1, W0, [W15]
00636C  36FFEE     BRA LEU, 0x634A
517:                           val = frame->pixels[i][j];
00634A  90013E     MOV [W14+6], W2
00634C  78009E     MOV [W14], W1
00634E  2004B0     MOV #0x4B, W0
006350  B98800     MUL.SS W1, W0, W0
006352  780080     MOV W0, W1
006354  90001E     MOV [W14+2], W0
006356  408000     ADD W1, W0, W0
006358  400066     ADD W0, #0x6, W0
00635A  410000     ADD W2, W0, W0
00635C  784090     MOV.B [W0], W1
00635E  984741     MOV.B W1, [W14+4]
518:                           
519:                       }
520:                   }
521:               
522:               }
006378  FA8000     ULNK
00637A  060000     RETURN
523:               
524:               typedef enum {
525:                   LEFT_RIGHT = 0,
526:                   UP_DOWN,
527:               } AtanSimpleAngle;    
528:               
529:               static AtanSimpleAngle atanSimple(int y, int x) {
00637C  FA0004     LNK #0x4
00637E  780F00     MOV W0, [W14]
006380  980711     MOV W1, [W14+2]
530:               
531:                   if(y > 0) { y = -y; }
006382  78009E     MOV [W14], W1
006384  EB0000     CLR W0
006386  508F80     SUB W1, W0, [W15]
006388  340001     BRA LE, 0x638C
00638A  EA0F1E     NEG [W14], [W14]
532:                   if(x > 0) { x = -x; }
00638C  90009E     MOV [W14+2], W1
00638E  EB0000     CLR W0
006390  508F80     SUB W1, W0, [W15]
006392  340003     BRA LE, 0x639A
006394  90001E     MOV [W14+2], W0
006396  EA0000     NEG W0, W0
006398  980710     MOV W0, [W14+2]
533:                   
534:                   if(x > y) { return LEFT_RIGHT; }
00639A  90009E     MOV [W14+2], W1
00639C  78001E     MOV [W14], W0
00639E  508F80     SUB W1, W0, [W15]
0063A0  340002     BRA LE, 0x63A6
0063A2  EB0000     CLR W0
0063A4  370001     BRA 0x63A8
535:                   else { return UP_DOWN; }
0063A6  200010     MOV #0x1, W0
536:                   
537:               }
0063A8  FA8000     ULNK
0063AA  060000     RETURN
---  C:/Users/Cameron/Documents/Git/ibird-lib/cmd.c  ----------------------------------------------------
1:                 /**
2:                  * Copyright (c) 2010-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Robot command processing module
31:                 *
32:                 * by Stan Baek
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Stan Baek		 2011-07-10	   Initial implementation
38:                 *  Humphrey Hu		 2011-08-06    Added more commands and reply-to functionality
39:                 *                      
40:                 * Notes:
41:                 *
42:                 * To do:
43:                 *	
44:                 */
45:                
46:                #include <stdio.h>
47:                #include "cam.h"
48:                #include "telemetry.h"
49:                #include "cmd.h"
50:                #include "cmd_const.h"
51:                #include "radio.h"
52:                #include "rate.h"
53:                #include "lstrobe.h"
54:                #include "net.h"
55:                #include "dfmem.h"
56:                #include "utils.h"
57:                #include "ports.h"
58:                #include "gyro.h"
59:                #include "xl.h"
60:                #include "clock_sync.h"
61:                #include "sys_clock.h"
62:                #include "led.h"
63:                #include "motor_ctrl.h"
64:                #include "payload.h"
65:                #include "attitude.h"
66:                #include "regulator.h"
67:                #include "mac_packet.h"
68:                #include "cv.h"
69:                #include "directory.h"
70:                #include "carray.h"
71:                #include "slew.h"
72:                #include "hall.h"
73:                #include <string.h>
74:                #include <stdlib.h>
75:                #include <math.h>
76:                
77:                typedef union {
78:                    float fval;
79:                    unsigned long lval;
80:                    short sval[2];
81:                    unsigned char cval[4];
82:                } uByte4;
83:                
84:                typedef union {
85:                    unsigned short sval;
86:                    unsigned char cval[2];
87:                } uByte2;
88:                
89:                // use an array of function pointer to avoid a number of case statements
90:                // MAX_CMD_FUNC_SIZE is defined in cmd_const.h
91:                void (*cmd_func[MAX_CMD_FUNC_SIZE])(MacPacket);
92:                
93:                // ==== Static Variables =======================================================
94:                static CircArray input_queue;
95:                
96:                // ==== Function Prototypes ====================================================
97:                static void cmdAddressRequest(MacPacket packet);
98:                static void cmdAddressOffer(MacPacket packet);
99:                static void cmdAddressAccept(MacPacket packet);
100:               
101:               static void cmdDirUpdateRequest(MacPacket packet);
102:               static void cmdDirUpdateResponse(MacPacket packet);
103:               static void cmdDirDumpRequest(MacPacket packet);
104:               static void cmdDirDumpResponse(MacPacket packet);
105:               
106:               static void cmdRequestClockUpdate(MacPacket packet);
107:               static void cmdResponseClockUpdate(MacPacket packet);
108:               
109:               static void cmdStopClosed(MacPacket packet);
110:               static void cmdCalibCrank(MacPacket packet);
111:               
112:               static void cmdRotateRefGlobal(MacPacket packet);
113:               static void cmdRotateRefLocal(MacPacket packet);
114:               static void cmdSetRegulatorOffsets(MacPacket packet);
115:               static void cmdSetRegulatorMode(MacPacket packet);
116:               static void cmdSetRegulatorRef(MacPacket packet);
117:               static void cmdSetRegulatorTempRotation(MacPacket packet);
118:               static void cmdSetRegulatorPid(MacPacket packet);
119:               static void cmdSetRegulatorRateFilter(MacPacket packet);
120:               static void cmdSetRemoteControlValues(MacPacket packet);
121:               
122:               static void cmdSetRateMode(MacPacket packet);
123:               static void cmdSetRateSlew(MacPacket packet);
124:               
125:               static void cmdRequestRawFrame(MacPacket packet);
126:               static void cmdResponseRawFrame(MacPacket packet);
127:               static void cmdSetBackgroundFrame(MacPacket packet);
128:               static void cmdCamParamRequest(MacPacket packet);
129:               static void cmdCamParamResponse(MacPacket packet);
130:               
131:               static void cmdRequestTelemetry(MacPacket packet);
132:               static void cmdResponseTelemetry(MacPacket packet);
133:               static void cmdRecordTelemetry(MacPacket packet);
134:               
135:               static void cmdSetLogging(MacPacket packet);
136:               static void cmdGetMemContents(MacPacket packet);
137:               
138:               static void cmdRunGyroCalib(MacPacket packet);
139:               static void cmdGetGyroCalibParam(MacPacket packet);
140:               
141:               static void cmdSetEstimateRunning(MacPacket packet);
142:               
143:               static void cmdSetHP(MacPacket packet);
144:               
145:               static void cmdZeroEstimate(MacPacket packet);
146:               static void cmdRequestAttitude(MacPacket packet);
147:               static void cmdResponseAttitude(MacPacket packet);
148:               
149:               static void cmdSetTelemSubsample(MacPacket packet);
150:               static void cmdSetSlewLimit(MacPacket packet);
151:               
152:               static void cmdToggleStreaming(MacPacket packet);
153:               
154:               static void cmdSetVelProfile(MacPacket packet);
155:               static void cmdHallPIDSetInput(MacPacket packet);
156:               static void cmdSetHallGains(MacPacket packet);
157:               static void cmdHallPIDOn(MacPacket packet);
158:               
159:               static void cmdEcho(MacPacket packet);
160:               static void cmdNop(MacPacket packet);
161:               
162:               // =============== Public Functions ============================================
163:               unsigned int cmdSetup(unsigned int queue_size) {
004BBA  FA0004     LNK #0x4
004BBC  980710     MOV W0, [W14+2]
164:               
165:                   unsigned int i;
166:               
167:                   input_queue = carrayCreate(queue_size);
004BBE  90001E     MOV [W14+2], W0
004BC0  028F1C     CALL carrayCreate
004BC2  000000     NOP
004BC4  88F570     MOV W0, input_queue
168:                   if(input_queue == NULL) {
004BC6  80F571     MOV input_queue, W1
004BC8  EB0000     CLR W0
004BCA  508F80     SUB W1, W0, [W15]
004BCC  3A0002     BRA NZ, 0x4BD2
169:                       return 0;
004BCE  EB0000     CLR W0
004BD0  37006D     BRA 0x4CAC
170:                   }
171:               
172:                   // initialize the array of func pointers with Nop()
173:                   for(i = 0; i < MAX_CMD_FUNC_SIZE; ++i) {
004BD2  EB0000     CLR W0
004BD4  780F00     MOV W0, [W14]
004BD6  370007     BRA 0x4BE6
004BE4  E80F1E     INC [W14], [W14]
004BE6  2005F0     MOV #0x5F, W0
004BE8  78009E     MOV [W14], W1
004BEA  508F80     SUB W1, W0, [W15]
004BEC  36FFF5     BRA LEU, 0x4BD8
174:                       cmd_func[i] = &cmdNop;
004BD8  78001E     MOV [W14], W0
004BDA  400080     ADD W0, W0, W1
004BDC  21DEE0     MOV #0x1DEE, W0
004BDE  408000     ADD W1, W0, W0
004BE0  258141     MOV #0x5814, W1
004BE2  780801     MOV W1, [W0]
175:                   }
176:               
177:                   cmd_func[CMD_ADDRESS_REQUEST] = &cmdAddressRequest;
004BEE  24D0C0     MOV #0x4D0C, W0
004BF0  88F270     MOV W0, 0x1E4E
178:                   cmd_func[CMD_ADDRESS_OFFER] = &cmdAddressOffer;
004BF2  24D1A0     MOV #0x4D1A, W0
004BF4  88F280     MOV W0, 0x1E50
179:                   cmd_func[CMD_ADDRESS_ACCEPT] = &cmdAddressAccept;
004BF6  24D280     MOV #0x4D28, W0
004BF8  88F290     MOV W0, 0x1E52
180:               
181:                   cmd_func[CMD_DIR_UPDATE_REQUEST] = &cmdDirUpdateRequest;
004BFA  24D360     MOV #0x4D36, W0
004BFC  88F2B0     MOV W0, 0x1E56
182:                   cmd_func[CMD_DIR_UPDATE_RESPONSE] = &cmdDirUpdateResponse;
004BFE  24D3E0     MOV #0x4D3E, W0
004C00  88F2C0     MOV W0, 0x1E58
183:                   cmd_func[CMD_DIR_DUMP_REQUEST] = &cmdDirDumpRequest;
004C02  24E060     MOV #0x4E06, W0
004C04  88F2D0     MOV W0, 0x1E5A
184:                   cmd_func[CMD_DIR_DUMP_RESPONSE] = &cmdDirDumpResponse;
004C06  24F3C0     MOV #0x4F3C, W0
004C08  88F2E0     MOV W0, 0x1E5C
185:               
186:                   cmd_func[CMD_CLOCK_UPDATE_REQUEST] = &cmdRequestClockUpdate;
004C0A  24F440     MOV #0x4F44, W0
004C0C  88F2F0     MOV W0, 0x1E5E
187:                   cmd_func[CMD_CLOCK_UPDATE_RESPONSE] = &cmdResponseClockUpdate;
004C0E  24F520     MOV #0x4F52, W0
004C10  88F300     MOV W0, 0x1E60
188:               
189:                   cmd_func[CMD_SET_ESTIMATE_RUNNING] = &cmdSetEstimateRunning;
004C12  2539A0     MOV #0x539A, W0
004C14  88F230     MOV W0, 0x1E46
190:               
191:                   cmd_func[CMD_ECHO] = &cmdEcho;
004C16  257940     MOV #0x5794, W0
004C18  88F0A0     MOV W0, 0x1E14
192:               
193:                   cmd_func[CMD_STOP_CLOSED] = &cmdStopClosed;
004C1A  24FD60     MOV #0x4FD6, W0
004C1C  88F0C0     MOV W0, 0x1E18
194:                   cmd_func[CMD_CALIB_CRANK] = &cmdCalibCrank;
004C1E  24FF60     MOV #0x4FF6, W0
004C20  88F0D0     MOV W0, 0x1E1A
195:               
196:                   cmd_func[CMD_ROTATE_REF_GLOBAL] = &cmdRotateRefGlobal;
004C22  250020     MOV #0x5002, W0
004C24  88F0F0     MOV W0, 0x1E1E
197:                   cmd_func[CMD_ROTATE_REF_LOCAL] = &cmdRotateRefLocal;
004C26  2501C0     MOV #0x501C, W0
004C28  88F100     MOV W0, 0x1E20
198:                   cmd_func[CMD_SET_TEMP_ROT] = &cmdSetRegulatorTempRotation;
004C2A  2508A0     MOV #0x508A, W0
004C2C  88F0E0     MOV W0, 0x1E1C
199:                   cmd_func[CMD_SET_REGULATOR_OFFSETS] = &cmdSetRegulatorOffsets;
004C2E  250360     MOV #0x5036, W0
004C30  88F170     MOV W0, 0x1E2E
200:                   cmd_func[CMD_SET_REGULATOR_MODE] = &cmdSetRegulatorMode;
004C32  250500     MOV #0x5050, W0
004C34  88F180     MOV W0, 0x1E30
201:                   cmd_func[CMD_SET_REGULATOR_REF] = &cmdSetRegulatorRef;
004C36  2506C0     MOV #0x506C, W0
004C38  88F190     MOV W0, 0x1E32
202:                   cmd_func[CMD_SET_REGULATOR_PID] = &cmdSetRegulatorPid;
004C3A  250A40     MOV #0x50A4, W0
004C3C  88F1A0     MOV W0, 0x1E34
203:                   cmd_func[CMD_SET_REGULATOR_RATE_FILTER] = &cmdSetRegulatorRateFilter;
004C3E  250D60     MOV #0x50D6, W0
004C40  88F1B0     MOV W0, 0x1E36
204:               
205:                   cmd_func[CMD_SET_RATE_MODE] = &cmdSetRateMode;
004C42  251640     MOV #0x5164, W0
004C44  88F1D0     MOV W0, 0x1E3A
206:                   cmd_func[CMD_SET_RATE_SLEW] = &cmdSetRateSlew;
004C46  251980     MOV #0x5198, W0
004C48  88F1E0     MOV W0, 0x1E3C
207:               
208:                   cmd_func[CMD_RAW_FRAME_REQUEST] = &cmdRequestRawFrame;
004C4A  253DC0     MOV #0x53DC, W0
004C4C  88F370     MOV W0, 0x1E6E
209:                   cmd_func[CMD_RAW_FRAME_RESPONSE] = &cmdResponseRawFrame;
004C4E  255DC0     MOV #0x55DC, W0
004C50  88F380     MOV W0, 0x1E70
210:                   cmd_func[CMD_SET_BACKGROUND_FRAME] = &cmdSetBackgroundFrame;
004C52  255E40     MOV #0x55E4, W0
004C54  88F3A0     MOV W0, 0x1E74
211:                   cmd_func[CMD_CAM_PARAM_REQUEST] = &cmdCamParamRequest;
004C56  2560A0     MOV #0x560A, W0
004C58  88F3F0     MOV W0, 0x1E7E
212:                   cmd_func[CMD_CAM_PARAM_RESPONSE] = &cmdCamParamResponse;
004C5A  256740     MOV #0x5674, W0
004C5C  88F400     MOV W0, 0x1E80
213:               
214:                   cmd_func[CMD_SET_RC_VALUES] = &cmdSetRemoteControlValues;
004C5E  251320     MOV #0x5132, W0
004C60  88F1C0     MOV W0, 0x1E38
215:               
216:                   cmd_func[CMD_RECORD_TELEMETRY] = &cmdRecordTelemetry;
004C62  253780     MOV #0x5378, W0
004C64  88F260     MOV W0, 0x1E4C
217:                   cmd_func[CMD_REQUEST_TELEMETRY] = &cmdRequestTelemetry;
004C66  253800     MOV #0x5380, W0
004C68  88F240     MOV W0, 0x1E48
218:                   cmd_func[CMD_RESPONSE_TELEMETRY] = &cmdResponseTelemetry;
004C6A  253920     MOV #0x5392, W0
004C6C  88F250     MOV W0, 0x1E4A
219:               
220:                   cmd_func[CMD_RECORD_SENSOR_DUMP] = &cmdSetLogging;
004C6E  251B60     MOV #0x51B6, W0
004C70  88F1F0     MOV W0, 0x1E3E
221:                   cmd_func[CMD_GET_MEM_CONTENTS] = &cmdGetMemContents;
004C72  251E60     MOV #0x51E6, W0
004C74  88F200     MOV W0, 0x1E40
222:                   cmd_func[CMD_RUN_GYRO_CALIB] = &cmdRunGyroCalib;
004C76  252EA0     MOV #0x52EA, W0
004C78  88F210     MOV W0, 0x1E42
223:                   cmd_func[CMD_GET_GYRO_CALIB_PARAM] = &cmdGetGyroCalibParam;
004C7A  2531A0     MOV #0x531A, W0
004C7C  88F220     MOV W0, 0x1E44
224:               
225:                   cmd_func[CMD_SET_HP] = &cmdSetHP;
004C7E  257480     MOV #0x5748, W0
004C80  88F410     MOV W0, 0x1E82
226:                   
227:                   cmd_func[CMD_ZERO_ESTIMATE] = &cmdZeroEstimate;
004C82  257220     MOV #0x5722, W0
004C84  88F430     MOV W0, 0x1E86
228:                   cmd_func[CMD_REQUEST_ATTITUDE] = &cmdRequestAttitude;
004C86  2572E0     MOV #0x572E, W0
004C88  88F470     MOV W0, 0x1E8E
229:                   cmd_func[CMD_RESPONSE_ATTITUDE] = &cmdResponseAttitude;
004C8A  257400     MOV #0x5740, W0
004C8C  88F480     MOV W0, 0x1E90
230:                   
231:                   cmd_func[CMD_SET_TELEM_SUBSAMPLE] = &cmdSetTelemSubsample;
004C8E  257540     MOV #0x5754, W0
004C90  88F490     MOV W0, 0x1E92
232:                   cmd_func[CMD_SET_SLEW_LIMIT] = &cmdSetSlewLimit;
004C92  257780     MOV #0x5778, W0
004C94  88F4A0     MOV W0, 0x1E94
233:               
234:                   cmd_func[CMD_TOGGLE_STREAMING] = &cmdToggleStreaming;
004C96  253CA0     MOV #0x53CA, W0
004C98  88F4B0     MOV W0, 0x1E96
235:               
236:                   cmd_func[CMD_SET_VEL_PROFILE] = &cmdSetVelProfile;
004C9A  24F600     MOV #0x4F60, W0
004C9C  88F4C0     MOV W0, 0x1E98
237:                   cmd_func[CMD_SET_HALL_INPUT] = &cmdHallPIDSetInput;
004C9E  24F820     MOV #0x4F82, W0
004CA0  88F4E0     MOV W0, 0x1E9C
238:                   cmd_func[CMD_SET_HALL_GAINS] = &cmdSetHallGains;
004CA2  24FA80     MOV #0x4FA8, W0
004CA4  88F4D0     MOV W0, 0x1E9A
239:                   cmd_func[CMD_HALL_PID_ON] = &cmdHallPIDOn;
004CA6  24FCA0     MOV #0x4FCA, W0
004CA8  88F4F0     MOV W0, 0x1E9E
240:               
241:                   return 1;
004CAA  200010     MOV #0x1, W0
242:                   
243:               }
004CAC  FA8000     ULNK
004CAE  060000     RETURN
244:               
245:               unsigned int cmdQueuePacket(MacPacket packet) {
004CB0  FA0002     LNK #0x2
004CB2  780F00     MOV W0, [W14]
246:               
247:                   return carrayAddTail(input_queue, packet);
004CB4  80F570     MOV input_queue, W0
004CB6  78009E     MOV [W14], W1
004CB8  028F9A     CALL carrayAddTail
004CBA  000000     NOP
248:               
249:               }
004CBC  FA8000     ULNK
004CBE  060000     RETURN
250:               
251:               void cmdProcessBuffer(void) {
004CC0  FA0006     LNK #0x6
252:               
253:                   MacPacket packet;
254:                   Payload pld;
255:                   unsigned char command;  
256:               
257:                   // Check for unprocessed packet
258:                   //packet = radioDequeueRxPacket();
259:                   packet = carrayPopTail(input_queue);
004CC2  80F570     MOV input_queue, W0
004CC4  029102     CALL carrayPopTail
004CC6  000000     NOP
004CC8  780F00     MOV W0, [W14]
260:                   if(packet == NULL) { 
004CCA  78009E     MOV [W14], W1
004CCC  EB0000     CLR W0
004CCE  508F80     SUB W1, W0, [W15]
004CD0  32001A     BRA Z, 0x4D06
261:                       return;
004D06  000000     NOP
262:                   } else {
263:                       Nop();
004CD2  000000     NOP
264:                       Nop();
004CD4  000000     NOP
265:                   }
266:               
267:                   pld = macGetPayload(packet);
004CD6  78001E     MOV [W14], W0
004CD8  0286E6     CALL macGetPayload
004CDA  000000     NOP
004CDC  980710     MOV W0, [W14+2]
268:                   command = payGetType(pld);
004CDE  90001E     MOV [W14+2], W0
004CE0  02CAF2     CALL payGetType
004CE2  000000     NOP
004CE4  984740     MOV.B W0, [W14+4]
269:                   if(command < MAX_CMD_FUNC_SIZE) {
004CE6  9040CE     MOV.B [W14+4], W1
004CE8  B3C5F0     MOV #0x5F, W0
004CEA  50CF80     SUB.B W1, W0, [W15]
004CEC  3E0008     BRA GTU, 0x4CFE
270:                       cmd_func[command](packet);
004CEE  90404E     MOV.B [W14+4], W0
004CF0  FB8000     ZE W0, W0
004CF2  400080     ADD W0, W0, W1
004CF4  21DEE0     MOV #0x1DEE, W0
004CF6  408000     ADD W1, W0, W0
004CF8  780090     MOV [W0], W1
004CFA  78001E     MOV [W14], W0
004CFC  010001     CALL W1
271:                   }
272:                   radioReturnPacket(packet);
004CFE  78001E     MOV [W14], W0
004D00  028240     CALL radioReturnPacket
004D02  000000     NOP
004D04  370001     BRA 0x4D08
273:                   
274:               }
004D08  FA8000     ULNK
004D0A  060000     RETURN
275:               
276:               // =============== Private Functions ===========================================
277:               
278:               // ====== Networking ===========================================================
279:               
280:               static void cmdAddressRequest(MacPacket packet) {
004D0C  FA0002     LNK #0x2
004D0E  780F00     MOV W0, [W14]
281:                   
282:                   netHandleRequest(packet);
004D10  78001E     MOV [W14], W0
004D12  02C41C     CALL netHandleRequest
004D14  000000     NOP
283:                   
284:               }
004D16  FA8000     ULNK
004D18  060000     RETURN
285:               
286:               static void cmdAddressOffer(MacPacket packet) {
004D1A  FA0002     LNK #0x2
004D1C  780F00     MOV W0, [W14]
287:                   
288:                   netHandleOffer(packet);
004D1E  78001E     MOV [W14], W0
004D20  02C380     CALL netHandleOffer
004D22  000000     NOP
289:                   
290:               }
004D24  FA8000     ULNK
004D26  060000     RETURN
291:               
292:               static void cmdAddressAccept(MacPacket packet) {
004D28  FA0002     LNK #0x2
004D2A  780F00     MOV W0, [W14]
293:                   
294:                   netHandleAccept(packet);
004D2C  78001E     MOV [W14], W0
004D2E  02C424     CALL netHandleAccept
004D30  000000     NOP
295:                   
296:               }
004D32  FA8000     ULNK
004D34  060000     RETURN
297:               
298:               static void cmdDirUpdateRequest(MacPacket packet) {
004D36  FA0002     LNK #0x2
004D38  780F00     MOV W0, [W14]
299:               
300:                   
301:               
302:               }
004D3A  FA8000     ULNK
004D3C  060000     RETURN
303:               
304:               static void cmdDirUpdateResponse(MacPacket packet) {
004D3E  FA000C     LNK #0xC
004D40  980750     MOV W0, [W14+10]
305:               
306:                   typedef struct {
307:                       unsigned long long UUID;        
308:                       unsigned long timestamp;
309:                       unsigned int address;
310:                   }UpdateEntry;
311:               
312:                   Payload pld;
313:                   unsigned int i, num_entries;
314:                   DirEntry entry;
315:                   UpdateEntry *update;
316:               
317:                   pld = macGetPayload(packet);
004D42  90005E     MOV [W14+10], W0
004D44  0286E6     CALL macGetPayload
004D46  000000     NOP
004D48  980720     MOV W0, [W14+4]
318:                   update = (UpdateEntry*) payGetData(pld);
004D4A  90002E     MOV [W14+4], W0
004D4C  02CAA0     CALL payGetData
004D4E  000000     NOP
004D50  980730     MOV W0, [W14+6]
319:                   num_entries = payGetDataLength(pld)/sizeof(UpdateEntry);
004D52  90002E     MOV [W14+4], W0
004D54  02CAD2     CALL payGetDataLength
004D56  000000     NOP
004D58  FB8080     ZE W0, W1
004D5A  2000E0     MOV #0xE, W0
004D5C  780100     MOV W0, W2
004D5E  090011     REPEAT #0x11
004D60  D88082     DIV.UW W1, W2
004D62  784000     MOV.B W0, W0
004D64  FB8000     ZE W0, W0
004D66  980740     MOV W0, [W14+8]
320:               
321:                   for(i = 0; i < num_entries; i++) {        
004D68  EB0000     CLR W0
004D6A  780F00     MOV W0, [W14]
004D6C  370046     BRA 0x4DFA
004DF8  E80F1E     INC [W14], [W14]
004DFA  90004E     MOV [W14+8], W0
004DFC  78009E     MOV [W14], W1
004DFE  508F80     SUB W1, W0, [W15]
004E00  39FFB6     BRA NC, 0x4D6E
322:                       entry = dirQueryID(update[i].UUID); // Retrieve entry
004D6E  78001E     MOV [W14], W0
004D70  B9006E     MUL.SU W0, #14, W0
004D72  780000     MOV W0, W0
004D74  9000BE     MOV [W14+6], W1
004D76  408000     ADD W1, W0, W0
004D78  BE0150     MOV.D [++W0], W2
004D7A  BE0040     MOV.D [--W0], W0
004D7C  02CBE0     CALL dirQueryID
004D7E  000000     NOP
004D80  980710     MOV W0, [W14+2]
323:                       if(entry == NULL) {                 // If not seen, create
004D82  90009E     MOV [W14+2], W1
004D84  EB0000     CLR W0
004D86  508F80     SUB W1, W0, [W15]
004D88  3A0008     BRA NZ, 0x4D9A
324:                           entry = dirAddNew();
004D8A  02CC04     CALL dirAddNew
004D8C  000000     NOP
004D8E  980710     MOV W0, [W14+2]
325:                           if(entry == NULL) { continue; } // Check for creation failure
004D90  90009E     MOV [W14+2], W1
004D92  EB0000     CLR W0
004D94  508F80     SUB W1, W0, [W15]
004D96  3A000E     BRA NZ, 0x4DB4
004D98  37002F     BRA 0x4DF8
326:                       // Skip updates older than current info
327:                       } else if(update[i].timestamp < entry->timestamp){ continue; }
004D9A  78001E     MOV [W14], W0
004D9C  B9006E     MUL.SU W0, #14, W0
004D9E  780000     MOV W0, W0
004DA0  9000BE     MOV [W14+6], W1
004DA2  408000     ADD W1, W0, W0
004DA4  900140     MOV [W0+8], W2
004DA6  9001D0     MOV [W0+10], W3
004DA8  90001E     MOV [W14+2], W0
004DAA  9008B0     MOV [W0+22], W1
004DAC  900820     MOV [W0+20], W0
004DAE  510F80     SUB W2, W0, [W15]
004DB0  598F81     SUBB W3, W1, [W15]
004DB2  390021     BRA NC, 0x4DF6
004DF6  000000     NOP
328:                       entry->uuid = update[i].UUID;
004DB4  78001E     MOV [W14], W0
004DB6  B9006E     MUL.SU W0, #14, W0
004DB8  780000     MOV W0, W0
004DBA  9000BE     MOV [W14+6], W1
004DBC  408000     ADD W1, W0, W0
004DBE  BE0150     MOV.D [++W0], W2
004DC0  BE0040     MOV.D [--W0], W0
004DC2  90021E     MOV [W14+2], W4
004DC4  BE9A00     MOV.D W0, [W4++]
004DC6  BE9202     MOV.D W2, [W4--]
329:                       entry->address = update[i].address;
004DC8  78001E     MOV [W14], W0
004DCA  B9006E     MUL.SU W0, #14, W0
004DCC  780000     MOV W0, W0
004DCE  9000BE     MOV [W14+6], W1
004DD0  408000     ADD W1, W0, W0
004DD2  9000E0     MOV [W0+12], W1
004DD4  90001E     MOV [W14+2], W0
004DD6  980841     MOV W1, [W0+24]
330:                       entry->pan_id = netGetLocalPanID();
004DD8  02C31E     CALL netGetLocalPanID
004DDA  000000     NOP
004DDC  90009E     MOV [W14+2], W1
004DDE  9808D0     MOV W0, [W1+26]
331:                       entry->timestamp = update[i].timestamp;
004DE0  78001E     MOV [W14], W0
004DE2  B9006E     MUL.SU W0, #14, W0
004DE4  780000     MOV W0, W0
004DE6  9000BE     MOV [W14+6], W1
004DE8  408000     ADD W1, W0, W0
004DEA  9000D0     MOV [W0+10], W1
004DEC  900040     MOV [W0+8], W0
004DEE  90011E     MOV [W14+2], W2
004DF0  980920     MOV W0, [W2+20]
004DF2  980931     MOV W1, [W2+22]
004DF4  370001     BRA 0x4DF8
332:                   }
333:               
334:               }
004E02  FA8000     ULNK
004E04  060000     RETURN
335:               
336:               static void cmdDirDumpRequest(MacPacket packet) {
004E06  FA0016     LNK #0x16
004E08  BE9F88     MOV.D W8, [W15++]
004E0A  980F20     MOV W0, [W14+20]
337:               
338:                   Payload pld;
339:                   MacPacket response;
340:                   unsigned int *frame, req_addr, req_pan, i, size;
341:               
342:                   pld = macGetPayload(packet);
004E0E  90082E     MOV [W14+20], W0
004E10  0286E6     CALL macGetPayload
004E12  000000     NOP
004E14  980710     MOV W0, [W14+2]
343:                   frame = (unsigned int*) payGetData(pld);
004E16  90001E     MOV [W14+2], W0
004E18  02CAA0     CALL payGetData
004E1A  000000     NOP
004E1C  980720     MOV W0, [W14+4]
344:               
345:                   req_addr = frame[0];
004E1E  90002E     MOV [W14+4], W0
004E20  780090     MOV [W0], W1
004E22  980731     MOV W1, [W14+6]
346:                   req_pan = frame[1];
004E24  90002E     MOV [W14+4], W0
004E26  E88000     INC2 W0, W0
004E28  780090     MOV [W0], W1
004E2A  980741     MOV W1, [W14+8]
347:               
348:                   // Send all if both addresses 0
349:                   if(req_addr == 0 && req_pan == 0) {
004E2C  9000BE     MOV [W14+6], W1
004E2E  EB0000     CLR W0
004E30  508F80     SUB W1, W0, [W15]
004E32  3A004E     BRA NZ, 0x4ED0
004E34  9000CE     MOV [W14+8], W1
004E36  EB0000     CLR W0
004E38  508F80     SUB W1, W0, [W15]
004E3A  3A004A     BRA NZ, 0x4ED0
004E3C  78000F     MOV W15, W0
004E3E  780480     MOV W0, W9
004ECE  370032     BRA 0x4F34
350:               
351:                       size = dirGetSize();
004E40  02CC3C     CALL dirGetSize
004E42  000000     NOP
004E44  980750     MOV W0, [W14+10]
352:                       DirEntry entries[size];
004E46  90005E     MOV [W14+10], W0
004E48  780080     MOV W0, W1
004E4A  E90081     DEC W1, W1
004E4C  980761     MOV W1, [W14+12]
004E4E  400000     ADD W0, W0, W0
004E50  E80000     INC W0, W0
004E52  E80000     INC W0, W0
004E54  D10000     LSR W0, W0
004E56  400080     ADD W0, W0, W1
004E58  78000F     MOV W15, W0
004E5A  478781     ADD W15, W1, W15
004E5C  E80000     INC W0, W0
004E5E  D10000     LSR W0, W0
004E60  400000     ADD W0, W0, W0
004E62  980770     MOV W0, [W14+14]
353:                       dirGetEntries(entries); // Assume we get size # of entries
004E64  90007E     MOV [W14+14], W0
004E66  02CC48     CALL dirGetEntries
004E68  000000     NOP
354:               
355:                       i = 0;
004E6A  EB0000     CLR W0
004E6C  780F00     MOV W0, [W14]
356:                       while(i < size) {
004E6E  37002A     BRA 0x4EC4
004EC4  90005E     MOV [W14+10], W0
004EC6  78009E     MOV [W14], W1
004EC8  508F80     SUB W1, W0, [W15]
004ECA  39FFD2     BRA NC, 0x4E70
004ECC  780789     MOV W9, W15
357:                           
358:                           response = radioRequestPacket(sizeof(DirEntryStruct));
004E70  2001C0     MOV #0x1C, W0
004E72  0281B2     CALL radioRequestPacket
004E74  000000     NOP
004E76  980F00     MOV W0, [W14+16]
359:                           if(response == NULL) { continue; }
004E78  90088E     MOV [W14+16], W1
004E7A  EB0000     CLR W0
004E7C  508F80     SUB W1, W0, [W15]
004E7E  320021     BRA Z, 0x4EC2
004EC2  000000     NOP
360:                           macSetDestAddr(response, macGetSrcAddr(packet));
004E80  90082E     MOV [W14+20], W0
004E82  028674     CALL macGetSrcAddr
004E84  000000     NOP
004E86  780080     MOV W0, W1
004E88  90080E     MOV [W14+16], W0
004E8A  02863C     CALL macSetDestAddr
004E8C  000000     NOP
361:                           pld = macGetPayload(response);
004E8E  90080E     MOV [W14+16], W0
004E90  0286E6     CALL macGetPayload
004E92  000000     NOP
004E94  980710     MOV W0, [W14+2]
362:                           paySetType(pld, CMD_DIR_DUMP_RESPONSE);
004E96  B3C371     MOV #0x37, W1
004E98  90001E     MOV [W14+2], W0
004E9A  02CADE     CALL paySetType
004E9C  000000     NOP
363:                           paySetData(pld, sizeof(DirEntryStruct), (unsigned char*) entries[i]);
004E9E  9000FE     MOV [W14+14], W1
004EA0  78001E     MOV [W14], W0
004EA2  400000     ADD W0, W0, W0
004EA4  780061     MOV [W1+W0], W0
004EA6  780100     MOV W0, W2
004EA8  B3C1C1     MOV #0x1C, W1
004EAA  90001E     MOV [W14+2], W0
004EAC  02CAAE     CALL paySetData
004EAE  000000     NOP
364:                           while(!radioEnqueueTxPacket(response));
004EB0  000000     NOP
004EB2  90080E     MOV [W14+16], W0
004EB4  028128     CALL radioEnqueueTxPacket
004EB6  000000     NOP
004EB8  EB0080     CLR W1
004EBA  500F81     SUB W0, W1, [W15]
004EBC  32FFFA     BRA Z, 0x4EB2
365:                           i++;
004EBE  E80F1E     INC [W14], [W14]
004EC0  370001     BRA 0x4EC4
366:                       }
367:                               
368:                   } else {
369:               
370:                       DirEntry entry;
371:               
372:                       entry = dirQueryAddress(req_addr, req_pan);
004ED0  9000CE     MOV [W14+8], W1
004ED2  90003E     MOV [W14+6], W0
004ED4  02CBB8     CALL dirQueryAddress
004ED6  000000     NOP
004ED8  980F10     MOV W0, [W14+18]
373:                       if(entry == NULL) { return; }
004EDA  90089E     MOV [W14+18], W1
004EDC  EB0000     CLR W0
004EDE  508F80     SUB W1, W0, [W15]
004EE0  320028     BRA Z, 0x4F32
004EE2  370001     BRA 0x4EE6
004F32  000000     NOP
374:                       
375:                       while(1) {
376:                           
377:                           response = radioRequestPacket(sizeof(DirEntryStruct));
004EE6  2001C0     MOV #0x1C, W0
004EE8  0281B2     CALL radioRequestPacket
004EEA  000000     NOP
004EEC  980F00     MOV W0, [W14+16]
378:                           if(response == NULL) { continue; }
004EEE  90088E     MOV [W14+16], W1
004EF0  EB0000     CLR W0
004EF2  508F80     SUB W1, W0, [W15]
004EF4  32FFF7     BRA Z, 0x4EE4
379:                           macSetDestAddr(response, macGetSrcAddr(packet));
004EF6  90082E     MOV [W14+20], W0
004EF8  028674     CALL macGetSrcAddr
004EFA  000000     NOP
004EFC  780080     MOV W0, W1
004EFE  90080E     MOV [W14+16], W0
004F00  02863C     CALL macSetDestAddr
004F02  000000     NOP
380:                           pld = macGetPayload(response);
004F04  90080E     MOV [W14+16], W0
004F06  0286E6     CALL macGetPayload
004F08  000000     NOP
004F0A  980710     MOV W0, [W14+2]
381:                           paySetType(pld, CMD_DIR_DUMP_RESPONSE);
004F0C  B3C371     MOV #0x37, W1
004F0E  90001E     MOV [W14+2], W0
004F10  02CADE     CALL paySetType
004F12  000000     NOP
382:                           //paySetData(pld, sizeof(DirEntryStruct), (unsigned char*) &entry);
383:                           memcpy(payGetData(pld), entry, sizeof(DirEntryStruct));
004F14  90001E     MOV [W14+2], W0
004F16  02CAA0     CALL payGetData
004F18  000000     NOP
004F1A  2001C2     MOV #0x1C, W2
004F1C  90089E     MOV [W14+18], W1
004F1E  023582     CALL _memcpy
004F20  000000     NOP
384:                           while(!radioEnqueueTxPacket(response));
004F22  000000     NOP
004F24  90080E     MOV [W14+16], W0
004F26  028128     CALL radioEnqueueTxPacket
004F28  000000     NOP
004F2A  EB0080     CLR W1
004F2C  500F81     SUB W0, W1, [W15]
004F2E  32FFFA     BRA Z, 0x4F24
385:                           break;
004F30  370001     BRA 0x4F34
386:                       }
004EE4  000000     NOP
387:                   }
388:                   
389:               }
004E0C  78040F     MOV W15, W8
004F34  780788     MOV W8, W15
004F36  BE044F     MOV.D [--W15], W8
004F38  FA8000     ULNK
004F3A  060000     RETURN
390:               
391:               static void cmdDirDumpResponse(MacPacket packet) {
004F3C  FA0002     LNK #0x2
004F3E  780F00     MOV W0, [W14]
392:               
393:                   return;
394:               
395:               }
004F40  FA8000     ULNK
004F42  060000     RETURN
396:               
397:               static void cmdRequestClockUpdate(MacPacket packet) {
004F44  FA0002     LNK #0x2
004F46  780F00     MOV W0, [W14]
398:               
399:                   clksyncHandleRequest(packet);
004F48  78001E     MOV [W14], W0
004F4A  02A8B2     CALL clksyncHandleRequest
004F4C  000000     NOP
400:               
401:               }
004F4E  FA8000     ULNK
004F50  060000     RETURN
402:               
403:               static void cmdResponseClockUpdate(MacPacket packet) {
004F52  FA0002     LNK #0x2
004F54  780F00     MOV W0, [W14]
404:               
405:                   clksyncHandleResponse(packet);
004F56  78001E     MOV [W14], W0
004F58  02A976     CALL clksyncHandleResponse
004F5A  000000     NOP
406:               
407:               }
004F5C  FA8000     ULNK
004F5E  060000     RETURN
408:               
409:               // ====== Regulator and Control ===============================================
410:               
411:               // set up velocity profile structure  - assume 4 set points for now, generalize later
412:               static void cmdSetVelProfile(MacPacket packet){
004F60  FA0008     LNK #0x8
004F62  980730     MOV W0, [W14+6]
413:               
414:                   Payload pld;
415:                   unsigned char *frame;
416:                   hallVelCmd *params;
417:               
418:                   pld = macGetPayload(packet);
004F64  90003E     MOV [W14+6], W0
004F66  0286E6     CALL macGetPayload
004F68  000000     NOP
004F6A  780F00     MOV W0, [W14]
419:                   frame = payGetData(pld);
004F6C  78001E     MOV [W14], W0
004F6E  02CAA0     CALL payGetData
004F70  000000     NOP
004F72  980710     MOV W0, [W14+2]
420:                   params = (hallVelCmd*) frame;
004F74  90001E     MOV [W14+2], W0
004F76  980720     MOV W0, [W14+4]
421:                   hallSetVelProfile(&params[0]);
004F78  90002E     MOV [W14+4], W0
004F7A  0265A6     CALL hallSetVelProfile
004F7C  000000     NOP
422:               }
004F7E  FA8000     ULNK
004F80  060000     RETURN
423:               
424:               static void cmdHallPIDSetInput(MacPacket packet) {
004F82  FA0006     LNK #0x6
004F84  980720     MOV W0, [W14+4]
425:                   Payload pld;
426:                   unsigned int *frame;
427:               
428:                   pld = macGetPayload(packet);
004F86  90002E     MOV [W14+4], W0
004F88  0286E6     CALL macGetPayload
004F8A  000000     NOP
004F8C  780F00     MOV W0, [W14]
429:                   frame = (unsigned int*) payGetData(pld);
004F8E  78001E     MOV [W14], W0
004F90  02CAA0     CALL payGetData
004F92  000000     NOP
004F94  980710     MOV W0, [W14+2]
430:                   hallPIDSetInput(frame[0],frame[1]);
004F96  90001E     MOV [W14+2], W0
004F98  E88000     INC2 W0, W0
004F9A  780090     MOV [W0], W1
004F9C  90001E     MOV [W14+2], W0
004F9E  780010     MOV [W0], W0
004FA0  0265FE     CALL hallPIDSetInput
004FA2  000000     NOP
431:               }
004FA4  FA8000     ULNK
004FA6  060000     RETURN
432:               
433:               static void cmdSetHallGains(MacPacket packet) {
004FA8  FA0008     LNK #0x8
004FAA  980730     MOV W0, [W14+6]
434:                   Payload pld;
435:                   unsigned char *frame;
436:                   hallGains *params;
437:               
438:                   pld = macGetPayload(packet);
004FAC  90003E     MOV [W14+6], W0
004FAE  0286E6     CALL macGetPayload
004FB0  000000     NOP
004FB2  780F00     MOV W0, [W14]
439:                   frame = payGetData(pld);
004FB4  78001E     MOV [W14], W0
004FB6  02CAA0     CALL payGetData
004FB8  000000     NOP
004FBA  980710     MOV W0, [W14+2]
440:                   params = (hallGains*) frame;
004FBC  90001E     MOV [W14+2], W0
004FBE  980720     MOV W0, [W14+4]
441:                   hallSetGains(&params[0]);
004FC0  90002E     MOV [W14+4], W0
004FC2  02665E     CALL hallSetGains
004FC4  000000     NOP
442:               }
004FC6  FA8000     ULNK
004FC8  060000     RETURN
443:               
444:               static void cmdHallPIDOn(MacPacket packet) {
004FCA  FA0002     LNK #0x2
004FCC  780F00     MOV W0, [W14]
445:                   hallPIDOn();
004FCE  026684     CALL hallPIDOn
004FD0  000000     NOP
446:               }
004FD2  FA8000     ULNK
004FD4  060000     RETURN
447:               
448:               static void cmdStopClosed(MacPacket packet) {
004FD6  FA0006     LNK #0x6
004FD8  980720     MOV W0, [W14+4]
449:                   Payload pld = macGetPayload(packet);
004FDA  90002E     MOV [W14+4], W0
004FDC  0286E6     CALL macGetPayload
004FDE  000000     NOP
004FE0  780F00     MOV W0, [W14]
450:                   unsigned char flag = *(payGetData(pld));
004FE2  78001E     MOV [W14], W0
004FE4  02CAA0     CALL payGetData
004FE6  000000     NOP
004FE8  784090     MOV.B [W0], W1
004FEA  984721     MOV.B W1, [W14+2]
451:                   
452:                   rgltrStopWings(flag);
004FEC  90402E     MOV.B [W14+2], W0
004FEE  0247F2     CALL rgltrStopWings
004FF0  000000     NOP
453:               }
004FF2  FA8000     ULNK
004FF4  060000     RETURN
454:               
455:               static void cmdCalibCrank(MacPacket packet) {
004FF6  FA0002     LNK #0x2
004FF8  780F00     MOV W0, [W14]
456:                   calibCrank();
004FFA  02482E     CALL calibCrank
004FFC  000000     NOP
457:               }
004FFE  FA8000     ULNK
005000  060000     RETURN
458:               
459:               static void cmdRotateRefGlobal(MacPacket packet) {
005002  FA0004     LNK #0x4
005004  980710     MOV W0, [W14+2]
460:                   
461:                   Quaternion *rot = payGetData(macGetPayload(packet));
005006  90001E     MOV [W14+2], W0
005008  0286E6     CALL macGetPayload
00500A  000000     NOP
00500C  02CAA0     CALL payGetData
00500E  000000     NOP
005010  780F00     MOV W0, [W14]
462:                   
463:                   rateApplyGlobalRotation(rot);
005012  78001E     MOV [W14], W0
005014  02C112     CALL rateApplyGlobalRotation
005016  000000     NOP
464:                   
465:               }
005018  FA8000     ULNK
00501A  060000     RETURN
466:               
467:               static void cmdRotateRefLocal(MacPacket packet) {
00501C  FA0004     LNK #0x4
00501E  980710     MOV W0, [W14+2]
468:                   
469:                   Quaternion *rot = payGetData(macGetPayload(packet));
005020  90001E     MOV [W14+2], W0
005022  0286E6     CALL macGetPayload
005024  000000     NOP
005026  02CAA0     CALL payGetData
005028  000000     NOP
00502A  780F00     MOV W0, [W14]
470:                       
471:                   rateApplyLocalRotation(rot);
00502C  78001E     MOV [W14], W0
00502E  02C136     CALL rateApplyLocalRotation
005030  000000     NOP
472:               
473:               }
005032  FA8000     ULNK
005034  060000     RETURN
474:               
475:               static void cmdSetRegulatorOffsets(MacPacket packet) {
005036  FA0004     LNK #0x4
005038  980710     MOV W0, [W14+2]
476:               
477:                   float* frame = payGetData(macGetPayload(packet)); 
00503A  90001E     MOV [W14+2], W0
00503C  0286E6     CALL macGetPayload
00503E  000000     NOP
005040  02CAA0     CALL payGetData
005042  000000     NOP
005044  780F00     MOV W0, [W14]
478:                   rgltrSetOffsets(frame);
005046  78001E     MOV [W14], W0
005048  024122     CALL rgltrSetOffsets
00504A  000000     NOP
479:               
480:               }
00504C  FA8000     ULNK
00504E  060000     RETURN
481:               
482:               static void cmdSetRegulatorMode(MacPacket packet) {
005050  FA0004     LNK #0x4
005052  980710     MOV W0, [W14+2]
483:                       
484:                   unsigned char* frame = payGetData(macGetPayload(packet));       
005054  90001E     MOV [W14+2], W0
005056  0286E6     CALL macGetPayload
005058  000000     NOP
00505A  02CAA0     CALL payGetData
00505C  000000     NOP
00505E  780F00     MOV W0, [W14]
485:                   rgltrSetMode(frame[0]);
005060  78001E     MOV [W14], W0
005062  784010     MOV.B [W0], W0
005064  02400A     CALL rgltrSetMode
005066  000000     NOP
486:                   
487:               }
005068  FA8000     ULNK
00506A  060000     RETURN
488:               
489:               static void cmdSetRegulatorRef(MacPacket packet) {
00506C  FA0006     LNK #0x6
00506E  980720     MOV W0, [W14+4]
490:               
491:                   Payload pld = macGetPayload(packet);
005070  90002E     MOV [W14+4], W0
005072  0286E6     CALL macGetPayload
005074  000000     NOP
005076  780F00     MOV W0, [W14]
492:                   Quaternion *ref = (Quaternion*)payGetData(pld);
005078  78001E     MOV [W14], W0
00507A  02CAA0     CALL payGetData
00507C  000000     NOP
00507E  980710     MOV W0, [W14+2]
493:                   
494:                   rgltrSetQuatRef(ref);
005080  90001E     MOV [W14+2], W0
005082  0242BC     CALL rgltrSetQuatRef
005084  000000     NOP
495:                   
496:               }
005086  FA8000     ULNK
005088  060000     RETURN
497:               
498:               static void cmdSetRegulatorTempRotation(MacPacket packet) {
00508A  FA0004     LNK #0x4
00508C  980710     MOV W0, [W14+2]
499:               
500:                   Quaternion *rot = payGetData(macGetPayload(packet));
00508E  90001E     MOV [W14+2], W0
005090  0286E6     CALL macGetPayload
005092  000000     NOP
005094  02CAA0     CALL payGetData
005096  000000     NOP
005098  780F00     MOV W0, [W14]
501:               
502:                   rgltrSetTempRot(rot);
00509A  78001E     MOV [W14], W0
00509C  0242D8     CALL rgltrSetTempRot
00509E  000000     NOP
503:               
504:               }
0050A0  FA8000     ULNK
0050A2  060000     RETURN
505:               
506:               static void cmdSetRegulatorPid(MacPacket packet) {
0050A4  FA0008     LNK #0x8
0050A6  980730     MOV W0, [W14+6]
507:                       
508:                   Payload pld;
509:                   unsigned char *frame;
510:                   PidParamsStruct *params;
511:                   
512:                   pld = macGetPayload(packet);
0050A8  90003E     MOV [W14+6], W0
0050AA  0286E6     CALL macGetPayload
0050AC  000000     NOP
0050AE  780F00     MOV W0, [W14]
513:                   frame = payGetData(pld);
0050B0  78001E     MOV [W14], W0
0050B2  02CAA0     CALL payGetData
0050B4  000000     NOP
0050B6  980710     MOV W0, [W14+2]
514:                   params = (PidParamsStruct*) frame;
0050B8  90001E     MOV [W14+2], W0
0050BA  980720     MOV W0, [W14+4]
515:                   
516:                   rgltrSetYawPid(&params[0]);
0050BC  90002E     MOV [W14+4], W0
0050BE  024152     CALL rgltrSetYawPid
0050C0  000000     NOP
517:                   rgltrSetPitchPid(&params[1]);
0050C2  90002E     MOV [W14+4], W0
0050C4  40007C     ADD W0, #0x1C, W0
0050C6  0241B2     CALL rgltrSetPitchPid
0050C8  000000     NOP
518:                   rgltrSetRollPid(&params[2]);
0050CA  90002E     MOV [W14+4], W0
0050CC  B00380     ADD #0x38, W0
0050CE  024212     CALL rgltrSetRollPid
0050D0  000000     NOP
519:               
520:               }
0050D2  FA8000     ULNK
0050D4  060000     RETURN
521:               
522:               static void cmdSetRegulatorRateFilter(MacPacket packet) {
0050D6  FA000C     LNK #0xC
0050D8  980750     MOV W0, [W14+10]
523:                   
524:                   Payload pld;
525:                   unsigned int *frame;
526:                   RateFilterParamsStruct params;
527:               
528:                   pld = macGetPayload(packet);
0050DA  90005E     MOV [W14+10], W0
0050DC  0286E6     CALL macGetPayload
0050DE  000000     NOP
0050E0  780F00     MOV W0, [W14]
529:                   frame = (unsigned int*) payGetData(pld);
0050E2  78001E     MOV [W14], W0
0050E4  02CAA0     CALL payGetData
0050E6  000000     NOP
0050E8  980710     MOV W0, [W14+2]
530:               
531:                   params.order = frame[0];
0050EA  90001E     MOV [W14+2], W0
0050EC  780010     MOV [W0], W0
0050EE  784000     MOV.B W0, W0
0050F0  4700E4     ADD W14, #0x4, W1
0050F2  784880     MOV.B W0, [W1]
532:                   params.type = frame[1];
0050F4  90001E     MOV [W14+2], W0
0050F6  E88000     INC2 W0, W0
0050F8  780010     MOV [W0], W0
0050FA  784000     MOV.B W0, W0
0050FC  4700E4     ADD W14, #0x4, W1
0050FE  984090     MOV.B W0, [W1+1]
533:                   params.xcoeffs = frame + 2; // Order + 1 floats per array;
005100  90001E     MOV [W14+2], W0
005102  4000E4     ADD W0, #0x4, W1
005104  470064     ADD W14, #0x4, W0
005106  980011     MOV W1, [W0+2]
534:                   params.ycoeffs = params.xcoeffs + (params.order + 1); // Typed pointer magic
005108  470064     ADD W14, #0x4, W0
00510A  900090     MOV [W0+2], W1
00510C  470064     ADD W14, #0x4, W0
00510E  784010     MOV.B [W0], W0
005110  FB8000     ZE W0, W0
005112  E80000     INC W0, W0
005114  DD0042     SL W0, #2, W0
005116  408080     ADD W1, W0, W1
005118  470064     ADD W14, #0x4, W0
00511A  980021     MOV W1, [W0+4]
535:                   
536:                   rgltrSetYawRateFilter(&params);
00511C  470064     ADD W14, #0x4, W0
00511E  024098     CALL rgltrSetYawRateFilter
005120  000000     NOP
537:                   rgltrSetPitchRateFilter(&params);
005122  470064     ADD W14, #0x4, W0
005124  0240C6     CALL rgltrSetPitchRateFilter
005126  000000     NOP
538:                   rgltrSetRollRateFilter(&params);
005128  470064     ADD W14, #0x4, W0
00512A  0240F4     CALL rgltrSetRollRateFilter
00512C  000000     NOP
539:                   
540:               }
00512E  FA8000     ULNK
005130  060000     RETURN
541:                 
542:               static void cmdSetRemoteControlValues(MacPacket packet) {
005132  FA0006     LNK #0x6
005134  980720     MOV W0, [W14+4]
543:                   
544:                   Payload pld = macGetPayload(packet);
005136  90002E     MOV [W14+4], W0
005138  0286E6     CALL macGetPayload
00513A  000000     NOP
00513C  780F00     MOV W0, [W14]
545:                   float* frame = (float *)payGetData(pld);
00513E  78001E     MOV [W14], W0
005140  02CAA0     CALL payGetData
005142  000000     NOP
005144  980710     MOV W0, [W14+2]
546:                       
547:                   // parameters are: thrust, steer, and elevator
548:                   rgltrSetRemoteControlValues(frame[0], frame[1], frame[2]);
005146  90001E     MOV [W14+2], W0
005148  400068     ADD W0, #0x8, W0
00514A  BE0110     MOV.D [W0], W2
00514C  90001E     MOV [W14+2], W0
00514E  400064     ADD W0, #0x4, W0
005150  BE0010     MOV.D [W0], W0
005152  90021E     MOV [W14+2], W4
005154  BE0314     MOV.D [W4], W6
005156  BE0202     MOV.D W2, W4
005158  BE0100     MOV.D W0, W2
00515A  BE0006     MOV.D W6, W0
00515C  0242FA     CALL rgltrSetRemoteControlValues
00515E  000000     NOP
549:               
550:               }
005160  FA8000     ULNK
005162  060000     RETURN
551:               
552:               static void cmdSetRateMode(MacPacket packet) {
005164  FA0006     LNK #0x6
005166  980720     MOV W0, [W14+4]
553:               
554:                   Payload pld = macGetPayload(packet);
005168  90002E     MOV [W14+4], W0
00516A  0286E6     CALL macGetPayload
00516C  000000     NOP
00516E  780F00     MOV W0, [W14]
555:                   unsigned char flag = *(payGetData(pld));
005170  78001E     MOV [W14], W0
005172  02CAA0     CALL payGetData
005174  000000     NOP
005176  784090     MOV.B [W0], W1
005178  984721     MOV.B W1, [W14+2]
556:               
557:                   if(flag == 0) {
00517A  9040AE     MOV.B [W14+2], W1
00517C  EB4000     CLR.B W0
00517E  50CF80     SUB.B W1, W0, [W15]
005180  3A0003     BRA NZ, 0x5188
558:                       rateDisable();
005182  02C106     CALL rateDisable
005184  000000     NOP
005186  370006     BRA 0x5194
559:                   } else if(flag == 1) {
005188  9040AE     MOV.B [W14+2], W1
00518A  B3C010     MOV #0x1, W0
00518C  50CF80     SUB.B W1, W0, [W15]
00518E  3A0002     BRA NZ, 0x5194
560:                       rateEnable();
005190  02C0FA     CALL rateEnable
005192  000000     NOP
561:                   }
562:               
563:               }
005194  FA8000     ULNK
005196  060000     RETURN
564:               
565:               static void cmdSetRateSlew(MacPacket packet) {
005198  FA0006     LNK #0x6
00519A  980720     MOV W0, [W14+4]
566:               
567:                   Payload pld = macGetPayload(packet);
00519C  90002E     MOV [W14+4], W0
00519E  0286E6     CALL macGetPayload
0051A0  000000     NOP
0051A2  780F00     MOV W0, [W14]
568:                   Rate slew = (Rate)payGetData(pld);
0051A4  78001E     MOV [W14], W0
0051A6  02CAA0     CALL payGetData
0051A8  000000     NOP
0051AA  980710     MOV W0, [W14+2]
569:                   rateSetGlobalSlew(slew);
0051AC  90001E     MOV [W14+2], W0
0051AE  02C0B2     CALL rateSetGlobalSlew
0051B0  000000     NOP
570:               
571:               }
0051B2  FA8000     ULNK
0051B4  060000     RETURN
572:               
573:               // ====== Telemetry and Sensors ===============================================
574:               static void cmdSetLogging(MacPacket packet) {
0051B6  FA0008     LNK #0x8
0051B8  980730     MOV W0, [W14+6]
575:               
576:                   Payload pld;    
577:                   unsigned char *frame, flag;
578:               
579:                   pld = macGetPayload(packet);
0051BA  90003E     MOV [W14+6], W0
0051BC  0286E6     CALL macGetPayload
0051BE  000000     NOP
0051C0  780F00     MOV W0, [W14]
580:                   frame = payGetData(pld);
0051C2  78001E     MOV [W14], W0
0051C4  02CAA0     CALL payGetData
0051C6  000000     NOP
0051C8  980710     MOV W0, [W14+2]
581:                   flag = frame[0];
0051CA  90001E     MOV [W14+2], W0
0051CC  784090     MOV.B [W0], W1
0051CE  984741     MOV.B W1, [W14+4]
582:               
583:                   if(flag) {
0051D0  9040CE     MOV.B [W14+4], W1
0051D2  EB4000     CLR.B W0
0051D4  50CF80     SUB.B W1, W0, [W15]
0051D6  320003     BRA Z, 0x51DE
584:                       telemStartLogging();
0051D8  02B5D8     CALL telemStartLogging
0051DA  000000     NOP
0051DC  370002     BRA 0x51E2
585:                   } else {
586:                       telemStopLogging();
0051DE  02B60E     CALL telemStopLogging
0051E0  000000     NOP
587:                   }
588:               
589:               }
0051E2  FA8000     ULNK
0051E4  060000     RETURN
590:               
591:               static void cmdGetMemContents(MacPacket packet) {
0051E6  FA0024     LNK #0x24
0051E8  981710     MOV W0, [W14+34]
592:               
593:                   Payload pld;
594:                   MacPacket data_packet;
595:                   unsigned char *frame;
596:                   DfmemGeometryStruct geo;
597:               
598:                   pld = macGetPayload(packet);
0051EA  90101E     MOV [W14+34], W0
0051EC  0286E6     CALL macGetPayload
0051EE  000000     NOP
0051F0  980740     MOV W0, [W14+8]
599:                   frame = payGetData(pld);
0051F2  90004E     MOV [W14+8], W0
0051F4  02CAA0     CALL payGetData
0051F6  000000     NOP
0051F8  980750     MOV W0, [W14+10]
600:                   dfmemGetGeometryParams(&geo);
0051FA  470072     ADD W14, #0x12, W0
0051FC  027EE2     CALL dfmemGetGeometryParams
0051FE  000000     NOP
601:               
602:                   unsigned int start_page = frame[0] + (frame[1] << 8);
005200  90005E     MOV [W14+10], W0
005202  784010     MOV.B [W0], W0
005204  FB8080     ZE W0, W1
005206  90005E     MOV [W14+10], W0
005208  E80000     INC W0, W0
00520A  784010     MOV.B [W0], W0
00520C  FB8000     ZE W0, W0
00520E  DD0048     SL W0, #8, W0
005210  408000     ADD W1, W0, W0
005212  980760     MOV W0, [W14+12]
603:                   unsigned int end_page = frame[2] + (frame[3] << 8);
005214  90005E     MOV [W14+10], W0
005216  E88000     INC2 W0, W0
005218  784010     MOV.B [W0], W0
00521A  FB8080     ZE W0, W1
00521C  90005E     MOV [W14+10], W0
00521E  400063     ADD W0, #0x3, W0
005220  784010     MOV.B [W0], W0
005222  FB8000     ZE W0, W0
005224  DD0048     SL W0, #8, W0
005226  408000     ADD W1, W0, W0
005228  980770     MOV W0, [W14+14]
604:                   unsigned int tx_data_size = frame[4] + (frame[5] << 8);
00522A  90005E     MOV [W14+10], W0
00522C  400064     ADD W0, #0x4, W0
00522E  784010     MOV.B [W0], W0
005230  FB8080     ZE W0, W1
005232  90005E     MOV [W14+10], W0
005234  400065     ADD W0, #0x5, W0
005236  784010     MOV.B [W0], W0
005238  FB8000     ZE W0, W0
00523A  DD0048     SL W0, #8, W0
00523C  408000     ADD W1, W0, W0
00523E  980F00     MOV W0, [W14+16]
605:                   unsigned int page, j;
606:                   unsigned char count = 0;
005240  EB4000     CLR.B W0
005242  984760     MOV.B W0, [W14+6]
607:                   
608:                   // Send back memory contents
609:                   for (page = start_page; page < end_page; ++page) {
005244  90006E     MOV [W14+12], W0
005246  980710     MOV W0, [W14+2]
005248  370047     BRA 0x52D8
0052D2  90001E     MOV [W14+2], W0
0052D4  E80000     INC W0, W0
0052D6  980710     MOV W0, [W14+2]
0052D8  90009E     MOV [W14+2], W1
0052DA  90007E     MOV [W14+14], W0
0052DC  508F80     SUB W1, W0, [W15]
0052DE  39FFB5     BRA NC, 0x524A
610:                       j = 0;
00524A  EB0000     CLR W0
00524C  980720     MOV W0, [W14+4]
611:                       while (j + tx_data_size <= geo.bytes_per_page) {
00524E  37003A     BRA 0x52C4
0052C4  9000AE     MOV [W14+4], W1
0052C6  90080E     MOV [W14+16], W0
0052C8  408080     ADD W1, W0, W1
0052CA  470072     ADD W14, #0x12, W0
0052CC  900040     MOV [W0+8], W0
0052CE  508F80     SUB W1, W0, [W15]
0052D0  36FFBF     BRA LEU, 0x5250
612:                           data_packet = NULL;
005250  EB0000     CLR W0
005252  780F00     MOV W0, [W14]
613:                           while(data_packet == NULL) {
005254  370004     BRA 0x525E
00525E  78009E     MOV [W14], W1
005260  EB0000     CLR W0
005262  508F80     SUB W1, W0, [W15]
005264  32FFF8     BRA Z, 0x5256
614:                               data_packet = radioRequestPacket(tx_data_size);
005256  90080E     MOV [W14+16], W0
005258  0281B2     CALL radioRequestPacket
00525A  000000     NOP
00525C  780F00     MOV W0, [W14]
615:                           }
616:               
617:                           macSetDestAddr(data_packet, 0x1020);
005266  210201     MOV #0x1020, W1
005268  78001E     MOV [W14], W0
00526A  02863C     CALL macSetDestAddr
00526C  000000     NOP
618:                           macSetDestPan(data_packet, 0x1005);
00526E  210051     MOV #0x1005, W1
005270  78001E     MOV [W14], W0
005272  02864C     CALL macSetDestPan
005274  000000     NOP
619:                           pld = macGetPayload(data_packet);
005276  78001E     MOV [W14], W0
005278  0286E6     CALL macGetPayload
00527A  000000     NOP
00527C  980740     MOV W0, [W14+8]
620:               
621:                           dfmemRead(page, j, tx_data_size, payGetData(pld));
00527E  90004E     MOV [W14+8], W0
005280  02CAA0     CALL payGetData
005282  000000     NOP
005284  780180     MOV W0, W3
005286  90090E     MOV [W14+16], W2
005288  9000AE     MOV [W14+4], W1
00528A  90001E     MOV [W14+2], W0
00528C  027AF0     CALL dfmemRead
00528E  000000     NOP
622:               
623:                           paySetStatus(pld, count++);
005290  90406E     MOV.B [W14+6], W0
005292  9040EE     MOV.B [W14+6], W1
005294  E84081     INC.B W1, W1
005296  984761     MOV.B W1, [W14+6]
005298  784080     MOV.B W0, W1
00529A  90004E     MOV [W14+8], W0
00529C  02CB02     CALL paySetStatus
00529E  000000     NOP
624:                           paySetType(pld, CMD_RESPONSE_TELEMETRY);
0052A0  B3C2E1     MOV #0x2E, W1
0052A2  90004E     MOV [W14+8], W0
0052A4  02CADE     CALL paySetType
0052A6  000000     NOP
625:                           while(!radioEnqueueTxPacket(data_packet));
0052A8  000000     NOP
0052AA  78001E     MOV [W14], W0
0052AC  028128     CALL radioEnqueueTxPacket
0052AE  000000     NOP
0052B0  EB0080     CLR W1
0052B2  500F81     SUB W0, W1, [W15]
0052B4  32FFFA     BRA Z, 0x52AA
626:                           j += tx_data_size;
0052B6  9000AE     MOV [W14+4], W1
0052B8  90080E     MOV [W14+16], W0
0052BA  408000     ADD W1, W0, W0
0052BC  980720     MOV W0, [W14+4]
627:                           delay_ms(20);
0052BE  200140     MOV #0x14, W0
0052C0  02E270     CALL msELAPSED
0052C2  000000     NOP
628:                       }
629:               
630:                   }
631:               
632:                   // Signal end of transfer    
633:                   LED_GREEN = 0; LED_RED = 0; LED_ORANGE = 0;
0052E0  A9A2CB     BCLR 0x2CB, #5
0052E2  A982CB     BCLR 0x2CB, #4
0052E4  A9C2CB     BCLR 0x2CB, #6
634:                   
635:               }
0052E6  FA8000     ULNK
0052E8  060000     RETURN
636:               
637:               static void cmdRunGyroCalib(MacPacket packet) {
0052EA  FA0008     LNK #0x8
0052EC  980730     MOV W0, [W14+6]
638:                   
639:                   Payload pld = macGetPayload(packet);
0052EE  90003E     MOV [W14+6], W0
0052F0  0286E6     CALL macGetPayload
0052F2  000000     NOP
0052F4  780F00     MOV W0, [W14]
640:                   unsigned int* frame = (unsigned int*) payGetData(pld);
0052F6  78001E     MOV [W14], W0
0052F8  02CAA0     CALL payGetData
0052FA  000000     NOP
0052FC  980710     MOV W0, [W14+2]
641:                   
642:                   unsigned int count = frame[0];
0052FE  90001E     MOV [W14+2], W0
005300  780090     MOV [W0], W1
005302  980721     MOV W1, [W14+4]
643:               
644:                   radioSetWatchdogState(0);
005304  EB4000     CLR.B W0
005306  0280FE     CALL radioSetWatchdogState
005308  000000     NOP
645:                   gyroRunCalib(count);
00530A  90002E     MOV [W14+4], W0
00530C  0294A6     CALL gyroRunCalib
00530E  000000     NOP
646:                   radioSetWatchdogState(1);
005310  B3C010     MOV #0x1, W0
005312  0280FE     CALL radioSetWatchdogState
005314  000000     NOP
647:               
648:               }
005316  FA8000     ULNK
005318  060000     RETURN
649:               
650:               static void cmdGetGyroCalibParam(MacPacket packet) {
00531A  FA0008     LNK #0x8
00531C  980730     MOV W0, [W14+6]
651:                       
652:                   //Payload pld = macGetPayload(packet);
653:                   //unsigned char status = payGetStatus(pld);
654:                   //unsigned char* frame = payGetData(pld);
655:                   unsigned int srcAddr = macGetSrcAddr(packet);
00531E  90003E     MOV [W14+6], W0
005320  028674     CALL macGetSrcAddr
005322  000000     NOP
005324  780F00     MOV W0, [W14]
656:                   
657:                   Payload pld;
658:                   MacPacket response;
659:                   
660:                   response = radioRequestPacket(12);
005326  2000C0     MOV #0xC, W0
005328  0281B2     CALL radioRequestPacket
00532A  000000     NOP
00532C  980710     MOV W0, [W14+2]
661:                   if(response == NULL) { return; }
00532E  90009E     MOV [W14+2], W1
005330  EB0000     CLR W0
005332  508F80     SUB W1, W0, [W15]
005334  32001E     BRA Z, 0x5372
005372  000000     NOP
662:                   macSetDestAddr(response, srcAddr);
005336  78009E     MOV [W14], W1
005338  90001E     MOV [W14+2], W0
00533A  02863C     CALL macSetDestAddr
00533C  000000     NOP
663:                   pld = response->payload;
00533E  90001E     MOV [W14+2], W0
005340  9000E0     MOV [W0+12], W1
005342  980721     MOV W1, [W14+4]
664:                   paySetData(pld, 12, gyroGetCalibParam());
005344  029482     CALL gyroGetCalibParam
005346  000000     NOP
005348  780100     MOV W0, W2
00534A  B3C0C1     MOV #0xC, W1
00534C  90002E     MOV [W14+4], W0
00534E  02CAAE     CALL paySetData
005350  000000     NOP
665:                   paySetStatus(pld, 0);
005352  EB4080     CLR.B W1
005354  90002E     MOV [W14+4], W0
005356  02CB02     CALL paySetStatus
005358  000000     NOP
666:                   paySetType(pld, CMD_GET_GYRO_CALIB_PARAM);
00535A  B3C2B1     MOV #0x2B, W1
00535C  90002E     MOV [W14+4], W0
00535E  02CADE     CALL paySetType
005360  000000     NOP
667:                   while(!radioEnqueueTxPacket(response));
005362  000000     NOP
005364  90001E     MOV [W14+2], W0
005366  028128     CALL radioEnqueueTxPacket
005368  000000     NOP
00536A  EB0080     CLR W1
00536C  500F81     SUB W0, W1, [W15]
00536E  32FFFA     BRA Z, 0x5364
005370  370001     BRA 0x5374
668:               }
005374  FA8000     ULNK
005376  060000     RETURN
669:               
670:               static void cmdRecordTelemetry(MacPacket packet) {
005378  FA0002     LNK #0x2
00537A  780F00     MOV W0, [W14]
671:               
672:                   
673:               
674:               }
00537C  FA8000     ULNK
00537E  060000     RETURN
675:               
676:               static void cmdRequestTelemetry(MacPacket packet) {
005380  FA0002     LNK #0x2
005382  780F00     MOV W0, [W14]
677:               
678:                   telemSendB(macGetSrcAddr(packet));
005384  78001E     MOV [W14], W0
005386  028674     CALL macGetSrcAddr
005388  000000     NOP
00538A  02B748     CALL telemSendB
00538C  000000     NOP
679:               
680:               }
00538E  FA8000     ULNK
005390  060000     RETURN
681:               
682:               static void cmdResponseTelemetry(MacPacket packet) {
005392  FA0002     LNK #0x2
005394  780F00     MOV W0, [W14]
683:               
684:                   return; // Do nothing
685:                   
686:               }
005396  FA8000     ULNK
005398  060000     RETURN
687:               
688:               static void cmdSetEstimateRunning(MacPacket packet) {
00539A  FA0006     LNK #0x6
00539C  980720     MOV W0, [W14+4]
689:                       
690:                   Payload pld = macGetPayload(packet);
00539E  90002E     MOV [W14+4], W0
0053A0  0286E6     CALL macGetPayload
0053A2  000000     NOP
0053A4  780F00     MOV W0, [W14]
691:                   //unsigned char status = payGetStatus(pld);
692:                   unsigned char* frame = payGetData(pld);
0053A6  78001E     MOV [W14], W0
0053A8  02CAA0     CALL payGetData
0053AA  000000     NOP
0053AC  980710     MOV W0, [W14+2]
693:                   
694:                   
695:                   if (frame[0] == 0) {
0053AE  90001E     MOV [W14+2], W0
0053B0  784090     MOV.B [W0], W1
0053B2  EB4000     CLR.B W0
0053B4  50CF80     SUB.B W1, W0, [W15]
0053B6  3A0004     BRA NZ, 0x53C0
696:                       attSetRunning(0);
0053B8  EB4000     CLR.B W0
0053BA  028B0C     CALL attSetRunning
0053BC  000000     NOP
0053BE  370003     BRA 0x53C6
697:                   } else {
698:                       attSetRunning(1);
0053C0  B3C010     MOV #0x1, W0
0053C2  028B0C     CALL attSetRunning
0053C4  000000     NOP
699:                   }
700:               }
0053C6  FA8000     ULNK
0053C8  060000     RETURN
701:               
702:               static void cmdToggleStreaming(MacPacket packet) {
0053CA  FA0002     LNK #0x2
0053CC  780F00     MOV W0, [W14]
703:                   
704:                   telemToggleStreaming(macGetSrcAddr(packet));
0053CE  78001E     MOV [W14], W0
0053D0  028674     CALL macGetSrcAddr
0053D2  000000     NOP
0053D4  02B5B4     CALL telemToggleStreaming
0053D6  000000     NOP
705:                   
706:               }
0053D8  FA8000     ULNK
0053DA  060000     RETURN
707:               
708:               // ====== Camera and Vision ===================================================
709:               // TODO: Use a struct to simplify the packetization
710:               static void cmdRequestRawFrame(MacPacket packet) {
0053DC  FA00BC     LNK #0xBC
0053DE  989F50     MOV W0, [W14+186]
711:                   
712:                   unsigned int srcAddr, srcPan, height, width, i, temp;
713:                   unsigned int sent, to_send, block_size = 75;
0053E0  2004B0     MOV #0x4B, W0
0053E2  980740     MOV W0, [W14+8]
714:                   MacPacket response;
715:                   Payload pld;
716:                   CamFrame frame;
717:                   CamRow *row;
718:                   CvResultStruct info;
719:               
720:                   srcAddr = macGetSrcAddr(packet);
0053E4  90985E     MOV [W14+186], W0
0053E6  028674     CALL macGetSrcAddr
0053E8  000000     NOP
0053EA  980750     MOV W0, [W14+10]
721:                   srcPan = macGetSrcPan(packet);    
0053EC  90985E     MOV [W14+186], W0
0053EE  028680     CALL macGetSrcPan
0053F0  000000     NOP
0053F2  980760     MOV W0, [W14+12]
722:               
723:                   frame = NULL;
0053F4  EB0000     CLR W0
0053F6  980730     MOV W0, [W14+6]
724:                   while(frame == NULL) {
0053F8  370003     BRA 0x5400
005400  9000BE     MOV [W14+6], W1
005402  EB0000     CLR W0
005404  508F80     SUB W1, W0, [W15]
005406  32FFF9     BRA Z, 0x53FA
725:                       frame = camGetFrame();
0053FA  029ACE     CALL camGetFrame
0053FC  000000     NOP
0053FE  980730     MOV W0, [W14+6]
726:                   }           
727:               
728:                   cvProcessFrame(frame, &info);    
005408  47007A     ADD W14, #0x1A, W0
00540A  780080     MOV W0, W1
00540C  90003E     MOV [W14+6], W0
00540E  02584A     CALL cvProcessFrame
005410  000000     NOP
729:               
730:                   height = DS_IMAGE_ROWS;
005412  2003C0     MOV #0x3C, W0
005414  980770     MOV W0, [W14+14]
731:                   width = DS_IMAGE_COLS;
005416  2004B0     MOV #0x4B, W0
005418  980F00     MOV W0, [W14+16]
732:               
733:                   for(i = 0; i < height; i++) {        
00541A  EB0000     CLR W0
00541C  780F00     MOV W0, [W14]
00541E  37006A     BRA 0x54F4
0054F2  E80F1E     INC [W14], [W14]
0054F4  90007E     MOV [W14+14], W0
0054F6  78009E     MOV [W14], W1
0054F8  508F80     SUB W1, W0, [W15]
0054FA  39FF92     BRA NC, 0x5420
734:                       row = &(frame->pixels[i]);
005420  90003E     MOV [W14+6], W0
005422  400166     ADD W0, #0x6, W2
005424  78009E     MOV [W14], W1
005426  2004B0     MOV #0x4B, W0
005428  B98800     MUL.SS W1, W0, W0
00542A  780000     MOV W0, W0
00542C  410000     ADD W2, W0, W0
00542E  980F10     MOV W0, [W14+18]
735:                       to_send = width;
005430  90080E     MOV [W14+16], W0
005432  980720     MOV W0, [W14+4]
736:                       while(to_send > 0) {            
005434  37005A     BRA 0x54EA
0054EA  9000AE     MOV [W14+4], W1
0054EC  EB0000     CLR W0
0054EE  508F80     SUB W1, W0, [W15]
0054F0  3AFFA2     BRA NZ, 0x5436
737:                           response = radioRequestPacket(block_size + 6);
005436  90004E     MOV [W14+8], W0
005438  400066     ADD W0, #0x6, W0
00543A  0281B2     CALL radioRequestPacket
00543C  000000     NOP
00543E  980F20     MOV W0, [W14+20]
738:                           if(response == NULL) { continue; }
005440  9008AE     MOV [W14+20], W1
005442  EB0000     CLR W0
005444  508F80     SUB W1, W0, [W15]
005446  320050     BRA Z, 0x54E8
0054E8  000000     NOP
739:                           pld = macGetPayload(response);
005448  90082E     MOV [W14+20], W0
00544A  0286E6     CALL macGetPayload
00544C  000000     NOP
00544E  980F30     MOV W0, [W14+22]
740:                           paySetType(pld, CMD_RAW_FRAME_RESPONSE);
005450  B3C411     MOV #0x41, W1
005452  90083E     MOV [W14+22], W0
005454  02CADE     CALL paySetType
005456  000000     NOP
741:                           paySetStatus(pld, 0);
005458  EB4080     CLR.B W1
00545A  90083E     MOV [W14+22], W0
00545C  02CB02     CALL paySetStatus
00545E  000000     NOP
742:                           macSetDestAddr(response, srcAddr);
005460  9000DE     MOV [W14+10], W1
005462  90082E     MOV [W14+20], W0
005464  02863C     CALL macSetDestAddr
005466  000000     NOP
743:                           macSetDestPan(response, srcPan);
005468  9000EE     MOV [W14+12], W1
00546A  90082E     MOV [W14+20], W0
00546C  02864C     CALL macSetDestPan
00546E  000000     NOP
744:                           temp = frame->frame_num;
005470  90003E     MOV [W14+6], W0
005472  900020     MOV [W0+4], W0
005474  980F40     MOV W0, [W14+24]
745:                           paySetData(pld, 2, (unsigned char *)&temp);
005476  470078     ADD W14, #0x18, W0
005478  780100     MOV W0, W2
00547A  B3C021     MOV #0x2, W1
00547C  90083E     MOV [W14+22], W0
00547E  02CAAE     CALL paySetData
005480  000000     NOP
746:                           temp = i;
005482  78001E     MOV [W14], W0
005484  980F40     MOV W0, [W14+24]
747:                           payAppendData(pld, 2, 2, (unsigned char*)&temp);
005486  470078     ADD W14, #0x18, W0
005488  780180     MOV W0, W3
00548A  B3C022     MOV #0x2, W2
00548C  B3C021     MOV #0x2, W1
00548E  90083E     MOV [W14+22], W0
005490  02CA40     CALL payAppendData
005492  000000     NOP
748:                           temp = width - to_send;
005494  90088E     MOV [W14+16], W1
005496  90002E     MOV [W14+4], W0
005498  508000     SUB W1, W0, W0
00549A  980F40     MOV W0, [W14+24]
749:                           payAppendData(pld, 4, 2, (unsigned char*)&temp);
00549C  470078     ADD W14, #0x18, W0
00549E  780180     MOV W0, W3
0054A0  B3C022     MOV #0x2, W2
0054A2  B3C041     MOV #0x4, W1
0054A4  90083E     MOV [W14+22], W0
0054A6  02CA40     CALL payAppendData
0054A8  000000     NOP
750:                           temp = (block_size < to_send) ? block_size : to_send;
0054AA  9000CE     MOV [W14+8], W1
0054AC  90002E     MOV [W14+4], W0
0054AE  500F81     SUB W0, W1, [W15]
0054B0  360001     BRA LEU, 0x54B4
0054B2  780001     MOV W1, W0
0054B4  980F40     MOV W0, [W14+24]
751:                           payAppendData(pld, 6, temp, *row + (width - to_send));
0054B6  90089E     MOV [W14+18], W1
0054B8  90090E     MOV [W14+16], W2
0054BA  90002E     MOV [W14+4], W0
0054BC  510000     SUB W2, W0, W0
0054BE  408080     ADD W1, W0, W1
0054C0  90084E     MOV [W14+24], W0
0054C2  784000     MOV.B W0, W0
0054C4  780181     MOV W1, W3
0054C6  784100     MOV.B W0, W2
0054C8  B3C061     MOV #0x6, W1
0054CA  90083E     MOV [W14+22], W0
0054CC  02CA40     CALL payAppendData
0054CE  000000     NOP
752:               
753:                           while(!radioEnqueueTxPacket(response));
0054D0  000000     NOP
0054D2  90082E     MOV [W14+20], W0
0054D4  028128     CALL radioEnqueueTxPacket
0054D6  000000     NOP
0054D8  EB0080     CLR W1
0054DA  500F81     SUB W0, W1, [W15]
0054DC  32FFFA     BRA Z, 0x54D2
754:               
755:                           to_send = to_send - temp;
0054DE  90084E     MOV [W14+24], W0
0054E0  9000AE     MOV [W14+4], W1
0054E2  508000     SUB W1, W0, W0
0054E4  980720     MOV W0, [W14+4]
0054E6  370001     BRA 0x54EA
756:               
757:                       }
758:               
759:                   }
760:                   sent = 0;
0054FC  EB0000     CLR W0
0054FE  980710     MOV W0, [W14+2]
761:                   while(!sent) {
005500  370064     BRA 0x55CA
0055CA  90009E     MOV [W14+2], W1
0055CC  EB0000     CLR W0
0055CE  508F80     SUB W1, W0, [W15]
0055D0  32FF98     BRA Z, 0x5502
762:                       response = radioRequestPacket(10);
005502  2000A0     MOV #0xA, W0
005504  0281B2     CALL radioRequestPacket
005506  000000     NOP
005508  980F20     MOV W0, [W14+20]
763:                       if(response == NULL) { continue; }
00550A  9008AE     MOV [W14+20], W1
00550C  EB0000     CLR W0
00550E  508F80     SUB W1, W0, [W15]
005510  32005B     BRA Z, 0x55C8
0055C8  000000     NOP
764:                       pld = macGetPayload(response);
005512  90082E     MOV [W14+20], W0
005514  0286E6     CALL macGetPayload
005516  000000     NOP
005518  980F30     MOV W0, [W14+22]
765:                       paySetType(pld, CMD_CENTROID_REPORT);
00551A  B3C421     MOV #0x42, W1
00551C  90083E     MOV [W14+22], W0
00551E  02CADE     CALL paySetType
005520  000000     NOP
766:                       paySetStatus(pld, 1);
005522  B3C011     MOV #0x1, W1
005524  90083E     MOV [W14+22], W0
005526  02CB02     CALL paySetStatus
005528  000000     NOP
767:                       macSetDestAddr(response, srcAddr);
00552A  9000DE     MOV [W14+10], W1
00552C  90082E     MOV [W14+20], W0
00552E  02863C     CALL macSetDestAddr
005530  000000     NOP
768:                       macSetDestPan(response, srcPan);
005532  9000EE     MOV [W14+12], W1
005534  90082E     MOV [W14+20], W0
005536  02864C     CALL macSetDestPan
005538  000000     NOP
769:                       temp = info.centroid[0];
00553A  47007A     ADD W14, #0x1A, W0
00553C  908830     MOV [W0+150], W0
00553E  980F40     MOV W0, [W14+24]
770:                       paySetData(pld, 2, (unsigned char*)&temp);
005540  470078     ADD W14, #0x18, W0
005542  780100     MOV W0, W2
005544  B3C021     MOV #0x2, W1
005546  90083E     MOV [W14+22], W0
005548  02CAAE     CALL paySetData
00554A  000000     NOP
771:                       temp = info.centroid[1];
00554C  47007A     ADD W14, #0x1A, W0
00554E  908840     MOV [W0+152], W0
005550  980F40     MOV W0, [W14+24]
772:                       payAppendData(pld, 2, 2, (unsigned char*)&temp);
005552  470078     ADD W14, #0x18, W0
005554  780180     MOV W0, W3
005556  B3C022     MOV #0x2, W2
005558  B3C021     MOV #0x2, W1
00555A  90083E     MOV [W14+22], W0
00555C  02CA40     CALL payAppendData
00555E  000000     NOP
773:                       temp = info.max[0];
005560  47007A     ADD W14, #0x1A, W0
005562  908850     MOV [W0+154], W0
005564  980F40     MOV W0, [W14+24]
774:                       payAppendData(pld, 4, 2, (unsigned char*)&temp);
005566  470078     ADD W14, #0x18, W0
005568  780180     MOV W0, W3
00556A  B3C022     MOV #0x2, W2
00556C  B3C041     MOV #0x4, W1
00556E  90083E     MOV [W14+22], W0
005570  02CA40     CALL payAppendData
005572  000000     NOP
775:                       temp = info.max[1];
005574  47007A     ADD W14, #0x1A, W0
005576  908860     MOV [W0+156], W0
005578  980F40     MOV W0, [W14+24]
776:                       payAppendData(pld, 6, 2, (unsigned char*)&temp);
00557A  470078     ADD W14, #0x18, W0
00557C  780180     MOV W0, W3
00557E  B3C022     MOV #0x2, W2
005580  B3C061     MOV #0x6, W1
005582  90083E     MOV [W14+22], W0
005584  02CA40     CALL payAppendData
005586  000000     NOP
777:                       temp = info.max_lum;
005588  47007A     ADD W14, #0x1A, W0
00558A  915860     MOV.B [W0+158], W0
00558C  FB8000     ZE W0, W0
00558E  980F40     MOV W0, [W14+24]
778:                       payAppendData(pld, 8, 1, (unsigned char*)&temp);
005590  470078     ADD W14, #0x18, W0
005592  780180     MOV W0, W3
005594  B3C012     MOV #0x1, W2
005596  B3C081     MOV #0x8, W1
005598  90083E     MOV [W14+22], W0
00559A  02CA40     CALL payAppendData
00559C  000000     NOP
779:                       temp = info.avg_lum;
00559E  47007A     ADD W14, #0x1A, W0
0055A0  904860     MOV.B [W0+14], W0
0055A2  FB8000     ZE W0, W0
0055A4  980F40     MOV W0, [W14+24]
780:                       payAppendData(pld, 9, 1, (unsigned char*)&temp);
0055A6  470078     ADD W14, #0x18, W0
0055A8  780180     MOV W0, W3
0055AA  B3C012     MOV #0x1, W2
0055AC  B3C091     MOV #0x9, W1
0055AE  90083E     MOV [W14+22], W0
0055B0  02CA40     CALL payAppendData
0055B2  000000     NOP
781:                       while(!radioEnqueueTxPacket(response));
0055B4  000000     NOP
0055B6  90082E     MOV [W14+20], W0
0055B8  028128     CALL radioEnqueueTxPacket
0055BA  000000     NOP
0055BC  EB0080     CLR W1
0055BE  500F81     SUB W0, W1, [W15]
0055C0  32FFFA     BRA Z, 0x55B6
782:                       sent = 1;
0055C2  200010     MOV #0x1, W0
0055C4  980710     MOV W0, [W14+2]
0055C6  370001     BRA 0x55CA
783:                   }
784:                   camReturnFrame(frame);
0055D2  90003E     MOV [W14+6], W0
0055D4  029AD6     CALL camReturnFrame
0055D6  000000     NOP
785:               
786:               }
0055D8  FA8000     ULNK
0055DA  060000     RETURN
787:               
788:               static void cmdResponseRawFrame(MacPacket packet) {
0055DC  FA0002     LNK #0x2
0055DE  780F00     MOV W0, [W14]
789:                   return; // Do nothing
790:               }
0055E0  FA8000     ULNK
0055E2  060000     RETURN
791:               
792:               static void cmdSetBackgroundFrame(MacPacket packet) {
0055E4  FA0004     LNK #0x4
0055E6  980710     MOV W0, [W14+2]
793:               
794:                   CamFrame frame;
795:               
796:                   frame = NULL;
0055E8  EB0000     CLR W0
0055EA  780F00     MOV W0, [W14]
797:                   while(frame == NULL) {
0055EC  370003     BRA 0x55F4
0055F4  78009E     MOV [W14], W1
0055F6  EB0000     CLR W0
0055F8  508F80     SUB W1, W0, [W15]
0055FA  32FFF9     BRA Z, 0x55EE
798:                       frame = camGetFrame();
0055EE  029ACE     CALL camGetFrame
0055F0  000000     NOP
0055F2  780F00     MOV W0, [W14]
799:                   }
800:               
801:                   camReturnFrame(cvSetBackgroundFrame(frame));
0055FC  78001E     MOV [W14], W0
0055FE  025878     CALL cvSetBackgroundFrame
005600  000000     NOP
005602  029AD6     CALL camReturnFrame
005604  000000     NOP
802:               
803:               }
005606  FA8000     ULNK
005608  060000     RETURN
804:               
805:               static void cmdCamParamRequest(MacPacket packet) {
00560A  FA0012     LNK #0x12
00560C  980F00     MOV W0, [W14+16]
806:               
807:                   Payload pld;
808:                   CamParamStruct params;
809:                   MacPacket response;
810:                   
811:                   pld = macGetPayload(packet);
00560E  90080E     MOV [W14+16], W0
005610  0286E6     CALL macGetPayload
005612  000000     NOP
005614  780F00     MOV W0, [W14]
812:                   camGetParams(&params);
005616  470064     ADD W14, #0x4, W0
005618  02996A     CALL camGetParams
00561A  000000     NOP
813:                   
814:                   response = radioRequestPacket(sizeof(CamParamStruct));
00561C  2000C0     MOV #0xC, W0
00561E  0281B2     CALL radioRequestPacket
005620  000000     NOP
005622  980710     MOV W0, [W14+2]
815:                   if(response == NULL) { return; }
005624  90009E     MOV [W14+2], W1
005626  EB0000     CLR W0
005628  508F80     SUB W1, W0, [W15]
00562A  320021     BRA Z, 0x566E
00566E  000000     NOP
816:                   
817:                   macSetDestAddr(response, macGetSrcAddr(packet));
00562C  90080E     MOV [W14+16], W0
00562E  028674     CALL macGetSrcAddr
005630  000000     NOP
005632  780080     MOV W0, W1
005634  90001E     MOV [W14+2], W0
005636  02863C     CALL macSetDestAddr
005638  000000     NOP
818:                   pld = macGetPayload(response);
00563A  90001E     MOV [W14+2], W0
00563C  0286E6     CALL macGetPayload
00563E  000000     NOP
005640  780F00     MOV W0, [W14]
819:                   paySetType(pld, CMD_CAM_PARAM_RESPONSE);
005642  B3C491     MOV #0x49, W1
005644  78001E     MOV [W14], W0
005646  02CADE     CALL paySetType
005648  000000     NOP
820:                   paySetStatus(pld, 0);
00564A  EB4080     CLR.B W1
00564C  78001E     MOV [W14], W0
00564E  02CB02     CALL paySetStatus
005650  000000     NOP
821:                   paySetData(pld, sizeof(CamParamStruct), (unsigned char*)&params);
005652  470064     ADD W14, #0x4, W0
005654  780100     MOV W0, W2
005656  B3C0C1     MOV #0xC, W1
005658  78001E     MOV [W14], W0
00565A  02CAAE     CALL paySetData
00565C  000000     NOP
822:               
823:                   while(!radioEnqueueTxPacket(response));
00565E  000000     NOP
005660  90001E     MOV [W14+2], W0
005662  028128     CALL radioEnqueueTxPacket
005664  000000     NOP
005666  EB0080     CLR W1
005668  500F81     SUB W0, W1, [W15]
00566A  32FFFA     BRA Z, 0x5660
00566C  370001     BRA 0x5670
824:               
825:               
826:               }
005670  FA8000     ULNK
005672  060000     RETURN
827:               
828:               static void cmdCamParamResponse(MacPacket packet) {
005674  FA0016     LNK #0x16
005676  980F20     MOV W0, [W14+20]
829:               
830:                   Payload pld;
831:                   unsigned char *frame;
832:                   CamParamStruct *params;
833:                   LStrobeParamStruct lstrobe_params;
834:                   DirEntry entry;
835:                   unsigned int addr, pan;
836:                   
837:                   pld = macGetPayload(packet);
005678  90082E     MOV [W14+20], W0
00567A  0286E6     CALL macGetPayload
00567C  000000     NOP
00567E  780F00     MOV W0, [W14]
838:                   frame = payGetData(pld);
005680  78001E     MOV [W14], W0
005682  02CAA0     CALL payGetData
005684  000000     NOP
005686  980710     MOV W0, [W14+2]
839:                   params = (CamParamStruct*) frame;
005688  90001E     MOV [W14+2], W0
00568A  980720     MOV W0, [W14+4]
840:                       
841:                   addr = macGetSrcAddr(packet);
00568C  90082E     MOV [W14+20], W0
00568E  028674     CALL macGetSrcAddr
005690  000000     NOP
005692  980730     MOV W0, [W14+6]
842:                   pan = macGetSrcPan(packet);
005694  90082E     MOV [W14+20], W0
005696  028680     CALL macGetSrcPan
005698  000000     NOP
00569A  980740     MOV W0, [W14+8]
843:                   entry = dirQueryAddress(addr, pan);
00569C  9000CE     MOV [W14+8], W1
00569E  90003E     MOV [W14+6], W0
0056A0  02CBB8     CALL dirQueryAddress
0056A2  000000     NOP
0056A4  980750     MOV W0, [W14+10]
844:                   
845:                   if(entry == NULL) { return; }
0056A6  9000DE     MOV [W14+10], W1
0056A8  EB0000     CLR W0
0056AA  508F80     SUB W1, W0, [W15]
0056AC  320037     BRA Z, 0x571C
00571C  000000     NOP
846:                   entry->frame_period = params->frame_period;
0056AE  90002E     MOV [W14+4], W0
0056B0  9000D0     MOV [W0+10], W1
0056B2  900040     MOV [W0+8], W0
0056B4  90015E     MOV [W14+10], W2
0056B6  980160     MOV W0, [W2+12]
0056B8  980171     MOV W1, [W2+14]
847:                   entry->frame_start = params->frame_start;
0056BA  90002E     MOV [W14+4], W0
0056BC  9000B0     MOV [W0+6], W1
0056BE  900020     MOV [W0+4], W0
0056C0  90015E     MOV [W14+10], W2
0056C2  980900     MOV W0, [W2+16]
0056C4  980911     MOV W1, [W2+18]
848:               
849:                   lstrobe_params.period = 5*(params->frame_period/4);
0056C6  90002E     MOV [W14+4], W0
0056C8  9000D0     MOV [W0+10], W1
0056CA  900040     MOV [W0+8], W0
0056CC  DD094E     SL W1, #14, W2
0056CE  DE0042     LSR W0, #2, W0
0056D0  710000     IOR W2, W0, W0
0056D2  DE08C2     LSR W1, #2, W1
0056D4  780000     MOV W0, W0
0056D6  B90065     MUL.SU W0, #5, W0
0056D8  780000     MOV W0, W0
0056DA  980760     MOV W0, [W14+12]
850:                   lstrobe_params.period_offset = (params->frame_start/4) % (params->frame_period/4);
0056DC  90002E     MOV [W14+4], W0
0056DE  9000B0     MOV [W0+6], W1
0056E0  900020     MOV [W0+4], W0
0056E2  DE0AC2     LSR W1, #2, W5
0056E4  DD094E     SL W1, #14, W2
0056E6  DE0242     LSR W0, #2, W4
0056E8  710204     IOR W2, W4, W4
0056EA  90002E     MOV [W14+4], W0
0056EC  9000D0     MOV [W0+10], W1
0056EE  900040     MOV [W0+8], W0
0056F0  DD094E     SL W1, #14, W2
0056F2  DE0042     LSR W0, #2, W0
0056F4  710000     IOR W2, W0, W0
0056F6  DE08C2     LSR W1, #2, W1
0056F8  BE0100     MOV.D W0, W2
0056FA  BE0004     MOV.D W4, W0
0056FC  022E1C     CALL ___umodsi3
0056FE  000000     NOP
005700  780000     MOV W0, W0
005702  980770     MOV W0, [W14+14]
851:                   lstrobe_params.on_time = 625/4; // 1 ms
005704  2009C0     MOV #0x9C, W0
005706  980F00     MOV W0, [W14+16]
852:                   lstrobe_params.off_time = lstrobe_params.period - lstrobe_params.on_time;
005708  9000EE     MOV [W14+12], W1
00570A  90080E     MOV [W14+16], W0
00570C  508000     SUB W1, W0, W0
00570E  980F10     MOV W0, [W14+18]
853:                   lstrobeSetParam(&lstrobe_params);
005710  47006C     ADD W14, #0xC, W0
005712  02D844     CALL lstrobeSetParam
005714  000000     NOP
854:                   lstrobeStart();
005716  02D894     CALL lstrobeStart
005718  000000     NOP
00571A  370001     BRA 0x571E
855:                   
856:               }
00571E  FA8000     ULNK
005720  060000     RETURN
857:               
858:               static void cmdZeroEstimate(MacPacket packet) {
005722  FA0002     LNK #0x2
005724  780F00     MOV W0, [W14]
859:               
860:                   attReset();
005726  028A6A     CALL attReset
005728  000000     NOP
861:                   //xlReadXYZ();
862:                   //attZero();
863:               
864:               }
00572A  FA8000     ULNK
00572C  060000     RETURN
865:               
866:               static void cmdRequestAttitude(MacPacket packet) {
00572E  FA0002     LNK #0x2
005730  780F00     MOV W0, [W14]
867:               
868:                   telemSendAttitude(macGetSrcAddr(packet));
005732  78001E     MOV [W14], W0
005734  028674     CALL macGetSrcAddr
005736  000000     NOP
005738  02B7AA     CALL telemSendAttitude
00573A  000000     NOP
869:               
870:               }
00573C  FA8000     ULNK
00573E  060000     RETURN
871:               
872:               static void cmdResponseAttitude(MacPacket packet) {
005740  FA0002     LNK #0x2
005742  780F00     MOV W0, [W14]
873:               
874:                   // Write me!
875:                   return;
876:               
877:               }
005744  FA8000     ULNK
005746  060000     RETURN
878:               
879:               void cmdSetHP(MacPacket packet) {
005748  FA0002     LNK #0x2
00574A  780F00     MOV W0, [W14]
880:               
881:                   cvSetHP();
00574C  02583A     CALL cvSetHP
00574E  000000     NOP
882:               
883:               }
005750  FA8000     ULNK
005752  060000     RETURN
884:               
885:               void cmdSetTelemSubsample(MacPacket packet) {
005754  FA0008     LNK #0x8
005756  980730     MOV W0, [W14+6]
886:               
887:                   Payload pld = macGetPayload(packet);
005758  90003E     MOV [W14+6], W0
00575A  0286E6     CALL macGetPayload
00575C  000000     NOP
00575E  780F00     MOV W0, [W14]
888:                   unsigned int* frame = (unsigned int*) payGetData(pld);
005760  78001E     MOV [W14], W0
005762  02CAA0     CALL payGetData
005764  000000     NOP
005766  980710     MOV W0, [W14+2]
889:                   unsigned int count = frame[0];
005768  90001E     MOV [W14+2], W0
00576A  780090     MOV [W0], W1
00576C  980721     MOV W1, [W14+4]
890:               
891:                   telemSetSubsampleRate(count);
00576E  90002E     MOV [W14+4], W0
005770  02B5A8     CALL telemSetSubsampleRate
005772  000000     NOP
892:                   
893:               }
005774  FA8000     ULNK
005776  060000     RETURN
894:               
895:               void cmdSetSlewLimit(MacPacket packet) {
005778  FA0004     LNK #0x4
00577A  980710     MOV W0, [W14+2]
896:               
897:                   float *data;
898:               
899:                   data = (float *) payGetData(macGetPayload(packet));
00577C  90001E     MOV [W14+2], W0
00577E  0286E6     CALL macGetPayload
005780  000000     NOP
005782  02CAA0     CALL payGetData
005784  000000     NOP
005786  780F00     MOV W0, [W14]
900:                   slewSetLimit(*data);
005788  78001E     MOV [W14], W0
00578A  BE0010     MOV.D [W0], W0
00578C  02CECA     CALL slewSetLimit
00578E  000000     NOP
901:                   
902:               }
005790  FA8000     ULNK
005792  060000     RETURN
903:               
904:               /*-----------------------------------------------------------------------------
905:                *          AUX functions
906:               -----------------------------------------------------------------------------*/
907:               static void cmdEcho(MacPacket packet) {
005794  FA000E     LNK #0xE
005796  980760     MOV W0, [W14+12]
908:                       
909:                   Payload pld = macGetPayload(packet);
005798  90006E     MOV [W14+12], W0
00579A  0286E6     CALL macGetPayload
00579C  000000     NOP
00579E  780F00     MOV W0, [W14]
910:                   unsigned char status = payGetStatus(pld);
0057A0  78001E     MOV [W14], W0
0057A2  02CB14     CALL payGetStatus
0057A4  000000     NOP
0057A6  984720     MOV.B W0, [W14+2]
911:                   unsigned char* frame = payGetData(pld);
0057A8  78001E     MOV [W14], W0
0057AA  02CAA0     CALL payGetData
0057AC  000000     NOP
0057AE  980720     MOV W0, [W14+4]
912:                   unsigned int length = payGetDataLength(pld);
0057B0  78001E     MOV [W14], W0
0057B2  02CAD2     CALL payGetDataLength
0057B4  000000     NOP
0057B6  FB8000     ZE W0, W0
0057B8  980730     MOV W0, [W14+6]
913:                   unsigned int srcAddr = macGetSrcAddr(packet);
0057BA  90006E     MOV [W14+12], W0
0057BC  028674     CALL macGetSrcAddr
0057BE  000000     NOP
0057C0  980740     MOV W0, [W14+8]
914:                   
915:                   MacPacket response;
916:                   
917:                   response = radioRequestPacket(length);
0057C2  90003E     MOV [W14+6], W0
0057C4  0281B2     CALL radioRequestPacket
0057C6  000000     NOP
0057C8  980750     MOV W0, [W14+10]
918:                   if(response == NULL) { return; }
0057CA  9000DE     MOV [W14+10], W1
0057CC  EB0000     CLR W0
0057CE  508F80     SUB W1, W0, [W15]
0057D0  32001E     BRA Z, 0x580E
00580E  000000     NOP
919:                   macSetDestAddr(response, srcAddr);
0057D2  9000CE     MOV [W14+8], W1
0057D4  90005E     MOV [W14+10], W0
0057D6  02863C     CALL macSetDestAddr
0057D8  000000     NOP
920:                   
921:                   pld = response->payload;
0057DA  90005E     MOV [W14+10], W0
0057DC  9000E0     MOV [W0+12], W1
0057DE  780F01     MOV W1, [W14]
922:                   paySetData(pld, length, frame);
0057E0  90003E     MOV [W14+6], W0
0057E2  784000     MOV.B W0, W0
0057E4  90012E     MOV [W14+4], W2
0057E6  784080     MOV.B W0, W1
0057E8  78001E     MOV [W14], W0
0057EA  02CAAE     CALL paySetData
0057EC  000000     NOP
923:                   paySetStatus(pld, status);
0057EE  9040AE     MOV.B [W14+2], W1
0057F0  78001E     MOV [W14], W0
0057F2  02CB02     CALL paySetStatus
0057F4  000000     NOP
924:                   paySetType(pld, CMD_ECHO);
0057F6  B3C131     MOV #0x13, W1
0057F8  78001E     MOV [W14], W0
0057FA  02CADE     CALL paySetType
0057FC  000000     NOP
925:                   
926:                   while(!radioEnqueueTxPacket(response));
0057FE  000000     NOP
005800  90005E     MOV [W14+10], W0
005802  028128     CALL radioEnqueueTxPacket
005804  000000     NOP
005806  EB0080     CLR W1
005808  500F81     SUB W0, W1, [W15]
00580A  32FFFA     BRA Z, 0x5800
00580C  370001     BRA 0x5810
927:               }
005810  FA8000     ULNK
005812  060000     RETURN
928:               
929:               static void cmdNop(MacPacket packet) {
005814  FA0002     LNK #0x2
005816  780F00     MOV W0, [W14]
930:                           
931:                   Nop();
005818  000000     NOP
932:               }
00581A  FA8000     ULNK
00581C  060000     RETURN
933:               
934:               
935:               
---  C:/Users/Cameron/Documents/Git/ibird-lib/clock_sync.c  ---------------------------------------------
1:                 /**
2:                  * Copyright (c) 2011-2012, Regents of the University of California
3:                  * All rights reserved.
4:                  *
5:                  * Redistribution and use in source and binary forms, with or without
6:                  * modification, are permitted provided that the following conditions are met:
7:                  *
8:                  * - Redistributions of source code must retain the above copyright notice,
9:                  *   this list of conditions and the following disclaimer.
10:                 * - Redistributions in binary form must reproduce the above copyright notice,
11:                 *   this list of conditions and the following disclaimer in the documentation
12:                 *   and/or other materials provided with the distribution.
13:                 * - Neither the name of the University of California, Berkeley nor the names
14:                 *   of its contributors may be used to endorse or promote products derived
15:                 *   from this software without specific prior written permission.
16:                 *
17:                 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
18:                 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
19:                 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
20:                 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
21:                 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
22:                 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
23:                 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
24:                 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
25:                 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
26:                 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
27:                 * POSSIBILITY OF SUCH DAMAGE.
28:                 *
29:                 *
30:                 * Clock Synchronization Module
31:                 *
32:                 * by Humphrey Hu
33:                 *
34:                 * v.beta
35:                 *
36:                 * Revisions:
37:                 *  Humphrey Hu		2012-02-28		Initial implementation 
38:                 *                      
39:                 * Notes:
40:                 *  Still need to implement iteration counting and pos/neg offset comparison for
41:                 *  in-sync determination
42:                 */
43:                
44:                // ==== REFERENCES ============================================================
45:                #include "mac_packet.h"
46:                #include "radio.h"
47:                #include "net.h"
48:                #include "cmd_const.h"
49:                #include "sys_clock.h"
50:                #include "clock_sync.h"
51:                #include "led.h"
52:                // ==== CONSTANTS =============================================================
53:                
54:                #define DEFAULT_SYNC_TOL        (312) // 0.5 ms (625 ticks/ms)
55:                
56:                #define SAMPLES_PER_ITERATION   (1)
57:                #define MAX_ITERATIONS          (40)
58:                #define MAX_PENDING_REQUESTS    (10)
59:                
60:                #define DEFAULT_MASTER_ADDR     (0x1021)
61:                #define DEFAULT_MASTER_PAN      (0x1001)
62:                
63:                // ==== STATIC VARIABLES ======================================================
64:                
65:                SyncStatusStruct status;
66:                
67:                // =========== Function Stubs =================================================
68:                
69:                static void clksyncSendRequest(SyncStatus sync);
70:                static void clksyncProcessSamples(SyncStatus sync);
71:                
72:                // =========== Public Functions ===============================================
73:                void clksyncSetup(void) {
00A824  FA0000     LNK #0x0
74:                
75:                    status.tolerance = DEFAULT_SYNC_TOL;
00A826  201380     MOV #0x138, W0
00A828  200001     MOV #0x0, W1
00A82A  890BF0     MOV W0, 0x217E
00A82C  890C01     MOV W1, 0x2180
76:                    
77:                    status.master_addr = DEFAULT_MASTER_ADDR; // Make more general
00A82E  210210     MOV #0x1021, W0
00A830  890BD0     MOV W0, 0x217A
78:                    status.master_pan = DEFAULT_MASTER_PAN;
00A832  210010     MOV #0x1001, W0
00A834  890BE0     MOV W0, 0x217C
79:                
80:                    status.state = STATE_UNSYNCED;
00A836  EB0000     CLR W0
00A838  890BC0     MOV W0, status
81:                    status.requests = 0;
00A83A  EB0000     CLR W0
00A83C  890C10     MOV W0, 0x2182
82:                    status.responses = 0;
00A83E  EB0000     CLR W0
00A840  890C20     MOV W0, 0x2184
83:                    status.iterations = 0;
00A842  EB0000     CLR W0
00A844  890C30     MOV W0, 0x2186
84:                    status.accumulator = 0;
00A846  221884     MOV #0x2188, W4
00A848  B80060     MUL.UU W0, #0, W0
00A84A  B81160     MUL.UU W2, #0, W2
00A84C  BE9A00     MOV.D W0, [W4++]
00A84E  BE9202     MOV.D W2, [W4--]
85:                
86:                    if(netGetLocalAddress() == status.master_addr &&
00A850  02C316     CALL netGetLocalAddress
00A852  000000     NOP
00A854  810BD1     MOV 0x217A, W1
00A856  500F81     SUB W0, W1, [W15]
00A858  3A0007     BRA NZ, 0xA868
00A860  500F81     SUB W0, W1, [W15]
00A862  3A0002     BRA NZ, 0xA868
87:                        netGetLocalPanID() == status.master_pan) {
00A85A  02C31E     CALL netGetLocalPanID
00A85C  000000     NOP
00A85E  810BE1     MOV 0x217C, W1
88:                        status.state = STATE_MASTER;
00A864  200010     MOV #0x1, W0
00A866  890BC0     MOV W0, status
89:                    }
90:                
91:                    
92:                }
00A868  FA8000     ULNK
00A86A  060000     RETURN
93:                
94:                void clksyncSetTolerance(unsigned long tol) {
00A86C  FA0004     LNK #0x4
00A86E  BE8F00     MOV.D W0, [W14]
95:                
96:                    status.tolerance = tol;
00A870  BE001E     MOV.D [W14], W0
00A872  890BF0     MOV W0, 0x217E
00A874  890C01     MOV W1, 0x2180
97:                
98:                }
00A876  FA8000     ULNK
00A878  060000     RETURN
99:                
100:               void clksyncSetMasterAddr(unsigned int addr, unsigned int pan) {
00A87A  FA0004     LNK #0x4
00A87C  780F00     MOV W0, [W14]
00A87E  980711     MOV W1, [W14+2]
101:               
102:                   status.master_addr = addr;
00A880  78001E     MOV [W14], W0
00A882  890BD0     MOV W0, 0x217A
103:                   status.master_pan = pan;
00A884  90001E     MOV [W14+2], W0
00A886  890BE0     MOV W0, 0x217C
104:                   
105:               }
00A888  FA8000     ULNK
00A88A  060000     RETURN
106:               
107:               void clksyncSync(void) {
00A88C  FA0000     LNK #0x0
108:               
109:                   if(clksyncIsDone()) { return; }
00A88E  070009     RCALL clksyncIsDone
00A890  EB4080     CLR.B W1
00A892  504F81     SUB.B W0, W1, [W15]
00A894  3A0003     BRA NZ, 0xA89C
00A89C  000000     NOP
110:                   
111:                   clksyncSendRequest(&status);
00A896  221780     MOV #0x2178, W0
00A898  0700C2     RCALL clksyncSendRequest
00A89A  370001     BRA 0xA89E
112:               
113:               }
00A89E  FA8000     ULNK
00A8A0  060000     RETURN
114:               
115:               unsigned char clksyncIsDone(void) {
00A8A2  FA0000     LNK #0x0
116:               
117:                   return status.state != STATE_UNSYNCED;
00A8A4  810BC0     MOV status, W0
00A8A6  EA0080     NEG W0, W1
00A8A8  708000     IOR W1, W0, W0
00A8AA  DE004F     LSR W0, #15, W0
00A8AC  784000     MOV.B W0, W0
118:               
119:               }
00A8AE  FA8000     ULNK
00A8B0  060000     RETURN
120:                
121:               void clksyncHandleRequest(MacPacket packet) {
00A8B2  FA0014     LNK #0x14
00A8B4  BE9F88     MOV.D W8, [W15++]
00A8B6  980F10     MOV W0, [W14+18]
122:               
123:                   Payload pld;
124:                   MacPacket response;
125:                   unsigned long* frame;
126:                   unsigned long s0, m1, m2;
127:                   
128:                   pld = macGetPayload(packet);
00A8B8  90081E     MOV [W14+18], W0
00A8BA  0286E6     CALL macGetPayload
00A8BC  000000     NOP
00A8BE  780F00     MOV W0, [W14]
129:                   frame = (unsigned long*) payGetData(pld);
00A8C0  78001E     MOV [W14], W0
00A8C2  02CAA0     CALL payGetData
00A8C4  000000     NOP
00A8C6  980710     MOV W0, [W14+2]
130:                   
131:                   s0 = frame[0]; // Read requester time of flight
00A8C8  90001E     MOV [W14+2], W0
00A8CA  BE0010     MOV.D [W0], W0
00A8CC  980730     MOV W0, [W14+6]
00A8CE  980741     MOV W1, [W14+8]
132:                   m1 = packet->timestamp + sclockGetOffsetTicks(); // Read local time of reception
00A8D0  90081E     MOV [W14+18], W0
00A8D2  900C00     MOV [W0+16], W8
00A8D4  900C90     MOV [W0+18], W9
00A8D6  02DE70     CALL sclockGetOffsetTicks
00A8D8  000000     NOP
00A8DA  400008     ADD W0, W8, W0
00A8DC  488089     ADDC W1, W9, W1
00A8DE  980750     MOV W0, [W14+10]
00A8E0  980761     MOV W1, [W14+12]
133:               
134:                   response = radioRequestPacket(12); // Sending 3 longs
00A8E2  2000C0     MOV #0xC, W0
00A8E4  0281B2     CALL radioRequestPacket
00A8E6  000000     NOP
00A8E8  980720     MOV W0, [W14+4]
135:                   if(response == NULL) { return; }
00A8EA  9000AE     MOV [W14+4], W1
00A8EC  EB0000     CLR W0
00A8EE  508F80     SUB W1, W0, [W15]
00A8F0  32003E     BRA Z, 0xA96E
00A96E  000000     NOP
136:               
137:                   macSetDestAddr(response, macGetSrcAddr(packet));
00A8F2  90081E     MOV [W14+18], W0
00A8F4  028674     CALL macGetSrcAddr
00A8F6  000000     NOP
00A8F8  780080     MOV W0, W1
00A8FA  90002E     MOV [W14+4], W0
00A8FC  02863C     CALL macSetDestAddr
00A8FE  000000     NOP
138:                   macSetDestPan(response, macGetSrcPan(packet));
00A900  90081E     MOV [W14+18], W0
00A902  028680     CALL macGetSrcPan
00A904  000000     NOP
00A906  780080     MOV W0, W1
00A908  90002E     MOV [W14+4], W0
00A90A  02864C     CALL macSetDestPan
00A90C  000000     NOP
139:                   pld = macGetPayload(response); // Create response packet
00A90E  90002E     MOV [W14+4], W0
00A910  0286E6     CALL macGetPayload
00A912  000000     NOP
00A914  780F00     MOV W0, [W14]
140:                   paySetType(pld, CMD_CLOCK_UPDATE_RESPONSE);
00A916  B3C391     MOV #0x39, W1
00A918  78001E     MOV [W14], W0
00A91A  02CADE     CALL paySetType
00A91C  000000     NOP
141:                   paySetData(pld, 4, (unsigned char*) &s0);
00A91E  470066     ADD W14, #0x6, W0
00A920  780100     MOV W0, W2
00A922  B3C041     MOV #0x4, W1
00A924  78001E     MOV [W14], W0
00A926  02CAAE     CALL paySetData
00A928  000000     NOP
142:                   payAppendData(pld, 4, 4, (unsigned char*) & m1);
00A92A  47006A     ADD W14, #0xA, W0
00A92C  780180     MOV W0, W3
00A92E  B3C042     MOV #0x4, W2
00A930  B3C041     MOV #0x4, W1
00A932  78001E     MOV [W14], W0
00A934  02CA40     CALL payAppendData
00A936  000000     NOP
143:                   
144:                   // Empty TX queue to minimize time of flight error
145:                   while(!radioTxQueueEmpty());
00A938  000000     NOP
00A93A  028138     CALL radioTxQueueEmpty
00A93C  000000     NOP
00A93E  EB0080     CLR W1
00A940  500F81     SUB W0, W1, [W15]
00A942  32FFFB     BRA Z, 0xA93A
146:                   
147:                   m2 = sclockGetGlobalTicks(); // Get approximate time of flight
00A944  02DE28     CALL sclockGetGlobalTicks
00A946  000000     NOP
00A948  980770     MOV W0, [W14+14]
00A94A  980F01     MOV W1, [W14+16]
148:                   payAppendData(pld, 8, 4, (unsigned char*) & m2);
00A94C  47006E     ADD W14, #0xE, W0
00A94E  780180     MOV W0, W3
00A950  B3C042     MOV #0x4, W2
00A952  B3C081     MOV #0x8, W1
00A954  78001E     MOV [W14], W0
00A956  02CA40     CALL payAppendData
00A958  000000     NOP
149:                   
150:                   while(!radioEnqueueTxPacket(response));
00A95A  000000     NOP
00A95C  90002E     MOV [W14+4], W0
00A95E  028128     CALL radioEnqueueTxPacket
00A960  000000     NOP
00A962  EB0080     CLR W1
00A964  500F81     SUB W0, W1, [W15]
00A966  32FFFA     BRA Z, 0xA95C
151:                   radioProcess(); // Fast send
00A968  028276     CALL radioProcess
00A96A  000000     NOP
00A96C  370001     BRA 0xA970
152:               
153:               }
00A970  BE044F     MOV.D [--W15], W8
00A972  FA8000     ULNK
00A974  060000     RETURN
154:               
155:               void clksyncHandleResponse(MacPacket packet) {
00A976  FA001E     LNK #0x1E
00A978  BE9F88     MOV.D W8, [W15++]
00A97A  980F60     MOV W0, [W14+28]
156:               
157:                   Payload pld;    
158:                   unsigned long* frame;
159:                   unsigned long s0, m1, m2, s3;
160:                   long long residual_offset;
161:               
162:                   pld = macGetPayload(packet);
00A97C  90086E     MOV [W14+28], W0
00A97E  0286E6     CALL macGetPayload
00A980  000000     NOP
00A982  780F00     MOV W0, [W14]
163:                   frame = (unsigned long *) payGetData(pld);
00A984  78001E     MOV [W14], W0
00A986  02CAA0     CALL payGetData
00A988  000000     NOP
00A98A  980710     MOV W0, [W14+2]
164:                   
165:                   s0 = frame[0];
00A98C  90001E     MOV [W14+2], W0
00A98E  BE0110     MOV.D [W0], W2
00A990  980722     MOV W2, [W14+4]
00A992  980733     MOV W3, [W14+6]
166:                   m1 = frame[1];
00A994  90001E     MOV [W14+2], W0
00A996  400064     ADD W0, #0x4, W0
00A998  BE0110     MOV.D [W0], W2
00A99A  980742     MOV W2, [W14+8]
00A99C  980753     MOV W3, [W14+10]
167:                   m2 = frame[2];
00A99E  90001E     MOV [W14+2], W0
00A9A0  400068     ADD W0, #0x8, W0
00A9A2  BE0110     MOV.D [W0], W2
00A9A4  980762     MOV W2, [W14+12]
00A9A6  980773     MOV W3, [W14+14]
168:                   s3 = packet->timestamp + sclockGetOffsetTicks();
00A9A8  90086E     MOV [W14+28], W0
00A9AA  900C00     MOV [W0+16], W8
00A9AC  900C90     MOV [W0+18], W9
00A9AE  02DE70     CALL sclockGetOffsetTicks
00A9B0  000000     NOP
00A9B2  400008     ADD W0, W8, W0
00A9B4  488089     ADDC W1, W9, W1
00A9B6  980F00     MOV W0, [W14+16]
00A9B8  980F11     MOV W1, [W14+18]
169:                   
170:                   residual_offset = (-s0 - s3 + m1 + m2)/2;
00A9BA  90002E     MOV [W14+4], W0
00A9BC  9000BE     MOV [W14+6], W1
00A9BE  100160     SUBR W0, #0x0, W2
00A9C0  1881E0     SUBBR W1, #0x0, W3
00A9C2  90080E     MOV [W14+16], W0
00A9C4  90089E     MOV [W14+18], W1
00A9C6  510100     SUB W2, W0, W2
00A9C8  598181     SUBB W3, W1, W3
00A9CA  90004E     MOV [W14+8], W0
00A9CC  9000DE     MOV [W14+10], W1
00A9CE  400102     ADD W0, W2, W2
00A9D0  488183     ADDC W1, W3, W3
00A9D2  90006E     MOV [W14+12], W0
00A9D4  9000FE     MOV [W14+14], W1
00A9D6  400002     ADD W0, W2, W0
00A9D8  488083     ADDC W1, W3, W1
00A9DA  D10081     LSR W1, W1
00A9DC  D38000     RRC W0, W0
00A9DE  980F20     MOV W0, [W14+20]
00A9E0  980F31     MOV W1, [W14+22]
00A9E2  EB0000     CLR W0
00A9E4  980F40     MOV W0, [W14+24]
00A9E6  EB0000     CLR W0
00A9E8  980F50     MOV W0, [W14+26]
171:                   status.accumulator += residual_offset;
00A9EA  221880     MOV #0x2188, W0
00A9EC  BE0230     MOV.D [W0++], W4
00A9EE  BE0320     MOV.D [W0--], W6
00A9F0  90082E     MOV [W14+20], W0
00A9F2  9008BE     MOV [W14+22], W1
00A9F4  90094E     MOV [W14+24], W2
00A9F6  9009DE     MOV [W14+26], W3
00A9F8  400004     ADD W0, W4, W0
00A9FA  488085     ADDC W1, W5, W1
00A9FC  490106     ADDC W2, W6, W2
00A9FE  498187     ADDC W3, W7, W3
00AA00  221884     MOV #0x2188, W4
00AA02  BE9A00     MOV.D W0, [W4++]
00AA04  BE9202     MOV.D W2, [W4--]
172:                       
173:                   status.responses++;
00AA06  810C20     MOV 0x2184, W0
00AA08  E80000     INC W0, W0
00AA0A  890C20     MOV W0, 0x2184
174:               
175:                   if(status.responses >= SAMPLES_PER_ITERATION) {
00AA0C  810C21     MOV 0x2184, W1
00AA0E  EB0000     CLR W0
00AA10  508F80     SUB W1, W0, [W15]
00AA12  320002     BRA Z, 0xAA18
176:                       clksyncProcessSamples(&status);
00AA14  221780     MOV #0x2178, W0
00AA16  070052     RCALL clksyncProcessSamples
177:                   }
178:               }
00AA18  BE044F     MOV.D [--W15], W8
00AA1A  FA8000     ULNK
00AA1C  060000     RETURN
179:                
180:               // ==== PRIVATE FUNCTIONS ===================================================== 
181:               static void clksyncSendRequest(SyncStatus sync) {
00AA1E  FA000A     LNK #0xA
00AA20  980740     MOV W0, [W14+8]
182:               
183:                   MacPacket packet;
184:                   Payload pld;
185:                   unsigned long s0;
186:                   
187:                   packet = radioRequestPacket(4);
00AA22  200040     MOV #0x4, W0
00AA24  0281B2     CALL radioRequestPacket
00AA26  000000     NOP
00AA28  780F00     MOV W0, [W14]
188:                   if(packet == NULL) { return; }
00AA2A  78009E     MOV [W14], W1
00AA2C  EB0000     CLR W0
00AA2E  508F80     SUB W1, W0, [W15]
00AA30  320042     BRA Z, 0xAAB6
00AAB6  000000     NOP
189:                   macSetDestAddr(packet, sync->master_addr);
00AA32  90004E     MOV [W14+8], W0
00AA34  900010     MOV [W0+2], W0
00AA36  780080     MOV W0, W1
00AA38  78001E     MOV [W14], W0
00AA3A  02863C     CALL macSetDestAddr
00AA3C  000000     NOP
190:                   macSetDestPan(packet, sync->master_pan);
00AA3E  90004E     MOV [W14+8], W0
00AA40  900020     MOV [W0+4], W0
00AA42  780080     MOV W0, W1
00AA44  78001E     MOV [W14], W0
00AA46  02864C     CALL macSetDestPan
00AA48  000000     NOP
191:                   pld = macGetPayload(packet);
00AA4A  78001E     MOV [W14], W0
00AA4C  0286E6     CALL macGetPayload
00AA4E  000000     NOP
00AA50  980710     MOV W0, [W14+2]
192:                   paySetType(pld, CMD_CLOCK_UPDATE_REQUEST);
00AA52  B3C381     MOV #0x38, W1
00AA54  90001E     MOV [W14+2], W0
00AA56  02CADE     CALL paySetType
00AA58  000000     NOP
193:               
194:                   while(!radioTxQueueEmpty());
00AA5A  000000     NOP
00AA5C  028138     CALL radioTxQueueEmpty
00AA5E  000000     NOP
00AA60  EB0080     CLR W1
00AA62  500F81     SUB W0, W1, [W15]
00AA64  32FFFB     BRA Z, 0xAA5C
195:                   
196:                   s0 = sclockGetGlobalTicks();
00AA66  02DE28     CALL sclockGetGlobalTicks
00AA68  000000     NOP
00AA6A  980720     MOV W0, [W14+4]
00AA6C  980731     MOV W1, [W14+6]
197:                   pld = macGetPayload(packet);
00AA6E  78001E     MOV [W14], W0
00AA70  0286E6     CALL macGetPayload
00AA72  000000     NOP
00AA74  980710     MOV W0, [W14+2]
198:                   paySetData(pld, 4, (unsigned char*) &s0);
00AA76  470064     ADD W14, #0x4, W0
00AA78  780100     MOV W0, W2
00AA7A  B3C041     MOV #0x4, W1
00AA7C  90001E     MOV [W14+2], W0
00AA7E  02CAAE     CALL paySetData
00AA80  000000     NOP
199:               
200:                   while(!radioEnqueueTxPacket(packet));
00AA82  000000     NOP
00AA84  78001E     MOV [W14], W0
00AA86  028128     CALL radioEnqueueTxPacket
00AA88  000000     NOP
00AA8A  EB0080     CLR W1
00AA8C  500F81     SUB W0, W1, [W15]
00AA8E  32FFFA     BRA Z, 0xAA84
201:                   radioProcess(); // Fast send
00AA90  028276     CALL radioProcess
00AA92  000000     NOP
202:               
203:                   sync->requests++;
00AA94  90004E     MOV [W14+8], W0
00AA96  900050     MOV [W0+10], W0
00AA98  E80080     INC W0, W1
00AA9A  90004E     MOV [W14+8], W0
00AA9C  980051     MOV W1, [W0+10]
204:                   if(sync->requests - sync->responses > MAX_PENDING_REQUESTS) {
00AA9E  90004E     MOV [W14+8], W0
00AAA0  9000D0     MOV [W0+10], W1
00AAA2  90004E     MOV [W14+8], W0
00AAA4  900060     MOV [W0+12], W0
00AAA6  508080     SUB W1, W0, W1
00AAA8  2000A0     MOV #0xA, W0
00AAAA  508F80     SUB W1, W0, [W15]
00AAAC  360005     BRA LEU, 0xAAB8
205:                       sync->state = STATE_REQUEST_TIMEOUT;        
00AAAE  90004E     MOV [W14+8], W0
00AAB0  200031     MOV #0x3, W1
00AAB2  780801     MOV W1, [W0]
00AAB4  370001     BRA 0xAAB8
206:                   }
207:               
208:               }
00AAB8  FA8000     ULNK
00AABA  060000     RETURN
209:               
210:               void clksyncProcessSamples(SyncStatus sync) {
00AABC  FA001A     LNK #0x1A
00AABE  BE9F88     MOV.D W8, [W15++]
00AAC0  BE9F8A     MOV.D W10, [W15++]
00AAC2  980F00     MOV W0, [W14+16]
211:               
212:                   unsigned long current_offset, error;
213:                   long long average_offset;
214:               
215:                   current_offset = sclockGetOffsetTicks();
00AAC4  02DE70     CALL sclockGetOffsetTicks
00AAC6  000000     NOP
00AAC8  BE8F00     MOV.D W0, [W14]
216:                   average_offset = sync->accumulator/sync->responses;
00AACA  90080E     MOV [W14+16], W0
00AACC  900A00     MOV [W0+16], W4
00AACE  900A90     MOV [W0+18], W5
00AAD0  900B20     MOV [W0+20], W6
00AAD2  900BB0     MOV [W0+22], W7
00AAD4  980F14     MOV W4, [W14+18]
00AAD6  980F25     MOV W5, [W14+20]
00AAD8  980F36     MOV W6, [W14+22]
00AADA  980F47     MOV W7, [W14+24]
00AADC  90080E     MOV [W14+16], W0
00AADE  900060     MOV [W0+12], W0
00AAE0  200001     MOV #0x0, W1
00AAE2  200002     MOV #0x0, W2
00AAE4  200003     MOV #0x0, W3
00AAE6  BE0302     MOV.D W2, W6
00AAE8  BE0200     MOV.D W0, W4
00AAEA  90081E     MOV [W14+18], W0
00AAEC  9008AE     MOV [W14+20], W1
00AAEE  90093E     MOV [W14+22], W2
00AAF0  9009CE     MOV [W14+24], W3
00AAF2  022978     CALL ___divdi3
00AAF4  000000     NOP
00AAF6  980720     MOV W0, [W14+4]
00AAF8  980731     MOV W1, [W14+6]
00AAFA  980742     MOV W2, [W14+8]
00AAFC  980753     MOV W3, [W14+10]
217:                   error = (unsigned long) current_offset + average_offset;
00AAFE  90002E     MOV [W14+4], W0
00AB00  9000BE     MOV [W14+6], W1
00AB02  40033E     ADD W0, [W14++], W6
00AB04  4883AE     ADDC W1, [W14--], W7
00AB06  BE0006     MOV.D W6, W0
00AB08  980760     MOV W0, [W14+12]
00AB0A  980771     MOV W1, [W14+14]
218:               
219:                   sclockSetOffsetTicks(error);
00AB0C  90006E     MOV [W14+12], W0
00AB0E  9000FE     MOV [W14+14], W1
00AB10  02DE8A     CALL sclockSetOffsetTicks
00AB12  000000     NOP
220:               
221:                   sync->accumulator = 0;
00AB14  900A0E     MOV [W14+16], W4
00AB16  B80060     MUL.UU W0, #0, W0
00AB18  B81160     MUL.UU W2, #0, W2
00AB1A  980A00     MOV W0, [W4+16]
00AB1C  980A11     MOV W1, [W4+18]
00AB1E  980A22     MOV W2, [W4+20]
00AB20  980A33     MOV W3, [W4+22]
222:                   sync->requests = 0;
00AB22  90080E     MOV [W14+16], W0
00AB24  EB0080     CLR W1
00AB26  980051     MOV W1, [W0+10]
223:                   sync->responses = 0;
00AB28  90080E     MOV [W14+16], W0
00AB2A  EB0080     CLR W1
00AB2C  980061     MOV W1, [W0+12]
224:                   sync->iterations++;
00AB2E  90080E     MOV [W14+16], W0
00AB30  900070     MOV [W0+14], W0
00AB32  E80080     INC W0, W1
00AB34  90080E     MOV [W14+16], W0
00AB36  980071     MOV W1, [W0+14]
225:               
226:                   if((average_offset < sync->tolerance)){ //&&
00AB38  90080E     MOV [W14+16], W0
00AB3A  9000C0     MOV [W0+8], W1
00AB3C  900030     MOV [W0+6], W0
00AB3E  BE0400     MOV.D W0, W8
00AB40  EB0500     CLR W10
00AB42  EB0580     CLR W11
00AB44  90002E     MOV [W14+4], W0
00AB46  9000BE     MOV [W14+6], W1
00AB48  90014E     MOV [W14+8], W2
00AB4A  9001DE     MOV [W14+10], W3
00AB4C  E14000     CP W8, W0
00AB4E  E1C801     CPB W9, W1
00AB50  E1D002     CPB W10, W2
00AB52  E1D803     CPB W11, W3
00AB54  340003     BRA LE, 0xAB5C
227:                           //(average_offset > -(sync->tolerance))) {
228:                       sync->state = STATE_SYNCED;
00AB56  90080E     MOV [W14+16], W0
00AB58  200021     MOV #0x2, W1
00AB5A  780801     MOV W1, [W0]
229:                   }
230:               
231:                   if(sync->iterations > MAX_ITERATIONS) {
00AB5C  90080E     MOV [W14+16], W0
00AB5E  9000F0     MOV [W0+14], W1
00AB60  200280     MOV #0x28, W0
00AB62  508F80     SUB W1, W0, [W15]
00AB64  360003     BRA LEU, 0xAB6C
232:                       sync->state = STATE_ITERS_EXCEEDED;        
00AB66  90080E     MOV [W14+16], W0
00AB68  200041     MOV #0x4, W1
00AB6A  780801     MOV W1, [W0]
233:                   }
234:               
235:               }
00AB6C  BE054F     MOV.D [--W15], W10
00AB6E  BE044F     MOV.D [--W15], W8
00AB70  FA8000     ULNK
00AB72  060000     RETURN
236:                
237:                
238:                
239:                
240:                
241:                
242:                
243:                
244:                
---  C:/Users/Cameron/Documents/Git/ibird-lib/adc_pid.c  ------------------------------------------------
1:                 /*
2:                  * Name: SetupADC.c
3:                  * Desc: Configure the analog to digital converter.
4:                  * Date: 2009-04-02
5:                  * Author: fgb
6:                  */
7:                 
8:                 #include "adc.h"
9:                 #include "adc_pid.h"
10:                #include "p33Fxxxx.h"
11:                #include "ports.h"
12:                
13:                //Functions
14:                static void adcSetupPeripheral(void);
15:                //DMA related functions
16:                static void initDma0(void);
17:                void __attribute__((__interrupt__)) _DMA0Interrupt(void);
18:                
19:                
20:                //Variables to store values as they come out of the DMA buffer
21:                static unsigned int adc_bemfL;
22:                static unsigned int adc_bemfR;
23:                static unsigned int adc_battery;
24:                static unsigned int adc_AN3;
25:                
26:                void adcSetup(void){
00DD36  FA0000     LNK #0x0
27:                	adcSetupPeripheral();
00DD38  070003     RCALL adcSetupPeripheral
28:                	initDma0(); //DMA is needed to read multiple values from the ADC core
00DD3A  070041     RCALL initDma0
29:                }
00DD3C  FA8000     ULNK
00DD3E  060000     RETURN
30:                
31:                static void adcSetupPeripheral(void){
00DD40  FA0000     LNK #0x0
32:                	unsigned int AD1CON1value, AD1CON2value, AD1CON3value, AD1CON4value, 
33:                				AD1PCFGHvalue, AD1PCFGLvalue, AD1CSSHvalue, AD1CSSLvalue, 
34:                				AD1CHS0value, AD1CHS123value;
35:                
36:                	//Setup:
37:                	//ADC1 : Ch0 - AN11 then AN1
38:                	//		 Ch1 - AN0 then AN3
39:                	//ADC2 : Left unconfigured for user applications
40:                //	AD1CON1value = ADC_MODULE_ON & 			//ADC module is enabled
41:                //				   ADC_IDLE_CONTINUE & 		// ADC will continue in idle mode
42:                //                                   ADC_AD12B_10BIT & 		// ADC in 10 bit mode
43:                //				   ADC_FORMAT_INTG & 		// ADC in integer format (CLARIFY)
44:                //				   ADC_CLK_MPWM & 			// MCPWM interval ends sampling and starts conversion
45:                //                                   ADC_MULTIPLE & 		//Simultaneously sample CH0 and CH1
46:                //				   ADC_ADDMABM_ORDER &		//DMA buffers are written in the order of conversion
47:                //				   ADC_AUTO_SAMPLING_ON & 	//ADC does not need to be triggered manually
48:                //				   ADC_SAMP_ON;				//sample / hold amplifiers are sampling  (maybe incorrect)
49:                //        AD1CON2value = ADC_VREF_AVDD_AVSS & 	//Vref+ = AVdd , Vref- = AVss
50:                //				   ADC_SCAN_ON & 			//Do not scan through ADC channels
51:                //				   ADC_SELECT_CHAN_0 & 	//Sample & convert
52:                //				   ADC_ALT_BUF_OFF &		//Use one 16 word buffer
53:                //				   ADC_ALT_INPUT_OFF & 		// Alternate between MUXA and MUXB
54:                //				   ADC_DMA_ADD_INC_2;		//Increment DMA address after 2 samples, to account for alt. sampling
55:                //        AD1CON3value = ADC_CONV_CLK_SYSTEM & 	//Use System clock, not internal RC osc
56:                //				   ADC_CONV_CLK_3Tcy & 		//Tad = 3 * Tcy
57:                //				   ADC_SAMPLE_TIME_1; 		//Sample Time = 1*Tad
58:                //	AD1CON4value = ADC_DMA_BUF_LOC_1; 		//This may be wrong (TODO)
59:                //
60:                //
61:                //	AD1CHS123value = 0;
62:                //
63:                // 	AD1CHS0value = ADC_CH0_NEG_SAMPLEA_VREFN & 		// Sample A, Vref- = AVss
64:                //				   ADC_CH0_POS_SAMPLEA_AN11; 		// Sample A, CH0 = AN11
65:                //
66:                //
67:                //        AD1CSSHvalue = SCAN_NONE_16_31; 				//Skip AN16-AN131 for Input Scan
68:                //	AD1CSSLvalue = SCAN_NONE_0_15 | (1 << 0) //AN0
69:                //                                  | (1 << 1) //AN1
70:                //                                  | (1 << 11); //AN11
71:                //
72:                //	//Set pins to analog inputs; also check init_default.c
73:                //	AD1PCFGHvalue = ENABLE_ALL_DIG_16_31; //Shouldn't matter, only AN0-15 on 706A
74:                //        AD1PCFGLvalue = ENABLE_AN0_ANA & ENABLE_AN1_ANA & ENABLE_AN11_ANA;
75:                //
76:                //        SetChanADC1(AD1CHS123value, AD1CHS0value);
77:                //        OpenADC1(AD1CON1value, AD1CON2value, AD1CON3value, AD1CON4value, AD1PCFGLvalue, AD1PCFGHvalue, AD1CSSHvalue, AD1CSSLvalue);
78:                
79:                        AD1CON1bits.ADON = 0;       //disable
00DD42  A9E321     BCLR 0x321, #7
80:                        AD1CON1bits.ADSIDL = 0;     //continue in idle mode
00DD44  A9A321     BCLR 0x321, #5
81:                        AD1CON1bits.AD12B = 0;      //10 bit mode
00DD46  A94321     BCLR 0x321, #2
82:                        AD1CON1bits.FORM = 0b00;    //integer (0000 00dd dddd dddd) format output
00DD48  801901     MOV AD1CON1, W1
00DD4A  2FCFF0     MOV #0xFCFF, W0
00DD4C  608000     AND W1, W0, W0
00DD4E  881900     MOV W0, AD1CON1
83:                        AD1CON1bits.SSRC = 0b011;   //Sample clock source based on PWM
00DD50  801901     MOV AD1CON1, W1
00DD52  2FF1F0     MOV #0xFF1F, W0
00DD54  608080     AND W1, W0, W1
00DD56  200600     MOV #0x60, W0
00DD58  708000     IOR W1, W0, W0
00DD5A  881900     MOV W0, AD1CON1
84:                        AD1CON1bits.SIMSAM = 1;     //Sample channels simultaneously
00DD5C  A86320     BSET AD1CON1, #3
85:                        AD1CON1bits.ASAM = 1;       //Auto sampling on
00DD5E  A84320     BSET AD1CON1, #2
86:                        AD1CON1bits.ADDMABM = 1;
00DD60  A88321     BSET 0x321, #4
87:                
88:                        AD1CON2bits.VCFG = 0b000;   //Vdd is pos. ref and Vss is neg. ref.
00DD62  801911     MOV AD1CON2, W1
00DD64  21FFF0     MOV #0x1FFF, W0
00DD66  608000     AND W1, W0, W0
00DD68  881910     MOV W0, AD1CON2
89:                        AD1CON2bits.CSCNA = 1;      //scan inputs
00DD6A  A84323     BSET 0x323, #2
90:                        AD1CON2bits.CHPS = 0b00;    //Convert channels 0 and 1
00DD6C  801911     MOV AD1CON2, W1
00DD6E  2FCFF0     MOV #0xFCFF, W0
00DD70  608000     AND W1, W0, W0
00DD72  881910     MOV W0, AD1CON2
91:                        AD1CON2bits.SMPI = 0b0010;  //Interrupt after 3 conversions (depends on CHPS and SIMSAM)
00DD74  801911     MOV AD1CON2, W1
00DD76  2FFC30     MOV #0xFFC3, W0
00DD78  608000     AND W1, W0, W0
00DD7A  A03000     BSET W0, #3
00DD7C  881910     MOV W0, AD1CON2
92:                        AD1CON2bits.BUFM = 0;       //Always fill conversion buffer from first element
00DD7E  A92322     BCLR AD1CON2, #1
93:                        AD1CON2bits.ALTS = 0;       //Alternate MUXes for analog input selection
00DD80  A90322     BCLR AD1CON2, #0
94:                
95:                        AD1CON3bits.ADRC = 0;       //Derive conversion clock from system clock
00DD82  A9E325     BCLR 0x325, #7
96:                    //    AD1CON3bits.SAMC = 0b00001; //Auto sampling clock period is one Tad
97:                        AD1CON3bits.ADCS = 0b00000010; // Each TAD is 3 Tcy
00DD84  B3C020     MOV #0x2, W0
00DD86  B7E324     MOVWF.B WREG, AD1CON3
98:                
99:                        AD1PCFGL = 0xF7FC;          //Enable AN0 - AN3 as analog inputs
00DD88  2F7FC0     MOV #0xF7FC, W0
00DD8A  881960     MOV W0, AD1PCFGL
100:               
101:                       AD1CHS0bits.CH0SA = 0b01011;      //Select AN1 for CH0 +ve input
00DD8C  801941     MOV AD1CHS0, W1
00DD8E  2FFE00     MOV #0xFFE0, W0
00DD90  608000     AND W1, W0, W0
00DD92  B300B0     IOR #0xB, W0
00DD94  881940     MOV W0, AD1CHS0
102:                       AD1CHS0bits.CH0NA = 0;      //Select Vref- for CH0 -ve input
00DD96  A9E328     BCLR AD1CHS0, #7
103:               
104:                       AD1CSSL = 0x0803;
00DD98  208030     MOV #0x803, W0
00DD9A  881980     MOV W0, AD1CSSL
105:               
106:                       //AD1CHS123bits.CH123SA = 0b1;  //Select AN3 for CH1 +ve input
107:                       //AD1CHS123bits.CH123NA = 0b00;  //Select Vref- for CH1 -ve input
108:               
109:                       AD1CON1bits.ADON = 1;       //enable
00DD9C  A8E321     BSET 0x321, #7
110:                       
111:               	IFS0bits.AD1IF = 0; // Clear the A/D interrupt flag bit
00DD9E  A9A085     BCLR 0x85, #5
112:               	IEC0bits.AD1IE = 0; //Disable A/D interrupt
00DDA0  A9A095     BCLR 0x95, #5
113:               }
00DDA2  FA8000     ULNK
00DDA4  060000     RETURN
114:               
115:               
116:               //For testing purposes, should not be enabled
117:               /*
118:               void __attribute__((interrupt,no_auto_psv)) _ADC1Interrupt(void)
119:               {
120:               	//ADC sync indicator
121:               	if(AD1CON1bits.DONE){
122:               		LATB |= (1<<4);
123:               	}else{
124:               		LATB &= ~(1<<4);
125:               	}
126:               	IFS0bits.AD1IF = 0;
127:               }
128:               */
129:               
130:               //Getters for other modules to access values
131:               unsigned int adcGetBEMFL(){
00DDA6  FA0000     LNK #0x0
132:               	return adc_bemfL;
00DDA8  810F20     MOV _adc_bemfL, W0
133:               }
00DDAA  FA8000     ULNK
00DDAC  060000     RETURN
134:               
135:               unsigned int adcGetBEMFR(){
00DDAE  FA0000     LNK #0x0
136:               	return adc_bemfR;
00DDB0  810F30     MOV _adc_bemfR, W0
137:               }
00DDB2  FA8000     ULNK
00DDB4  060000     RETURN
138:               
139:               unsigned int adcGetVBatt(){
00DDB6  FA0000     LNK #0x0
140:               	return adc_battery;
00DDB8  810F40     MOV _adc_battery, W0
141:               }
00DDBA  FA8000     ULNK
00DDBC  060000     RETURN
142:               
143:               
144:               //////////////////////////////////////////////////////////////////////
145:               ///////////////      DMA Section     /////////////////////////////////
146:               //////////////////////////////////////////////////////////////////////
147:               
148:               #define  SAMP_BUFF_SIZE	 		1		// Size of the input buffer per analog input
149:               
150:               //Buffers need special attribute to be in DMA memory space
151:               static int  BufferA[3][SAMP_BUFF_SIZE] __attribute__((space(dma)));
152:               //static int  BufferB[3][SAMP_BUFF_SIZE] __attribute__((space(dma)));
153:               
154:               static unsigned int DmaBuffer = 0;
155:               
156:               
157:               
158:               /*****************************************************************************
159:               * Function Name : initDma0
160:               * Description   : Setup function for DMA0, to read ADC1 into a buffer
161:               * Parameters    : None
162:               * Return Value  : None
163:               *****************************************************************************/
164:               static void initDma0(void)
165:               {
00DDBE  FA0000     LNK #0x0
166:               	DMA0CONbits.AMODE = 0;			// Configure DMA for Register Indirect w/ post-increment
00DDC0  801C01     MOV DMA0CON, W1
00DDC2  2FFCF0     MOV #0xFFCF, W0
00DDC4  608000     AND W1, W0, W0
00DDC6  881C00     MOV W0, DMA0CON
167:               	DMA0CONbits.MODE  = 2;			// Configure DMA for Continuous Ping-Pong mode
00DDC8  801C01     MOV DMA0CON, W1
00DDCA  2FFFC0     MOV #0xFFFC, W0
00DDCC  608000     AND W1, W0, W0
00DDCE  A01000     BSET W0, #1
00DDD0  881C00     MOV W0, DMA0CON
168:               	
169:               	DMA0PAD=(int)&ADC1BUF0;
00DDD2  203000     MOV #0x300, W0
00DDD4  881C40     MOV W0, DMA0PAD
170:               	//DMA0CNT = (SAMP_BUFF_SIZE*2)-1;					
171:               	DMA0CNT = 2;  //See dsPIC user's manual. 3 analog reads -> DMA0CNT = 3-1 = 2
00DDD6  200020     MOV #0x2, W0
00DDD8  881C50     MOV W0, DMA0CNT
172:               	//DMA0CNT = 7;
173:               
174:               	DMA0REQ=13; //ADC1 requests
00DDDA  2000D0     MOV #0xD, W0
00DDDC  881C10     MOV W0, DMA0REQ
175:               
176:               	DMA0STA = __builtin_dmaoffset(BufferA);		
00DDDE  204EA0     MOV #0x4EA, W0
00DDE0  881C20     MOV W0, DMA0STA
177:               	//DMA0STB = __builtin_dmaoffset(BufferB);
178:               
179:               	IFS0bits.DMA0IF = 0;			//Clear the DMA interrupt flag bit
00DDE2  A98084     BCLR IFS0, #4
180:                       IEC0bits.DMA0IE = 1;			//Set the DMA interrupt enable bit
00DDE4  A88094     BSET IEC0, #4
181:               
182:               	DMA0CONbits.CHEN=1;
00DDE6  A8E381     BSET 0x381, #7
183:               }
00DDE8  FA8000     ULNK
00DDEA  060000     RETURN
184:               
185:               /*****************************************************************************
186:               * Function Name : _DMA0Interrupt
187:               * Description   : Interrupt hander for DMA0 , associated with ADC1 here.
188:               				  Motor BEMF vales are set through setter functions.
189:               * Parameters    : None
190:               * Return Value  : None
191:               *****************************************************************************/
192:               void __attribute__((interrupt, no_auto_psv)) _DMA0Interrupt(void)
193:               {
00DDEC  781F80     MOV W0, [W15++]
00DDEE  FA0000     LNK #0x0
194:               //	if(DmaBuffer==0) {
195:               //		adc_battery = 	BufferA[0][0];	//AN0
196:               //		adc_bemfR = 	BufferA[1][0];	//AN1
197:               //		adc_bemfL = 	BufferA[2][0];	//AN11
198:               //
199:               //	} else {
200:               //
201:               //		adc_battery = 	BufferB[0][0];	//AN0
202:               //		adc_bemfR = 	BufferB[1][0];	//AN1
203:               //		adc_bemfL = 	BufferB[2][0];	//AN11
204:               //	}
205:                       adc_battery = 	BufferA[0][0];	//AN0
00DDF0  822750     MOV BufferA, W0
00DDF2  890F40     MOV W0, _adc_battery
206:                       adc_bemfR = 	BufferA[1][0];	//AN1
00DDF4  822760     MOV 0x44EC, W0
00DDF6  890F30     MOV W0, _adc_bemfR
207:                       adc_bemfL = 	BufferA[2][0];	//AN11
00DDF8  822770     MOV 0x44EE, W0
00DDFA  890F20     MOV W0, _adc_bemfL
208:               	DmaBuffer ^= 1;	 //Toggle between buffers
00DDFC  810F60     MOV DmaBuffer, W0
00DDFE  A20000     BTG W0, #0
00DE00  890F60     MOV W0, DmaBuffer
209:               	IFS0bits.DMA0IF = 0;		//Clear the DMA0 Interrupt Flag
00DE02  A98084     BCLR IFS0, #4
210:               }
00DE04  FA8000     ULNK
00DE06  78004F     MOV [--W15], W0
00DE08  064000     RETFIE
211:               // End DMA section
---  ../../imageproc-lib/ovcam.h  -----------------------------------------------------------------------
0098A6  FA0000     LNK #0x0
0098A8  000000     NOP
0098AA  801671     MOV PORTC, W1
0098AC  220000     MOV #0x2000, W0
0098AE  608080     AND W1, W0, W1
0098B0  EB0000     CLR W0
0098B2  508F80     SUB W1, W0, [W15]
0098B4  3AFFFA     BRA NZ, 0x98AA
0098B6  000000     NOP
0098B8  801671     MOV PORTC, W1
0098BA  220000     MOV #0x2000, W0
0098BC  608080     AND W1, W0, W1
0098BE  EB0000     CLR W0
0098C0  508F80     SUB W1, W0, [W15]
0098C2  32FFFA     BRA Z, 0x98B8
0098C4  FA8000     ULNK
0098C6  060000     RETURN
009D24  FA0000     LNK #0x0
009D26  A9C2D1     BCLR 0x2D1, #6
009D28  FA8000     ULNK
009D2A  060000     RETURN
